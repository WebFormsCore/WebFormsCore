using Microsoft.CodeAnalysis;
using Microsoft.CodeAnalysis.CSharp;
using Microsoft.CodeAnalysis.CSharp.Syntax;
using Microsoft.CodeAnalysis.Text;
using System.Collections.Immutable;
using System.Text;

namespace WebFormsCore.SourceGenerator;

[Generator]
public class ControlEventsGenerator : IIncrementalGenerator
{
    public void Initialize(IncrementalGeneratorInitializationContext context)
    {
        var controlTypes = context.SyntaxProvider
            .CreateSyntaxProvider(
                predicate: static (node, _) => node is TypeDeclarationSyntax { BaseList.Types.Count: > 0 },
                transform: static (ctx, token) => GetControlTypeSymbol(ctx, token))
            .Where(static symbol => symbol is not null);

        var compilationAndControls = controlTypes
            .Collect()
            .Combine(context.CompilationProvider);

        context.RegisterSourceOutput(compilationAndControls, static (spc, source) => Execute(spc, source.Left, source.Right));
    }

    private static INamedTypeSymbol? GetControlTypeSymbol(GeneratorSyntaxContext context, CancellationToken token)
    {
        if (context.Node is not TypeDeclarationSyntax typeDeclaration)
        {
            return null;
        }

        if (context.SemanticModel.GetDeclaredSymbol(typeDeclaration, token) is not INamedTypeSymbol typeSymbol)
        {
            return null;
        }

        if (typeSymbol.TypeKind != TypeKind.Class || typeSymbol.DeclaredAccessibility == Accessibility.Private)
        {
            return null;
        }

        if (typeSymbol.IsAbstract)
        {
            return null;
        }

        return IsControl(typeSymbol) ? typeSymbol : null;
    }

    private static bool IsControl(INamedTypeSymbol typeSymbol)
    {
        var current = typeSymbol;

        while (current is not null)
        {
            if (current.Name == "Control" && current.ContainingNamespace.ToString() == "WebFormsCore.UI")
            {
                return true;
            }

            current = current.BaseType;
        }

        return false;
    }

    private static void Execute(SourceProductionContext context, ImmutableArray<INamedTypeSymbol?> controlSymbols, Compilation compilation)
    {
        if (compilation is CSharpCompilation { LanguageVersion: < (LanguageVersion)1400 })
        {
            return;
        }

        var asyncEventHandler = compilation.GetTypeByMetadataName("WebFormsCore.AsyncEventHandler");
        var asyncEventHandlerGeneric = compilation.GetTypeByMetadataName("WebFormsCore.AsyncEventHandler`2");

        var distinctControls = controlSymbols
            .Where(static symbol => symbol is not null)
            .Distinct(SymbolEqualityComparer.Default)
            .Cast<INamedTypeSymbol>()
            .OrderBy(static symbol => symbol.ToDisplayString(SymbolDisplayFormat.FullyQualifiedFormat))
            .ToArray();

        if (distinctControls.Length == 0)
        {
            return;
        }

        var sb = new StringBuilder();
        sb.AppendLine("// <auto-generated/>");
        sb.AppendLine("namespace WebFormsCore.UI;");
        sb.AppendLine();
        sb.AppendLine("public static partial class ControlExtensions");
        sb.AppendLine("{");

        var anyExtensions = false;

        foreach (var control in distinctControls)
        {
            var events = GetEventSymbols(control)
                .SelectMany(evt => CreateEventModels(control, evt, asyncEventHandler, asyncEventHandlerGeneric, control.TypeParameters.Length == 0 ? ReceiverTypeParameterName : null))
                .ToArray();

            if (events.Length == 0)
            {
                continue;
            }

            anyExtensions = true;

            var extensionSignature = GetExtensionSignature(control);
            sb.AppendLine($"    {extensionSignature.Signature}");
            sb.Append(extensionSignature.Constraints);

            sb.AppendLine("    {");

            foreach (var evt in events)
            {
                sb.AppendLine($"        {evt.Accessibility} {evt.PropertyType} {evt.Name}");
                sb.AppendLine("        {");
                sb.AppendLine($"            set => control.{evt.EventName} += {evt.Assignment};");
                sb.AppendLine("        }");
                sb.AppendLine();
            }

            sb.AppendLine("    }");
            sb.AppendLine();
        }

        if (!anyExtensions)
        {
            return;
        }

        sb.AppendLine("}");

        context.AddSource("ControlEvents.g.cs", SourceText.From(sb.ToString(), Encoding.UTF8));
    }

    private static IEnumerable<IEventSymbol> GetEventSymbols(INamedTypeSymbol controlType)
    {
        foreach (var evt in controlType.GetMembers().OfType<IEventSymbol>())
        {
            if (evt.IsStatic)
            {
                continue;
            }

            if (evt.ExplicitInterfaceImplementations.Length > 0)
            {
                continue;
            }

            if (evt.DeclaredAccessibility is not (Accessibility.Public or Accessibility.Internal))
            {
                continue;
            }

            yield return evt;
        }
    }

    private static IEnumerable<EventModel> CreateEventModels(INamedTypeSymbol controlType, IEventSymbol evt, INamedTypeSymbol? asyncEventHandler, INamedTypeSymbol? asyncEventHandlerGeneric, string? receiverTypeParameter)
    {
        if (evt.Type is not INamedTypeSymbol eventType)
        {
            yield break;
        }

        var access = GetEffectiveAccessibility(controlType, evt, eventType);
        var eventTypeDisplay = eventType.ToDisplayString(SymbolDisplayFormat.FullyQualifiedFormat);
        var asyncPropertyName = $"On{evt.Name}Async";
        var syncPropertyName = $"On{evt.Name}";

        if (asyncEventHandler is not null && SymbolEqualityComparer.Default.Equals(eventType, asyncEventHandler))
        {
            var senderType = receiverTypeParameter ?? "global::System.Object";
            var funcType = $"global::System.Func<{senderType}, global::System.EventArgs, global::System.Threading.Tasks.Task>";
            var assignment = receiverTypeParameter is null
                ? "value.Invoke"
                : $"async (sender, args) => await value(({receiverTypeParameter})sender, args)";
            yield return new EventModel(asyncPropertyName, evt.Name, access, funcType, assignment);

            var actionType = $"global::System.Action<{senderType}, global::System.EventArgs>";
            var syncAssignment = receiverTypeParameter is null
                ? "(sender, args) => { value(sender, args); return global::System.Threading.Tasks.Task.CompletedTask; }"
                : $"(sender, args) => {{ value(({receiverTypeParameter})sender, args); return global::System.Threading.Tasks.Task.CompletedTask; }}";
            yield return new EventModel(syncPropertyName, evt.Name, access, actionType, syncAssignment);
            yield break;
        }

        if (asyncEventHandlerGeneric is not null && SymbolEqualityComparer.Default.Equals(eventType.OriginalDefinition, asyncEventHandlerGeneric))
        {
            if (eventType.TypeArguments.Length != 2)
            {
                yield break;
            }

            var senderType = receiverTypeParameter ?? eventType.TypeArguments[0].ToDisplayString(SymbolDisplayFormat.FullyQualifiedFormat);
            var argsType = eventType.TypeArguments[1].ToDisplayString(SymbolDisplayFormat.FullyQualifiedFormat);
            var funcType = $"global::System.Func<{senderType}, {argsType}, global::System.Threading.Tasks.Task>";
            var assignment = receiverTypeParameter is null
                ? "value.Invoke"
                : $"async (sender, args) => await value(({receiverTypeParameter})sender, args)";
            yield return new EventModel(asyncPropertyName, evt.Name, access, funcType, assignment);

            var actionType = $"global::System.Action<{senderType}, {argsType}>";
            var syncAssignment = receiverTypeParameter is null
                ? "(sender, args) => { value(sender, args); return global::System.Threading.Tasks.Task.CompletedTask; }"
                : $"(sender, args) => {{ value(({receiverTypeParameter})sender, args); return global::System.Threading.Tasks.Task.CompletedTask; }}";
            yield return new EventModel(syncPropertyName, evt.Name, access, actionType, syncAssignment);
            yield break;
        }

        yield return new EventModel(syncPropertyName, evt.Name, access, eventTypeDisplay, "value");
    }

    private const string ReceiverTypeParameterName = "T";

    private static ExtensionSignature GetExtensionSignature(INamedTypeSymbol controlType)
    {
        return controlType.TypeParameters.Length == 0
            ? GetGenericReceiverSignature(controlType)
            : GetConcreteReceiverSignature(controlType);
    }

    private static ExtensionSignature GetGenericReceiverSignature(INamedTypeSymbol controlType)
    {
        var controlTypeName = controlType.ToDisplayString(SymbolDisplayFormat.FullyQualifiedFormat);
        var signature = $"extension<{ReceiverTypeParameterName}>({ReceiverTypeParameterName} control)";
        var constraints = $"        where {ReceiverTypeParameterName} : {controlTypeName}{Environment.NewLine}";
        return new ExtensionSignature(signature, constraints);
    }

    private static ExtensionSignature GetConcreteReceiverSignature(INamedTypeSymbol controlType)
    {
        var typeParameters = GetTypeParameters(controlType);
        var constraints = GetTypeConstraints(controlType);
        var controlTypeName = controlType.ToDisplayString(SymbolDisplayFormat.FullyQualifiedFormat);
        var signature = $"extension{typeParameters}({controlTypeName} control)";
        return new ExtensionSignature(signature, constraints.Length == 0 ? string.Empty : $"{constraints}{Environment.NewLine}");
    }

    private static string GetTypeParameters(INamedTypeSymbol type)
    {
        if (type.TypeParameters.Length == 0)
        {
            return string.Empty;
        }

        var parameters = string.Join(", ", type.TypeParameters.Select(static p => p.Name));
        return $"<{parameters}>";
    }

    private static string GetTypeConstraints(INamedTypeSymbol type)
    {
        if (type.TypeParameters.Length == 0)
        {
            return string.Empty;
        }

        var sb = new StringBuilder();

        foreach (var parameter in type.TypeParameters)
        {
            var constraints = new List<string>();

            if (parameter.HasUnmanagedTypeConstraint)
            {
                constraints.Add("unmanaged");
            }
            else if (parameter.HasReferenceTypeConstraint)
            {
                constraints.Add("class");
            }
            else if (parameter.HasValueTypeConstraint)
            {
                constraints.Add("struct");
            }

            if (parameter.HasNotNullConstraint)
            {
                constraints.Add("notnull");
            }

            constraints.AddRange(parameter.ConstraintTypes.Select(static constraint =>
                constraint.ToDisplayString(SymbolDisplayFormat.FullyQualifiedFormat)));

            if (parameter.HasConstructorConstraint)
            {
                constraints.Add("new()");
            }

            if (constraints.Count == 0)
            {
                continue;
            }

            sb.AppendLine($"        where {parameter.Name} : {string.Join(", ", constraints)}");
        }

        return sb.ToString().TrimEnd();
    }

    private sealed record EventModel(string Name, string EventName, string Accessibility, string PropertyType, string Assignment);

    private sealed record ExtensionSignature(string Signature, string Constraints);

    private static string GetEffectiveAccessibility(INamedTypeSymbol controlType, IEventSymbol evt, INamedTypeSymbol eventType)
    {
        if (controlType.DeclaredAccessibility != Accessibility.Public)
        {
            return "internal";
        }

        if (evt.DeclaredAccessibility != Accessibility.Public)
        {
            return "internal";
        }

        if (!IsTypePublic(eventType))
        {
            return "internal";
        }

        return "public";
    }

    private static bool IsTypePublic(ITypeSymbol type)
    {
        switch (type)
        {
            case ITypeParameterSymbol:
                return true;
            case IArrayTypeSymbol array:
                return IsTypePublic(array.ElementType);
            case INamedTypeSymbol named:
                if (named.DeclaredAccessibility != Accessibility.Public)
                {
                    return false;
                }

                if (named.ContainingType is not null && named.ContainingType.DeclaredAccessibility != Accessibility.Public)
                {
                    return false;
                }

                foreach (var argument in named.TypeArguments)
                {
                    if (!IsTypePublic(argument))
                    {
                        return false;
                    }
                }

                return true;
            default:
                return true;
        }
    }
}