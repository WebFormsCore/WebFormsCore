(function() {

//#region rolldown:runtime
	var __create = Object.create;
	var __defProp = Object.defineProperty;
	var __getOwnPropDesc = Object.getOwnPropertyDescriptor;
	var __getOwnPropNames = Object.getOwnPropertyNames;
	var __getProtoOf = Object.getPrototypeOf;
	var __hasOwnProp = Object.prototype.hasOwnProperty;
	var __commonJSMin = (cb, mod) => () => (mod || cb((mod = { exports: {} }).exports, mod), mod.exports);
	var __copyProps = (to, from, except, desc) => {
		if (from && typeof from === "object" || typeof from === "function") {
			for (var keys = __getOwnPropNames(from), i = 0, n = keys.length, key; i < n; i++) {
				key = keys[i];
				if (!__hasOwnProp.call(to, key) && key !== except) {
					__defProp(to, key, {
						get: ((k) => from[k]).bind(null, key),
						enumerable: !(desc = __getOwnPropDesc(from, key)) || desc.enumerable
					});
				}
			}
		}
		return to;
	};
	var __toESM = (mod, isNodeMode, target) => (target = mod != null ? __create(__getProtoOf(mod)) : {}, __copyProps(isNodeMode || !mod || !mod.__esModule ? __defProp(target, "default", {
		value: mod,
		enumerable: true
	}) : target, mod));

//#endregion

//#region node_modules/tinymce/tinymce.js
	var require_tinymce = /* @__PURE__ */ __commonJSMin(((exports, module) => {
		/**
		* TinyMCE version 6.7.0 (2023-08-30)
		*/
		(function() {
			"use strict";
			var typeOf$1 = function(x) {
				if (x === null) return "null";
				if (x === void 0) return "undefined";
				var t = typeof x;
				if (t === "object" && (Array.prototype.isPrototypeOf(x) || x.constructor && x.constructor.name === "Array")) return "array";
				if (t === "object" && (String.prototype.isPrototypeOf(x) || x.constructor && x.constructor.name === "String")) return "string";
				return t;
			};
			var isEquatableType = function(x) {
				return [
					"undefined",
					"boolean",
					"number",
					"string",
					"function",
					"xml",
					"null"
				].indexOf(x) !== -1;
			};
			var sort$1 = function(xs, compareFn) {
				return Array.prototype.slice.call(xs).sort(compareFn);
			};
			var contramap = function(eqa, f) {
				return eq$2(function(x, y) {
					return eqa.eq(f(x), f(y));
				});
			};
			var eq$2 = function(f) {
				return { eq: f };
			};
			var eqString = eq$2(function(x, y) {
				return x === y;
			});
			var eqArray = function(eqa) {
				return eq$2(function(x, y) {
					if (x.length !== y.length) return false;
					var len = x.length;
					for (var i = 0; i < len; i++) if (!eqa.eq(x[i], y[i])) return false;
					return true;
				});
			};
			var eqSortedArray = function(eqa, compareFn) {
				return contramap(eqArray(eqa), function(xs) {
					return sort$1(xs, compareFn);
				});
			};
			var eqRecord = function(eqa) {
				return eq$2(function(x, y) {
					var kx = Object.keys(x);
					var ky = Object.keys(y);
					if (!eqSortedArray(eqString).eq(kx, ky)) return false;
					var len = kx.length;
					for (var i = 0; i < len; i++) {
						var q = kx[i];
						if (!eqa.eq(x[q], y[q])) return false;
					}
					return true;
				});
			};
			var eqAny = eq$2(function(x, y) {
				if (x === y) return true;
				var tx = typeOf$1(x);
				if (tx !== typeOf$1(y)) return false;
				if (isEquatableType(tx)) return x === y;
				else if (tx === "array") return eqArray(eqAny).eq(x, y);
				else if (tx === "object") return eqRecord(eqAny).eq(x, y);
				return false;
			});
			const getPrototypeOf$2 = Object.getPrototypeOf;
			const hasProto = (v, constructor, predicate) => {
				var _a;
				if (predicate(v, constructor.prototype)) return true;
				else return ((_a = v.constructor) === null || _a === void 0 ? void 0 : _a.name) === constructor.name;
			};
			const typeOf = (x) => {
				const t = typeof x;
				if (x === null) return "null";
				else if (t === "object" && Array.isArray(x)) return "array";
				else if (t === "object" && hasProto(x, String, (o, proto) => proto.isPrototypeOf(o))) return "string";
				else return t;
			};
			const isType$1 = (type$2) => (value$3) => typeOf(value$3) === type$2;
			const isSimpleType = (type$2) => (value$3) => typeof value$3 === type$2;
			const eq$1 = (t) => (a) => t === a;
			const is$4 = (value$3, constructor) => isObject(value$3) && hasProto(value$3, constructor, (o, proto) => getPrototypeOf$2(o) === proto);
			const isString = isType$1("string");
			const isObject = isType$1("object");
			const isPlainObject = (value$3) => is$4(value$3, Object);
			const isArray$1 = isType$1("array");
			const isNull = eq$1(null);
			const isBoolean = isSimpleType("boolean");
			const isUndefined = eq$1(void 0);
			const isNullable = (a) => a === null || a === void 0;
			const isNonNullable = (a) => !isNullable(a);
			const isFunction = isSimpleType("function");
			const isNumber = isSimpleType("number");
			const isArrayOf = (value$3, pred) => {
				if (isArray$1(value$3)) {
					for (let i = 0, len = value$3.length; i < len; ++i) if (!pred(value$3[i])) return false;
					return true;
				}
				return false;
			};
			const noop = () => {};
			const compose = (fa, fb) => {
				return (...args) => {
					return fa(fb.apply(null, args));
				};
			};
			const compose1 = (fbc, fab) => (a) => fbc(fab(a));
			const constant = (value$3) => {
				return () => {
					return value$3;
				};
			};
			const identity = (x) => {
				return x;
			};
			const tripleEquals = (a, b) => {
				return a === b;
			};
			function curry(fn, ...initialArgs) {
				return (...restArgs) => {
					const all$1 = initialArgs.concat(restArgs);
					return fn.apply(null, all$1);
				};
			}
			const not = (f) => (t) => !f(t);
			const die = (msg) => {
				return () => {
					throw new Error(msg);
				};
			};
			const apply$1 = (f) => {
				return f();
			};
			const call = (f) => {
				f();
			};
			const never = constant(false);
			const always = constant(true);
			class Optional {
				constructor(tag, value$3) {
					this.tag = tag;
					this.value = value$3;
				}
				static some(value$3) {
					return new Optional(true, value$3);
				}
				static none() {
					return Optional.singletonNone;
				}
				fold(onNone, onSome) {
					if (this.tag) return onSome(this.value);
					else return onNone();
				}
				isSome() {
					return this.tag;
				}
				isNone() {
					return !this.tag;
				}
				map(mapper) {
					if (this.tag) return Optional.some(mapper(this.value));
					else return Optional.none();
				}
				bind(binder$1) {
					if (this.tag) return binder$1(this.value);
					else return Optional.none();
				}
				exists(predicate) {
					return this.tag && predicate(this.value);
				}
				forall(predicate) {
					return !this.tag || predicate(this.value);
				}
				filter(predicate) {
					if (!this.tag || predicate(this.value)) return this;
					else return Optional.none();
				}
				getOr(replacement) {
					return this.tag ? this.value : replacement;
				}
				or(replacement) {
					return this.tag ? this : replacement;
				}
				getOrThunk(thunk) {
					return this.tag ? this.value : thunk();
				}
				orThunk(thunk) {
					return this.tag ? this : thunk();
				}
				getOrDie(message) {
					if (!this.tag) throw new Error(message !== null && message !== void 0 ? message : "Called getOrDie on None");
					else return this.value;
				}
				static from(value$3) {
					return isNonNullable(value$3) ? Optional.some(value$3) : Optional.none();
				}
				getOrNull() {
					return this.tag ? this.value : null;
				}
				getOrUndefined() {
					return this.value;
				}
				each(worker) {
					if (this.tag) worker(this.value);
				}
				toArray() {
					return this.tag ? [this.value] : [];
				}
				toString() {
					return this.tag ? `some(${this.value})` : "none()";
				}
			}
			Optional.singletonNone = new Optional(false);
			const nativeSlice = Array.prototype.slice;
			const nativeIndexOf = Array.prototype.indexOf;
			const nativePush = Array.prototype.push;
			const rawIndexOf = (ts, t) => nativeIndexOf.call(ts, t);
			const indexOf$1 = (xs, x) => {
				const r$1 = rawIndexOf(xs, x);
				return r$1 === -1 ? Optional.none() : Optional.some(r$1);
			};
			const contains$2 = (xs, x) => rawIndexOf(xs, x) > -1;
			const exists = (xs, pred) => {
				for (let i = 0, len = xs.length; i < len; i++) {
					const x = xs[i];
					if (pred(x, i)) return true;
				}
				return false;
			};
			const map$3 = (xs, f) => {
				const len = xs.length;
				const r$1 = new Array(len);
				for (let i = 0; i < len; i++) {
					const x = xs[i];
					r$1[i] = f(x, i);
				}
				return r$1;
			};
			const each$e = (xs, f) => {
				for (let i = 0, len = xs.length; i < len; i++) {
					const x = xs[i];
					f(x, i);
				}
			};
			const eachr = (xs, f) => {
				for (let i = xs.length - 1; i >= 0; i--) {
					const x = xs[i];
					f(x, i);
				}
			};
			const partition$2 = (xs, pred) => {
				const pass = [];
				const fail = [];
				for (let i = 0, len = xs.length; i < len; i++) {
					const x = xs[i];
					(pred(x, i) ? pass : fail).push(x);
				}
				return {
					pass,
					fail
				};
			};
			const filter$5 = (xs, pred) => {
				const r$1 = [];
				for (let i = 0, len = xs.length; i < len; i++) {
					const x = xs[i];
					if (pred(x, i)) r$1.push(x);
				}
				return r$1;
			};
			const foldr = (xs, f, acc) => {
				eachr(xs, (x, i) => {
					acc = f(acc, x, i);
				});
				return acc;
			};
			const foldl = (xs, f, acc) => {
				each$e(xs, (x, i) => {
					acc = f(acc, x, i);
				});
				return acc;
			};
			const findUntil$1 = (xs, pred, until) => {
				for (let i = 0, len = xs.length; i < len; i++) {
					const x = xs[i];
					if (pred(x, i)) return Optional.some(x);
					else if (until(x, i)) break;
				}
				return Optional.none();
			};
			const find$2 = (xs, pred) => {
				return findUntil$1(xs, pred, never);
			};
			const findIndex$2 = (xs, pred) => {
				for (let i = 0, len = xs.length; i < len; i++) {
					const x = xs[i];
					if (pred(x, i)) return Optional.some(i);
				}
				return Optional.none();
			};
			const flatten = (xs) => {
				const r$1 = [];
				for (let i = 0, len = xs.length; i < len; ++i) {
					if (!isArray$1(xs[i])) throw new Error("Arr.flatten item " + i + " was not an array, input: " + xs);
					nativePush.apply(r$1, xs[i]);
				}
				return r$1;
			};
			const bind$3 = (xs, f) => flatten(map$3(xs, f));
			const forall = (xs, pred) => {
				for (let i = 0, len = xs.length; i < len; ++i) {
					const x = xs[i];
					if (pred(x, i) !== true) return false;
				}
				return true;
			};
			const reverse = (xs) => {
				const r$1 = nativeSlice.call(xs, 0);
				r$1.reverse();
				return r$1;
			};
			const difference = (a1, a2) => filter$5(a1, (x) => !contains$2(a2, x));
			const mapToObject = (xs, f) => {
				const r$1 = {};
				for (let i = 0, len = xs.length; i < len; i++) {
					const x = xs[i];
					r$1[String(x)] = f(x, i);
				}
				return r$1;
			};
			const sort = (xs, comparator) => {
				const copy$1 = nativeSlice.call(xs, 0);
				copy$1.sort(comparator);
				return copy$1;
			};
			const get$b = (xs, i) => i >= 0 && i < xs.length ? Optional.some(xs[i]) : Optional.none();
			const head = (xs) => get$b(xs, 0);
			const last$3 = (xs) => get$b(xs, xs.length - 1);
			const from = isFunction(Array.from) ? Array.from : (x) => nativeSlice.call(x);
			const findMap = (arr, f) => {
				for (let i = 0; i < arr.length; i++) {
					const r$1 = f(arr[i], i);
					if (r$1.isSome()) return r$1;
				}
				return Optional.none();
			};
			const unique$1 = (xs, comparator) => {
				const r$1 = [];
				const isDuplicated$1 = isFunction(comparator) ? (x) => exists(r$1, (i) => comparator(i, x)) : (x) => contains$2(r$1, x);
				for (let i = 0, len = xs.length; i < len; i++) {
					const x = xs[i];
					if (!isDuplicated$1(x)) r$1.push(x);
				}
				return r$1;
			};
			const keys = Object.keys;
			const hasOwnProperty$2 = Object.hasOwnProperty;
			const each$d = (obj, f) => {
				const props = keys(obj);
				for (let k = 0, len = props.length; k < len; k++) {
					const i = props[k];
					const x = obj[i];
					f(x, i);
				}
			};
			const map$2 = (obj, f) => {
				return tupleMap(obj, (x, i) => ({
					k: i,
					v: f(x, i)
				}));
			};
			const tupleMap = (obj, f) => {
				const r$1 = {};
				each$d(obj, (x, i) => {
					const tuple = f(x, i);
					r$1[tuple.k] = tuple.v;
				});
				return r$1;
			};
			const objAcc = (r$1) => (x, i) => {
				r$1[i] = x;
			};
			const internalFilter = (obj, pred, onTrue, onFalse) => {
				each$d(obj, (x, i) => {
					(pred(x, i) ? onTrue : onFalse)(x, i);
				});
			};
			const bifilter = (obj, pred) => {
				const t = {};
				const f = {};
				internalFilter(obj, pred, objAcc(t), objAcc(f));
				return {
					t,
					f
				};
			};
			const filter$4 = (obj, pred) => {
				const t = {};
				internalFilter(obj, pred, objAcc(t), noop);
				return t;
			};
			const mapToArray = (obj, f) => {
				const r$1 = [];
				each$d(obj, (value$3, name$1) => {
					r$1.push(f(value$3, name$1));
				});
				return r$1;
			};
			const values = (obj) => {
				return mapToArray(obj, identity);
			};
			const get$a = (obj, key) => {
				return has$2(obj, key) ? Optional.from(obj[key]) : Optional.none();
			};
			const has$2 = (obj, key) => hasOwnProperty$2.call(obj, key);
			const hasNonNullableKey = (obj, key) => has$2(obj, key) && obj[key] !== void 0 && obj[key] !== null;
			const equal$1 = (a1, a2, eq$3 = eqAny) => eqRecord(eq$3).eq(a1, a2);
			const stringArray = (a) => {
				const all$1 = {};
				each$e(a, (key) => {
					all$1[key] = {};
				});
				return keys(all$1);
			};
			const isArrayLike = (o) => o.length !== void 0;
			const isArray = Array.isArray;
			const toArray$1 = (obj) => {
				if (!isArray(obj)) {
					const array = [];
					for (let i = 0, l = obj.length; i < l; i++) array[i] = obj[i];
					return array;
				} else return obj;
			};
			const each$c = (o, cb, s) => {
				if (!o) return false;
				s = s || o;
				if (isArrayLike(o)) {
					for (let n = 0, l = o.length; n < l; n++) if (cb.call(s, o[n], n, o) === false) return false;
				} else for (const n in o) if (has$2(o, n)) {
					if (cb.call(s, o[n], n, o) === false) return false;
				}
				return true;
			};
			const map$1 = (array, callback) => {
				const out = [];
				each$c(array, (item, index) => {
					out.push(callback(item, index, array));
				});
				return out;
			};
			const filter$3 = (a, f) => {
				const o = [];
				each$c(a, (v, index) => {
					if (!f || f(v, index, a)) o.push(v);
				});
				return o;
			};
			const indexOf = (a, v) => {
				if (a) {
					for (let i = 0, l = a.length; i < l; i++) if (a[i] === v) return i;
				}
				return -1;
			};
			const reduce = (collection, iteratee, accumulator, thisArg) => {
				let acc = isUndefined(accumulator) ? collection[0] : accumulator;
				for (let i = 0; i < collection.length; i++) acc = iteratee.call(thisArg, acc, collection[i], i);
				return acc;
			};
			const findIndex$1 = (array, predicate, thisArg) => {
				for (let i = 0, l = array.length; i < l; i++) if (predicate.call(thisArg, array[i], i, array)) return i;
				return -1;
			};
			const last$2 = (collection) => collection[collection.length - 1];
			const cached = (f) => {
				let called = false;
				let r$1;
				return (...args) => {
					if (!called) {
						called = true;
						r$1 = f.apply(null, args);
					}
					return r$1;
				};
			};
			const DeviceType = (os$2, browser, userAgent$1, mediaMatch$1) => {
				const isiPad = os$2.isiOS() && /ipad/i.test(userAgent$1) === true;
				const isiPhone = os$2.isiOS() && !isiPad;
				const isMobile = os$2.isiOS() || os$2.isAndroid();
				const isTouch$1 = isMobile || mediaMatch$1("(pointer:coarse)");
				const isTablet$1 = isiPad || !isiPhone && isMobile && mediaMatch$1("(min-device-width:768px)");
				const isPhone$1 = isiPhone || isMobile && !isTablet$1;
				const iOSwebview = browser.isSafari() && os$2.isiOS() && /safari/i.test(userAgent$1) === false;
				const isDesktop = !isPhone$1 && !isTablet$1 && !iOSwebview;
				return {
					isiPad: constant(isiPad),
					isiPhone: constant(isiPhone),
					isTablet: constant(isTablet$1),
					isPhone: constant(isPhone$1),
					isTouch: constant(isTouch$1),
					isAndroid: os$2.isAndroid,
					isiOS: os$2.isiOS,
					isWebView: constant(iOSwebview),
					isDesktop: constant(isDesktop)
				};
			};
			const firstMatch = (regexes, s) => {
				for (let i = 0; i < regexes.length; i++) {
					const x = regexes[i];
					if (x.test(s)) return x;
				}
			};
			const find$1 = (regexes, agent) => {
				const r$1 = firstMatch(regexes, agent);
				if (!r$1) return {
					major: 0,
					minor: 0
				};
				const group = (i) => {
					return Number(agent.replace(r$1, "$" + i));
				};
				return nu$3(group(1), group(2));
			};
			const detect$5 = (versionRegexes, agent) => {
				const cleanedAgent = String(agent).toLowerCase();
				if (versionRegexes.length === 0) return unknown$2();
				return find$1(versionRegexes, cleanedAgent);
			};
			const unknown$2 = () => {
				return nu$3(0, 0);
			};
			const nu$3 = (major, minor) => {
				return {
					major,
					minor
				};
			};
			const Version = {
				nu: nu$3,
				detect: detect$5,
				unknown: unknown$2
			};
			const detectBrowser$1 = (browsers$1, userAgentData) => {
				return findMap(userAgentData.brands, (uaBrand) => {
					const lcBrand = uaBrand.brand.toLowerCase();
					return find$2(browsers$1, (browser) => {
						var _a;
						return lcBrand === ((_a = browser.brand) === null || _a === void 0 ? void 0 : _a.toLowerCase());
					}).map((info) => ({
						current: info.name,
						version: Version.nu(parseInt(uaBrand.version, 10), 0)
					}));
				});
			};
			const detect$4 = (candidates, userAgent$1) => {
				const agent = String(userAgent$1).toLowerCase();
				return find$2(candidates, (candidate) => {
					return candidate.search(agent);
				});
			};
			const detectBrowser = (browsers$1, userAgent$1) => {
				return detect$4(browsers$1, userAgent$1).map((browser) => {
					const version = Version.detect(browser.versionRegexes, userAgent$1);
					return {
						current: browser.name,
						version
					};
				});
			};
			const detectOs = (oses$1, userAgent$1) => {
				return detect$4(oses$1, userAgent$1).map((os$2) => {
					const version = Version.detect(os$2.versionRegexes, userAgent$1);
					return {
						current: os$2.name,
						version
					};
				});
			};
			const removeFromStart = (str, numChars) => {
				return str.substring(numChars);
			};
			const checkRange = (str, substr, start$2) => substr === "" || str.length >= substr.length && str.substr(start$2, start$2 + substr.length) === substr;
			const removeLeading = (str, prefix) => {
				return startsWith(str, prefix) ? removeFromStart(str, prefix.length) : str;
			};
			const contains$1 = (str, substr, start$2 = 0, end$1) => {
				const idx = str.indexOf(substr, start$2);
				if (idx !== -1) return isUndefined(end$1) ? true : idx + substr.length <= end$1;
				else return false;
			};
			const startsWith = (str, prefix) => {
				return checkRange(str, prefix, 0);
			};
			const endsWith = (str, suffix) => {
				return checkRange(str, suffix, str.length - suffix.length);
			};
			const blank = (r$1) => (s) => s.replace(r$1, "");
			const trim$3 = blank(/^\s+|\s+$/g);
			const lTrim = blank(/^\s+/g);
			const rTrim = blank(/\s+$/g);
			const isNotEmpty = (s) => s.length > 0;
			const isEmpty$3 = (s) => !isNotEmpty(s);
			const repeat = (s, count$2) => count$2 <= 0 ? "" : new Array(count$2 + 1).join(s);
			const toInt = (value$3, radix = 10) => {
				const num = parseInt(value$3, radix);
				return isNaN(num) ? Optional.none() : Optional.some(num);
			};
			const normalVersionRegex = /.*?version\/\ ?([0-9]+)\.([0-9]+).*/;
			const checkContains = (target) => {
				return (uastring) => {
					return contains$1(uastring, target);
				};
			};
			const browsers = [
				{
					name: "Edge",
					versionRegexes: [/.*?edge\/ ?([0-9]+)\.([0-9]+)$/],
					search: (uastring) => {
						return contains$1(uastring, "edge/") && contains$1(uastring, "chrome") && contains$1(uastring, "safari") && contains$1(uastring, "applewebkit");
					}
				},
				{
					name: "Chromium",
					brand: "Chromium",
					versionRegexes: [/.*?chrome\/([0-9]+)\.([0-9]+).*/, normalVersionRegex],
					search: (uastring) => {
						return contains$1(uastring, "chrome") && !contains$1(uastring, "chromeframe");
					}
				},
				{
					name: "IE",
					versionRegexes: [/.*?msie\ ?([0-9]+)\.([0-9]+).*/, /.*?rv:([0-9]+)\.([0-9]+).*/],
					search: (uastring) => {
						return contains$1(uastring, "msie") || contains$1(uastring, "trident");
					}
				},
				{
					name: "Opera",
					versionRegexes: [normalVersionRegex, /.*?opera\/([0-9]+)\.([0-9]+).*/],
					search: checkContains("opera")
				},
				{
					name: "Firefox",
					versionRegexes: [/.*?firefox\/\ ?([0-9]+)\.([0-9]+).*/],
					search: checkContains("firefox")
				},
				{
					name: "Safari",
					versionRegexes: [normalVersionRegex, /.*?cpu os ([0-9]+)_([0-9]+).*/],
					search: (uastring) => {
						return (contains$1(uastring, "safari") || contains$1(uastring, "mobile/")) && contains$1(uastring, "applewebkit");
					}
				}
			];
			const oses = [
				{
					name: "Windows",
					search: checkContains("win"),
					versionRegexes: [/.*?windows\ nt\ ?([0-9]+)\.([0-9]+).*/]
				},
				{
					name: "iOS",
					search: (uastring) => {
						return contains$1(uastring, "iphone") || contains$1(uastring, "ipad");
					},
					versionRegexes: [
						/.*?version\/\ ?([0-9]+)\.([0-9]+).*/,
						/.*cpu os ([0-9]+)_([0-9]+).*/,
						/.*cpu iphone os ([0-9]+)_([0-9]+).*/
					]
				},
				{
					name: "Android",
					search: checkContains("android"),
					versionRegexes: [/.*?android\ ?([0-9]+)\.([0-9]+).*/]
				},
				{
					name: "macOS",
					search: checkContains("mac os x"),
					versionRegexes: [/.*?mac\ os\ x\ ?([0-9]+)_([0-9]+).*/]
				},
				{
					name: "Linux",
					search: checkContains("linux"),
					versionRegexes: []
				},
				{
					name: "Solaris",
					search: checkContains("sunos"),
					versionRegexes: []
				},
				{
					name: "FreeBSD",
					search: checkContains("freebsd"),
					versionRegexes: []
				},
				{
					name: "ChromeOS",
					search: checkContains("cros"),
					versionRegexes: [/.*?chrome\/([0-9]+)\.([0-9]+).*/]
				}
			];
			const PlatformInfo = {
				browsers: constant(browsers),
				oses: constant(oses)
			};
			const edge = "Edge";
			const chromium = "Chromium";
			const ie = "IE";
			const opera = "Opera";
			const firefox = "Firefox";
			const safari = "Safari";
			const unknown$1 = () => {
				return nu$2({
					current: void 0,
					version: Version.unknown()
				});
			};
			const nu$2 = (info) => {
				const current = info.current;
				const version = info.version;
				const isBrowser = (name$1) => () => current === name$1;
				return {
					current,
					version,
					isEdge: isBrowser(edge),
					isChromium: isBrowser(chromium),
					isIE: isBrowser(ie),
					isOpera: isBrowser(opera),
					isFirefox: isBrowser(firefox),
					isSafari: isBrowser(safari)
				};
			};
			const Browser = {
				unknown: unknown$1,
				nu: nu$2,
				edge: constant(edge),
				chromium: constant(chromium),
				ie: constant(ie),
				opera: constant(opera),
				firefox: constant(firefox),
				safari: constant(safari)
			};
			const windows = "Windows";
			const ios = "iOS";
			const android = "Android";
			const linux = "Linux";
			const macos = "macOS";
			const solaris = "Solaris";
			const freebsd = "FreeBSD";
			const chromeos = "ChromeOS";
			const unknown = () => {
				return nu$1({
					current: void 0,
					version: Version.unknown()
				});
			};
			const nu$1 = (info) => {
				const current = info.current;
				const version = info.version;
				const isOS = (name$1) => () => current === name$1;
				return {
					current,
					version,
					isWindows: isOS(windows),
					isiOS: isOS(ios),
					isAndroid: isOS(android),
					isMacOS: isOS(macos),
					isLinux: isOS(linux),
					isSolaris: isOS(solaris),
					isFreeBSD: isOS(freebsd),
					isChromeOS: isOS(chromeos)
				};
			};
			const OperatingSystem = {
				unknown,
				nu: nu$1,
				windows: constant(windows),
				ios: constant(ios),
				android: constant(android),
				linux: constant(linux),
				macos: constant(macos),
				solaris: constant(solaris),
				freebsd: constant(freebsd),
				chromeos: constant(chromeos)
			};
			const detect$3 = (userAgent$1, userAgentDataOpt, mediaMatch$1) => {
				const browsers$1 = PlatformInfo.browsers();
				const oses$1 = PlatformInfo.oses();
				const browser = userAgentDataOpt.bind((userAgentData) => detectBrowser$1(browsers$1, userAgentData)).orThunk(() => detectBrowser(browsers$1, userAgent$1)).fold(Browser.unknown, Browser.nu);
				const os$2 = detectOs(oses$1, userAgent$1).fold(OperatingSystem.unknown, OperatingSystem.nu);
				return {
					browser,
					os: os$2,
					deviceType: DeviceType(os$2, browser, userAgent$1, mediaMatch$1)
				};
			};
			const PlatformDetection = { detect: detect$3 };
			const mediaMatch = (query) => window.matchMedia(query).matches;
			let platform$4 = cached(() => PlatformDetection.detect(navigator.userAgent, Optional.from(navigator.userAgentData), mediaMatch));
			const detect$2 = () => platform$4();
			const userAgent = navigator.userAgent;
			const platform$3 = detect$2();
			const browser$3 = platform$3.browser;
			const os$1 = platform$3.os;
			const deviceType = platform$3.deviceType;
			const windowsPhone = userAgent.indexOf("Windows Phone") !== -1;
			const Env = {
				transparentSrc: "data:image/gif;base64,R0lGODlhAQABAIAAAAAAAP///yH5BAEAAAAALAAAAAABAAEAAAIBRAA7",
				documentMode: browser$3.isIE() ? document.documentMode || 7 : 10,
				cacheSuffix: null,
				container: null,
				canHaveCSP: !browser$3.isIE(),
				windowsPhone,
				browser: {
					current: browser$3.current,
					version: browser$3.version,
					isChromium: browser$3.isChromium,
					isEdge: browser$3.isEdge,
					isFirefox: browser$3.isFirefox,
					isIE: browser$3.isIE,
					isOpera: browser$3.isOpera,
					isSafari: browser$3.isSafari
				},
				os: {
					current: os$1.current,
					version: os$1.version,
					isAndroid: os$1.isAndroid,
					isChromeOS: os$1.isChromeOS,
					isFreeBSD: os$1.isFreeBSD,
					isiOS: os$1.isiOS,
					isLinux: os$1.isLinux,
					isMacOS: os$1.isMacOS,
					isSolaris: os$1.isSolaris,
					isWindows: os$1.isWindows
				},
				deviceType: {
					isDesktop: deviceType.isDesktop,
					isiPad: deviceType.isiPad,
					isiPhone: deviceType.isiPhone,
					isPhone: deviceType.isPhone,
					isTablet: deviceType.isTablet,
					isTouch: deviceType.isTouch,
					isWebView: deviceType.isWebView
				}
			};
			const whiteSpaceRegExp$1 = /^\s*|\s*$/g;
			const trim$2 = (str) => {
				return isNullable(str) ? "" : ("" + str).replace(whiteSpaceRegExp$1, "");
			};
			const is$3 = (obj, type$2) => {
				if (!type$2) return obj !== void 0;
				if (type$2 === "array" && isArray(obj)) return true;
				return typeof obj === type$2;
			};
			const makeMap$4 = (items, delim, map$4 = {}) => {
				const resolvedItems = isString(items) ? items.split(delim || ",") : items || [];
				let i = resolvedItems.length;
				while (i--) map$4[resolvedItems[i]] = {};
				return map$4;
			};
			const hasOwnProperty$1 = has$2;
			const extend$3 = (obj, ...exts) => {
				for (let i = 0; i < exts.length; i++) {
					const ext = exts[i];
					for (const name$1 in ext) if (has$2(ext, name$1)) {
						const value$3 = ext[name$1];
						if (value$3 !== void 0) obj[name$1] = value$3;
					}
				}
				return obj;
			};
			const walk$4 = function(o, f, n, s) {
				s = s || this;
				if (o) {
					if (n) o = o[n];
					each$c(o, (o$1, i) => {
						if (f.call(s, o$1, i, n) === false) return false;
						else {
							walk$4(o$1, f, n, s);
							return true;
						}
					});
				}
			};
			const resolve$3 = (n, o = window) => {
				const path$1 = n.split(".");
				for (let i = 0, l = path$1.length; i < l; i++) {
					o = o[path$1[i]];
					if (!o) break;
				}
				return o;
			};
			const explode$3 = (s, d) => {
				if (isArray$1(s)) return s;
				else if (s === "") return [];
				else return map$1(s.split(d || ","), trim$2);
			};
			const _addCacheSuffix = (url) => {
				const cacheSuffix = Env.cacheSuffix;
				if (cacheSuffix) url += (url.indexOf("?") === -1 ? "?" : "&") + cacheSuffix;
				return url;
			};
			const Tools = {
				trim: trim$2,
				isArray,
				is: is$3,
				toArray: toArray$1,
				makeMap: makeMap$4,
				each: each$c,
				map: map$1,
				grep: filter$3,
				inArray: indexOf,
				hasOwn: hasOwnProperty$1,
				extend: extend$3,
				walk: walk$4,
				resolve: resolve$3,
				explode: explode$3,
				_addCacheSuffix
			};
			const is$2 = (lhs, rhs, comparator = tripleEquals) => lhs.exists((left) => comparator(left, rhs));
			const equals = (lhs, rhs, comparator = tripleEquals) => lift2(lhs, rhs, comparator).getOr(lhs.isNone() && rhs.isNone());
			const cat = (arr) => {
				const r$1 = [];
				const push = (x) => {
					r$1.push(x);
				};
				for (let i = 0; i < arr.length; i++) arr[i].each(push);
				return r$1;
			};
			const lift2 = (oa, ob, f) => oa.isSome() && ob.isSome() ? Optional.some(f(oa.getOrDie(), ob.getOrDie())) : Optional.none();
			const lift3 = (oa, ob, oc, f) => oa.isSome() && ob.isSome() && oc.isSome() ? Optional.some(f(oa.getOrDie(), ob.getOrDie(), oc.getOrDie())) : Optional.none();
			const someIf = (b, a) => b ? Optional.some(a) : Optional.none();
			const Global = typeof window !== "undefined" ? window : Function("return this;")();
			const path = (parts, scope) => {
				let o = scope !== void 0 && scope !== null ? scope : Global;
				for (let i = 0; i < parts.length && o !== void 0 && o !== null; ++i) o = o[parts[i]];
				return o;
			};
			const resolve$2 = (p, scope) => {
				return path(p.split("."), scope);
			};
			const unsafe = (name$1, scope) => {
				return resolve$2(name$1, scope);
			};
			const getOrDie = (name$1, scope) => {
				const actual = unsafe(name$1, scope);
				if (actual === void 0 || actual === null) throw new Error(name$1 + " not available on this browser");
				return actual;
			};
			const getPrototypeOf$1 = Object.getPrototypeOf;
			const sandHTMLElement = (scope) => {
				return getOrDie("HTMLElement", scope);
			};
			const isPrototypeOf = (x) => {
				const scope = resolve$2("ownerDocument.defaultView", x);
				return isObject(x) && (sandHTMLElement(scope).prototype.isPrototypeOf(x) || /^HTML\w*Element$/.test(getPrototypeOf$1(x).constructor.name));
			};
			const COMMENT = 8;
			const DOCUMENT = 9;
			const DOCUMENT_FRAGMENT = 11;
			const ELEMENT = 1;
			const TEXT = 3;
			const name = (element) => {
				return element.dom.nodeName.toLowerCase();
			};
			const type$1 = (element) => element.dom.nodeType;
			const isType = (t) => (element) => type$1(element) === t;
			const isComment$1 = (element) => type$1(element) === COMMENT || name(element) === "#comment";
			const isHTMLElement = (element) => isElement$7(element) && isPrototypeOf(element.dom);
			const isElement$7 = isType(ELEMENT);
			const isText$b = isType(TEXT);
			const isDocument$2 = isType(DOCUMENT);
			const isDocumentFragment$1 = isType(DOCUMENT_FRAGMENT);
			const isTag = (tag) => (e) => isElement$7(e) && name(e) === tag;
			const rawSet = (dom$1, key, value$3) => {
				if (isString(value$3) || isBoolean(value$3) || isNumber(value$3)) dom$1.setAttribute(key, value$3 + "");
				else {
					console.error("Invalid call to Attribute.set. Key ", key, ":: Value ", value$3, ":: Element ", dom$1);
					throw new Error("Attribute value was not simple");
				}
			};
			const set$3 = (element, key, value$3) => {
				rawSet(element.dom, key, value$3);
			};
			const setAll$1 = (element, attrs) => {
				const dom$1 = element.dom;
				each$d(attrs, (v, k) => {
					rawSet(dom$1, k, v);
				});
			};
			const get$9 = (element, key) => {
				const v = element.dom.getAttribute(key);
				return v === null ? void 0 : v;
			};
			const getOpt = (element, key) => Optional.from(get$9(element, key));
			const has$1 = (element, key) => {
				const dom$1 = element.dom;
				return dom$1 && dom$1.hasAttribute ? dom$1.hasAttribute(key) : false;
			};
			const remove$a = (element, key) => {
				element.dom.removeAttribute(key);
			};
			const hasNone = (element) => {
				const attrs = element.dom.attributes;
				return attrs === void 0 || attrs === null || attrs.length === 0;
			};
			const clone$4 = (element) => foldl(element.dom.attributes, (acc, attr) => {
				acc[attr.name] = attr.value;
				return acc;
			}, {});
			const read$4 = (element, attr) => {
				const value$3 = get$9(element, attr);
				return value$3 === void 0 || value$3 === "" ? [] : value$3.split(" ");
			};
			const add$4 = (element, attr, id) => {
				set$3(element, attr, read$4(element, attr).concat([id]).join(" "));
				return true;
			};
			const remove$9 = (element, attr, id) => {
				const nu$4 = filter$5(read$4(element, attr), (v) => v !== id);
				if (nu$4.length > 0) set$3(element, attr, nu$4.join(" "));
				else remove$a(element, attr);
				return false;
			};
			const supports = (element) => element.dom.classList !== void 0;
			const get$8 = (element) => read$4(element, "class");
			const add$3 = (element, clazz) => add$4(element, "class", clazz);
			const remove$8 = (element, clazz) => remove$9(element, "class", clazz);
			const toggle$2 = (element, clazz) => {
				if (contains$2(get$8(element), clazz)) return remove$8(element, clazz);
				else return add$3(element, clazz);
			};
			const add$2 = (element, clazz) => {
				if (supports(element)) element.dom.classList.add(clazz);
				else add$3(element, clazz);
			};
			const cleanClass = (element) => {
				if ((supports(element) ? element.dom.classList : get$8(element)).length === 0) remove$a(element, "class");
			};
			const remove$7 = (element, clazz) => {
				if (supports(element)) element.dom.classList.remove(clazz);
				else remove$8(element, clazz);
				cleanClass(element);
			};
			const toggle$1 = (element, clazz) => {
				const result = supports(element) ? element.dom.classList.toggle(clazz) : toggle$2(element, clazz);
				cleanClass(element);
				return result;
			};
			const has = (element, clazz) => supports(element) && element.dom.classList.contains(clazz);
			const fromHtml$1 = (html$2, scope) => {
				const div = (scope || document).createElement("div");
				div.innerHTML = html$2;
				if (!div.hasChildNodes() || div.childNodes.length > 1) {
					const message = "HTML does not have a single root node";
					console.error(message, html$2);
					throw new Error(message);
				}
				return fromDom$2(div.childNodes[0]);
			};
			const fromTag = (tag, scope) => {
				return fromDom$2((scope || document).createElement(tag));
			};
			const fromText = (text$1, scope) => {
				return fromDom$2((scope || document).createTextNode(text$1));
			};
			const fromDom$2 = (node) => {
				if (node === null || node === void 0) throw new Error("Node cannot be null or undefined");
				return { dom: node };
			};
			const fromPoint$2 = (docElm, x, y) => Optional.from(docElm.dom.elementFromPoint(x, y)).map(fromDom$2);
			const SugarElement = {
				fromHtml: fromHtml$1,
				fromTag,
				fromText,
				fromDom: fromDom$2,
				fromPoint: fromPoint$2
			};
			const toArray = (target, f) => {
				const r$1 = [];
				const recurse = (e) => {
					r$1.push(e);
					return f(e);
				};
				let cur = f(target);
				do
					cur = cur.bind(recurse);
				while (cur.isSome());
				return r$1;
			};
			const is$1 = (element, selector) => {
				const dom$1 = element.dom;
				if (dom$1.nodeType !== ELEMENT) return false;
				else {
					const elem = dom$1;
					if (elem.matches !== void 0) return elem.matches(selector);
					else if (elem.msMatchesSelector !== void 0) return elem.msMatchesSelector(selector);
					else if (elem.webkitMatchesSelector !== void 0) return elem.webkitMatchesSelector(selector);
					else if (elem.mozMatchesSelector !== void 0) return elem.mozMatchesSelector(selector);
					else throw new Error("Browser lacks native selectors");
				}
			};
			const bypassSelector = (dom$1) => dom$1.nodeType !== ELEMENT && dom$1.nodeType !== DOCUMENT && dom$1.nodeType !== DOCUMENT_FRAGMENT || dom$1.childElementCount === 0;
			const all = (selector, scope) => {
				const base = scope === void 0 ? document : scope.dom;
				return bypassSelector(base) ? [] : map$3(base.querySelectorAll(selector), SugarElement.fromDom);
			};
			const one = (selector, scope) => {
				const base = scope === void 0 ? document : scope.dom;
				return bypassSelector(base) ? Optional.none() : Optional.from(base.querySelector(selector)).map(SugarElement.fromDom);
			};
			const eq = (e1, e2) => e1.dom === e2.dom;
			const contains = (e1, e2) => {
				const d1 = e1.dom;
				const d2 = e2.dom;
				return d1 === d2 ? false : d1.contains(d2);
			};
			const owner$1 = (element) => SugarElement.fromDom(element.dom.ownerDocument);
			const documentOrOwner = (dos) => isDocument$2(dos) ? dos : owner$1(dos);
			const documentElement = (element) => SugarElement.fromDom(documentOrOwner(element).dom.documentElement);
			const defaultView = (element) => SugarElement.fromDom(documentOrOwner(element).dom.defaultView);
			const parent = (element) => Optional.from(element.dom.parentNode).map(SugarElement.fromDom);
			const parentElement = (element) => Optional.from(element.dom.parentElement).map(SugarElement.fromDom);
			const parents$1 = (element, isRoot$2) => {
				const stop$1 = isFunction(isRoot$2) ? isRoot$2 : never;
				let dom$1 = element.dom;
				const ret = [];
				while (dom$1.parentNode !== null && dom$1.parentNode !== void 0) {
					const rawParent = dom$1.parentNode;
					const p = SugarElement.fromDom(rawParent);
					ret.push(p);
					if (stop$1(p) === true) break;
					else dom$1 = rawParent;
				}
				return ret;
			};
			const siblings = (element) => {
				const filterSelf = (elements) => filter$5(elements, (x) => !eq(element, x));
				return parent(element).map(children$1).map(filterSelf).getOr([]);
			};
			const prevSibling = (element) => Optional.from(element.dom.previousSibling).map(SugarElement.fromDom);
			const nextSibling = (element) => Optional.from(element.dom.nextSibling).map(SugarElement.fromDom);
			const prevSiblings = (element) => reverse(toArray(element, prevSibling));
			const nextSiblings = (element) => toArray(element, nextSibling);
			const children$1 = (element) => map$3(element.dom.childNodes, SugarElement.fromDom);
			const child$1 = (element, index) => {
				const cs = element.dom.childNodes;
				return Optional.from(cs[index]).map(SugarElement.fromDom);
			};
			const firstChild = (element) => child$1(element, 0);
			const lastChild = (element) => child$1(element, element.dom.childNodes.length - 1);
			const childNodesCount = (element) => element.dom.childNodes.length;
			const hasChildNodes = (element) => element.dom.hasChildNodes();
			const getHead = (doc) => {
				const b = doc.dom.head;
				if (b === null || b === void 0) throw new Error("Head is not available yet");
				return SugarElement.fromDom(b);
			};
			const isShadowRoot = (dos) => isDocumentFragment$1(dos) && isNonNullable(dos.dom.host);
			const supported = isFunction(Element.prototype.attachShadow) && isFunction(Node.prototype.getRootNode);
			const isSupported$1 = constant(supported);
			const getRootNode = supported ? (e) => SugarElement.fromDom(e.dom.getRootNode()) : documentOrOwner;
			const getStyleContainer = (dos) => isShadowRoot(dos) ? dos : getHead(documentOrOwner(dos));
			const getContentContainer = (dos) => isShadowRoot(dos) ? dos : SugarElement.fromDom(documentOrOwner(dos).dom.body);
			const getShadowRoot = (e) => {
				const r$1 = getRootNode(e);
				return isShadowRoot(r$1) ? Optional.some(r$1) : Optional.none();
			};
			const getShadowHost = (e) => SugarElement.fromDom(e.dom.host);
			const getOriginalEventTarget = (event) => {
				if (isSupported$1() && isNonNullable(event.target)) {
					const el = SugarElement.fromDom(event.target);
					if (isElement$7(el) && isOpenShadowHost(el)) {
						if (event.composed && event.composedPath) {
							const composedPath = event.composedPath();
							if (composedPath) return head(composedPath);
						}
					}
				}
				return Optional.from(event.target);
			};
			const isOpenShadowHost = (element) => isNonNullable(element.dom.shadowRoot);
			const inBody = (element) => {
				const dom$1 = isText$b(element) ? element.dom.parentNode : element.dom;
				if (dom$1 === void 0 || dom$1 === null || dom$1.ownerDocument === null) return false;
				const doc = dom$1.ownerDocument;
				return getShadowRoot(SugarElement.fromDom(dom$1)).fold(() => doc.body.contains(dom$1), compose1(inBody, getShadowHost));
			};
			var ClosestOrAncestor = (is$5, ancestor$5, scope, a, isRoot$2) => {
				if (is$5(scope, a)) return Optional.some(scope);
				else if (isFunction(isRoot$2) && isRoot$2(scope)) return Optional.none();
				else return ancestor$5(scope, a, isRoot$2);
			};
			const ancestor$4 = (scope, predicate, isRoot$2) => {
				let element = scope.dom;
				const stop$1 = isFunction(isRoot$2) ? isRoot$2 : never;
				while (element.parentNode) {
					element = element.parentNode;
					const el = SugarElement.fromDom(element);
					if (predicate(el)) return Optional.some(el);
					else if (stop$1(el)) break;
				}
				return Optional.none();
			};
			const closest$4 = (scope, predicate, isRoot$2) => {
				const is$5 = (s, test) => test(s);
				return ClosestOrAncestor(is$5, ancestor$4, scope, predicate, isRoot$2);
			};
			const sibling$1 = (scope, predicate) => {
				const element = scope.dom;
				if (!element.parentNode) return Optional.none();
				return child(SugarElement.fromDom(element.parentNode), (x) => !eq(scope, x) && predicate(x));
			};
			const child = (scope, predicate) => {
				const pred = (node) => predicate(SugarElement.fromDom(node));
				return find$2(scope.dom.childNodes, pred).map(SugarElement.fromDom);
			};
			const descendant$1 = (scope, predicate) => {
				const descend$1 = (node) => {
					for (let i = 0; i < node.childNodes.length; i++) {
						const child$2 = SugarElement.fromDom(node.childNodes[i]);
						if (predicate(child$2)) return Optional.some(child$2);
						const res = descend$1(node.childNodes[i]);
						if (res.isSome()) return res;
					}
					return Optional.none();
				};
				return descend$1(scope.dom);
			};
			const ancestor$3 = (scope, selector, isRoot$2) => ancestor$4(scope, (e) => is$1(e, selector), isRoot$2);
			const descendant = (scope, selector) => one(selector, scope);
			const closest$3 = (scope, selector, isRoot$2) => {
				const is$5 = (element, selector$1) => is$1(element, selector$1);
				return ClosestOrAncestor(is$5, ancestor$3, scope, selector, isRoot$2);
			};
			const closest$2 = (target) => closest$3(target, "[contenteditable]");
			const isEditable$3 = (element, assumeEditable = false) => {
				if (inBody(element)) return element.dom.isContentEditable;
				else return closest$2(element).fold(constant(assumeEditable), (editable) => getRaw$1(editable) === "true");
			};
			const getRaw$1 = (element) => element.dom.contentEditable;
			const isSupported = (dom$1) => dom$1.style !== void 0 && isFunction(dom$1.style.getPropertyValue);
			const internalSet = (dom$1, property, value$3) => {
				if (!isString(value$3)) {
					console.error("Invalid call to CSS.set. Property ", property, ":: Value ", value$3, ":: Element ", dom$1);
					throw new Error("CSS value must be a string: " + value$3);
				}
				if (isSupported(dom$1)) dom$1.style.setProperty(property, value$3);
			};
			const internalRemove = (dom$1, property) => {
				if (isSupported(dom$1)) dom$1.style.removeProperty(property);
			};
			const set$2 = (element, property, value$3) => {
				const dom$1 = element.dom;
				internalSet(dom$1, property, value$3);
			};
			const setAll = (element, css) => {
				const dom$1 = element.dom;
				each$d(css, (v, k) => {
					internalSet(dom$1, k, v);
				});
			};
			const get$7 = (element, property) => {
				const dom$1 = element.dom;
				const r$1 = window.getComputedStyle(dom$1).getPropertyValue(property);
				return r$1 === "" && !inBody(element) ? getUnsafeProperty(dom$1, property) : r$1;
			};
			const getUnsafeProperty = (dom$1, property) => isSupported(dom$1) ? dom$1.style.getPropertyValue(property) : "";
			const getRaw = (element, property) => {
				const dom$1 = element.dom;
				const raw = getUnsafeProperty(dom$1, property);
				return Optional.from(raw).filter((r$1) => r$1.length > 0);
			};
			const getAllRaw = (element) => {
				const css = {};
				const dom$1 = element.dom;
				if (isSupported(dom$1)) for (let i = 0; i < dom$1.style.length; i++) {
					const ruleName = dom$1.style.item(i);
					css[ruleName] = dom$1.style[ruleName];
				}
				return css;
			};
			const remove$6 = (element, property) => {
				const dom$1 = element.dom;
				internalRemove(dom$1, property);
				if (is$2(getOpt(element, "style").map(trim$3), "")) remove$a(element, "style");
			};
			const reflow = (e) => e.dom.offsetWidth;
			const before$3 = (marker, element) => {
				parent(marker).each((v) => {
					v.dom.insertBefore(element.dom, marker.dom);
				});
			};
			const after$4 = (marker, element) => {
				nextSibling(marker).fold(() => {
					parent(marker).each((v) => {
						append$1(v, element);
					});
				}, (v) => {
					before$3(v, element);
				});
			};
			const prepend = (parent$1, element) => {
				firstChild(parent$1).fold(() => {
					append$1(parent$1, element);
				}, (v) => {
					parent$1.dom.insertBefore(element.dom, v.dom);
				});
			};
			const append$1 = (parent$1, element) => {
				parent$1.dom.appendChild(element.dom);
			};
			const wrap$2 = (element, wrapper) => {
				before$3(element, wrapper);
				append$1(wrapper, element);
			};
			const after$3 = (marker, elements) => {
				each$e(elements, (x, i) => {
					after$4(i === 0 ? marker : elements[i - 1], x);
				});
			};
			const append = (parent$1, elements) => {
				each$e(elements, (x) => {
					append$1(parent$1, x);
				});
			};
			const empty = (element) => {
				element.dom.textContent = "";
				each$e(children$1(element), (rogue) => {
					remove$5(rogue);
				});
			};
			const remove$5 = (element) => {
				const dom$1 = element.dom;
				if (dom$1.parentNode !== null) dom$1.parentNode.removeChild(dom$1);
			};
			const unwrap = (wrapper) => {
				const children$2 = children$1(wrapper);
				if (children$2.length > 0) after$3(wrapper, children$2);
				remove$5(wrapper);
			};
			const fromHtml = (html$2, scope) => {
				const div = (scope || document).createElement("div");
				div.innerHTML = html$2;
				return children$1(SugarElement.fromDom(div));
			};
			const fromDom$1 = (nodes) => map$3(nodes, SugarElement.fromDom);
			const get$6 = (element) => element.dom.innerHTML;
			const set$1 = (element, content) => {
				const docDom = owner$1(element).dom;
				const fragment = SugarElement.fromDom(docDom.createDocumentFragment());
				append(fragment, fromHtml(content, docDom));
				empty(element);
				append$1(element, fragment);
			};
			const getOuter = (element) => {
				const container = SugarElement.fromTag("div");
				append$1(container, SugarElement.fromDom(element.dom.cloneNode(true)));
				return get$6(container);
			};
			const mkEvent = (target, x, y, stop$1, prevent, kill, raw) => ({
				target,
				x,
				y,
				stop: stop$1,
				prevent,
				kill,
				raw
			});
			const fromRawEvent = (rawEvent) => {
				const target = SugarElement.fromDom(getOriginalEventTarget(rawEvent).getOr(rawEvent.target));
				const stop$1 = () => rawEvent.stopPropagation();
				const prevent = () => rawEvent.preventDefault();
				const kill = compose(prevent, stop$1);
				return mkEvent(target, rawEvent.clientX, rawEvent.clientY, stop$1, prevent, kill, rawEvent);
			};
			const handle$1 = (filter$6, handler) => (rawEvent) => {
				if (filter$6(rawEvent)) handler(fromRawEvent(rawEvent));
			};
			const binder = (element, event, filter$6, handler, useCapture) => {
				const wrapped = handle$1(filter$6, handler);
				element.dom.addEventListener(event, wrapped, useCapture);
				return { unbind: curry(unbind, element, event, wrapped, useCapture) };
			};
			const bind$2 = (element, event, filter$6, handler) => binder(element, event, filter$6, handler, false);
			const unbind = (element, event, handler, useCapture) => {
				element.dom.removeEventListener(event, handler, useCapture);
			};
			const r = (left, top) => {
				const translate$1 = (x, y) => r(left + x, top + y);
				return {
					left,
					top,
					translate: translate$1
				};
			};
			const SugarPosition = r;
			const boxPosition = (dom$1) => {
				const box = dom$1.getBoundingClientRect();
				return SugarPosition(box.left, box.top);
			};
			const firstDefinedOrZero = (a, b) => {
				if (a !== void 0) return a;
				else return b !== void 0 ? b : 0;
			};
			const absolute = (element) => {
				const doc = element.dom.ownerDocument;
				const body = doc.body;
				const win = doc.defaultView;
				const html$2 = doc.documentElement;
				if (body === element.dom) return SugarPosition(body.offsetLeft, body.offsetTop);
				const scrollTop = firstDefinedOrZero(win === null || win === void 0 ? void 0 : win.pageYOffset, html$2.scrollTop);
				const scrollLeft$1 = firstDefinedOrZero(win === null || win === void 0 ? void 0 : win.pageXOffset, html$2.scrollLeft);
				const clientTop = firstDefinedOrZero(html$2.clientTop, body.clientTop);
				const clientLeft = firstDefinedOrZero(html$2.clientLeft, body.clientLeft);
				return viewport(element).translate(scrollLeft$1 - clientLeft, scrollTop - clientTop);
			};
			const viewport = (element) => {
				const dom$1 = element.dom;
				const body = dom$1.ownerDocument.body;
				if (body === dom$1) return SugarPosition(body.offsetLeft, body.offsetTop);
				if (!inBody(element)) return SugarPosition(0, 0);
				return boxPosition(dom$1);
			};
			const get$5 = (_DOC) => {
				const doc = _DOC !== void 0 ? _DOC.dom : document;
				return SugarPosition(doc.body.scrollLeft || doc.documentElement.scrollLeft, doc.body.scrollTop || doc.documentElement.scrollTop);
			};
			const to = (x, y, _DOC) => {
				const win = (_DOC !== void 0 ? _DOC.dom : document).defaultView;
				if (win) win.scrollTo(x, y);
			};
			const intoView = (element, alignToTop) => {
				if (detect$2().browser.isSafari() && isFunction(element.dom.scrollIntoViewIfNeeded)) element.dom.scrollIntoViewIfNeeded(false);
				else element.dom.scrollIntoView(alignToTop);
			};
			const get$4 = (_win) => {
				const win = _win === void 0 ? window : _win;
				if (detect$2().browser.isFirefox()) return Optional.none();
				else return Optional.from(win.visualViewport);
			};
			const bounds = (x, y, width, height) => ({
				x,
				y,
				width,
				height,
				right: x + width,
				bottom: y + height
			});
			const getBounds = (_win) => {
				const win = _win === void 0 ? window : _win;
				const doc = win.document;
				const scroll = get$5(SugarElement.fromDom(doc));
				return get$4(win).fold(() => {
					const html$2 = win.document.documentElement;
					const width = html$2.clientWidth;
					const height = html$2.clientHeight;
					return bounds(scroll.left, scroll.top, width, height);
				}, (visualViewport) => bounds(Math.max(visualViewport.pageLeft, scroll.left), Math.max(visualViewport.pageTop, scroll.top), visualViewport.width, visualViewport.height));
			};
			const children = (scope, predicate) => filter$5(children$1(scope), predicate);
			const descendants$1 = (scope, predicate) => {
				let result = [];
				each$e(children$1(scope), (x) => {
					if (predicate(x)) result = result.concat([x]);
					result = result.concat(descendants$1(x, predicate));
				});
				return result;
			};
			const descendants = (scope, selector) => all(selector, scope);
			const ancestor$2 = (scope, selector, isRoot$2) => ancestor$3(scope, selector, isRoot$2).isSome();
			class DomTreeWalker {
				constructor(startNode, rootNode) {
					this.node = startNode;
					this.rootNode = rootNode;
					this.current = this.current.bind(this);
					this.next = this.next.bind(this);
					this.prev = this.prev.bind(this);
					this.prev2 = this.prev2.bind(this);
				}
				current() {
					return this.node;
				}
				next(shallow$2) {
					this.node = this.findSibling(this.node, "firstChild", "nextSibling", shallow$2);
					return this.node;
				}
				prev(shallow$2) {
					this.node = this.findSibling(this.node, "lastChild", "previousSibling", shallow$2);
					return this.node;
				}
				prev2(shallow$2) {
					this.node = this.findPreviousNode(this.node, shallow$2);
					return this.node;
				}
				findSibling(node, startName, siblingName, shallow$2) {
					if (node) {
						if (!shallow$2 && node[startName]) return node[startName];
						if (node !== this.rootNode) {
							let sibling$2 = node[siblingName];
							if (sibling$2) return sibling$2;
							for (let parent$1 = node.parentNode; parent$1 && parent$1 !== this.rootNode; parent$1 = parent$1.parentNode) {
								sibling$2 = parent$1[siblingName];
								if (sibling$2) return sibling$2;
							}
						}
					}
				}
				findPreviousNode(node, shallow$2) {
					if (node) {
						const sibling$2 = node.previousSibling;
						if (this.rootNode && sibling$2 === this.rootNode) return;
						if (sibling$2) {
							if (!shallow$2) {
								for (let child$2 = sibling$2.lastChild; child$2; child$2 = child$2.lastChild) if (!child$2.lastChild) return child$2;
							}
							return sibling$2;
						}
						const parent$1 = node.parentNode;
						if (parent$1 && parent$1 !== this.rootNode) return parent$1;
					}
				}
			}
			const isNodeType = (type$2) => {
				return (node) => {
					return !!node && node.nodeType === type$2;
				};
			};
			const isRestrictedNode = (node) => !!node && !Object.getPrototypeOf(node);
			const isElement$6 = isNodeType(1);
			const matchNodeName = (name$1) => {
				const lowerCasedName = name$1.toLowerCase();
				return (node) => isNonNullable(node) && node.nodeName.toLowerCase() === lowerCasedName;
			};
			const matchNodeNames = (names) => {
				const lowerCasedNames = names.map((s) => s.toLowerCase());
				return (node) => {
					if (node && node.nodeName) return contains$2(lowerCasedNames, node.nodeName.toLowerCase());
					return false;
				};
			};
			const matchStyleValues = (name$1, values$1) => {
				const items = values$1.toLowerCase().split(" ");
				return (node) => {
					if (isElement$6(node)) {
						const win = node.ownerDocument.defaultView;
						if (win) for (let i = 0; i < items.length; i++) {
							const computed = win.getComputedStyle(node, null);
							if ((computed ? computed.getPropertyValue(name$1) : null) === items[i]) return true;
						}
					}
					return false;
				};
			};
			const hasAttribute = (attrName) => {
				return (node) => {
					return isElement$6(node) && node.hasAttribute(attrName);
				};
			};
			const hasAttributeValue = (attrName, attrValue) => {
				return (node) => {
					return isElement$6(node) && node.getAttribute(attrName) === attrValue;
				};
			};
			const isBogus$2 = (node) => isElement$6(node) && node.hasAttribute("data-mce-bogus");
			const isBogusAll$1 = (node) => isElement$6(node) && node.getAttribute("data-mce-bogus") === "all";
			const isTable$2 = (node) => isElement$6(node) && node.tagName === "TABLE";
			const hasContentEditableState = (value$3) => {
				return (node) => {
					if (isElement$6(node)) {
						if (node.contentEditable === value$3) return true;
						if (node.getAttribute("data-mce-contenteditable") === value$3) return true;
					}
					return false;
				};
			};
			const isTextareaOrInput = matchNodeNames(["textarea", "input"]);
			const isText$a = isNodeType(3);
			const isCData = isNodeType(4);
			const isPi = isNodeType(7);
			const isComment = isNodeType(8);
			const isDocument$1 = isNodeType(9);
			const isDocumentFragment = isNodeType(11);
			const isBr$6 = matchNodeName("br");
			const isImg = matchNodeName("img");
			const isContentEditableTrue$3 = hasContentEditableState("true");
			const isContentEditableFalse$b = hasContentEditableState("false");
			const isTableCell$3 = matchNodeNames(["td", "th"]);
			const isTableCellOrCaption = matchNodeNames([
				"td",
				"th",
				"caption"
			]);
			const isMedia$2 = matchNodeNames([
				"video",
				"audio",
				"object",
				"embed"
			]);
			const isListItem$2 = matchNodeName("li");
			const isDetails = matchNodeName("details");
			const isSummary = matchNodeName("summary");
			const zeroWidth = "";
			const nbsp = "\xA0";
			const isZwsp$2 = (char) => char === zeroWidth;
			const removeZwsp = (s) => s.replace(/\uFEFF/g, "");
			const NodeValue = (is$5, name$1) => {
				const get$10 = (element) => {
					if (!is$5(element)) throw new Error("Can only get " + name$1 + " value of a " + name$1 + " node");
					return getOption$1(element).getOr("");
				};
				const getOption$1 = (element) => is$5(element) ? Optional.from(element.dom.nodeValue) : Optional.none();
				const set$4 = (element, value$3) => {
					if (!is$5(element)) throw new Error("Can only set raw " + name$1 + " value of a " + name$1 + " node");
					element.dom.nodeValue = value$3;
				};
				return {
					get: get$10,
					getOption: getOption$1,
					set: set$4
				};
			};
			const api$1 = NodeValue(isText$b, "text");
			const get$3 = (element) => api$1.get(element);
			const getOption = (element) => api$1.getOption(element);
			const set = (element, value$3) => api$1.set(element, value$3);
			const blocks = [
				"article",
				"aside",
				"details",
				"div",
				"dt",
				"figcaption",
				"footer",
				"form",
				"fieldset",
				"header",
				"hgroup",
				"html",
				"main",
				"nav",
				"section",
				"summary",
				"body",
				"p",
				"dl",
				"multicol",
				"dd",
				"figure",
				"address",
				"center",
				"blockquote",
				"h1",
				"h2",
				"h3",
				"h4",
				"h5",
				"h6",
				"listing",
				"xmp",
				"pre",
				"plaintext",
				"menu",
				"dir",
				"ul",
				"ol",
				"li",
				"hr",
				"table",
				"tbody",
				"thead",
				"tfoot",
				"th",
				"tr",
				"td",
				"caption"
			];
			const tableCells = ["td", "th"];
			const tableSections = [
				"thead",
				"tbody",
				"tfoot"
			];
			const textBlocks = [
				"h1",
				"h2",
				"h3",
				"h4",
				"h5",
				"h6",
				"p",
				"div",
				"address",
				"pre",
				"form",
				"blockquote",
				"center",
				"dir",
				"fieldset",
				"header",
				"footer",
				"article",
				"section",
				"hgroup",
				"aside",
				"nav",
				"figure"
			];
			const headings = [
				"h1",
				"h2",
				"h3",
				"h4",
				"h5",
				"h6"
			];
			const listItems$1 = [
				"li",
				"dd",
				"dt"
			];
			const lists = [
				"ul",
				"ol",
				"dl"
			];
			const wsElements = [
				"pre",
				"script",
				"textarea",
				"style"
			];
			const wrapBlockElements = ["pre"].concat(headings);
			const lazyLookup = (items) => {
				let lookup$2;
				return (node) => {
					lookup$2 = lookup$2 ? lookup$2 : mapToObject(items, always);
					return has$2(lookup$2, name(node));
				};
			};
			const isBlock$2 = lazyLookup(blocks);
			const isTable$1 = (node) => name(node) === "table";
			const isInline$1 = (node) => isElement$7(node) && !isBlock$2(node);
			const isBr$5 = (node) => isElement$7(node) && name(node) === "br";
			const isTextBlock$2 = lazyLookup(textBlocks);
			const isList = lazyLookup(lists);
			const isListItem$1 = lazyLookup(listItems$1);
			const isTableSection = lazyLookup(tableSections);
			const isTableCell$2 = lazyLookup(tableCells);
			const isWsPreserveElement = lazyLookup(wsElements);
			const isWrapBlockElement = lazyLookup(wrapBlockElements);
			const isWrapElement = (node) => isWrapBlockElement(node) || isInline$1(node);
			const getLastChildren$1 = (elm) => {
				const children$2 = [];
				let rawNode = elm.dom;
				while (rawNode) {
					children$2.push(SugarElement.fromDom(rawNode));
					rawNode = rawNode.lastChild;
				}
				return children$2;
			};
			const removeTrailingBr = (elm) => {
				const allBrs = descendants(elm, "br");
				const brs = filter$5(getLastChildren$1(elm).slice(-1), isBr$5);
				if (allBrs.length === brs.length) each$e(brs, remove$5);
			};
			const createPaddingBr = () => {
				const br = SugarElement.fromTag("br");
				set$3(br, "data-mce-bogus", "1");
				return br;
			};
			const fillWithPaddingBr = (elm) => {
				empty(elm);
				append$1(elm, createPaddingBr());
			};
			const trimBlockTrailingBr = (elm) => {
				lastChild(elm).each((lastChild$1) => {
					prevSibling(lastChild$1).each((lastChildPrevSibling) => {
						if (isBlock$2(elm) && isBr$5(lastChild$1) && isBlock$2(lastChildPrevSibling)) remove$5(lastChild$1);
					});
				});
			};
			const ZWSP$1 = zeroWidth;
			const isZwsp$1 = isZwsp$2;
			const trim$1 = removeZwsp;
			const isElement$5 = isElement$6;
			const isText$9 = isText$a;
			const isCaretContainerBlock$1 = (node) => {
				if (isText$9(node)) node = node.parentNode;
				return isElement$5(node) && node.hasAttribute("data-mce-caret");
			};
			const isCaretContainerInline = (node) => isText$9(node) && isZwsp$1(node.data);
			const isCaretContainer$2 = (node) => isCaretContainerBlock$1(node) || isCaretContainerInline(node);
			const hasContent = (node) => node.firstChild !== node.lastChild || !isBr$6(node.firstChild);
			const insertInline$1 = (node, before$1) => {
				var _a;
				const textNode = ((_a = node.ownerDocument) !== null && _a !== void 0 ? _a : document).createTextNode(ZWSP$1);
				const parentNode = node.parentNode;
				if (!before$1) {
					const sibling$2 = node.nextSibling;
					if (isText$9(sibling$2)) {
						if (isCaretContainer$2(sibling$2)) return sibling$2;
						if (startsWithCaretContainer$1(sibling$2)) {
							sibling$2.splitText(1);
							return sibling$2;
						}
					}
					if (node.nextSibling) parentNode === null || parentNode === void 0 || parentNode.insertBefore(textNode, node.nextSibling);
					else parentNode === null || parentNode === void 0 || parentNode.appendChild(textNode);
				} else {
					const sibling$2 = node.previousSibling;
					if (isText$9(sibling$2)) {
						if (isCaretContainer$2(sibling$2)) return sibling$2;
						if (endsWithCaretContainer$1(sibling$2)) return sibling$2.splitText(sibling$2.data.length - 1);
					}
					parentNode === null || parentNode === void 0 || parentNode.insertBefore(textNode, node);
				}
				return textNode;
			};
			const isBeforeInline = (pos) => {
				const container = pos.container();
				if (!isText$a(container)) return false;
				return container.data.charAt(pos.offset()) === ZWSP$1 || pos.isAtStart() && isCaretContainerInline(container.previousSibling);
			};
			const isAfterInline = (pos) => {
				const container = pos.container();
				if (!isText$a(container)) return false;
				return container.data.charAt(pos.offset() - 1) === ZWSP$1 || pos.isAtEnd() && isCaretContainerInline(container.nextSibling);
			};
			const insertBlock = (blockName, node, before$1) => {
				var _a;
				const blockNode = ((_a = node.ownerDocument) !== null && _a !== void 0 ? _a : document).createElement(blockName);
				blockNode.setAttribute("data-mce-caret", before$1 ? "before" : "after");
				blockNode.setAttribute("data-mce-bogus", "all");
				blockNode.appendChild(createPaddingBr().dom);
				const parentNode = node.parentNode;
				if (!before$1) if (node.nextSibling) parentNode === null || parentNode === void 0 || parentNode.insertBefore(blockNode, node.nextSibling);
				else parentNode === null || parentNode === void 0 || parentNode.appendChild(blockNode);
				else parentNode === null || parentNode === void 0 || parentNode.insertBefore(blockNode, node);
				return blockNode;
			};
			const startsWithCaretContainer$1 = (node) => isText$9(node) && node.data[0] === ZWSP$1;
			const endsWithCaretContainer$1 = (node) => isText$9(node) && node.data[node.data.length - 1] === ZWSP$1;
			const trimBogusBr = (elm) => {
				var _a;
				const brs = elm.getElementsByTagName("br");
				const lastBr = brs[brs.length - 1];
				if (isBogus$2(lastBr)) (_a = lastBr.parentNode) === null || _a === void 0 || _a.removeChild(lastBr);
			};
			const showCaretContainerBlock = (caretContainer) => {
				if (caretContainer && caretContainer.hasAttribute("data-mce-caret")) {
					trimBogusBr(caretContainer);
					caretContainer.removeAttribute("data-mce-caret");
					caretContainer.removeAttribute("data-mce-bogus");
					caretContainer.removeAttribute("style");
					caretContainer.removeAttribute("data-mce-style");
					caretContainer.removeAttribute("_moz_abspos");
					return caretContainer;
				}
				return null;
			};
			const isRangeInCaretContainerBlock = (range) => isCaretContainerBlock$1(range.startContainer);
			const isContentEditableTrue$2 = isContentEditableTrue$3;
			const isContentEditableFalse$a = isContentEditableFalse$b;
			const isBr$4 = isBr$6;
			const isText$8 = isText$a;
			const isInvalidTextElement = matchNodeNames([
				"script",
				"style",
				"textarea"
			]);
			const isAtomicInline = matchNodeNames([
				"img",
				"input",
				"textarea",
				"hr",
				"iframe",
				"video",
				"audio",
				"object",
				"embed"
			]);
			const isTable = matchNodeNames(["table"]);
			const isCaretContainer$1 = isCaretContainer$2;
			const isCaretCandidate$3 = (node) => {
				if (isCaretContainer$1(node)) return false;
				if (isText$8(node)) return !isInvalidTextElement(node.parentNode);
				return isAtomicInline(node) || isBr$4(node) || isTable(node) || isNonUiContentEditableFalse(node);
			};
			const isUnselectable = (node) => isElement$6(node) && node.getAttribute("unselectable") === "true";
			const isNonUiContentEditableFalse = (node) => !isUnselectable(node) && isContentEditableFalse$a(node);
			const isInEditable = (node, root) => {
				for (let tempNode = node.parentNode; tempNode && tempNode !== root; tempNode = tempNode.parentNode) {
					if (isNonUiContentEditableFalse(tempNode)) return false;
					if (isContentEditableTrue$2(tempNode)) return true;
				}
				return true;
			};
			const isAtomicContentEditableFalse = (node) => {
				if (!isNonUiContentEditableFalse(node)) return false;
				return !foldl(from(node.getElementsByTagName("*")), (result, elm) => {
					return result || isContentEditableTrue$2(elm);
				}, false);
			};
			const isAtomic$1 = (node) => isAtomicInline(node) || isAtomicContentEditableFalse(node);
			const isEditableCaretCandidate$1 = (node, root) => isCaretCandidate$3(node) && isInEditable(node, root);
			const whiteSpaceRegExp = /^[ \t\r\n]*$/;
			const isWhitespaceText = (text$1) => whiteSpaceRegExp.test(text$1);
			const isZwsp = (text$1) => {
				for (const c of text$1) if (!isZwsp$2(c)) return false;
				return true;
			};
			const isCollapsibleWhitespace$1 = (c) => " \f	\v".indexOf(c) !== -1;
			const isNewLineChar = (c) => c === "\n" || c === "\r";
			const isNewline = (text$1, idx) => idx < text$1.length && idx >= 0 ? isNewLineChar(text$1[idx]) : false;
			const normalize$4 = (text$1, tabSpaces = 4, isStartOfContent = true, isEndOfContent = true) => {
				const tabSpace = repeat(" ", tabSpaces);
				const normalizedText = text$1.replace(/\t/g, tabSpace);
				return foldl(normalizedText, (acc, c) => {
					if (isCollapsibleWhitespace$1(c) || c === nbsp) if (acc.pcIsSpace || acc.str === "" && isStartOfContent || acc.str.length === normalizedText.length - 1 && isEndOfContent || isNewline(normalizedText, acc.str.length + 1)) return {
						pcIsSpace: false,
						str: acc.str + nbsp
					};
					else return {
						pcIsSpace: true,
						str: acc.str + " "
					};
					else return {
						pcIsSpace: isNewLineChar(c),
						str: acc.str + c
					};
				}, {
					pcIsSpace: false,
					str: ""
				}).str;
			};
			const hasWhitespacePreserveParent = (node, rootNode) => {
				const rootElement = SugarElement.fromDom(rootNode);
				return ancestor$2(SugarElement.fromDom(node), "pre,code", curry(eq, rootElement));
			};
			const isWhitespace$1 = (node, rootNode) => {
				return isText$a(node) && isWhitespaceText(node.data) && !hasWhitespacePreserveParent(node, rootNode);
			};
			const isNamedAnchor = (node) => {
				return isElement$6(node) && node.nodeName === "A" && !node.hasAttribute("href") && (node.hasAttribute("name") || node.hasAttribute("id"));
			};
			const isContent$1 = (node, rootNode) => {
				return isCaretCandidate$3(node) && !isWhitespace$1(node, rootNode) || isNamedAnchor(node) || isBookmark(node);
			};
			const isBookmark = hasAttribute("data-mce-bookmark");
			const isBogus$1 = hasAttribute("data-mce-bogus");
			const isBogusAll = hasAttributeValue("data-mce-bogus", "all");
			const isEmptyNode = (targetNode, skipBogus) => {
				let brCount = 0;
				if (isContent$1(targetNode, targetNode)) return false;
				else {
					let node = targetNode.firstChild;
					if (!node) return true;
					const walker = new DomTreeWalker(node, targetNode);
					do {
						if (skipBogus) {
							if (isBogusAll(node)) {
								node = walker.next(true);
								continue;
							}
							if (isBogus$1(node)) {
								node = walker.next();
								continue;
							}
						}
						if (isBr$6(node)) {
							brCount++;
							node = walker.next();
							continue;
						}
						if (isContent$1(node, targetNode)) return false;
						node = walker.next();
					} while (node);
					return brCount <= 1;
				}
			};
			const isEmpty$2 = (elm, skipBogus = true) => isEmptyNode(elm.dom, skipBogus);
			const transparentBlockAttr = "data-mce-block";
			const elementNames = (map$4) => filter$5(keys(map$4), (key) => !/[A-Z]/.test(key));
			const makeSelectorFromSchemaMap = (map$4) => elementNames(map$4).join(",");
			const updateTransparent = (blocksSelector, transparent) => {
				if (isNonNullable(transparent.querySelector(blocksSelector))) {
					transparent.setAttribute(transparentBlockAttr, "true");
					if (transparent.getAttribute("data-mce-selected") === "inline-boundary") transparent.removeAttribute("data-mce-selected");
					return true;
				} else {
					transparent.removeAttribute(transparentBlockAttr);
					return false;
				}
			};
			const updateBlockStateOnChildren = (schema, scope) => {
				const transparentSelector = makeSelectorFromSchemaMap(schema.getTransparentElements());
				const blocksSelector = makeSelectorFromSchemaMap(schema.getBlockElements());
				return filter$5(scope.querySelectorAll(transparentSelector), (transparent) => updateTransparent(blocksSelector, transparent));
			};
			const trimEdge = (el, leftSide) => {
				var _a;
				const childPropertyName = leftSide ? "lastChild" : "firstChild";
				for (let child$2 = el[childPropertyName]; child$2; child$2 = child$2[childPropertyName]) if (isEmpty$2(SugarElement.fromDom(child$2))) {
					(_a = child$2.parentNode) === null || _a === void 0 || _a.removeChild(child$2);
					return;
				}
			};
			const split$2 = (parentElm, splitElm) => {
				const range = document.createRange();
				const parentNode = parentElm.parentNode;
				if (parentNode) {
					range.setStartBefore(parentElm);
					range.setEndBefore(splitElm);
					const beforeFragment = range.extractContents();
					trimEdge(beforeFragment, true);
					range.setStartAfter(splitElm);
					range.setEndAfter(parentElm);
					const afterFragment = range.extractContents();
					trimEdge(afterFragment, false);
					if (!isEmpty$2(SugarElement.fromDom(beforeFragment))) parentNode.insertBefore(beforeFragment, parentElm);
					if (!isEmpty$2(SugarElement.fromDom(splitElm))) parentNode.insertBefore(splitElm, parentElm);
					if (!isEmpty$2(SugarElement.fromDom(afterFragment))) parentNode.insertBefore(afterFragment, parentElm);
					parentNode.removeChild(parentElm);
				}
			};
			const splitInvalidChildren = (schema, scope, transparentBlocks) => {
				const blocksElements = schema.getBlockElements();
				const rootNode = SugarElement.fromDom(scope);
				const isBlock$3 = (el) => name(el) in blocksElements;
				const isRoot$2 = (el) => eq(el, rootNode);
				each$e(fromDom$1(transparentBlocks), (transparentBlock) => {
					ancestor$4(transparentBlock, isBlock$3, isRoot$2).each((parentBlock) => {
						const invalidChildren = children(transparentBlock, (el) => isBlock$3(el) && !schema.isValidChild(name(parentBlock), name(el)));
						if (invalidChildren.length > 0) {
							const stateScope = parentElement(parentBlock);
							each$e(invalidChildren, (child$2) => {
								ancestor$4(child$2, isBlock$3, isRoot$2).each((parentBlock$1) => {
									split$2(parentBlock$1.dom, child$2.dom);
								});
							});
							stateScope.each((scope$1) => updateBlockStateOnChildren(schema, scope$1.dom));
						}
					});
				});
			};
			const unwrapInvalidChildren = (schema, scope, transparentBlocks) => {
				each$e([...transparentBlocks, ...isTransparentBlock(schema, scope) ? [scope] : []], (block) => each$e(descendants(SugarElement.fromDom(block), block.nodeName.toLowerCase()), (elm) => {
					if (isTransparentInline(schema, elm.dom)) unwrap(elm);
				}));
			};
			const updateChildren = (schema, scope) => {
				const transparentBlocks = updateBlockStateOnChildren(schema, scope);
				splitInvalidChildren(schema, scope, transparentBlocks);
				unwrapInvalidChildren(schema, scope, transparentBlocks);
			};
			const updateElement = (schema, target) => {
				if (isTransparentElement(schema, target)) updateTransparent(makeSelectorFromSchemaMap(schema.getBlockElements()), target);
			};
			const updateCaret = (schema, root, caretParent) => {
				const isRoot$2 = (el) => eq(el, SugarElement.fromDom(root));
				const parents$2 = parents$1(SugarElement.fromDom(caretParent), isRoot$2);
				get$b(parents$2, parents$2.length - 2).filter(isElement$7).fold(() => updateChildren(schema, root), (scope) => updateChildren(schema, scope.dom));
			};
			const hasBlockAttr = (el) => el.hasAttribute(transparentBlockAttr);
			const isTransparentElementName = (schema, name$1) => has$2(schema.getTransparentElements(), name$1);
			const isTransparentElement = (schema, node) => isElement$6(node) && isTransparentElementName(schema, node.nodeName);
			const isTransparentBlock = (schema, node) => isTransparentElement(schema, node) && hasBlockAttr(node);
			const isTransparentInline = (schema, node) => isTransparentElement(schema, node) && !hasBlockAttr(node);
			const isTransparentAstBlock = (schema, node) => node.type === 1 && isTransparentElementName(schema, node.name) && isString(node.attr(transparentBlockAttr));
			const browser$2 = detect$2().browser;
			const firstElement = (nodes) => find$2(nodes, isElement$7);
			const getTableCaptionDeltaY = (elm) => {
				if (browser$2.isFirefox() && name(elm) === "table") return firstElement(children$1(elm)).filter((elm$1) => {
					return name(elm$1) === "caption";
				}).bind((caption) => {
					return firstElement(nextSiblings(caption)).map((body) => {
						const bodyTop = body.dom.offsetTop;
						const captionTop = caption.dom.offsetTop;
						const captionHeight = caption.dom.offsetHeight;
						return bodyTop <= captionTop ? -captionHeight : 0;
					});
				}).getOr(0);
				else return 0;
			};
			const hasChild = (elm, child$2) => elm.children && contains$2(elm.children, child$2);
			const getPos = (body, elm, rootElm) => {
				let x = 0, y = 0;
				const doc = body.ownerDocument;
				rootElm = rootElm ? rootElm : body;
				if (elm) {
					if (rootElm === body && elm.getBoundingClientRect && get$7(SugarElement.fromDom(body), "position") === "static") {
						const pos = elm.getBoundingClientRect();
						x = pos.left + (doc.documentElement.scrollLeft || body.scrollLeft) - doc.documentElement.clientLeft;
						y = pos.top + (doc.documentElement.scrollTop || body.scrollTop) - doc.documentElement.clientTop;
						return {
							x,
							y
						};
					}
					let offsetParent = elm;
					while (offsetParent && offsetParent !== rootElm && offsetParent.nodeType && !hasChild(offsetParent, rootElm)) {
						const castOffsetParent = offsetParent;
						x += castOffsetParent.offsetLeft || 0;
						y += castOffsetParent.offsetTop || 0;
						offsetParent = castOffsetParent.offsetParent;
					}
					offsetParent = elm.parentNode;
					while (offsetParent && offsetParent !== rootElm && offsetParent.nodeType && !hasChild(offsetParent, rootElm)) {
						x -= offsetParent.scrollLeft || 0;
						y -= offsetParent.scrollTop || 0;
						offsetParent = offsetParent.parentNode;
					}
					y += getTableCaptionDeltaY(SugarElement.fromDom(elm));
				}
				return {
					x,
					y
				};
			};
			const StyleSheetLoader = (documentOrShadowRoot, settings = {}) => {
				let idCount = 0;
				const loadedStates = {};
				const edos = SugarElement.fromDom(documentOrShadowRoot);
				const doc = documentOrOwner(edos);
				const _setReferrerPolicy = (referrerPolicy) => {
					settings.referrerPolicy = referrerPolicy;
				};
				const _setContentCssCors = (contentCssCors) => {
					settings.contentCssCors = contentCssCors;
				};
				const addStyle = (element) => {
					append$1(getStyleContainer(edos), element);
				};
				const removeStyle = (id) => {
					descendant(getStyleContainer(edos), "#" + id).each(remove$5);
				};
				const getOrCreateState = (url) => get$a(loadedStates, url).getOrThunk(() => ({
					id: "mce-u" + idCount++,
					passed: [],
					failed: [],
					count: 0
				}));
				const load = (url) => new Promise((success, failure) => {
					let link;
					const urlWithSuffix = Tools._addCacheSuffix(url);
					const state = getOrCreateState(urlWithSuffix);
					loadedStates[urlWithSuffix] = state;
					state.count++;
					const resolve$4 = (callbacks, status) => {
						each$e(callbacks, call);
						state.status = status;
						state.passed = [];
						state.failed = [];
						if (link) {
							link.onload = null;
							link.onerror = null;
							link = null;
						}
					};
					const passed = () => resolve$4(state.passed, 2);
					const failed = () => resolve$4(state.failed, 3);
					if (success) state.passed.push(success);
					if (failure) state.failed.push(failure);
					if (state.status === 1) return;
					if (state.status === 2) {
						passed();
						return;
					}
					if (state.status === 3) {
						failed();
						return;
					}
					state.status = 1;
					const linkElem = SugarElement.fromTag("link", doc.dom);
					setAll$1(linkElem, {
						rel: "stylesheet",
						type: "text/css",
						id: state.id
					});
					if (settings.contentCssCors) set$3(linkElem, "crossOrigin", "anonymous");
					if (settings.referrerPolicy) set$3(linkElem, "referrerpolicy", settings.referrerPolicy);
					link = linkElem.dom;
					link.onload = passed;
					link.onerror = failed;
					addStyle(linkElem);
					set$3(linkElem, "href", urlWithSuffix);
				});
				const loadAll = (urls) => {
					return Promise.allSettled(map$3(urls, (url) => load(url).then(constant(url)))).then((results) => {
						const parts = partition$2(results, (r$1) => r$1.status === "fulfilled");
						if (parts.fail.length > 0) return Promise.reject(map$3(parts.fail, (result) => result.reason));
						else return map$3(parts.pass, (result) => result.value);
					});
				};
				const unload = (url) => {
					const urlWithSuffix = Tools._addCacheSuffix(url);
					get$a(loadedStates, urlWithSuffix).each((state) => {
						if (--state.count === 0) {
							delete loadedStates[urlWithSuffix];
							removeStyle(state.id);
						}
					});
				};
				const unloadAll = (urls) => {
					each$e(urls, (url) => {
						unload(url);
					});
				};
				return {
					load,
					loadAll,
					unload,
					unloadAll,
					_setReferrerPolicy,
					_setContentCssCors
				};
			};
			const create$d = () => {
				const map$4 = /* @__PURE__ */ new WeakMap();
				const forElement = (referenceElement, settings) => {
					const rootDom = getRootNode(referenceElement).dom;
					return Optional.from(map$4.get(rootDom)).getOrThunk(() => {
						const sl = StyleSheetLoader(rootDom, settings);
						map$4.set(rootDom, sl);
						return sl;
					});
				};
				return { forElement };
			};
			const instance = create$d();
			const isSpan = (node) => node.nodeName.toLowerCase() === "span";
			const isInlineContent = (node, root) => isNonNullable(node) && (isContent$1(node, root) || isInline$1(SugarElement.fromDom(node)));
			const surroundedByInlineContent = (node, root) => {
				const prev$1 = new DomTreeWalker(node, root).prev(false);
				const next$1 = new DomTreeWalker(node, root).next(false);
				const prevIsInline = isUndefined(prev$1) || isInlineContent(prev$1, root);
				const nextIsInline = isUndefined(next$1) || isInlineContent(next$1, root);
				return prevIsInline && nextIsInline;
			};
			const isBookmarkNode$2 = (node) => isSpan(node) && node.getAttribute("data-mce-type") === "bookmark";
			const isKeepTextNode = (node, root) => isText$a(node) && node.data.length > 0 && surroundedByInlineContent(node, root);
			const isKeepElement = (node) => isElement$6(node) ? node.childNodes.length > 0 : false;
			const isDocument = (node) => isDocumentFragment(node) || isDocument$1(node);
			const trimNode = (dom$1, node, root) => {
				var _a;
				const rootNode = root || node;
				if (isElement$6(node) && isBookmarkNode$2(node)) return node;
				const children$2 = node.childNodes;
				for (let i = children$2.length - 1; i >= 0; i--) trimNode(dom$1, children$2[i], rootNode);
				if (isElement$6(node)) {
					const currentChildren = node.childNodes;
					if (currentChildren.length === 1 && isBookmarkNode$2(currentChildren[0])) (_a = node.parentNode) === null || _a === void 0 || _a.insertBefore(currentChildren[0], node);
				}
				if (!isDocument(node) && !isContent$1(node, rootNode) && !isKeepElement(node) && !isKeepTextNode(node, rootNode)) dom$1.remove(node);
				return node;
			};
			const makeMap$3 = Tools.makeMap;
			const attrsCharsRegExp = /[&<>\"\u0060\u007E-\uD7FF\uE000-\uFFEF]|[\uD800-\uDBFF][\uDC00-\uDFFF]/g;
			const textCharsRegExp = /[<>&\u007E-\uD7FF\uE000-\uFFEF]|[\uD800-\uDBFF][\uDC00-\uDFFF]/g;
			const rawCharsRegExp = /[<>&\"\']/g;
			const entityRegExp = /&#([a-z0-9]+);?|&([a-z0-9]+);/gi;
			const asciiMap = {
				128: "",
				130: "",
				131: "",
				132: "",
				133: "",
				134: "",
				135: "",
				136: "",
				137: "",
				138: "",
				139: "",
				140: "",
				142: "",
				145: "",
				146: "",
				147: "",
				148: "",
				149: "",
				150: "",
				151: "",
				152: "",
				153: "",
				154: "",
				155: "",
				156: "",
				158: "",
				159: ""
			};
			const baseEntities = {
				"\"": "&quot;",
				"'": "&#39;",
				"<": "&lt;",
				">": "&gt;",
				"&": "&amp;",
				"`": "&#96;"
			};
			const reverseEntities = {
				"&lt;": "<",
				"&gt;": ">",
				"&amp;": "&",
				"&quot;": "\"",
				"&apos;": `'`
			};
			const nativeDecode = (text$1) => {
				const elm = SugarElement.fromTag("div").dom;
				elm.innerHTML = text$1;
				return elm.textContent || elm.innerText || text$1;
			};
			const buildEntitiesLookup = (items, radix) => {
				const lookup$2 = {};
				if (items) {
					const itemList = items.split(",");
					radix = radix || 10;
					for (let i = 0; i < itemList.length; i += 2) {
						const chr = String.fromCharCode(parseInt(itemList[i], radix));
						if (!baseEntities[chr]) {
							const entity = "&" + itemList[i + 1] + ";";
							lookup$2[chr] = entity;
							lookup$2[entity] = chr;
						}
					}
					return lookup$2;
				} else return;
			};
			const namedEntities = buildEntitiesLookup("50,nbsp,51,iexcl,52,cent,53,pound,54,curren,55,yen,56,brvbar,57,sect,58,uml,59,copy,5a,ordf,5b,laquo,5c,not,5d,shy,5e,reg,5f,macr,5g,deg,5h,plusmn,5i,sup2,5j,sup3,5k,acute,5l,micro,5m,para,5n,middot,5o,cedil,5p,sup1,5q,ordm,5r,raquo,5s,frac14,5t,frac12,5u,frac34,5v,iquest,60,Agrave,61,Aacute,62,Acirc,63,Atilde,64,Auml,65,Aring,66,AElig,67,Ccedil,68,Egrave,69,Eacute,6a,Ecirc,6b,Euml,6c,Igrave,6d,Iacute,6e,Icirc,6f,Iuml,6g,ETH,6h,Ntilde,6i,Ograve,6j,Oacute,6k,Ocirc,6l,Otilde,6m,Ouml,6n,times,6o,Oslash,6p,Ugrave,6q,Uacute,6r,Ucirc,6s,Uuml,6t,Yacute,6u,THORN,6v,szlig,70,agrave,71,aacute,72,acirc,73,atilde,74,auml,75,aring,76,aelig,77,ccedil,78,egrave,79,eacute,7a,ecirc,7b,euml,7c,igrave,7d,iacute,7e,icirc,7f,iuml,7g,eth,7h,ntilde,7i,ograve,7j,oacute,7k,ocirc,7l,otilde,7m,ouml,7n,divide,7o,oslash,7p,ugrave,7q,uacute,7r,ucirc,7s,uuml,7t,yacute,7u,thorn,7v,yuml,ci,fnof,sh,Alpha,si,Beta,sj,Gamma,sk,Delta,sl,Epsilon,sm,Zeta,sn,Eta,so,Theta,sp,Iota,sq,Kappa,sr,Lambda,ss,Mu,st,Nu,su,Xi,sv,Omicron,t0,Pi,t1,Rho,t3,Sigma,t4,Tau,t5,Upsilon,t6,Phi,t7,Chi,t8,Psi,t9,Omega,th,alpha,ti,beta,tj,gamma,tk,delta,tl,epsilon,tm,zeta,tn,eta,to,theta,tp,iota,tq,kappa,tr,lambda,ts,mu,tt,nu,tu,xi,tv,omicron,u0,pi,u1,rho,u2,sigmaf,u3,sigma,u4,tau,u5,upsilon,u6,phi,u7,chi,u8,psi,u9,omega,uh,thetasym,ui,upsih,um,piv,812,bull,816,hellip,81i,prime,81j,Prime,81u,oline,824,frasl,88o,weierp,88h,image,88s,real,892,trade,89l,alefsym,8cg,larr,8ch,uarr,8ci,rarr,8cj,darr,8ck,harr,8dl,crarr,8eg,lArr,8eh,uArr,8ei,rArr,8ej,dArr,8ek,hArr,8g0,forall,8g2,part,8g3,exist,8g5,empty,8g7,nabla,8g8,isin,8g9,notin,8gb,ni,8gf,prod,8gh,sum,8gi,minus,8gn,lowast,8gq,radic,8gt,prop,8gu,infin,8h0,ang,8h7,and,8h8,or,8h9,cap,8ha,cup,8hb,int,8hk,there4,8hs,sim,8i5,cong,8i8,asymp,8j0,ne,8j1,equiv,8j4,le,8j5,ge,8k2,sub,8k3,sup,8k4,nsub,8k6,sube,8k7,supe,8kl,oplus,8kn,otimes,8l5,perp,8m5,sdot,8o8,lceil,8o9,rceil,8oa,lfloor,8ob,rfloor,8p9,lang,8pa,rang,9ea,loz,9j0,spades,9j3,clubs,9j5,hearts,9j6,diams,ai,OElig,aj,oelig,b0,Scaron,b1,scaron,bo,Yuml,m6,circ,ms,tilde,802,ensp,803,emsp,809,thinsp,80c,zwnj,80d,zwj,80e,lrm,80f,rlm,80j,ndash,80k,mdash,80o,lsquo,80p,rsquo,80q,sbquo,80s,ldquo,80t,rdquo,80u,bdquo,810,dagger,811,Dagger,81g,permil,81p,lsaquo,81q,rsaquo,85c,euro", 32);
			const encodeRaw = (text$1, attr) => text$1.replace(attr ? attrsCharsRegExp : textCharsRegExp, (chr) => {
				return baseEntities[chr] || chr;
			});
			const encodeAllRaw = (text$1) => ("" + text$1).replace(rawCharsRegExp, (chr) => {
				return baseEntities[chr] || chr;
			});
			const encodeNumeric = (text$1, attr) => text$1.replace(attr ? attrsCharsRegExp : textCharsRegExp, (chr) => {
				if (chr.length > 1) return "&#" + ((chr.charCodeAt(0) - 55296) * 1024 + (chr.charCodeAt(1) - 56320) + 65536) + ";";
				return baseEntities[chr] || "&#" + chr.charCodeAt(0) + ";";
			});
			const encodeNamed = (text$1, attr, entities) => {
				const resolveEntities = entities || namedEntities;
				return text$1.replace(attr ? attrsCharsRegExp : textCharsRegExp, (chr) => {
					return baseEntities[chr] || resolveEntities[chr] || chr;
				});
			};
			const getEncodeFunc = (name$1, entities) => {
				const entitiesMap = buildEntitiesLookup(entities) || namedEntities;
				const encodeNamedAndNumeric = (text$1, attr) => text$1.replace(attr ? attrsCharsRegExp : textCharsRegExp, (chr) => {
					if (baseEntities[chr] !== void 0) return baseEntities[chr];
					if (entitiesMap[chr] !== void 0) return entitiesMap[chr];
					if (chr.length > 1) return "&#" + ((chr.charCodeAt(0) - 55296) * 1024 + (chr.charCodeAt(1) - 56320) + 65536) + ";";
					return "&#" + chr.charCodeAt(0) + ";";
				});
				const encodeCustomNamed = (text$1, attr) => {
					return encodeNamed(text$1, attr, entitiesMap);
				};
				const nameMap = makeMap$3(name$1.replace(/\+/g, ","));
				if (nameMap.named && nameMap.numeric) return encodeNamedAndNumeric;
				if (nameMap.named) {
					if (entities) return encodeCustomNamed;
					return encodeNamed;
				}
				if (nameMap.numeric) return encodeNumeric;
				return encodeRaw;
			};
			const decode = (text$1) => text$1.replace(entityRegExp, (all$1, numeric) => {
				if (numeric) {
					if (numeric.charAt(0).toLowerCase() === "x") numeric = parseInt(numeric.substr(1), 16);
					else numeric = parseInt(numeric, 10);
					if (numeric > 65535) {
						numeric -= 65536;
						return String.fromCharCode(55296 + (numeric >> 10), 56320 + (numeric & 1023));
					}
					return asciiMap[numeric] || String.fromCharCode(numeric);
				}
				return reverseEntities[all$1] || namedEntities[all$1] || nativeDecode(all$1);
			});
			const Entities = {
				encodeRaw,
				encodeAllRaw,
				encodeNumeric,
				encodeNamed,
				getEncodeFunc,
				decode
			};
			const split$1 = (items, delim) => {
				items = Tools.trim(items);
				return items ? items.split(delim || " ") : [];
			};
			const patternToRegExp = (str) => /* @__PURE__ */ new RegExp("^" + str.replace(/([?+*])/g, ".$1") + "$");
			const parseCustomElementsRules = (value$3) => {
				const customElementRegExp = /^(~)?(.+)$/;
				return bind$3(split$1(value$3, ","), (rule) => {
					const matches = customElementRegExp.exec(rule);
					if (matches) {
						const inline = matches[1] === "~";
						return [{
							inline,
							cloneName: inline ? "span" : "div",
							name: matches[2]
						}];
					} else return [];
				});
			};
			const getElementSetsAsStrings = (type$2) => {
				let globalAttributes, blockContent;
				let phrasingContent, flowContent;
				globalAttributes = "id accesskey class dir lang style tabindex title role";
				blockContent = "address blockquote div dl fieldset form h1 h2 h3 h4 h5 h6 hr menu ol p pre table ul";
				phrasingContent = "a abbr b bdo br button cite code del dfn em embed i iframe img input ins kbd label map noscript object q s samp script select small span strong sub sup textarea u var #text #comment";
				if (type$2 !== "html4") {
					const transparentContent = "a ins del canvas map";
					globalAttributes += " contenteditable contextmenu draggable dropzone hidden spellcheck translate";
					blockContent += " article aside details dialog figure main header footer hgroup section nav " + transparentContent;
					phrasingContent += " audio canvas command datalist mark meter output picture progress time wbr video ruby bdi keygen";
				}
				if (type$2 !== "html5-strict") {
					globalAttributes += " xml:lang";
					phrasingContent = [phrasingContent, "acronym applet basefont big font strike tt"].join(" ");
					blockContent = [blockContent, "center dir isindex noframes"].join(" ");
					flowContent = [blockContent, phrasingContent].join(" ");
				}
				flowContent = flowContent || [blockContent, phrasingContent].join(" ");
				return {
					globalAttributes,
					blockContent,
					phrasingContent,
					flowContent
				};
			};
			const makeSchema = (type$2) => {
				const { globalAttributes, phrasingContent, flowContent } = getElementSetsAsStrings(type$2);
				const schema = {};
				const add$5 = (name$1, attributes = "", children$2 = "") => {
					const childNames = split$1(children$2);
					const names = split$1(name$1);
					let ni = names.length;
					while (ni--) {
						const attributesOrder = split$1([globalAttributes, attributes].join(" "));
						schema[names[ni]] = {
							attributes: mapToObject(attributesOrder, constant({})),
							attributesOrder,
							children: mapToObject(childNames, constant({}))
						};
					}
				};
				const addAttrs = (name$1, attributes) => {
					const names = split$1(name$1);
					const attrs = split$1(attributes);
					let ni = names.length;
					while (ni--) {
						const schemaItem = schema[names[ni]];
						for (let i = 0, l = attrs.length; i < l; i++) {
							schemaItem.attributes[attrs[i]] = {};
							schemaItem.attributesOrder.push(attrs[i]);
						}
					}
				};
				if (type$2 !== "html5-strict") {
					each$e(split$1("acronym applet basefont big font strike tt"), (name$1) => {
						add$5(name$1, "", phrasingContent);
					});
					each$e(split$1("center dir isindex noframes"), (name$1) => {
						add$5(name$1, "", flowContent);
					});
				}
				add$5("html", "manifest", "head body");
				add$5("head", "", "base command link meta noscript script style title");
				add$5("title hr noscript br");
				add$5("base", "href target");
				add$5("link", "href rel media hreflang type sizes hreflang");
				add$5("meta", "name http-equiv content charset");
				add$5("style", "media type scoped");
				add$5("script", "src async defer type charset");
				add$5("body", "onafterprint onbeforeprint onbeforeunload onblur onerror onfocus onhashchange onload onmessage onoffline ononline onpagehide onpageshow onpopstate onresize onscroll onstorage onunload", flowContent);
				add$5("dd div", "", flowContent);
				add$5("address dt caption", "", type$2 === "html4" ? phrasingContent : flowContent);
				add$5("h1 h2 h3 h4 h5 h6 pre p abbr code var samp kbd sub sup i b u bdo span legend em strong small s cite dfn", "", phrasingContent);
				add$5("blockquote", "cite", flowContent);
				add$5("ol", "reversed start type", "li");
				add$5("ul", "", "li");
				add$5("li", "value", flowContent);
				add$5("dl", "", "dt dd");
				add$5("a", "href target rel media hreflang type", type$2 === "html4" ? phrasingContent : flowContent);
				add$5("q", "cite", phrasingContent);
				add$5("ins del", "cite datetime", flowContent);
				add$5("img", "src sizes srcset alt usemap ismap width height");
				add$5("iframe", "src name width height", flowContent);
				add$5("embed", "src type width height");
				add$5("object", "data type typemustmatch name usemap form width height", [flowContent, "param"].join(" "));
				add$5("param", "name value");
				add$5("map", "name", [flowContent, "area"].join(" "));
				add$5("area", "alt coords shape href target rel media hreflang type");
				add$5("table", "border", "caption colgroup thead tfoot tbody tr" + (type$2 === "html4" ? " col" : ""));
				add$5("colgroup", "span", "col");
				add$5("col", "span");
				add$5("tbody thead tfoot", "", "tr");
				add$5("tr", "", "td th");
				add$5("td", "colspan rowspan headers", flowContent);
				add$5("th", "colspan rowspan headers scope abbr", flowContent);
				add$5("form", "accept-charset action autocomplete enctype method name novalidate target", flowContent);
				add$5("fieldset", "disabled form name", [flowContent, "legend"].join(" "));
				add$5("label", "form for", phrasingContent);
				add$5("input", "accept alt autocomplete checked dirname disabled form formaction formenctype formmethod formnovalidate formtarget height list max maxlength min multiple name pattern readonly required size src step type value width");
				add$5("button", "disabled form formaction formenctype formmethod formnovalidate formtarget name type value", type$2 === "html4" ? flowContent : phrasingContent);
				add$5("select", "disabled form multiple name required size", "option optgroup");
				add$5("optgroup", "disabled label", "option");
				add$5("option", "disabled label selected value");
				add$5("textarea", "cols dirname disabled form maxlength name readonly required rows wrap");
				add$5("menu", "type label", [flowContent, "li"].join(" "));
				add$5("noscript", "", flowContent);
				if (type$2 !== "html4") {
					add$5("wbr");
					add$5("ruby", "", [phrasingContent, "rt rp"].join(" "));
					add$5("figcaption", "", flowContent);
					add$5("mark rt rp summary bdi", "", phrasingContent);
					add$5("canvas", "width height", flowContent);
					add$5("video", "src crossorigin poster preload autoplay mediagroup loop muted controls width height buffered", [flowContent, "track source"].join(" "));
					add$5("audio", "src crossorigin preload autoplay mediagroup loop muted controls buffered volume", [flowContent, "track source"].join(" "));
					add$5("picture", "", "img source");
					add$5("source", "src srcset type media sizes");
					add$5("track", "kind src srclang label default");
					add$5("datalist", "", [phrasingContent, "option"].join(" "));
					add$5("article section nav aside main header footer", "", flowContent);
					add$5("hgroup", "", "h1 h2 h3 h4 h5 h6");
					add$5("figure", "", [flowContent, "figcaption"].join(" "));
					add$5("time", "datetime", phrasingContent);
					add$5("dialog", "open", flowContent);
					add$5("command", "type label icon disabled checked radiogroup command");
					add$5("output", "for form name", phrasingContent);
					add$5("progress", "value max", phrasingContent);
					add$5("meter", "value min max low high optimum", phrasingContent);
					add$5("details", "open", [flowContent, "summary"].join(" "));
					add$5("keygen", "autofocus challenge disabled form keytype name");
				}
				if (type$2 !== "html5-strict") {
					addAttrs("script", "language xml:space");
					addAttrs("style", "xml:space");
					addAttrs("object", "declare classid code codebase codetype archive standby align border hspace vspace");
					addAttrs("embed", "align name hspace vspace");
					addAttrs("param", "valuetype type");
					addAttrs("a", "charset name rev shape coords");
					addAttrs("br", "clear");
					addAttrs("applet", "codebase archive code object alt name width height align hspace vspace");
					addAttrs("img", "name longdesc align border hspace vspace");
					addAttrs("iframe", "longdesc frameborder marginwidth marginheight scrolling align");
					addAttrs("font basefont", "size color face");
					addAttrs("input", "usemap align");
					addAttrs("select");
					addAttrs("textarea");
					addAttrs("h1 h2 h3 h4 h5 h6 div p legend caption", "align");
					addAttrs("ul", "type compact");
					addAttrs("li", "type");
					addAttrs("ol dl menu dir", "compact");
					addAttrs("pre", "width xml:space");
					addAttrs("hr", "align noshade size width");
					addAttrs("isindex", "prompt");
					addAttrs("table", "summary width frame rules cellspacing cellpadding align bgcolor");
					addAttrs("col", "width align char charoff valign");
					addAttrs("colgroup", "width align char charoff valign");
					addAttrs("thead", "align char charoff valign");
					addAttrs("tr", "align char charoff valign bgcolor");
					addAttrs("th", "axis align char charoff valign nowrap bgcolor width height");
					addAttrs("form", "accept");
					addAttrs("td", "abbr axis scope align char charoff valign nowrap bgcolor width height");
					addAttrs("tfoot", "align char charoff valign");
					addAttrs("tbody", "align char charoff valign");
					addAttrs("area", "nohref");
					addAttrs("body", "background bgcolor text link vlink alink");
				}
				if (type$2 !== "html4") {
					addAttrs("input button select textarea", "autofocus");
					addAttrs("input textarea", "placeholder");
					addAttrs("a", "download");
					addAttrs("link script img", "crossorigin");
					addAttrs("img", "loading");
					addAttrs("iframe", "sandbox seamless allow allowfullscreen loading");
				}
				if (type$2 !== "html4") each$e([schema.video, schema.audio], (item) => {
					delete item.children.audio;
					delete item.children.video;
				});
				each$e(split$1("a form meter progress dfn"), (name$1) => {
					if (schema[name$1]) delete schema[name$1].children[name$1];
				});
				delete schema.caption.children.table;
				delete schema.script;
				return schema;
			};
			const prefixToOperation = (prefix) => prefix === "-" ? "remove" : "add";
			const parseValidChildrenRules = (value$3) => {
				const childRuleRegExp = /^([+\-]?)([A-Za-z0-9_\-.\u00b7\u00c0-\u00d6\u00d8-\u00f6\u00f8-\u037d\u037f-\u1fff\u200c-\u200d\u203f-\u2040\u2070-\u218f\u2c00-\u2fef\u3001-\ud7ff\uf900-\ufdcf\ufdf0-\ufffd]+)\[([^\]]+)]$/;
				return bind$3(split$1(value$3, ","), (rule) => {
					const matches = childRuleRegExp.exec(rule);
					if (matches) {
						const prefix = matches[1];
						return [{
							operation: prefix ? prefixToOperation(prefix) : "replace",
							name: matches[2],
							validChildren: split$1(matches[3], "|")
						}];
					} else return [];
				});
			};
			const parseValidElementsAttrDataIntoElement = (attrData, targetElement) => {
				const attrRuleRegExp = /^([!\-])?(\w+[\\:]:\w+|[^=~<]+)?(?:([=~<])(.*))?$/;
				const hasPatternsRegExp = /[*?+]/;
				const { attributes, attributesOrder } = targetElement;
				return each$e(split$1(attrData, "|"), (rule) => {
					const matches = attrRuleRegExp.exec(rule);
					if (matches) {
						const attr = {};
						const attrType = matches[1];
						const attrName = matches[2].replace(/[\\:]:/g, ":");
						const attrPrefix = matches[3];
						const value$3 = matches[4];
						if (attrType === "!") {
							targetElement.attributesRequired = targetElement.attributesRequired || [];
							targetElement.attributesRequired.push(attrName);
							attr.required = true;
						}
						if (attrType === "-") {
							delete attributes[attrName];
							attributesOrder.splice(Tools.inArray(attributesOrder, attrName), 1);
							return;
						}
						if (attrPrefix) {
							if (attrPrefix === "=") {
								targetElement.attributesDefault = targetElement.attributesDefault || [];
								targetElement.attributesDefault.push({
									name: attrName,
									value: value$3
								});
								attr.defaultValue = value$3;
							} else if (attrPrefix === "~") {
								targetElement.attributesForced = targetElement.attributesForced || [];
								targetElement.attributesForced.push({
									name: attrName,
									value: value$3
								});
								attr.forcedValue = value$3;
							} else if (attrPrefix === "<") attr.validValues = Tools.makeMap(value$3, "?");
						}
						if (hasPatternsRegExp.test(attrName)) {
							const attrPattern = attr;
							targetElement.attributePatterns = targetElement.attributePatterns || [];
							attrPattern.pattern = patternToRegExp(attrName);
							targetElement.attributePatterns.push(attrPattern);
						} else {
							if (!attributes[attrName]) attributesOrder.push(attrName);
							attributes[attrName] = attr;
						}
					}
				});
			};
			const cloneAttributesInto = (from$1, to$1) => {
				each$d(from$1.attributes, (value$3, key) => {
					to$1.attributes[key] = value$3;
				});
				to$1.attributesOrder.push(...from$1.attributesOrder);
			};
			const parseValidElementsRules = (globalElement, validElements) => {
				const elementRuleRegExp = /^([#+\-])?([^\[!\/]+)(?:\/([^\[!]+))?(?:(!?)\[([^\]]+)])?$/;
				return bind$3(split$1(validElements, ","), (rule) => {
					const matches = elementRuleRegExp.exec(rule);
					if (matches) {
						const prefix = matches[1];
						const elementName = matches[2];
						const outputName = matches[3];
						const attrsPrefix = matches[4];
						const attrData = matches[5];
						const element = {
							attributes: {},
							attributesOrder: []
						};
						globalElement.each((el) => cloneAttributesInto(el, element));
						if (prefix === "#") element.paddEmpty = true;
						else if (prefix === "-") element.removeEmpty = true;
						if (attrsPrefix === "!") element.removeEmptyAttrs = true;
						if (attrData) parseValidElementsAttrDataIntoElement(attrData, element);
						if (outputName) element.outputName = elementName;
						if (elementName === "@") if (globalElement.isNone()) globalElement = Optional.some(element);
						else return [];
						return [outputName ? {
							name: elementName,
							element,
							aliasName: outputName
						} : {
							name: elementName,
							element
						}];
					} else return [];
				});
			};
			const mapCache = {};
			const makeMap$2 = Tools.makeMap, each$b = Tools.each, extend$2 = Tools.extend, explode$2 = Tools.explode;
			const createMap = (defaultValue, extendWith = {}) => {
				return extend$2(makeMap$2(defaultValue, " ", makeMap$2(defaultValue.toUpperCase(), " ")), extendWith);
			};
			const getTextRootBlockElements = (schema) => createMap("td th li dt dd figcaption caption details summary", schema.getTextBlockElements());
			const compileElementMap = (value$3, mode) => {
				if (value$3) {
					const styles = {};
					if (isString(value$3)) value$3 = { "*": value$3 };
					each$b(value$3, (value$4, key) => {
						styles[key] = styles[key.toUpperCase()] = mode === "map" ? makeMap$2(value$4, /[, ]/) : explode$2(value$4, /[, ]/);
					});
					return styles;
				} else return;
			};
			const Schema = (settings = {}) => {
				var _a;
				const elements = {};
				const children$2 = {};
				let patternElements = [];
				const customElementsMap = {};
				const specialElements = {};
				const createLookupTable = (option$1, defaultValue, extendWith) => {
					const value$3 = settings[option$1];
					if (!value$3) {
						let newValue = mapCache[option$1];
						if (!newValue) {
							newValue = createMap(defaultValue, extendWith);
							mapCache[option$1] = newValue;
						}
						return newValue;
					} else return makeMap$2(value$3, /[, ]/, makeMap$2(value$3.toUpperCase(), /[, ]/));
				};
				const schemaType = (_a = settings.schema) !== null && _a !== void 0 ? _a : "html5";
				const schemaItems = makeSchema(schemaType);
				if (settings.verify_html === false) settings.valid_elements = "*[*]";
				const validStyles = compileElementMap(settings.valid_styles);
				const invalidStyles = compileElementMap(settings.invalid_styles, "map");
				const validClasses = compileElementMap(settings.valid_classes, "map");
				const whitespaceElementsMap = createLookupTable("whitespace_elements", "pre script noscript style textarea video audio iframe object code");
				const selfClosingElementsMap = createLookupTable("self_closing_elements", "colgroup dd dt li option p td tfoot th thead tr");
				const voidElementsMap = createLookupTable("void_elements", "area base basefont br col frame hr img input isindex link meta param embed source wbr track");
				const boolAttrMap = createLookupTable("boolean_attributes", "checked compact declare defer disabled ismap multiple nohref noresize noshade nowrap readonly selected autoplay loop controls allowfullscreen");
				const nonEmptyOrMoveCaretBeforeOnEnter = "td th iframe video audio object script code";
				const nonEmptyElementsMap = createLookupTable("non_empty_elements", nonEmptyOrMoveCaretBeforeOnEnter + " pre", voidElementsMap);
				const moveCaretBeforeOnEnterElementsMap = createLookupTable("move_caret_before_on_enter_elements", nonEmptyOrMoveCaretBeforeOnEnter + " table", voidElementsMap);
				const textBlockElementsMap = createLookupTable("text_block_elements", "h1 h2 h3 h4 h5 h6 p div address pre form blockquote center dir fieldset header footer article section hgroup aside main nav figure");
				const blockElementsMap = createLookupTable("block_elements", "hr table tbody thead tfoot th tr td li ol ul caption dl dt dd noscript menu isindex option datalist select optgroup figcaption details summary", textBlockElementsMap);
				const textInlineElementsMap = createLookupTable("text_inline_elements", "span strong b em i font s strike u var cite dfn code mark q sup sub samp");
				const transparentElementsMap = createLookupTable("transparent_elements", "a ins del canvas map");
				each$b("script noscript iframe noframes noembed title style textarea xmp plaintext".split(" "), (name$1) => {
					specialElements[name$1] = new RegExp("</" + name$1 + "[^>]*>", "gi");
				});
				const addValidElements = (validElements) => {
					const globalElement = Optional.from(elements["@"]);
					const hasPatternsRegExp = /[*?+]/;
					each$e(parseValidElementsRules(globalElement, validElements !== null && validElements !== void 0 ? validElements : ""), ({ name: name$1, element, aliasName }) => {
						if (aliasName) elements[aliasName] = element;
						if (hasPatternsRegExp.test(name$1)) {
							const patternElement = element;
							patternElement.pattern = patternToRegExp(name$1);
							patternElements.push(patternElement);
						} else elements[name$1] = element;
					});
				};
				const setValidElements = (validElements) => {
					patternElements = [];
					each$e(keys(elements), (name$1) => {
						delete elements[name$1];
					});
					addValidElements(validElements);
				};
				const addCustomElements = (customElements) => {
					delete mapCache.text_block_elements;
					delete mapCache.block_elements;
					each$e(parseCustomElementsRules(customElements !== null && customElements !== void 0 ? customElements : ""), ({ inline, name: name$1, cloneName }) => {
						children$2[name$1] = children$2[cloneName];
						customElementsMap[name$1] = cloneName;
						nonEmptyElementsMap[name$1.toUpperCase()] = {};
						nonEmptyElementsMap[name$1] = {};
						if (!inline) {
							blockElementsMap[name$1.toUpperCase()] = {};
							blockElementsMap[name$1] = {};
						}
						if (!elements[name$1]) {
							let customRule = elements[cloneName];
							customRule = extend$2({}, customRule);
							delete customRule.removeEmptyAttrs;
							delete customRule.removeEmpty;
							elements[name$1] = customRule;
						}
						each$d(children$2, (element, elmName) => {
							if (element[cloneName]) {
								children$2[elmName] = element = extend$2({}, children$2[elmName]);
								element[name$1] = element[cloneName];
							}
						});
					});
				};
				const addValidChildren = (validChildren) => {
					each$e(parseValidChildrenRules(validChildren !== null && validChildren !== void 0 ? validChildren : ""), ({ operation, name: name$1, validChildren: validChildren$1 }) => {
						const parent$1 = operation === "replace" ? { "#comment": {} } : children$2[name$1];
						each$e(validChildren$1, (child$2) => {
							if (operation === "remove") delete parent$1[child$2];
							else parent$1[child$2] = {};
						});
						children$2[name$1] = parent$1;
					});
				};
				const getElementRule = (name$1) => {
					const element = elements[name$1];
					if (element) return element;
					let i = patternElements.length;
					while (i--) {
						const patternElement = patternElements[i];
						if (patternElement.pattern.test(name$1)) return patternElement;
					}
				};
				if (!settings.valid_elements) {
					each$b(schemaItems, (element, name$1) => {
						elements[name$1] = {
							attributes: element.attributes,
							attributesOrder: element.attributesOrder
						};
						children$2[name$1] = element.children;
					});
					each$b(split$1("strong/b em/i"), (item) => {
						const items = split$1(item, "/");
						elements[items[1]].outputName = items[0];
					});
					each$b(textInlineElementsMap, (_val, name$1) => {
						if (elements[name$1]) {
							if (settings.padd_empty_block_inline_children) elements[name$1].paddInEmptyBlock = true;
							elements[name$1].removeEmpty = true;
						}
					});
					each$b(split$1("ol ul blockquote a table tbody"), (name$1) => {
						if (elements[name$1]) elements[name$1].removeEmpty = true;
					});
					each$b(split$1("p h1 h2 h3 h4 h5 h6 th td pre div address caption li summary"), (name$1) => {
						if (elements[name$1]) elements[name$1].paddEmpty = true;
					});
					each$b(split$1("span"), (name$1) => {
						elements[name$1].removeEmptyAttrs = true;
					});
				} else {
					setValidElements(settings.valid_elements);
					each$b(schemaItems, (element, name$1) => {
						children$2[name$1] = element.children;
					});
				}
				addCustomElements(settings.custom_elements);
				addValidChildren(settings.valid_children);
				addValidElements(settings.extended_valid_elements);
				addValidChildren("+ol[ul|ol],+ul[ul|ol]");
				each$b({
					dd: "dl",
					dt: "dl",
					li: "ul ol",
					td: "tr",
					th: "tr",
					tr: "tbody thead tfoot",
					tbody: "table",
					thead: "table",
					tfoot: "table",
					legend: "fieldset",
					area: "map",
					param: "video audio object"
				}, (parents$2, item) => {
					if (elements[item]) elements[item].parentsRequired = split$1(parents$2);
				});
				if (settings.invalid_elements) each$b(explode$2(settings.invalid_elements), (item) => {
					if (elements[item]) delete elements[item];
				});
				if (!getElementRule("span")) addValidElements("span[!data-mce-type|*]");
				const getValidStyles = constant(validStyles);
				const getInvalidStyles = constant(invalidStyles);
				const getValidClasses = constant(validClasses);
				const getBoolAttrs = constant(boolAttrMap);
				const getBlockElements = constant(blockElementsMap);
				const getTextBlockElements = constant(textBlockElementsMap);
				const getTextInlineElements = constant(textInlineElementsMap);
				const getVoidElements = constant(Object.seal(voidElementsMap));
				const getSelfClosingElements = constant(selfClosingElementsMap);
				const getNonEmptyElements = constant(nonEmptyElementsMap);
				const getMoveCaretBeforeOnEnterElements = constant(moveCaretBeforeOnEnterElementsMap);
				const getWhitespaceElements = constant(whitespaceElementsMap);
				const getTransparentElements = constant(transparentElementsMap);
				const getSpecialElements = constant(Object.seal(specialElements));
				const isValidChild = (name$1, child$2) => {
					const parent$1 = children$2[name$1.toLowerCase()];
					return !!(parent$1 && parent$1[child$2.toLowerCase()]);
				};
				const isValid$1 = (name$1, attr) => {
					const rule = getElementRule(name$1);
					if (rule) if (attr) {
						if (rule.attributes[attr]) return true;
						const attrPatterns = rule.attributePatterns;
						if (attrPatterns) {
							let i = attrPatterns.length;
							while (i--) if (attrPatterns[i].pattern.test(attr)) return true;
						}
					} else return true;
					return false;
				};
				return {
					type: schemaType,
					children: children$2,
					elements,
					getValidStyles,
					getValidClasses,
					getBlockElements,
					getInvalidStyles,
					getVoidElements,
					getTextBlockElements,
					getTextInlineElements,
					getBoolAttrs,
					getElementRule,
					getSelfClosingElements,
					getNonEmptyElements,
					getMoveCaretBeforeOnEnterElements,
					getWhitespaceElements,
					getTransparentElements,
					getSpecialElements,
					isValidChild,
					isValid: isValid$1,
					getCustomElements: constant(customElementsMap),
					addValidElements,
					setValidElements,
					addCustomElements,
					addValidChildren
				};
			};
			const Styles = (settings = {}, schema) => {
				const urlOrStrRegExp = /(?:url(?:(?:\(\s*\"([^\"]+)\"\s*\))|(?:\(\s*\'([^\']+)\'\s*\))|(?:\(\s*([^)\s]+)\s*\))))|(?:\'([^\']+)\')|(?:\"([^\"]+)\")/gi;
				const styleRegExp = /\s*([^:]+):\s*([^;]+);?/g;
				const trimRightRegExp = /\s+$/;
				const encodingLookup = {};
				let validStyles;
				let invalidStyles;
				const invisibleChar = zeroWidth;
				if (schema) {
					validStyles = schema.getValidStyles();
					invalidStyles = schema.getInvalidStyles();
				}
				const encodingItems = `\\" \\' \\; \\: ; : `.split(" ");
				for (let i = 0; i < encodingItems.length; i++) {
					encodingLookup[encodingItems[i]] = invisibleChar + i;
					encodingLookup[invisibleChar + i] = encodingItems[i];
				}
				const self = {
					parse: (css) => {
						const styles = {};
						let isEncoded = false;
						const urlConverter = settings.url_converter;
						const urlConverterScope = settings.url_converter_scope || self;
						const compress = (prefix, suffix, noJoin) => {
							const top = styles[prefix + "-top" + suffix];
							if (!top) return;
							const right = styles[prefix + "-right" + suffix];
							if (!right) return;
							const bottom = styles[prefix + "-bottom" + suffix];
							if (!bottom) return;
							const left = styles[prefix + "-left" + suffix];
							if (!left) return;
							const box = [
								top,
								right,
								bottom,
								left
							];
							let i = box.length - 1;
							while (i--) if (box[i] !== box[i + 1]) break;
							if (i > -1 && noJoin) return;
							styles[prefix + suffix] = i === -1 ? box[0] : box.join(" ");
							delete styles[prefix + "-top" + suffix];
							delete styles[prefix + "-right" + suffix];
							delete styles[prefix + "-bottom" + suffix];
							delete styles[prefix + "-left" + suffix];
						};
						const canCompress = (key) => {
							const value$3 = styles[key];
							if (!value$3) return;
							const values$1 = value$3.indexOf(",") > -1 ? [value$3] : value$3.split(" ");
							let i = values$1.length;
							while (i--) if (values$1[i] !== values$1[0]) return false;
							styles[key] = values$1[0];
							return true;
						};
						const compress2 = (target, a, b, c) => {
							if (!canCompress(a)) return;
							if (!canCompress(b)) return;
							if (!canCompress(c)) return;
							styles[target] = styles[a] + " " + styles[b] + " " + styles[c];
							delete styles[a];
							delete styles[b];
							delete styles[c];
						};
						const encode = (str) => {
							isEncoded = true;
							return encodingLookup[str];
						};
						const decode$1 = (str, keepSlashes) => {
							if (isEncoded) str = str.replace(/\uFEFF[0-9]/g, (str$1) => {
								return encodingLookup[str$1];
							});
							if (!keepSlashes) str = str.replace(/\\([\'\";:])/g, "$1");
							return str;
						};
						const decodeSingleHexSequence = (escSeq) => {
							return String.fromCharCode(parseInt(escSeq.slice(1), 16));
						};
						const decodeHexSequences = (value$3) => {
							return value$3.replace(/\\[0-9a-f]+/gi, decodeSingleHexSequence);
						};
						const processUrl = (match$3, url, url2, url3, str, str2) => {
							str = str || str2;
							if (str) {
								str = decode$1(str);
								return `'` + str.replace(/\'/g, `\\'`) + `'`;
							}
							url = decode$1(url || url2 || url3 || "");
							if (!settings.allow_script_urls) {
								const scriptUrl = url.replace(/[\s\r\n]+/g, "");
								if (/(java|vb)script:/i.test(scriptUrl)) return "";
								if (!settings.allow_svg_data_urls && /^data:image\/svg/i.test(scriptUrl)) return "";
							}
							if (urlConverter) url = urlConverter.call(urlConverterScope, url, "style");
							return `url('` + url.replace(/\'/g, `\\'`) + `')`;
						};
						if (css) {
							css = css.replace(/[\u0000-\u001F]/g, "");
							css = css.replace(/\\[\"\';:\uFEFF]/g, encode).replace(/\"[^\"]+\"|\'[^\']+\'/g, (str) => {
								return str.replace(/[;:]/g, encode);
							});
							let matches;
							while (matches = styleRegExp.exec(css)) {
								styleRegExp.lastIndex = matches.index + matches[0].length;
								let name$1 = matches[1].replace(trimRightRegExp, "").toLowerCase();
								let value$3 = matches[2].replace(trimRightRegExp, "");
								if (name$1 && value$3) {
									name$1 = decodeHexSequences(name$1);
									value$3 = decodeHexSequences(value$3);
									if (name$1.indexOf(invisibleChar) !== -1 || name$1.indexOf("\"") !== -1) continue;
									if (!settings.allow_script_urls && (name$1 === "behavior" || /expression\s*\(|\/\*|\*\//.test(value$3))) continue;
									if (name$1 === "font-weight" && value$3 === "700") value$3 = "bold";
									else if (name$1 === "color" || name$1 === "background-color") value$3 = value$3.toLowerCase();
									value$3 = value$3.replace(urlOrStrRegExp, processUrl);
									styles[name$1] = isEncoded ? decode$1(value$3, true) : value$3;
								}
							}
							compress("border", "", true);
							compress("border", "-width");
							compress("border", "-color");
							compress("border", "-style");
							compress("padding", "");
							compress("margin", "");
							compress2("border", "border-width", "border-style", "border-color");
							if (styles.border === "medium none") delete styles.border;
							if (styles["border-image"] === "none") delete styles["border-image"];
						}
						return styles;
					},
					serialize: (styles, elementName) => {
						let css = "";
						const serializeStyles = (elemName, validStyleList) => {
							const styleList = validStyleList[elemName];
							if (styleList) for (let i = 0, l = styleList.length; i < l; i++) {
								const name$1 = styleList[i];
								const value$3 = styles[name$1];
								if (value$3) css += (css.length > 0 ? " " : "") + name$1 + ": " + value$3 + ";";
							}
						};
						const isValid$1 = (name$1, elemName) => {
							if (!invalidStyles || !elemName) return true;
							let styleMap = invalidStyles["*"];
							if (styleMap && styleMap[name$1]) return false;
							styleMap = invalidStyles[elemName];
							return !(styleMap && styleMap[name$1]);
						};
						if (elementName && validStyles) {
							serializeStyles("*", validStyles);
							serializeStyles(elementName, validStyles);
						} else each$d(styles, (value$3, name$1) => {
							if (value$3 && isValid$1(name$1, elementName)) css += (css.length > 0 ? " " : "") + name$1 + ": " + value$3 + ";";
						});
						return css;
					}
				};
				return self;
			};
			const deprecated = {
				keyLocation: true,
				layerX: true,
				layerY: true,
				returnValue: true,
				webkitMovementX: true,
				webkitMovementY: true,
				keyIdentifier: true,
				mozPressure: true
			};
			const isNativeEvent = (event) => event instanceof Event || isFunction(event.initEvent);
			const hasIsDefaultPrevented = (event) => event.isDefaultPrevented === always || event.isDefaultPrevented === never;
			const needsNormalizing = (event) => isNullable(event.preventDefault) || isNativeEvent(event);
			const clone$3 = (originalEvent, data$1) => {
				const event = data$1 !== null && data$1 !== void 0 ? data$1 : {};
				for (const name$1 in originalEvent) if (!has$2(deprecated, name$1)) event[name$1] = originalEvent[name$1];
				if (isNonNullable(originalEvent.composedPath)) event.composedPath = () => originalEvent.composedPath();
				return event;
			};
			const normalize$3 = (type$2, originalEvent, fallbackTarget, data$1) => {
				var _a;
				const event = clone$3(originalEvent, data$1);
				event.type = type$2;
				if (isNullable(event.target)) event.target = (_a = event.srcElement) !== null && _a !== void 0 ? _a : fallbackTarget;
				if (needsNormalizing(originalEvent)) {
					event.preventDefault = () => {
						event.defaultPrevented = true;
						event.isDefaultPrevented = always;
						if (isFunction(originalEvent.preventDefault)) originalEvent.preventDefault();
					};
					event.stopPropagation = () => {
						event.cancelBubble = true;
						event.isPropagationStopped = always;
						if (isFunction(originalEvent.stopPropagation)) originalEvent.stopPropagation();
					};
					event.stopImmediatePropagation = () => {
						event.isImmediatePropagationStopped = always;
						event.stopPropagation();
					};
					if (!hasIsDefaultPrevented(event)) {
						event.isDefaultPrevented = event.defaultPrevented === true ? always : never;
						event.isPropagationStopped = event.cancelBubble === true ? always : never;
						event.isImmediatePropagationStopped = never;
					}
				}
				return event;
			};
			const eventExpandoPrefix = "mce-data-";
			const mouseEventRe = /^(?:mouse|contextmenu)|click/;
			const addEvent = (target, name$1, callback, capture) => {
				target.addEventListener(name$1, callback, capture || false);
			};
			const removeEvent = (target, name$1, callback, capture) => {
				target.removeEventListener(name$1, callback, capture || false);
			};
			const isMouseEvent = (event) => isNonNullable(event) && mouseEventRe.test(event.type);
			const fix = (originalEvent, data$1) => {
				const event = normalize$3(originalEvent.type, originalEvent, document, data$1);
				if (isMouseEvent(originalEvent) && isUndefined(originalEvent.pageX) && !isUndefined(originalEvent.clientX)) {
					const eventDoc = event.target.ownerDocument || document;
					const doc = eventDoc.documentElement;
					const body = eventDoc.body;
					const mouseEvent = event;
					mouseEvent.pageX = originalEvent.clientX + (doc && doc.scrollLeft || body && body.scrollLeft || 0) - (doc && doc.clientLeft || body && body.clientLeft || 0);
					mouseEvent.pageY = originalEvent.clientY + (doc && doc.scrollTop || body && body.scrollTop || 0) - (doc && doc.clientTop || body && body.clientTop || 0);
				}
				return event;
			};
			const bindOnReady = (win, callback, eventUtils) => {
				const doc = win.document, event = { type: "ready" };
				if (eventUtils.domLoaded) {
					callback(event);
					return;
				}
				const isDocReady = () => {
					return doc.readyState === "complete" || doc.readyState === "interactive" && doc.body;
				};
				const readyHandler = () => {
					removeEvent(win, "DOMContentLoaded", readyHandler);
					removeEvent(win, "load", readyHandler);
					if (!eventUtils.domLoaded) {
						eventUtils.domLoaded = true;
						callback(event);
					}
					win = null;
				};
				if (isDocReady()) readyHandler();
				else addEvent(win, "DOMContentLoaded", readyHandler);
				if (!eventUtils.domLoaded) addEvent(win, "load", readyHandler);
			};
			class EventUtils {
				constructor() {
					this.domLoaded = false;
					this.events = {};
					this.count = 1;
					this.expando = eventExpandoPrefix + (+/* @__PURE__ */ new Date()).toString(32);
					this.hasFocusIn = "onfocusin" in document.documentElement;
					this.count = 1;
				}
				bind(target, names, callback, scope) {
					const self = this;
					let callbackList;
					const win = window;
					const defaultNativeHandler = (evt) => {
						self.executeHandlers(fix(evt || win.event), id);
					};
					if (!target || isText$a(target) || isComment(target)) return callback;
					let id;
					if (!target[self.expando]) {
						id = self.count++;
						target[self.expando] = id;
						self.events[id] = {};
					} else id = target[self.expando];
					scope = scope || target;
					const namesList = names.split(" ");
					let i = namesList.length;
					while (i--) {
						let name$1 = namesList[i];
						let nativeHandler = defaultNativeHandler;
						let capture = false;
						let fakeName = false;
						if (name$1 === "DOMContentLoaded") name$1 = "ready";
						if (self.domLoaded && name$1 === "ready" && target.readyState === "complete") {
							callback.call(scope, fix({ type: name$1 }));
							continue;
						}
						if (!self.hasFocusIn && (name$1 === "focusin" || name$1 === "focusout")) {
							capture = true;
							fakeName = name$1 === "focusin" ? "focus" : "blur";
							nativeHandler = (evt) => {
								const event = fix(evt || win.event);
								event.type = event.type === "focus" ? "focusin" : "focusout";
								self.executeHandlers(event, id);
							};
						}
						callbackList = self.events[id][name$1];
						if (!callbackList) {
							self.events[id][name$1] = callbackList = [{
								func: callback,
								scope
							}];
							callbackList.fakeName = fakeName;
							callbackList.capture = capture;
							callbackList.nativeHandler = nativeHandler;
							if (name$1 === "ready") bindOnReady(target, nativeHandler, self);
							else addEvent(target, fakeName || name$1, nativeHandler, capture);
						} else if (name$1 === "ready" && self.domLoaded) callback(fix({ type: name$1 }));
						else callbackList.push({
							func: callback,
							scope
						});
					}
					target = callbackList = null;
					return callback;
				}
				unbind(target, names, callback) {
					if (!target || isText$a(target) || isComment(target)) return this;
					const id = target[this.expando];
					if (id) {
						let eventMap = this.events[id];
						if (names) {
							const namesList = names.split(" ");
							let i = namesList.length;
							while (i--) {
								const name$1 = namesList[i];
								const callbackList = eventMap[name$1];
								if (callbackList) {
									if (callback) {
										let ci = callbackList.length;
										while (ci--) if (callbackList[ci].func === callback) {
											const nativeHandler = callbackList.nativeHandler;
											const fakeName = callbackList.fakeName, capture = callbackList.capture;
											const newCallbackList = callbackList.slice(0, ci).concat(callbackList.slice(ci + 1));
											newCallbackList.nativeHandler = nativeHandler;
											newCallbackList.fakeName = fakeName;
											newCallbackList.capture = capture;
											eventMap[name$1] = newCallbackList;
										}
									}
									if (!callback || callbackList.length === 0) {
										delete eventMap[name$1];
										removeEvent(target, callbackList.fakeName || name$1, callbackList.nativeHandler, callbackList.capture);
									}
								}
							}
						} else {
							each$d(eventMap, (callbackList, name$1) => {
								removeEvent(target, callbackList.fakeName || name$1, callbackList.nativeHandler, callbackList.capture);
							});
							eventMap = {};
						}
						for (const name$1 in eventMap) if (has$2(eventMap, name$1)) return this;
						delete this.events[id];
						try {
							delete target[this.expando];
						} catch (ex) {
							target[this.expando] = null;
						}
					}
					return this;
				}
				fire(target, name$1, args) {
					return this.dispatch(target, name$1, args);
				}
				dispatch(target, name$1, args) {
					if (!target || isText$a(target) || isComment(target)) return this;
					const event = fix({
						type: name$1,
						target
					}, args);
					do {
						const id = target[this.expando];
						if (id) this.executeHandlers(event, id);
						target = target.parentNode || target.ownerDocument || target.defaultView || target.parentWindow;
					} while (target && !event.isPropagationStopped());
					return this;
				}
				clean(target) {
					if (!target || isText$a(target) || isComment(target)) return this;
					if (target[this.expando]) this.unbind(target);
					if (!target.getElementsByTagName) target = target.document;
					if (target && target.getElementsByTagName) {
						this.unbind(target);
						const children$2 = target.getElementsByTagName("*");
						let i = children$2.length;
						while (i--) {
							target = children$2[i];
							if (target[this.expando]) this.unbind(target);
						}
					}
					return this;
				}
				destroy() {
					this.events = {};
				}
				cancel(e) {
					if (e) {
						e.preventDefault();
						e.stopImmediatePropagation();
					}
					return false;
				}
				executeHandlers(evt, id) {
					const container = this.events[id];
					const callbackList = container && container[evt.type];
					if (callbackList) for (let i = 0, l = callbackList.length; i < l; i++) {
						const callback = callbackList[i];
						if (callback && callback.func.call(callback.scope, evt) === false) evt.preventDefault();
						if (evt.isImmediatePropagationStopped()) return;
					}
				}
			}
			EventUtils.Event = new EventUtils();
			const each$a = Tools.each;
			const grep = Tools.grep;
			const internalStyleName = "data-mce-style";
			const numericalCssMap = Tools.makeMap("fill-opacity font-weight line-height opacity orphans widows z-index zoom", " ");
			const legacySetAttribute = (elm, name$1, value$3) => {
				if (isNullable(value$3) || value$3 === "") remove$a(elm, name$1);
				else set$3(elm, name$1, value$3);
			};
			const camelCaseToHyphens = (name$1) => name$1.replace(/[A-Z]/g, (v) => "-" + v.toLowerCase());
			const findNodeIndex = (node, normalized) => {
				let idx = 0;
				if (node) for (let lastNodeType = node.nodeType, tempNode = node.previousSibling; tempNode; tempNode = tempNode.previousSibling) {
					const nodeType = tempNode.nodeType;
					if (normalized && isText$a(tempNode)) {
						if (nodeType === lastNodeType || !tempNode.data.length) continue;
					}
					idx++;
					lastNodeType = nodeType;
				}
				return idx;
			};
			const updateInternalStyleAttr = (styles, elm) => {
				const rawValue = get$9(elm, "style");
				legacySetAttribute(elm, internalStyleName, styles.serialize(styles.parse(rawValue), name(elm)));
			};
			const convertStyleToString = (cssValue, cssName) => {
				if (isNumber(cssValue)) return has$2(numericalCssMap, cssName) ? cssValue + "" : cssValue + "px";
				else return cssValue;
			};
			const applyStyle$1 = ($elm, cssName, cssValue) => {
				const normalizedName = camelCaseToHyphens(cssName);
				if (isNullable(cssValue) || cssValue === "") remove$6($elm, normalizedName);
				else set$2($elm, normalizedName, convertStyleToString(cssValue, normalizedName));
			};
			const setupAttrHooks = (styles, settings, getContext$1) => {
				const keepValues = settings.keep_values;
				const keepUrlHook = {
					set: (elm, value$3, name$1) => {
						const sugarElm = SugarElement.fromDom(elm);
						if (isFunction(settings.url_converter) && isNonNullable(value$3)) value$3 = settings.url_converter.call(settings.url_converter_scope || getContext$1(), String(value$3), name$1, elm);
						legacySetAttribute(sugarElm, "data-mce-" + name$1, value$3);
						legacySetAttribute(sugarElm, name$1, value$3);
					},
					get: (elm, name$1) => {
						const sugarElm = SugarElement.fromDom(elm);
						return get$9(sugarElm, "data-mce-" + name$1) || get$9(sugarElm, name$1);
					}
				};
				const attrHooks = { style: {
					set: (elm, value$3) => {
						const sugarElm = SugarElement.fromDom(elm);
						if (keepValues) legacySetAttribute(sugarElm, internalStyleName, value$3);
						remove$a(sugarElm, "style");
						if (isString(value$3)) setAll(sugarElm, styles.parse(value$3));
					},
					get: (elm) => {
						const sugarElm = SugarElement.fromDom(elm);
						const value$3 = get$9(sugarElm, internalStyleName) || get$9(sugarElm, "style");
						return styles.serialize(styles.parse(value$3), name(sugarElm));
					}
				} };
				if (keepValues) attrHooks.href = attrHooks.src = keepUrlHook;
				return attrHooks;
			};
			const DOMUtils = (doc, settings = {}) => {
				const addedStyles = {};
				const win = window;
				const files = {};
				let counter = 0;
				const stdMode = true;
				const boxModel = true;
				const styleSheetLoader = instance.forElement(SugarElement.fromDom(doc), {
					contentCssCors: settings.contentCssCors,
					referrerPolicy: settings.referrerPolicy
				});
				const boundEvents = [];
				const schema = settings.schema ? settings.schema : Schema({});
				const styles = Styles({
					url_converter: settings.url_converter,
					url_converter_scope: settings.url_converter_scope
				}, settings.schema);
				const events = settings.ownEvents ? new EventUtils() : EventUtils.Event;
				const blockElementsMap = schema.getBlockElements();
				const isBlock$3 = (node) => {
					if (isString(node)) return has$2(blockElementsMap, node);
					else return isElement$6(node) && (has$2(blockElementsMap, node.nodeName) || isTransparentBlock(schema, node));
				};
				const get$10 = (elm) => elm && doc && isString(elm) ? doc.getElementById(elm) : elm;
				const _get = (elm) => {
					const value$3 = get$10(elm);
					return isNonNullable(value$3) ? SugarElement.fromDom(value$3) : null;
				};
				const getAttrib = (elm, name$1, defaultVal = "") => {
					let value$3;
					const $elm = _get(elm);
					if (isNonNullable($elm) && isElement$7($elm)) {
						const hook = attrHooks[name$1];
						if (hook && hook.get) value$3 = hook.get($elm.dom, name$1);
						else value$3 = get$9($elm, name$1);
					}
					return isNonNullable(value$3) ? value$3 : defaultVal;
				};
				const getAttribs = (elm) => {
					const node = get$10(elm);
					return isNullable(node) ? [] : node.attributes;
				};
				const setAttrib = (elm, name$1, value$3) => {
					run(elm, (e) => {
						if (isElement$6(e)) {
							const $elm = SugarElement.fromDom(e);
							const val = value$3 === "" ? null : value$3;
							const originalValue = get$9($elm, name$1);
							const hook = attrHooks[name$1];
							if (hook && hook.set) hook.set($elm.dom, val, name$1);
							else legacySetAttribute($elm, name$1, val);
							if (originalValue !== val && settings.onSetAttrib) settings.onSetAttrib({
								attrElm: $elm.dom,
								attrName: name$1,
								attrValue: val
							});
						}
					});
				};
				const clone$5 = (node, deep$2) => {
					return node.cloneNode(deep$2);
				};
				const getRoot = () => settings.root_element || doc.body;
				const getViewPort = (argWin) => {
					const vp = getBounds(argWin);
					return {
						x: vp.x,
						y: vp.y,
						w: vp.width,
						h: vp.height
					};
				};
				const getPos$1 = (elm, rootElm) => getPos(doc.body, get$10(elm), rootElm);
				const setStyle = (elm, name$1, value$3) => {
					run(elm, (e) => {
						const $elm = SugarElement.fromDom(e);
						applyStyle$1($elm, name$1, value$3);
						if (settings.update_styles) updateInternalStyleAttr(styles, $elm);
					});
				};
				const setStyles = (elm, stylesArg) => {
					run(elm, (e) => {
						const $elm = SugarElement.fromDom(e);
						each$d(stylesArg, (v, n) => {
							applyStyle$1($elm, n, v);
						});
						if (settings.update_styles) updateInternalStyleAttr(styles, $elm);
					});
				};
				const getStyle$1 = (elm, name$1, computed) => {
					const $elm = get$10(elm);
					if (isNullable($elm) || !isElement$6($elm)) return;
					if (computed) return get$7(SugarElement.fromDom($elm), camelCaseToHyphens(name$1));
					else {
						name$1 = name$1.replace(/-(\D)/g, (a, b) => b.toUpperCase());
						if (name$1 === "float") name$1 = "cssFloat";
						return $elm.style ? $elm.style[name$1] : void 0;
					}
				};
				const getSize = (elm) => {
					const $elm = get$10(elm);
					if (!$elm) return {
						w: 0,
						h: 0
					};
					let w = getStyle$1($elm, "width");
					let h = getStyle$1($elm, "height");
					if (!w || w.indexOf("px") === -1) w = "0";
					if (!h || h.indexOf("px") === -1) h = "0";
					return {
						w: parseInt(w, 10) || $elm.offsetWidth || $elm.clientWidth,
						h: parseInt(h, 10) || $elm.offsetHeight || $elm.clientHeight
					};
				};
				const getRect = (elm) => {
					const $elm = get$10(elm);
					const pos = getPos$1($elm);
					const size = getSize($elm);
					return {
						x: pos.x,
						y: pos.y,
						w: size.w,
						h: size.h
					};
				};
				const is$5 = (elm, selector) => {
					if (!elm) return false;
					return exists(isArray$1(elm) ? elm : [elm], (e) => {
						return is$1(SugarElement.fromDom(e), selector);
					});
				};
				const getParents$4 = (elm, selector, root, collect) => {
					const result = [];
					let node = get$10(elm);
					collect = collect === void 0;
					const resolvedRoot = root || (getRoot().nodeName !== "BODY" ? getRoot().parentNode : null);
					if (isString(selector)) if (selector === "*") selector = isElement$6;
					else {
						const selectorVal = selector;
						selector = (node$1) => is$5(node$1, selectorVal);
					}
					while (node) {
						if (node === resolvedRoot || isNullable(node.nodeType) || isDocument$1(node) || isDocumentFragment(node)) break;
						if (!selector || selector(node)) if (collect) result.push(node);
						else return [node];
						node = node.parentNode;
					}
					return collect ? result : null;
				};
				const getParent = (node, selector, root) => {
					const parents$2 = getParents$4(node, selector, root, false);
					return parents$2 && parents$2.length > 0 ? parents$2[0] : null;
				};
				const _findSib = (node, selector, name$1) => {
					let func = selector;
					if (node) {
						if (isString(selector)) func = (node$1) => {
							return is$5(node$1, selector);
						};
						for (let tempNode = node[name$1]; tempNode; tempNode = tempNode[name$1]) if (isFunction(func) && func(tempNode)) return tempNode;
					}
					return null;
				};
				const getNext = (node, selector) => _findSib(node, selector, "nextSibling");
				const getPrev = (node, selector) => _findSib(node, selector, "previousSibling");
				const isParentNode = (node) => isFunction(node.querySelectorAll);
				const select$1 = (selector, scope) => {
					var _a, _b;
					const elm = (_b = (_a = get$10(scope)) !== null && _a !== void 0 ? _a : settings.root_element) !== null && _b !== void 0 ? _b : doc;
					return isParentNode(elm) ? from(elm.querySelectorAll(selector)) : [];
				};
				const run = function(elm, func, scope) {
					const context$1 = scope !== null && scope !== void 0 ? scope : this;
					if (isArray$1(elm)) {
						const result = [];
						each$a(elm, (e, i) => {
							const node = get$10(e);
							if (node) result.push(func.call(context$1, node, i));
						});
						return result;
					} else {
						const node = get$10(elm);
						return !node ? false : func.call(context$1, node);
					}
				};
				const setAttribs = (elm, attrs) => {
					run(elm, ($elm) => {
						each$d(attrs, (value$3, name$1) => {
							setAttrib($elm, name$1, value$3);
						});
					});
				};
				const setHTML = (elm, html$2) => {
					run(elm, (e) => {
						set$1(SugarElement.fromDom(e), html$2);
					});
				};
				const add$5 = (parentElm, name$1, attrs, html$2, create$11) => run(parentElm, (parentElm$1) => {
					const newElm = isString(name$1) ? doc.createElement(name$1) : name$1;
					if (isNonNullable(attrs)) setAttribs(newElm, attrs);
					if (html$2) {
						if (!isString(html$2) && html$2.nodeType) newElm.appendChild(html$2);
						else if (isString(html$2)) setHTML(newElm, html$2);
					}
					return !create$11 ? parentElm$1.appendChild(newElm) : newElm;
				});
				const create$10 = (name$1, attrs, html$2) => add$5(doc.createElement(name$1), name$1, attrs, html$2, true);
				const decode$1 = Entities.decode;
				const encode = Entities.encodeAllRaw;
				const createHTML = (name$1, attrs, html$2 = "") => {
					let outHtml = "<" + name$1;
					for (const key in attrs) if (hasNonNullableKey(attrs, key)) outHtml += " " + key + "=\"" + encode(attrs[key]) + "\"";
					if (isEmpty$3(html$2) && has$2(schema.getVoidElements(), name$1)) return outHtml + " />";
					else return outHtml + ">" + html$2 + "</" + name$1 + ">";
				};
				const createFragment$1 = (html$2) => {
					const container = doc.createElement("div");
					const frag = doc.createDocumentFragment();
					frag.appendChild(container);
					if (html$2) container.innerHTML = html$2;
					let node;
					while (node = container.firstChild) frag.appendChild(node);
					frag.removeChild(container);
					return frag;
				};
				const remove$10 = (node, keepChildren) => {
					return run(node, (n) => {
						const $node = SugarElement.fromDom(n);
						if (keepChildren) each$e(children$1($node), (child$2) => {
							if (isText$b(child$2) && child$2.dom.length === 0) remove$5(child$2);
							else before$3($node, child$2);
						});
						remove$5($node);
						return $node.dom;
					});
				};
				const removeAllAttribs = (e) => run(e, (e$1) => {
					const attrs = e$1.attributes;
					for (let i = attrs.length - 1; i >= 0; i--) e$1.removeAttributeNode(attrs.item(i));
				});
				const parseStyle = (cssText) => styles.parse(cssText);
				const serializeStyle = (stylesArg, name$1) => styles.serialize(stylesArg, name$1);
				const addStyle = (cssText) => {
					if (self !== DOMUtils.DOM && doc === document) {
						if (addedStyles[cssText]) return;
						addedStyles[cssText] = true;
					}
					let styleElm = doc.getElementById("mceDefaultStyles");
					if (!styleElm) {
						styleElm = doc.createElement("style");
						styleElm.id = "mceDefaultStyles";
						styleElm.type = "text/css";
						const head$1 = doc.head;
						if (head$1.firstChild) head$1.insertBefore(styleElm, head$1.firstChild);
						else head$1.appendChild(styleElm);
					}
					if (styleElm.styleSheet) styleElm.styleSheet.cssText += cssText;
					else styleElm.appendChild(doc.createTextNode(cssText));
				};
				const loadCSS = (urls) => {
					if (!urls) urls = "";
					each$e(urls.split(","), (url) => {
						files[url] = true;
						styleSheetLoader.load(url).catch(noop);
					});
				};
				const toggleClass$1 = (elm, cls, state) => {
					run(elm, (e) => {
						if (isElement$6(e)) {
							const $elm = SugarElement.fromDom(e);
							each$e(cls.split(" "), (c) => {
								if (isNonNullable(state)) (state ? add$2 : remove$7)($elm, c);
								else toggle$1($elm, c);
							});
						}
					});
				};
				const addClass = (elm, cls) => {
					toggleClass$1(elm, cls, true);
				};
				const removeClass = (elm, cls) => {
					toggleClass$1(elm, cls, false);
				};
				const hasClass$1 = (elm, cls) => {
					const $elm = _get(elm);
					const classes = cls.split(" ");
					return isNonNullable($elm) && forall(classes, (c) => has($elm, c));
				};
				const show = (elm) => {
					run(elm, (e) => remove$6(SugarElement.fromDom(e), "display"));
				};
				const hide = (elm) => {
					run(elm, (e) => set$2(SugarElement.fromDom(e), "display", "none"));
				};
				const isHidden = (elm) => {
					const $elm = _get(elm);
					return isNonNullable($elm) && is$2(getRaw($elm, "display"), "none");
				};
				const uniqueId$2 = (prefix) => (!prefix ? "mce_" : prefix) + counter++;
				const getOuterHTML = (elm) => {
					const $elm = _get(elm);
					if (isNonNullable($elm)) return isElement$6($elm.dom) ? $elm.dom.outerHTML : getOuter($elm);
					else return "";
				};
				const setOuterHTML = (elm, html$2) => {
					run(elm, ($elm) => {
						if (isElement$6($elm)) $elm.outerHTML = html$2;
					});
				};
				const insertAfter$3 = (node, reference) => {
					const referenceNode = get$10(reference);
					return run(node, (node$1) => {
						const parent$1 = referenceNode === null || referenceNode === void 0 ? void 0 : referenceNode.parentNode;
						const nextSibling$1 = referenceNode === null || referenceNode === void 0 ? void 0 : referenceNode.nextSibling;
						if (parent$1) if (nextSibling$1) parent$1.insertBefore(node$1, nextSibling$1);
						else parent$1.appendChild(node$1);
						return node$1;
					});
				};
				const replace = (newElm, oldElm, keepChildren) => run(oldElm, (elm) => {
					var _a;
					const replacee = isArray$1(oldElm) ? newElm.cloneNode(true) : newElm;
					if (keepChildren) each$a(grep(elm.childNodes), (node) => {
						replacee.appendChild(node);
					});
					(_a = elm.parentNode) === null || _a === void 0 || _a.replaceChild(replacee, elm);
					return elm;
				});
				const rename = (elm, name$1) => {
					if (elm.nodeName !== name$1.toUpperCase()) {
						const newElm = create$10(name$1);
						each$a(getAttribs(elm), (attrNode) => {
							setAttrib(newElm, attrNode.nodeName, getAttrib(elm, attrNode.nodeName));
						});
						replace(newElm, elm, true);
						return newElm;
					} else return elm;
				};
				const findCommonAncestor = (a, b) => {
					let ps = a;
					while (ps) {
						let pe = b;
						while (pe && ps !== pe) pe = pe.parentNode;
						if (ps === pe) break;
						ps = ps.parentNode;
					}
					if (!ps && a.ownerDocument) return a.ownerDocument.documentElement;
					else return ps;
				};
				const isNonEmptyElement$1 = (node) => {
					if (isElement$6(node)) {
						const isNamedAnchor$1 = node.nodeName.toLowerCase() === "a" && !getAttrib(node, "href") && getAttrib(node, "id");
						if (getAttrib(node, "name") || getAttrib(node, "data-mce-bookmark") || isNamedAnchor$1) return true;
					}
					return false;
				};
				const isEmpty$4 = (node, elements, options) => {
					let brCount = 0;
					if (isNonEmptyElement$1(node)) return false;
					const firstChild$1 = node.firstChild;
					if (firstChild$1) {
						const walker = new DomTreeWalker(firstChild$1, node);
						const whitespaceElements = schema ? schema.getWhitespaceElements() : {};
						const nonEmptyElements = elements || (schema ? schema.getNonEmptyElements() : null);
						let tempNode = firstChild$1;
						do {
							if (isElement$6(tempNode)) {
								const bogusVal = tempNode.getAttribute("data-mce-bogus");
								if (bogusVal) {
									tempNode = walker.next(bogusVal === "all");
									continue;
								}
								const name$1 = tempNode.nodeName.toLowerCase();
								if (nonEmptyElements && nonEmptyElements[name$1]) {
									if (name$1 === "br") {
										brCount++;
										tempNode = walker.next();
										continue;
									}
									return false;
								}
								if (isNonEmptyElement$1(tempNode)) return false;
							}
							if (isComment(tempNode)) return false;
							if (isText$a(tempNode) && !isWhitespaceText(tempNode.data) && (!(options === null || options === void 0 ? void 0 : options.includeZwsp) || !isZwsp(tempNode.data))) return false;
							if (isText$a(tempNode) && tempNode.parentNode && whitespaceElements[tempNode.parentNode.nodeName] && isWhitespaceText(tempNode.data)) return false;
							tempNode = walker.next();
						} while (tempNode);
					}
					return brCount <= 1;
				};
				const createRng = () => doc.createRange();
				const split$3 = (parentElm, splitElm, replacementElm) => {
					let range = createRng();
					let beforeFragment;
					let afterFragment;
					if (parentElm && splitElm && parentElm.parentNode && splitElm.parentNode) {
						const parentNode = parentElm.parentNode;
						range.setStart(parentNode, findNodeIndex(parentElm));
						range.setEnd(splitElm.parentNode, findNodeIndex(splitElm));
						beforeFragment = range.extractContents();
						range = createRng();
						range.setStart(splitElm.parentNode, findNodeIndex(splitElm) + 1);
						range.setEnd(parentNode, findNodeIndex(parentElm) + 1);
						afterFragment = range.extractContents();
						parentNode.insertBefore(trimNode(self, beforeFragment), parentElm);
						if (replacementElm) parentNode.insertBefore(replacementElm, parentElm);
						else parentNode.insertBefore(splitElm, parentElm);
						parentNode.insertBefore(trimNode(self, afterFragment), parentElm);
						remove$10(parentElm);
						return replacementElm || splitElm;
					} else return;
				};
				const bind$4 = (target, name$1, func, scope) => {
					if (isArray$1(target)) {
						let i = target.length;
						const rv = [];
						while (i--) rv[i] = bind$4(target[i], name$1, func, scope);
						return rv;
					} else {
						if (settings.collect && (target === doc || target === win)) boundEvents.push([
							target,
							name$1,
							func,
							scope
						]);
						return events.bind(target, name$1, func, scope || self);
					}
				};
				const unbind$1 = (target, name$1, func) => {
					if (isArray$1(target)) {
						let i = target.length;
						const rv = [];
						while (i--) rv[i] = unbind$1(target[i], name$1, func);
						return rv;
					} else {
						if (boundEvents.length > 0 && (target === doc || target === win)) {
							let i = boundEvents.length;
							while (i--) {
								const [boundTarget, boundName, boundFunc] = boundEvents[i];
								if (target === boundTarget && (!name$1 || name$1 === boundName) && (!func || func === boundFunc)) events.unbind(boundTarget, boundName, boundFunc);
							}
						}
						return events.unbind(target, name$1, func);
					}
				};
				const dispatch = (target, name$1, evt) => events.dispatch(target, name$1, evt);
				const fire = (target, name$1, evt) => events.dispatch(target, name$1, evt);
				const getContentEditable = (node) => {
					if (node && isElement$6(node)) {
						const contentEditable = node.getAttribute("data-mce-contenteditable");
						if (contentEditable && contentEditable !== "inherit") return contentEditable;
						return node.contentEditable !== "inherit" ? node.contentEditable : null;
					} else return null;
				};
				const getContentEditableParent = (node) => {
					const root = getRoot();
					let state = null;
					for (let tempNode = node; tempNode && tempNode !== root; tempNode = tempNode.parentNode) {
						state = getContentEditable(tempNode);
						if (state !== null) break;
					}
					return state;
				};
				const isEditable$4 = (node) => {
					if (isNonNullable(node)) {
						const scope = isElement$6(node) ? node : node.parentElement;
						return isNonNullable(scope) && isEditable$3(SugarElement.fromDom(scope));
					} else return false;
				};
				const destroy$1 = () => {
					if (boundEvents.length > 0) {
						let i = boundEvents.length;
						while (i--) {
							const [boundTarget, boundName, boundFunc] = boundEvents[i];
							events.unbind(boundTarget, boundName, boundFunc);
						}
					}
					each$d(files, (_, url) => {
						styleSheetLoader.unload(url);
						delete files[url];
					});
				};
				const isChildOf = (node, parent$1) => {
					return node === parent$1 || parent$1.contains(node);
				};
				const dumpRng = (r$1) => "startContainer: " + r$1.startContainer.nodeName + ", startOffset: " + r$1.startOffset + ", endContainer: " + r$1.endContainer.nodeName + ", endOffset: " + r$1.endOffset;
				const self = {
					doc,
					settings,
					win,
					files,
					stdMode,
					boxModel,
					styleSheetLoader,
					boundEvents,
					styles,
					schema,
					events,
					isBlock: isBlock$3,
					root: null,
					clone: clone$5,
					getRoot,
					getViewPort,
					getRect,
					getSize,
					getParent,
					getParents: getParents$4,
					get: get$10,
					getNext,
					getPrev,
					select: select$1,
					is: is$5,
					add: add$5,
					create: create$10,
					createHTML,
					createFragment: createFragment$1,
					remove: remove$10,
					setStyle,
					getStyle: getStyle$1,
					setStyles,
					removeAllAttribs,
					setAttrib,
					setAttribs,
					getAttrib,
					getPos: getPos$1,
					parseStyle,
					serializeStyle,
					addStyle,
					loadCSS,
					addClass,
					removeClass,
					hasClass: hasClass$1,
					toggleClass: toggleClass$1,
					show,
					hide,
					isHidden,
					uniqueId: uniqueId$2,
					setHTML,
					getOuterHTML,
					setOuterHTML,
					decode: decode$1,
					encode,
					insertAfter: insertAfter$3,
					replace,
					rename,
					findCommonAncestor,
					run,
					getAttribs,
					isEmpty: isEmpty$4,
					createRng,
					nodeIndex: findNodeIndex,
					split: split$3,
					bind: bind$4,
					unbind: unbind$1,
					fire,
					dispatch,
					getContentEditable,
					getContentEditableParent,
					isEditable: isEditable$4,
					destroy: destroy$1,
					isChildOf,
					dumpRng
				};
				const attrHooks = setupAttrHooks(styles, settings, constant(self));
				return self;
			};
			DOMUtils.DOM = DOMUtils(document);
			DOMUtils.nodeIndex = findNodeIndex;
			const DOM$b = DOMUtils.DOM;
			const QUEUED = 0;
			const LOADING = 1;
			const LOADED = 2;
			const FAILED = 3;
			class ScriptLoader {
				constructor(settings = {}) {
					this.states = {};
					this.queue = [];
					this.scriptLoadedCallbacks = {};
					this.queueLoadedCallbacks = [];
					this.loading = false;
					this.settings = settings;
				}
				_setReferrerPolicy(referrerPolicy) {
					this.settings.referrerPolicy = referrerPolicy;
				}
				loadScript(url) {
					return new Promise((resolve$4, reject) => {
						const dom$1 = DOM$b;
						let elm;
						const cleanup = () => {
							dom$1.remove(id);
							if (elm) elm.onerror = elm.onload = elm = null;
						};
						const done = () => {
							cleanup();
							resolve$4();
						};
						const error$1 = () => {
							cleanup();
							reject("Failed to load script: " + url);
						};
						const id = dom$1.uniqueId();
						elm = document.createElement("script");
						elm.id = id;
						elm.type = "text/javascript";
						elm.src = Tools._addCacheSuffix(url);
						if (this.settings.referrerPolicy) dom$1.setAttrib(elm, "referrerpolicy", this.settings.referrerPolicy);
						elm.onload = done;
						elm.onerror = error$1;
						(document.getElementsByTagName("head")[0] || document.body).appendChild(elm);
					});
				}
				isDone(url) {
					return this.states[url] === LOADED;
				}
				markDone(url) {
					this.states[url] = LOADED;
				}
				add(url) {
					const self = this;
					self.queue.push(url);
					if (self.states[url] === void 0) self.states[url] = QUEUED;
					return new Promise((resolve$4, reject) => {
						if (!self.scriptLoadedCallbacks[url]) self.scriptLoadedCallbacks[url] = [];
						self.scriptLoadedCallbacks[url].push({
							resolve: resolve$4,
							reject
						});
					});
				}
				load(url) {
					return this.add(url);
				}
				remove(url) {
					delete this.states[url];
					delete this.scriptLoadedCallbacks[url];
				}
				loadQueue() {
					const queue = this.queue;
					this.queue = [];
					return this.loadScripts(queue);
				}
				loadScripts(scripts) {
					const self = this;
					const execCallbacks = (name$1, url) => {
						get$a(self.scriptLoadedCallbacks, url).each((callbacks) => {
							each$e(callbacks, (callback) => callback[name$1](url));
						});
						delete self.scriptLoadedCallbacks[url];
					};
					const processResults = (results) => {
						const failures = filter$5(results, (result) => result.status === "rejected");
						if (failures.length > 0) return Promise.reject(bind$3(failures, ({ reason }) => isArray$1(reason) ? reason : [reason]));
						else return Promise.resolve();
					};
					const load = (urls) => Promise.allSettled(map$3(urls, (url) => {
						if (self.states[url] === LOADED) {
							execCallbacks("resolve", url);
							return Promise.resolve();
						} else if (self.states[url] === FAILED) {
							execCallbacks("reject", url);
							return Promise.reject(url);
						} else {
							self.states[url] = LOADING;
							return self.loadScript(url).then(() => {
								self.states[url] = LOADED;
								execCallbacks("resolve", url);
								const queue = self.queue;
								if (queue.length > 0) {
									self.queue = [];
									return load(queue).then(processResults);
								} else return Promise.resolve();
							}, () => {
								self.states[url] = FAILED;
								execCallbacks("reject", url);
								return Promise.reject(url);
							});
						}
					}));
					const processQueue = (urls) => {
						self.loading = true;
						return load(urls).then((results) => {
							self.loading = false;
							const nextQueuedItem = self.queueLoadedCallbacks.shift();
							Optional.from(nextQueuedItem).each(call);
							return processResults(results);
						});
					};
					const uniqueScripts = stringArray(scripts);
					if (self.loading) return new Promise((resolve$4, reject) => {
						self.queueLoadedCallbacks.push(() => {
							processQueue(uniqueScripts).then(resolve$4, reject);
						});
					});
					else return processQueue(uniqueScripts);
				}
			}
			ScriptLoader.ScriptLoader = new ScriptLoader();
			const Cell = (initial) => {
				let value$3 = initial;
				const get$10 = () => {
					return value$3;
				};
				const set$4 = (v) => {
					value$3 = v;
				};
				return {
					get: get$10,
					set: set$4
				};
			};
			const isDuplicated = (items, item) => {
				const firstIndex = items.indexOf(item);
				return firstIndex !== -1 && items.indexOf(item, firstIndex + 1) > firstIndex;
			};
			const isRaw = (str) => isObject(str) && has$2(str, "raw");
			const isTokenised = (str) => isArray$1(str) && str.length > 1;
			const data = {};
			const currentCode = Cell("en");
			const getLanguageData = () => get$a(data, currentCode.get());
			const getData$1 = () => map$2(data, (value$3) => ({ ...value$3 }));
			const setCode = (newCode) => {
				if (newCode) currentCode.set(newCode);
			};
			const getCode = () => currentCode.get();
			const add$1 = (code, items) => {
				let langData = data[code];
				if (!langData) data[code] = langData = {};
				const lcNames = map$3(keys(items), (name$1) => name$1.toLowerCase());
				each$d(items, (translation, name$1) => {
					const lcName = name$1.toLowerCase();
					if (lcName !== name$1 && isDuplicated(lcNames, lcName)) {
						if (!has$2(items, lcName)) langData[lcName] = translation;
						langData[name$1] = translation;
					} else langData[lcName] = translation;
				});
			};
			const translate = (text$1) => {
				const langData = getLanguageData().getOr({});
				const toString = (obj) => {
					if (isFunction(obj)) return Object.prototype.toString.call(obj);
					return !isEmpty$4(obj) ? "" + obj : "";
				};
				const isEmpty$4 = (text$2) => text$2 === "" || text$2 === null || text$2 === void 0;
				const getLangData = (text$2) => {
					const textStr = toString(text$2);
					return has$2(langData, textStr) ? toString(langData[textStr]) : get$a(langData, textStr.toLowerCase()).map(toString).getOr(textStr);
				};
				const removeContext = (str) => str.replace(/{context:\w+}$/, "");
				if (isEmpty$4(text$1)) return "";
				if (isRaw(text$1)) return toString(text$1.raw);
				if (isTokenised(text$1)) {
					const values$1 = text$1.slice(1);
					return removeContext(getLangData(text$1[0]).replace(/\{([0-9]+)\}/g, ($1, $2) => has$2(values$1, $2) ? toString(values$1[$2]) : $1));
				}
				return removeContext(getLangData(text$1));
			};
			const isRtl$1 = () => getLanguageData().bind((items) => get$a(items, "_dir")).exists((dir) => dir === "rtl");
			const hasCode = (code) => has$2(data, code);
			const I18n = {
				getData: getData$1,
				setCode,
				getCode,
				add: add$1,
				translate,
				isRtl: isRtl$1,
				hasCode
			};
			const AddOnManager = () => {
				const items = [];
				const urls = {};
				const lookup$2 = {};
				const _listeners = [];
				const runListeners = (name$1, state) => {
					each$e(filter$5(_listeners, (listener) => listener.name === name$1 && listener.state === state), (listener) => listener.resolve());
				};
				const isLoaded = (name$1) => has$2(urls, name$1);
				const isAdded = (name$1) => has$2(lookup$2, name$1);
				const get$10 = (name$1) => {
					if (lookup$2[name$1]) return lookup$2[name$1].instance;
				};
				const loadLanguagePack = (name$1, languages) => {
					const language = I18n.getCode();
					const wrappedLanguages = "," + (languages || "") + ",";
					if (!language || languages && wrappedLanguages.indexOf("," + language + ",") === -1) return;
					ScriptLoader.ScriptLoader.add(urls[name$1] + "/langs/" + language + ".js");
				};
				const requireLangPack = (name$1, languages) => {
					if (AddOnManager.languageLoad !== false) if (isLoaded(name$1)) loadLanguagePack(name$1, languages);
					else waitFor(name$1, "loaded").then(() => loadLanguagePack(name$1, languages));
				};
				const add$5 = (id, addOn) => {
					items.push(addOn);
					lookup$2[id] = { instance: addOn };
					runListeners(id, "added");
					return addOn;
				};
				const remove$10 = (name$1) => {
					delete urls[name$1];
					delete lookup$2[name$1];
				};
				const createUrl = (baseUrl, dep) => {
					if (isString(dep)) return isString(baseUrl) ? {
						prefix: "",
						resource: dep,
						suffix: ""
					} : {
						prefix: baseUrl.prefix,
						resource: dep,
						suffix: baseUrl.suffix
					};
					else return dep;
				};
				const load = (name$1, addOnUrl) => {
					if (urls[name$1]) return Promise.resolve();
					let urlString = isString(addOnUrl) ? addOnUrl : addOnUrl.prefix + addOnUrl.resource + addOnUrl.suffix;
					if (urlString.indexOf("/") !== 0 && urlString.indexOf("://") === -1) urlString = AddOnManager.baseURL + "/" + urlString;
					urls[name$1] = urlString.substring(0, urlString.lastIndexOf("/"));
					const done = () => {
						runListeners(name$1, "loaded");
						return Promise.resolve();
					};
					if (lookup$2[name$1]) return done();
					else return ScriptLoader.ScriptLoader.add(urlString).then(done);
				};
				const waitFor = (name$1, state = "added") => {
					if (state === "added" && isAdded(name$1)) return Promise.resolve();
					else if (state === "loaded" && isLoaded(name$1)) return Promise.resolve();
					else return new Promise((resolve$4) => {
						_listeners.push({
							name: name$1,
							state,
							resolve: resolve$4
						});
					});
				};
				return {
					items,
					urls,
					lookup: lookup$2,
					get: get$10,
					requireLangPack,
					add: add$5,
					remove: remove$10,
					createUrl,
					load,
					waitFor
				};
			};
			AddOnManager.languageLoad = true;
			AddOnManager.baseURL = "";
			AddOnManager.PluginManager = AddOnManager();
			AddOnManager.ThemeManager = AddOnManager();
			AddOnManager.ModelManager = AddOnManager();
			const singleton = (doRevoke) => {
				const subject = Cell(Optional.none());
				const revoke = () => subject.get().each(doRevoke);
				const clear$2 = () => {
					revoke();
					subject.set(Optional.none());
				};
				const isSet = () => subject.get().isSome();
				const get$10 = () => subject.get();
				const set$4 = (s) => {
					revoke();
					subject.set(Optional.some(s));
				};
				return {
					clear: clear$2,
					isSet,
					get: get$10,
					set: set$4
				};
			};
			const repeatable = (delay) => {
				const intervalId = Cell(Optional.none());
				const revoke = () => intervalId.get().each((id) => clearInterval(id));
				const clear$2 = () => {
					revoke();
					intervalId.set(Optional.none());
				};
				const isSet = () => intervalId.get().isSome();
				const get$10 = () => intervalId.get();
				const set$4 = (functionToRepeat) => {
					revoke();
					intervalId.set(Optional.some(setInterval(functionToRepeat, delay)));
				};
				return {
					clear: clear$2,
					isSet,
					get: get$10,
					set: set$4
				};
			};
			const value$2 = () => {
				const subject = singleton(noop);
				const on = (f) => subject.get().each(f);
				return {
					...subject,
					on
				};
			};
			const first$1 = (fn, rate) => {
				let timer = null;
				const cancel = () => {
					if (!isNull(timer)) {
						clearTimeout(timer);
						timer = null;
					}
				};
				const throttle = (...args) => {
					if (isNull(timer)) timer = setTimeout(() => {
						timer = null;
						fn.apply(null, args);
					}, rate);
				};
				return {
					cancel,
					throttle
				};
			};
			const last$1 = (fn, rate) => {
				let timer = null;
				const cancel = () => {
					if (!isNull(timer)) {
						clearTimeout(timer);
						timer = null;
					}
				};
				const throttle = (...args) => {
					cancel();
					timer = setTimeout(() => {
						timer = null;
						fn.apply(null, args);
					}, rate);
				};
				return {
					cancel,
					throttle
				};
			};
			const annotation = constant("mce-annotation");
			const dataAnnotation = constant("data-mce-annotation");
			const dataAnnotationId = constant("data-mce-annotation-uid");
			const dataAnnotationActive = constant("data-mce-annotation-active");
			const dataAnnotationClasses = constant("data-mce-annotation-classes");
			const dataAnnotationAttributes = constant("data-mce-annotation-attrs");
			const isRoot$1 = (root) => (node) => eq(node, root);
			const identify = (editor, annotationName) => {
				const rng = editor.selection.getRng();
				const start$2 = SugarElement.fromDom(rng.startContainer);
				const root = SugarElement.fromDom(editor.getBody());
				const selector = annotationName.fold(() => "." + annotation(), (an) => `[${dataAnnotation()}="${an}"]`);
				return closest$3(child$1(start$2, rng.startOffset).getOr(start$2), selector, isRoot$1(root)).bind((c) => getOpt(c, `${dataAnnotationId()}`).bind((uid$1) => getOpt(c, `${dataAnnotation()}`).map((name$1) => {
					return {
						uid: uid$1,
						name: name$1,
						elements: findMarkers(editor, uid$1)
					};
				})));
			};
			const isAnnotation = (elem) => isElement$7(elem) && has(elem, annotation());
			const isBogusElement = (elem, root) => has$1(elem, "data-mce-bogus") || ancestor$2(elem, "[data-mce-bogus=\"all\"]", isRoot$1(root));
			const findMarkers = (editor, uid$1) => {
				const body = SugarElement.fromDom(editor.getBody());
				return filter$5(descendants(body, `[${dataAnnotationId()}="${uid$1}"]`), (descendant$2) => !isBogusElement(descendant$2, body));
			};
			const findAll = (editor, name$1) => {
				const body = SugarElement.fromDom(editor.getBody());
				const markers = descendants(body, `[${dataAnnotation()}="${name$1}"]`);
				const directory = {};
				each$e(markers, (m) => {
					if (!isBogusElement(m, body)) {
						const uid$1 = get$9(m, dataAnnotationId());
						directory[uid$1] = get$a(directory, uid$1).getOr([]).concat([m]);
					}
				});
				return directory;
			};
			const setup$x = (editor, registry$1) => {
				const changeCallbacks = Cell({});
				const initData = () => ({
					listeners: [],
					previous: value$2()
				});
				const withCallbacks = (name$1, f) => {
					updateCallbacks(name$1, (data$1) => {
						f(data$1);
						return data$1;
					});
				};
				const updateCallbacks = (name$1, f) => {
					const callbackMap = changeCallbacks.get();
					callbackMap[name$1] = f(get$a(callbackMap, name$1).getOrThunk(initData));
					changeCallbacks.set(callbackMap);
				};
				const fireCallbacks = (name$1, uid$1, elements) => {
					withCallbacks(name$1, (data$1) => {
						each$e(data$1.listeners, (f) => f(true, name$1, {
							uid: uid$1,
							nodes: map$3(elements, (elem) => elem.dom)
						}));
					});
				};
				const fireNoAnnotation = (name$1) => {
					withCallbacks(name$1, (data$1) => {
						each$e(data$1.listeners, (f) => f(false, name$1));
					});
				};
				const toggleActiveAttr = (uid$1, state) => {
					each$e(findMarkers(editor, uid$1), (elem) => {
						if (state) set$3(elem, dataAnnotationActive(), "true");
						else remove$a(elem, dataAnnotationActive());
					});
				};
				const onNodeChange = last$1(() => {
					each$e(sort(registry$1.getNames()), (name$1) => {
						updateCallbacks(name$1, (data$1) => {
							const prev$1 = data$1.previous.get();
							identify(editor, Optional.some(name$1)).fold(() => {
								prev$1.each((uid$1) => {
									fireNoAnnotation(name$1);
									data$1.previous.clear();
									toggleActiveAttr(uid$1, false);
								});
							}, ({ uid: uid$1, name: name$2, elements }) => {
								if (!is$2(prev$1, uid$1)) {
									prev$1.each((uid$2) => toggleActiveAttr(uid$2, false));
									fireCallbacks(name$2, uid$1, elements);
									data$1.previous.set(uid$1);
									toggleActiveAttr(uid$1, true);
								}
							});
							return {
								previous: data$1.previous,
								listeners: data$1.listeners
							};
						});
					});
				}, 30);
				editor.on("remove", () => {
					onNodeChange.cancel();
				});
				editor.on("NodeChange", () => {
					onNodeChange.throttle();
				});
				const addListener = (name$1, f) => {
					updateCallbacks(name$1, (data$1) => ({
						previous: data$1.previous,
						listeners: data$1.listeners.concat([f])
					}));
				};
				return { addListener };
			};
			const setup$w = (editor, registry$1) => {
				const dataAnnotation$1 = dataAnnotation();
				const identifyParserNode = (node) => Optional.from(node.attr(dataAnnotation$1)).bind(registry$1.lookup);
				const removeDirectAnnotation$1 = (node) => {
					var _a, _b;
					node.attr(dataAnnotationId(), null);
					node.attr(dataAnnotation(), null);
					node.attr(dataAnnotationActive(), null);
					const customAttrNames = Optional.from(node.attr(dataAnnotationAttributes())).map((names) => names.split(",")).getOr([]);
					const customClasses = Optional.from(node.attr(dataAnnotationClasses())).map((names) => names.split(",")).getOr([]);
					each$e(customAttrNames, (name$1) => node.attr(name$1, null));
					const newClassList = difference((_b = (_a = node.attr("class")) === null || _a === void 0 ? void 0 : _a.split(" ")) !== null && _b !== void 0 ? _b : [], [annotation()].concat(customClasses));
					node.attr("class", newClassList.length > 0 ? newClassList.join(" ") : null);
					node.attr(dataAnnotationClasses(), null);
					node.attr(dataAnnotationAttributes(), null);
				};
				editor.serializer.addTempAttr(dataAnnotationActive());
				editor.serializer.addAttributeFilter(dataAnnotation$1, (nodes) => {
					for (const node of nodes) identifyParserNode(node).each((settings) => {
						if (settings.persistent === false) if (node.name === "span") node.unwrap();
						else removeDirectAnnotation$1(node);
					});
				});
			};
			const create$c = () => {
				const annotations = {};
				const register$8 = (name$1, settings) => {
					annotations[name$1] = {
						name: name$1,
						settings
					};
				};
				const lookup$2 = (name$1) => get$a(annotations, name$1).map((a) => a.settings);
				const getNames = () => keys(annotations);
				return {
					register: register$8,
					lookup: lookup$2,
					getNames
				};
			};
			let unique = 0;
			const generate$1 = (prefix) => {
				const time = (/* @__PURE__ */ new Date()).getTime();
				const random = Math.floor(Math.random() * 1e9);
				unique++;
				return prefix + "_" + random + unique + String(time);
			};
			const add = (element, classes) => {
				each$e(classes, (x) => {
					add$2(element, x);
				});
			};
			const remove$4 = (element, classes) => {
				each$e(classes, (x) => {
					remove$7(element, x);
				});
			};
			const clone$2 = (original, isDeep) => SugarElement.fromDom(original.dom.cloneNode(isDeep));
			const shallow$1 = (original) => clone$2(original, false);
			const deep$1 = (original) => clone$2(original, true);
			const shallowAs = (original, tag) => {
				const nu$4 = SugarElement.fromTag(tag);
				setAll$1(nu$4, clone$4(original));
				return nu$4;
			};
			const mutate = (original, tag) => {
				const nu$4 = shallowAs(original, tag);
				after$4(original, nu$4);
				append(nu$4, children$1(original));
				remove$5(original);
				return nu$4;
			};
			const TextWalker = (startNode, rootNode, isBoundary$1 = never) => {
				const walker = new DomTreeWalker(startNode, rootNode);
				const walk$5 = (direction) => {
					let next$1;
					do
						next$1 = walker[direction]();
					while (next$1 && !isText$a(next$1) && !isBoundary$1(next$1));
					return Optional.from(next$1).filter(isText$a);
				};
				return {
					current: () => Optional.from(walker.current()).filter(isText$a),
					next: () => walk$5("next"),
					prev: () => walk$5("prev"),
					prev2: () => walk$5("prev2")
				};
			};
			const TextSeeker = (dom$1, isBoundary$1) => {
				const isBlockBoundary = isBoundary$1 ? isBoundary$1 : (node) => dom$1.isBlock(node) || isBr$6(node) || isContentEditableFalse$b(node);
				const walk$5 = (node, offset, walker, process$2) => {
					if (isText$a(node)) {
						const newOffset = process$2(node, offset, node.data);
						if (newOffset !== -1) return Optional.some({
							container: node,
							offset: newOffset
						});
					}
					return walker().bind((next$1) => walk$5(next$1.container, next$1.offset, walker, process$2));
				};
				const backwards = (node, offset, process$2, root) => {
					const walker = TextWalker(node, root !== null && root !== void 0 ? root : dom$1.getRoot(), isBlockBoundary);
					return walk$5(node, offset, () => walker.prev().map((prev$1) => ({
						container: prev$1,
						offset: prev$1.length
					})), process$2).getOrNull();
				};
				const forwards = (node, offset, process$2, root) => {
					const walker = TextWalker(node, root !== null && root !== void 0 ? root : dom$1.getRoot(), isBlockBoundary);
					return walk$5(node, offset, () => walker.next().map((next$1) => ({
						container: next$1,
						offset: 0
					})), process$2).getOrNull();
				};
				return {
					backwards,
					forwards
				};
			};
			const round$2 = Math.round;
			const clone$1 = (rect) => {
				if (!rect) return {
					left: 0,
					top: 0,
					bottom: 0,
					right: 0,
					width: 0,
					height: 0
				};
				return {
					left: round$2(rect.left),
					top: round$2(rect.top),
					bottom: round$2(rect.bottom),
					right: round$2(rect.right),
					width: round$2(rect.width),
					height: round$2(rect.height)
				};
			};
			const collapse = (rect, toStart) => {
				rect = clone$1(rect);
				if (toStart) rect.right = rect.left;
				else {
					rect.left = rect.left + rect.width;
					rect.right = rect.left;
				}
				rect.width = 0;
				return rect;
			};
			const isEqual = (rect1, rect2) => rect1.left === rect2.left && rect1.top === rect2.top && rect1.bottom === rect2.bottom && rect1.right === rect2.right;
			const isValidOverflow = (overflowY, rect1, rect2) => overflowY >= 0 && overflowY <= Math.min(rect1.height, rect2.height) / 2;
			const isAbove$1 = (rect1, rect2) => {
				const halfHeight = Math.min(rect2.height / 2, rect1.height / 2);
				if (rect1.bottom - halfHeight < rect2.top) return true;
				if (rect1.top > rect2.bottom) return false;
				return isValidOverflow(rect2.top - rect1.bottom, rect1, rect2);
			};
			const isBelow$1 = (rect1, rect2) => {
				if (rect1.top > rect2.bottom) return true;
				if (rect1.bottom < rect2.top) return false;
				return isValidOverflow(rect2.bottom - rect1.top, rect1, rect2);
			};
			const containsXY = (rect, clientX, clientY) => clientX >= rect.left && clientX <= rect.right && clientY >= rect.top && clientY <= rect.bottom;
			const boundingClientRectFromRects = (rects) => {
				return foldl(rects, (acc, rect) => {
					return acc.fold(() => Optional.some(rect), (prevRect) => {
						const left = Math.min(rect.left, prevRect.left);
						const top = Math.min(rect.top, prevRect.top);
						const right = Math.max(rect.right, prevRect.right);
						const bottom = Math.max(rect.bottom, prevRect.bottom);
						return Optional.some({
							top,
							right,
							bottom,
							left,
							width: right - left,
							height: bottom - top
						});
					});
				}, Optional.none());
			};
			const distanceToRectEdgeFromXY = (rect, x, y) => {
				const cx = Math.max(Math.min(x, rect.left + rect.width), rect.left);
				const cy = Math.max(Math.min(y, rect.top + rect.height), rect.top);
				return Math.sqrt((x - cx) * (x - cx) + (y - cy) * (y - cy));
			};
			const overlapY = (r1, r2) => Math.max(0, Math.min(r1.bottom, r2.bottom) - Math.max(r1.top, r2.top));
			const clamp$2 = (value$3, min$1, max$1) => Math.min(Math.max(value$3, min$1), max$1);
			const getSelectedNode = (range) => {
				const startContainer = range.startContainer, startOffset = range.startOffset;
				if (startContainer === range.endContainer && startContainer.hasChildNodes() && range.endOffset === startOffset + 1) return startContainer.childNodes[startOffset];
				return null;
			};
			const getNode$1 = (container, offset) => {
				if (isElement$6(container) && container.hasChildNodes()) {
					const childNodes = container.childNodes;
					return childNodes[clamp$2(offset, 0, childNodes.length - 1)];
				} else return container;
			};
			const getNodeUnsafe = (container, offset) => {
				if (offset < 0 && isElement$6(container) && container.hasChildNodes()) return;
				else return getNode$1(container, offset);
			};
			const extendingChars = /* @__PURE__ */ new RegExp("[-----------------------------------------------------------------------------------------------------------------------------------]");
			const isExtendingChar = (ch) => isString(ch) && ch.charCodeAt(0) >= 768 && extendingChars.test(ch);
			const or = (...args) => {
				return (x) => {
					for (let i = 0; i < args.length; i++) if (args[i](x)) return true;
					return false;
				};
			};
			const and = (...args) => {
				return (x) => {
					for (let i = 0; i < args.length; i++) if (!args[i](x)) return false;
					return true;
				};
			};
			const isElement$4 = isElement$6;
			const isCaretCandidate$2 = isCaretCandidate$3;
			const isBlock$1 = matchStyleValues("display", "block table");
			const isValidElementCaretCandidate = and(isElement$4, isCaretCandidate$2, not(matchStyleValues("float", "left right")));
			const isNotPre = not(matchStyleValues("white-space", "pre pre-line pre-wrap"));
			const isText$7 = isText$a;
			const isBr$3 = isBr$6;
			const nodeIndex$1 = DOMUtils.nodeIndex;
			const resolveIndex$1 = getNodeUnsafe;
			const createRange$1 = (doc) => doc ? doc.createRange() : DOMUtils.DOM.createRng();
			const isWhiteSpace$1 = (chr) => isString(chr) && /[\r\n\t ]/.test(chr);
			const isRange = (rng) => !!rng.setStart && !!rng.setEnd;
			const isHiddenWhiteSpaceRange = (range) => {
				const container = range.startContainer;
				const offset = range.startOffset;
				if (isWhiteSpace$1(range.toString()) && isNotPre(container.parentNode) && isText$a(container)) {
					const text$1 = container.data;
					if (isWhiteSpace$1(text$1[offset - 1]) || isWhiteSpace$1(text$1[offset + 1])) return true;
				}
				return false;
			};
			const getBrClientRect = (brNode) => {
				const doc = brNode.ownerDocument;
				const rng = createRange$1(doc);
				const nbsp$1 = doc.createTextNode(nbsp);
				const parentNode = brNode.parentNode;
				parentNode.insertBefore(nbsp$1, brNode);
				rng.setStart(nbsp$1, 0);
				rng.setEnd(nbsp$1, 1);
				const clientRect = clone$1(rng.getBoundingClientRect());
				parentNode.removeChild(nbsp$1);
				return clientRect;
			};
			const getBoundingClientRectWebKitText = (rng) => {
				const sc = rng.startContainer;
				const ec = rng.endContainer;
				const so = rng.startOffset;
				const eo = rng.endOffset;
				if (sc === ec && isText$a(ec) && so === 0 && eo === 1) {
					const newRng = rng.cloneRange();
					newRng.setEndAfter(ec);
					return getBoundingClientRect$1(newRng);
				} else return null;
			};
			const isZeroRect = (r$1) => r$1.left === 0 && r$1.right === 0 && r$1.top === 0 && r$1.bottom === 0;
			const getBoundingClientRect$1 = (item) => {
				var _a;
				let clientRect;
				const clientRects = item.getClientRects();
				if (clientRects.length > 0) clientRect = clone$1(clientRects[0]);
				else clientRect = clone$1(item.getBoundingClientRect());
				if (!isRange(item) && isBr$3(item) && isZeroRect(clientRect)) return getBrClientRect(item);
				if (isZeroRect(clientRect) && isRange(item)) return (_a = getBoundingClientRectWebKitText(item)) !== null && _a !== void 0 ? _a : clientRect;
				return clientRect;
			};
			const collapseAndInflateWidth = (clientRect, toStart) => {
				const newClientRect = collapse(clientRect, toStart);
				newClientRect.width = 1;
				newClientRect.right = newClientRect.left + 1;
				return newClientRect;
			};
			const getCaretPositionClientRects = (caretPosition) => {
				const clientRects = [];
				const addUniqueAndValidRect = (clientRect) => {
					if (clientRect.height === 0) return;
					if (clientRects.length > 0) {
						if (isEqual(clientRect, clientRects[clientRects.length - 1])) return;
					}
					clientRects.push(clientRect);
				};
				const addCharacterOffset = (container$1, offset$1) => {
					const range = createRange$1(container$1.ownerDocument);
					if (offset$1 < container$1.data.length) {
						if (isExtendingChar(container$1.data[offset$1])) return;
						if (isExtendingChar(container$1.data[offset$1 - 1])) {
							range.setStart(container$1, offset$1);
							range.setEnd(container$1, offset$1 + 1);
							if (!isHiddenWhiteSpaceRange(range)) {
								addUniqueAndValidRect(collapseAndInflateWidth(getBoundingClientRect$1(range), false));
								return;
							}
						}
					}
					if (offset$1 > 0) {
						range.setStart(container$1, offset$1 - 1);
						range.setEnd(container$1, offset$1);
						if (!isHiddenWhiteSpaceRange(range)) addUniqueAndValidRect(collapseAndInflateWidth(getBoundingClientRect$1(range), false));
					}
					if (offset$1 < container$1.data.length) {
						range.setStart(container$1, offset$1);
						range.setEnd(container$1, offset$1 + 1);
						if (!isHiddenWhiteSpaceRange(range)) addUniqueAndValidRect(collapseAndInflateWidth(getBoundingClientRect$1(range), true));
					}
				};
				const container = caretPosition.container();
				const offset = caretPosition.offset();
				if (isText$7(container)) {
					addCharacterOffset(container, offset);
					return clientRects;
				}
				if (isElement$4(container)) if (caretPosition.isAtEnd()) {
					const node = resolveIndex$1(container, offset);
					if (isText$7(node)) addCharacterOffset(node, node.data.length);
					if (isValidElementCaretCandidate(node) && !isBr$3(node)) addUniqueAndValidRect(collapseAndInflateWidth(getBoundingClientRect$1(node), false));
				} else {
					const node = resolveIndex$1(container, offset);
					if (isText$7(node)) addCharacterOffset(node, 0);
					if (isValidElementCaretCandidate(node) && caretPosition.isAtEnd()) {
						addUniqueAndValidRect(collapseAndInflateWidth(getBoundingClientRect$1(node), false));
						return clientRects;
					}
					const beforeNode = resolveIndex$1(caretPosition.container(), caretPosition.offset() - 1);
					if (isValidElementCaretCandidate(beforeNode) && !isBr$3(beforeNode)) {
						if (isBlock$1(beforeNode) || isBlock$1(node) || !isValidElementCaretCandidate(node)) addUniqueAndValidRect(collapseAndInflateWidth(getBoundingClientRect$1(beforeNode), false));
					}
					if (isValidElementCaretCandidate(node)) addUniqueAndValidRect(collapseAndInflateWidth(getBoundingClientRect$1(node), true));
				}
				return clientRects;
			};
			const CaretPosition = (container, offset, clientRects) => {
				const isAtStart = () => {
					if (isText$7(container)) return offset === 0;
					return offset === 0;
				};
				const isAtEnd = () => {
					if (isText$7(container)) return offset >= container.data.length;
					return offset >= container.childNodes.length;
				};
				const toRange = () => {
					const range = createRange$1(container.ownerDocument);
					range.setStart(container, offset);
					range.setEnd(container, offset);
					return range;
				};
				const getClientRects$1 = () => {
					if (!clientRects) clientRects = getCaretPositionClientRects(CaretPosition(container, offset));
					return clientRects;
				};
				const isVisible = () => getClientRects$1().length > 0;
				const isEqual$1 = (caretPosition) => caretPosition && container === caretPosition.container() && offset === caretPosition.offset();
				const getNode$2 = (before$1) => resolveIndex$1(container, before$1 ? offset - 1 : offset);
				return {
					container: constant(container),
					offset: constant(offset),
					toRange,
					getClientRects: getClientRects$1,
					isVisible,
					isAtStart,
					isAtEnd,
					isEqual: isEqual$1,
					getNode: getNode$2
				};
			};
			CaretPosition.fromRangeStart = (range) => CaretPosition(range.startContainer, range.startOffset);
			CaretPosition.fromRangeEnd = (range) => CaretPosition(range.endContainer, range.endOffset);
			CaretPosition.after = (node) => CaretPosition(node.parentNode, nodeIndex$1(node) + 1);
			CaretPosition.before = (node) => CaretPosition(node.parentNode, nodeIndex$1(node));
			CaretPosition.isAbove = (pos1, pos2) => lift2(head(pos2.getClientRects()), last$3(pos1.getClientRects()), isAbove$1).getOr(false);
			CaretPosition.isBelow = (pos1, pos2) => lift2(last$3(pos2.getClientRects()), head(pos1.getClientRects()), isBelow$1).getOr(false);
			CaretPosition.isAtStart = (pos) => pos ? pos.isAtStart() : false;
			CaretPosition.isAtEnd = (pos) => pos ? pos.isAtEnd() : false;
			CaretPosition.isTextPosition = (pos) => pos ? isText$a(pos.container()) : false;
			CaretPosition.isElementPosition = (pos) => !CaretPosition.isTextPosition(pos);
			const trimEmptyTextNode$1 = (dom$1, node) => {
				if (isText$a(node) && node.data.length === 0) dom$1.remove(node);
			};
			const insertNode = (dom$1, rng, node) => {
				rng.insertNode(node);
				trimEmptyTextNode$1(dom$1, node.previousSibling);
				trimEmptyTextNode$1(dom$1, node.nextSibling);
			};
			const insertFragment = (dom$1, rng, frag) => {
				const firstChild$1 = Optional.from(frag.firstChild);
				const lastChild$1 = Optional.from(frag.lastChild);
				rng.insertNode(frag);
				firstChild$1.each((child$2) => trimEmptyTextNode$1(dom$1, child$2.previousSibling));
				lastChild$1.each((child$2) => trimEmptyTextNode$1(dom$1, child$2.nextSibling));
			};
			const rangeInsertNode = (dom$1, rng, node) => {
				if (isDocumentFragment(node)) insertFragment(dom$1, rng, node);
				else insertNode(dom$1, rng, node);
			};
			const isText$6 = isText$a;
			const isBogus = isBogus$2;
			const nodeIndex = DOMUtils.nodeIndex;
			const normalizedParent = (node) => {
				const parentNode = node.parentNode;
				if (isBogus(parentNode)) return normalizedParent(parentNode);
				return parentNode;
			};
			const getChildNodes = (node) => {
				if (!node) return [];
				return reduce(node.childNodes, (result, node$1) => {
					if (isBogus(node$1) && node$1.nodeName !== "BR") result = result.concat(getChildNodes(node$1));
					else result.push(node$1);
					return result;
				}, []);
			};
			const normalizedTextOffset = (node, offset) => {
				let tempNode = node;
				while (tempNode = tempNode.previousSibling) {
					if (!isText$6(tempNode)) break;
					offset += tempNode.data.length;
				}
				return offset;
			};
			const equal = (a) => (b) => a === b;
			const normalizedNodeIndex = (node) => {
				let nodes, index;
				nodes = getChildNodes(normalizedParent(node));
				index = findIndex$1(nodes, equal(node), node);
				nodes = nodes.slice(0, index + 1);
				const numTextFragments = reduce(nodes, (result, node$1, i) => {
					if (isText$6(node$1) && isText$6(nodes[i - 1])) result++;
					return result;
				}, 0);
				nodes = filter$3(nodes, matchNodeNames([node.nodeName]));
				index = findIndex$1(nodes, equal(node), node);
				return index - numTextFragments;
			};
			const createPathItem = (node) => {
				return (isText$6(node) ? "text()" : node.nodeName.toLowerCase()) + "[" + normalizedNodeIndex(node) + "]";
			};
			const parentsUntil$1 = (root, node, predicate) => {
				const parents$2 = [];
				for (let tempNode = node.parentNode; tempNode && tempNode !== root; tempNode = tempNode.parentNode) {
					if (predicate && predicate(tempNode)) break;
					parents$2.push(tempNode);
				}
				return parents$2;
			};
			const create$b = (root, caretPosition) => {
				let path$1 = [];
				let container = caretPosition.container();
				let offset = caretPosition.offset();
				let outputOffset;
				if (isText$6(container)) outputOffset = normalizedTextOffset(container, offset);
				else {
					const childNodes = container.childNodes;
					if (offset >= childNodes.length) {
						outputOffset = "after";
						offset = childNodes.length - 1;
					} else outputOffset = "before";
					container = childNodes[offset];
				}
				path$1.push(createPathItem(container));
				let parents$2 = parentsUntil$1(root, container);
				parents$2 = filter$3(parents$2, not(isBogus$2));
				path$1 = path$1.concat(map$1(parents$2, (node) => {
					return createPathItem(node);
				}));
				return path$1.reverse().join("/") + "," + outputOffset;
			};
			const resolvePathItem = (node, name$1, index) => {
				let nodes = getChildNodes(node);
				nodes = filter$3(nodes, (node$1, index$1) => {
					return !isText$6(node$1) || !isText$6(nodes[index$1 - 1]);
				});
				nodes = filter$3(nodes, matchNodeNames([name$1]));
				return nodes[index];
			};
			const findTextPosition = (container, offset) => {
				let node = container;
				let targetOffset = 0;
				while (isText$6(node)) {
					const dataLen = node.data.length;
					if (offset >= targetOffset && offset <= targetOffset + dataLen) {
						container = node;
						offset = offset - targetOffset;
						break;
					}
					if (!isText$6(node.nextSibling)) {
						container = node;
						offset = dataLen;
						break;
					}
					targetOffset += dataLen;
					node = node.nextSibling;
				}
				if (isText$6(container) && offset > container.data.length) offset = container.data.length;
				return CaretPosition(container, offset);
			};
			const resolve$1 = (root, path$1) => {
				if (!path$1) return null;
				const parts = path$1.split(",");
				const paths = parts[0].split("/");
				const offset = parts.length > 1 ? parts[1] : "before";
				const container = reduce(paths, (result, value$3) => {
					const match$3 = /([\w\-\(\)]+)\[([0-9]+)\]/.exec(value$3);
					if (!match$3) return null;
					if (match$3[1] === "text()") match$3[1] = "#text";
					return resolvePathItem(result, match$3[1], parseInt(match$3[2], 10));
				}, root);
				if (!container) return null;
				if (!isText$6(container) && container.parentNode) {
					let nodeOffset;
					if (offset === "after") nodeOffset = nodeIndex(container) + 1;
					else nodeOffset = nodeIndex(container);
					return CaretPosition(container.parentNode, nodeOffset);
				}
				return findTextPosition(container, parseInt(offset, 10));
			};
			const isContentEditableFalse$9 = isContentEditableFalse$b;
			const getNormalizedTextOffset$1 = (trim$4, container, offset) => {
				let trimmedOffset = trim$4(container.data.slice(0, offset)).length;
				for (let node = container.previousSibling; node && isText$a(node); node = node.previousSibling) trimmedOffset += trim$4(node.data).length;
				return trimmedOffset;
			};
			const getPoint = (dom$1, trim$4, normalized, rng, start$2) => {
				const container = start$2 ? rng.startContainer : rng.endContainer;
				let offset = start$2 ? rng.startOffset : rng.endOffset;
				const point$1 = [];
				const root = dom$1.getRoot();
				if (isText$a(container)) point$1.push(normalized ? getNormalizedTextOffset$1(trim$4, container, offset) : offset);
				else {
					let after$1 = 0;
					const childNodes = container.childNodes;
					if (offset >= childNodes.length && childNodes.length) {
						after$1 = 1;
						offset = Math.max(0, childNodes.length - 1);
					}
					point$1.push(dom$1.nodeIndex(childNodes[offset], normalized) + after$1);
				}
				for (let node = container; node && node !== root; node = node.parentNode) point$1.push(dom$1.nodeIndex(node, normalized));
				return point$1;
			};
			const getLocation = (trim$4, selection, normalized, rng) => {
				const dom$1 = selection.dom;
				const start$2 = getPoint(dom$1, trim$4, normalized, rng, true);
				const forward = selection.isForward();
				const fakeCaret = isRangeInCaretContainerBlock(rng) ? { isFakeCaret: true } : {};
				if (!selection.isCollapsed()) return {
					start: start$2,
					end: getPoint(dom$1, trim$4, normalized, rng, false),
					forward,
					...fakeCaret
				};
				else return {
					start: start$2,
					forward,
					...fakeCaret
				};
			};
			const findIndex = (dom$1, name$1, element) => {
				let count$2 = 0;
				Tools.each(dom$1.select(name$1), (node) => {
					if (node.getAttribute("data-mce-bogus") === "all") return;
					else if (node === element) return false;
					else {
						count$2++;
						return;
					}
				});
				return count$2;
			};
			const moveEndPoint$1 = (rng, start$2) => {
				let container = start$2 ? rng.startContainer : rng.endContainer;
				let offset = start$2 ? rng.startOffset : rng.endOffset;
				if (isElement$6(container) && container.nodeName === "TR") {
					const childNodes = container.childNodes;
					container = childNodes[Math.min(start$2 ? offset : offset - 1, childNodes.length - 1)];
					if (container) {
						offset = start$2 ? 0 : container.childNodes.length;
						if (start$2) rng.setStart(container, offset);
						else rng.setEnd(container, offset);
					}
				}
			};
			const normalizeTableCellSelection = (rng) => {
				moveEndPoint$1(rng, true);
				moveEndPoint$1(rng, false);
				return rng;
			};
			const findSibling = (node, offset) => {
				if (isElement$6(node)) {
					node = getNode$1(node, offset);
					if (isContentEditableFalse$9(node)) return node;
				}
				if (isCaretContainer$2(node)) {
					if (isText$a(node) && isCaretContainerBlock$1(node)) node = node.parentNode;
					let sibling$2 = node.previousSibling;
					if (isContentEditableFalse$9(sibling$2)) return sibling$2;
					sibling$2 = node.nextSibling;
					if (isContentEditableFalse$9(sibling$2)) return sibling$2;
				}
			};
			const findAdjacentContentEditableFalseElm = (rng) => {
				return findSibling(rng.startContainer, rng.startOffset) || findSibling(rng.endContainer, rng.endOffset);
			};
			const getOffsetBookmark = (trim$4, normalized, selection) => {
				const element = selection.getNode();
				const rng = selection.getRng();
				if (element.nodeName === "IMG" || isContentEditableFalse$9(element)) {
					const name$1 = element.nodeName;
					return {
						name: name$1,
						index: findIndex(selection.dom, name$1, element)
					};
				}
				const sibling$2 = findAdjacentContentEditableFalseElm(rng);
				if (sibling$2) {
					const name$1 = sibling$2.tagName;
					return {
						name: name$1,
						index: findIndex(selection.dom, name$1, sibling$2)
					};
				}
				return getLocation(trim$4, selection, normalized, rng);
			};
			const getCaretBookmark = (selection) => {
				const rng = selection.getRng();
				return {
					start: create$b(selection.dom.getRoot(), CaretPosition.fromRangeStart(rng)),
					end: create$b(selection.dom.getRoot(), CaretPosition.fromRangeEnd(rng)),
					forward: selection.isForward()
				};
			};
			const getRangeBookmark = (selection) => {
				return {
					rng: selection.getRng(),
					forward: selection.isForward()
				};
			};
			const createBookmarkSpan = (dom$1, id, filled) => {
				const args = {
					"data-mce-type": "bookmark",
					id,
					"style": "overflow:hidden;line-height:0px"
				};
				return filled ? dom$1.create("span", args, "&#xFEFF;") : dom$1.create("span", args);
			};
			const getPersistentBookmark = (selection, filled) => {
				const dom$1 = selection.dom;
				let rng = selection.getRng();
				const id = dom$1.uniqueId();
				const collapsed = selection.isCollapsed();
				const element = selection.getNode();
				const name$1 = element.nodeName;
				const forward = selection.isForward();
				if (name$1 === "IMG") return {
					name: name$1,
					index: findIndex(dom$1, name$1, element)
				};
				const rng2 = normalizeTableCellSelection(rng.cloneRange());
				if (!collapsed) {
					rng2.collapse(false);
					rangeInsertNode(dom$1, rng2, createBookmarkSpan(dom$1, id + "_end", filled));
				}
				rng = normalizeTableCellSelection(rng);
				rng.collapse(true);
				const startBookmarkNode = createBookmarkSpan(dom$1, id + "_start", filled);
				rangeInsertNode(dom$1, rng, startBookmarkNode);
				selection.moveToBookmark({
					id,
					keep: true,
					forward
				});
				return {
					id,
					forward
				};
			};
			const getBookmark$2 = (selection, type$2, normalized = false) => {
				if (type$2 === 2) return getOffsetBookmark(trim$1, normalized, selection);
				else if (type$2 === 3) return getCaretBookmark(selection);
				else if (type$2) return getRangeBookmark(selection);
				else return getPersistentBookmark(selection, false);
			};
			const getUndoBookmark = curry(getOffsetBookmark, identity, true);
			const value$1 = (value$3) => {
				const applyHelper = (fn) => fn(value$3);
				const constHelper = constant(value$3);
				const outputHelper = () => output;
				const output = {
					tag: true,
					inner: value$3,
					fold: (_onError, onValue) => onValue(value$3),
					isValue: always,
					isError: never,
					map: (mapper) => Result.value(mapper(value$3)),
					mapError: outputHelper,
					bind: applyHelper,
					exists: applyHelper,
					forall: applyHelper,
					getOr: constHelper,
					or: outputHelper,
					getOrThunk: constHelper,
					orThunk: outputHelper,
					getOrDie: constHelper,
					each: (fn) => {
						fn(value$3);
					},
					toOptional: () => Optional.some(value$3)
				};
				return output;
			};
			const error = (error$1) => {
				const outputHelper = () => output;
				const output = {
					tag: false,
					inner: error$1,
					fold: (onError, _onValue) => onError(error$1),
					isValue: never,
					isError: always,
					map: outputHelper,
					mapError: (mapper) => Result.error(mapper(error$1)),
					bind: outputHelper,
					exists: never,
					forall: always,
					getOr: identity,
					or: identity,
					getOrThunk: apply$1,
					orThunk: apply$1,
					getOrDie: die(String(error$1)),
					each: noop,
					toOptional: Optional.none
				};
				return output;
			};
			const fromOption = (optional, err) => optional.fold(() => error(err), value$1);
			const Result = {
				value: value$1,
				error,
				fromOption
			};
			const generate = (cases) => {
				if (!isArray$1(cases)) throw new Error("cases must be an array");
				if (cases.length === 0) throw new Error("there must be at least one case");
				const constructors = [];
				const adt$4 = {};
				each$e(cases, (acase, count$2) => {
					const keys$1 = keys(acase);
					if (keys$1.length !== 1) throw new Error("one and only one name per case");
					const key = keys$1[0];
					const value$3 = acase[key];
					if (adt$4[key] !== void 0) throw new Error("duplicate key detected:" + key);
					else if (key === "cata") throw new Error("cannot have a case named cata (sorry)");
					else if (!isArray$1(value$3)) throw new Error("case arguments must be an array");
					constructors.push(key);
					adt$4[key] = (...args) => {
						const argLength = args.length;
						if (argLength !== value$3.length) throw new Error("Wrong number of arguments to case " + key + ". Expected " + value$3.length + " (" + value$3 + "), got " + argLength);
						const match$3 = (branches) => {
							const branchKeys = keys(branches);
							if (constructors.length !== branchKeys.length) throw new Error("Wrong number of arguments to match. Expected: " + constructors.join(",") + "\nActual: " + branchKeys.join(","));
							if (!forall(constructors, (reqKey) => {
								return contains$2(branchKeys, reqKey);
							})) throw new Error("Not all branches were specified when using match. Specified: " + branchKeys.join(", ") + "\nRequired: " + constructors.join(", "));
							return branches[key].apply(null, args);
						};
						return {
							fold: (...foldArgs) => {
								if (foldArgs.length !== cases.length) throw new Error("Wrong number of arguments to fold. Expected " + cases.length + ", got " + foldArgs.length);
								return foldArgs[count$2].apply(null, args);
							},
							match: match$3,
							log: (label) => {
								console.log(label, {
									constructors,
									constructor: key,
									params: args
								});
							}
						};
					};
				});
				return adt$4;
			};
			const Adt = { generate };
			Adt.generate([
				{ bothErrors: ["error1", "error2"] },
				{ firstError: ["error1", "value2"] },
				{ secondError: ["value1", "error2"] },
				{ bothValues: ["value1", "value2"] }
			]);
			const partition$1 = (results) => {
				const errors = [];
				const values$1 = [];
				each$e(results, (result) => {
					result.fold((err) => {
						errors.push(err);
					}, (value$3) => {
						values$1.push(value$3);
					});
				});
				return {
					errors,
					values: values$1
				};
			};
			const isInlinePattern = (pattern) => pattern.type === "inline-command" || pattern.type === "inline-format";
			const isBlockPattern = (pattern) => pattern.type === "block-command" || pattern.type === "block-format";
			const normalizePattern = (pattern) => {
				const err = (message) => Result.error({
					message,
					pattern
				});
				const formatOrCmd = (name$1, onFormat, onCommand) => {
					if (pattern.format !== void 0) {
						let formats;
						if (isArray$1(pattern.format)) {
							if (!forall(pattern.format, isString)) return err(name$1 + " pattern has non-string items in the `format` array");
							formats = pattern.format;
						} else if (isString(pattern.format)) formats = [pattern.format];
						else return err(name$1 + " pattern has non-string `format` parameter");
						return Result.value(onFormat(formats));
					} else if (pattern.cmd !== void 0) {
						if (!isString(pattern.cmd)) return err(name$1 + " pattern has non-string `cmd` parameter");
						return Result.value(onCommand(pattern.cmd, pattern.value));
					} else return err(name$1 + " pattern is missing both `format` and `cmd` parameters");
				};
				if (!isObject(pattern)) return err("Raw pattern is not an object");
				if (!isString(pattern.start)) return err("Raw pattern is missing `start` parameter");
				if (pattern.end !== void 0) {
					if (!isString(pattern.end)) return err("Inline pattern has non-string `end` parameter");
					if (pattern.start.length === 0 && pattern.end.length === 0) return err("Inline pattern has empty `start` and `end` parameters");
					let start$2 = pattern.start;
					let end$1 = pattern.end;
					if (end$1.length === 0) {
						end$1 = start$2;
						start$2 = "";
					}
					return formatOrCmd("Inline", (format) => ({
						type: "inline-format",
						start: start$2,
						end: end$1,
						format
					}), (cmd, value$3) => ({
						type: "inline-command",
						start: start$2,
						end: end$1,
						cmd,
						value: value$3
					}));
				} else if (pattern.replacement !== void 0) {
					if (!isString(pattern.replacement)) return err("Replacement pattern has non-string `replacement` parameter");
					if (pattern.start.length === 0) return err("Replacement pattern has empty `start` parameter");
					return Result.value({
						type: "inline-command",
						start: "",
						end: pattern.start,
						cmd: "mceInsertContent",
						value: pattern.replacement
					});
				} else {
					if (pattern.start.length === 0) return err("Block pattern has empty `start` parameter");
					return formatOrCmd("Block", (formats) => ({
						type: "block-format",
						start: pattern.start,
						format: formats[0]
					}), (command, commandValue) => ({
						type: "block-command",
						start: pattern.start,
						cmd: command,
						value: commandValue
					}));
				}
			};
			const getBlockPatterns = (patterns) => filter$5(patterns, isBlockPattern);
			const getInlinePatterns = (patterns) => filter$5(patterns, isInlinePattern);
			const createPatternSet = (patterns, dynamicPatternsLookup) => ({
				inlinePatterns: getInlinePatterns(patterns),
				blockPatterns: getBlockPatterns(patterns),
				dynamicPatternsLookup
			});
			const fromRawPatterns = (patterns) => {
				const normalized = partition$1(map$3(patterns, normalizePattern));
				each$e(normalized.errors, (err) => console.error(err.message, err.pattern));
				return normalized.values;
			};
			const fromRawPatternsLookup = (lookupFn) => {
				return (ctx) => {
					return fromRawPatterns(lookupFn(ctx));
				};
			};
			const deviceDetection$1 = detect$2().deviceType;
			const isTouch = deviceDetection$1.isTouch();
			const DOM$a = DOMUtils.DOM;
			const getHash = (value$3) => {
				return foldl(value$3.indexOf("=") > 0 ? value$3.split(/[;,](?![^=;,]*(?:[;,]|$))/) : value$3.split(","), (output, item) => {
					const arr = item.split("=");
					const key = arr[0];
					const val = arr.length > 1 ? arr[1] : key;
					output[trim$3(key)] = trim$3(val);
					return output;
				}, {});
			};
			const isRegExp = (x) => is$4(x, RegExp);
			const option = (name$1) => (editor) => editor.options.get(name$1);
			const stringOrObjectProcessor = (value$3) => isString(value$3) || isObject(value$3);
			const bodyOptionProcessor = (editor, defaultValue = "") => (value$3) => {
				const valid = isString(value$3);
				if (valid) if (value$3.indexOf("=") !== -1) return {
					value: get$a(getHash(value$3), editor.id).getOr(defaultValue),
					valid
				};
				else return {
					value: value$3,
					valid
				};
				else return {
					valid: false,
					message: "Must be a string."
				};
			};
			const register$7 = (editor) => {
				const registerOption = editor.options.register;
				registerOption("id", {
					processor: "string",
					default: editor.id
				});
				registerOption("selector", { processor: "string" });
				registerOption("target", { processor: "object" });
				registerOption("suffix", { processor: "string" });
				registerOption("cache_suffix", { processor: "string" });
				registerOption("base_url", { processor: "string" });
				registerOption("referrer_policy", {
					processor: "string",
					default: ""
				});
				registerOption("language_load", {
					processor: "boolean",
					default: true
				});
				registerOption("inline", {
					processor: "boolean",
					default: false
				});
				registerOption("iframe_attrs", {
					processor: "object",
					default: {}
				});
				registerOption("doctype", {
					processor: "string",
					default: "<!DOCTYPE html>"
				});
				registerOption("document_base_url", {
					processor: "string",
					default: editor.documentBaseUrl
				});
				registerOption("body_id", {
					processor: bodyOptionProcessor(editor, "tinymce"),
					default: "tinymce"
				});
				registerOption("body_class", {
					processor: bodyOptionProcessor(editor),
					default: ""
				});
				registerOption("content_security_policy", {
					processor: "string",
					default: ""
				});
				registerOption("br_in_pre", {
					processor: "boolean",
					default: true
				});
				registerOption("forced_root_block", {
					processor: (value$3) => {
						const valid = isString(value$3) && isNotEmpty(value$3);
						if (valid) return {
							value: value$3,
							valid
						};
						else return {
							valid: false,
							message: "Must be a non-empty string."
						};
					},
					default: "p"
				});
				registerOption("forced_root_block_attrs", {
					processor: "object",
					default: {}
				});
				registerOption("newline_behavior", {
					processor: (value$3) => {
						const valid = contains$2([
							"block",
							"linebreak",
							"invert",
							"default"
						], value$3);
						return valid ? {
							value: value$3,
							valid
						} : {
							valid: false,
							message: "Must be one of: block, linebreak, invert or default."
						};
					},
					default: "default"
				});
				registerOption("br_newline_selector", {
					processor: "string",
					default: ".mce-toc h2,figcaption,caption"
				});
				registerOption("no_newline_selector", {
					processor: "string",
					default: ""
				});
				registerOption("keep_styles", {
					processor: "boolean",
					default: true
				});
				registerOption("end_container_on_empty_block", {
					processor: (value$3) => {
						if (isBoolean(value$3)) return {
							valid: true,
							value: value$3
						};
						else if (isString(value$3)) return {
							valid: true,
							value: value$3
						};
						else return {
							valid: false,
							message: "Must be boolean or a string"
						};
					},
					default: "blockquote"
				});
				registerOption("font_size_style_values", {
					processor: "string",
					default: "xx-small,x-small,small,medium,large,x-large,xx-large"
				});
				registerOption("font_size_legacy_values", {
					processor: "string",
					default: "xx-small,small,medium,large,x-large,xx-large,300%"
				});
				registerOption("font_size_classes", {
					processor: "string",
					default: ""
				});
				registerOption("automatic_uploads", {
					processor: "boolean",
					default: true
				});
				registerOption("images_reuse_filename", {
					processor: "boolean",
					default: false
				});
				registerOption("images_replace_blob_uris", {
					processor: "boolean",
					default: true
				});
				registerOption("icons", {
					processor: "string",
					default: ""
				});
				registerOption("icons_url", {
					processor: "string",
					default: ""
				});
				registerOption("images_upload_url", {
					processor: "string",
					default: ""
				});
				registerOption("images_upload_base_path", {
					processor: "string",
					default: ""
				});
				registerOption("images_upload_credentials", {
					processor: "boolean",
					default: false
				});
				registerOption("images_upload_handler", { processor: "function" });
				registerOption("language", {
					processor: "string",
					default: "en"
				});
				registerOption("language_url", {
					processor: "string",
					default: ""
				});
				registerOption("entity_encoding", {
					processor: "string",
					default: "named"
				});
				registerOption("indent", {
					processor: "boolean",
					default: true
				});
				registerOption("indent_before", {
					processor: "string",
					default: "p,h1,h2,h3,h4,h5,h6,blockquote,div,title,style,pre,script,td,th,ul,ol,li,dl,dt,dd,area,table,thead,tfoot,tbody,tr,section,details,summary,article,hgroup,aside,figure,figcaption,option,optgroup,datalist"
				});
				registerOption("indent_after", {
					processor: "string",
					default: "p,h1,h2,h3,h4,h5,h6,blockquote,div,title,style,pre,script,td,th,ul,ol,li,dl,dt,dd,area,table,thead,tfoot,tbody,tr,section,details,summary,article,hgroup,aside,figure,figcaption,option,optgroup,datalist"
				});
				registerOption("indent_use_margin", {
					processor: "boolean",
					default: false
				});
				registerOption("indentation", {
					processor: "string",
					default: "40px"
				});
				registerOption("content_css", {
					processor: (value$3) => {
						const valid = value$3 === false || isString(value$3) || isArrayOf(value$3, isString);
						if (valid) if (isString(value$3)) return {
							value: map$3(value$3.split(","), trim$3),
							valid
						};
						else if (isArray$1(value$3)) return {
							value: value$3,
							valid
						};
						else if (value$3 === false) return {
							value: [],
							valid
						};
						else return {
							value: value$3,
							valid
						};
						else return {
							valid: false,
							message: "Must be false, a string or an array of strings."
						};
					},
					default: isInline(editor) ? [] : ["default"]
				});
				registerOption("content_style", { processor: "string" });
				registerOption("content_css_cors", {
					processor: "boolean",
					default: false
				});
				registerOption("font_css", {
					processor: (value$3) => {
						const valid = isString(value$3) || isArrayOf(value$3, isString);
						if (valid) return {
							value: isArray$1(value$3) ? value$3 : map$3(value$3.split(","), trim$3),
							valid
						};
						else return {
							valid: false,
							message: "Must be a string or an array of strings."
						};
					},
					default: []
				});
				registerOption("inline_boundaries", {
					processor: "boolean",
					default: true
				});
				registerOption("inline_boundaries_selector", {
					processor: "string",
					default: "a[href],code,span.mce-annotation"
				});
				registerOption("object_resizing", {
					processor: (value$3) => {
						const valid = isBoolean(value$3) || isString(value$3);
						if (valid) if (value$3 === false || deviceDetection$1.isiPhone() || deviceDetection$1.isiPad()) return {
							value: "",
							valid
						};
						else return {
							value: value$3 === true ? "table,img,figure.image,div,video,iframe" : value$3,
							valid
						};
						else return {
							valid: false,
							message: "Must be boolean or a string"
						};
					},
					default: !isTouch
				});
				registerOption("resize_img_proportional", {
					processor: "boolean",
					default: true
				});
				registerOption("event_root", { processor: "object" });
				registerOption("service_message", { processor: "string" });
				registerOption("theme", {
					processor: (value$3) => value$3 === false || isString(value$3) || isFunction(value$3),
					default: "silver"
				});
				registerOption("theme_url", { processor: "string" });
				registerOption("formats", { processor: "object" });
				registerOption("format_empty_lines", {
					processor: "boolean",
					default: false
				});
				registerOption("format_noneditable_selector", {
					processor: "string",
					default: ""
				});
				registerOption("preview_styles", {
					processor: (value$3) => {
						const valid = value$3 === false || isString(value$3);
						if (valid) return {
							value: value$3 === false ? "" : value$3,
							valid
						};
						else return {
							valid: false,
							message: "Must be false or a string"
						};
					},
					default: "font-family font-size font-weight font-style text-decoration text-transform color background-color border border-radius outline text-shadow"
				});
				registerOption("custom_ui_selector", {
					processor: "string",
					default: ""
				});
				registerOption("hidden_input", {
					processor: "boolean",
					default: true
				});
				registerOption("submit_patch", {
					processor: "boolean",
					default: true
				});
				registerOption("encoding", { processor: "string" });
				registerOption("add_form_submit_trigger", {
					processor: "boolean",
					default: true
				});
				registerOption("add_unload_trigger", {
					processor: "boolean",
					default: true
				});
				registerOption("custom_undo_redo_levels", {
					processor: "number",
					default: 0
				});
				registerOption("disable_nodechange", {
					processor: "boolean",
					default: false
				});
				registerOption("readonly", {
					processor: "boolean",
					default: false
				});
				registerOption("editable_root", {
					processor: "boolean",
					default: true
				});
				registerOption("plugins", {
					processor: "string[]",
					default: []
				});
				registerOption("external_plugins", { processor: "object" });
				registerOption("forced_plugins", { processor: "string[]" });
				registerOption("model", {
					processor: "string",
					default: editor.hasPlugin("rtc") ? "plugin" : "dom"
				});
				registerOption("model_url", { processor: "string" });
				registerOption("block_unsupported_drop", {
					processor: "boolean",
					default: true
				});
				registerOption("visual", {
					processor: "boolean",
					default: true
				});
				registerOption("visual_table_class", {
					processor: "string",
					default: "mce-item-table"
				});
				registerOption("visual_anchor_class", {
					processor: "string",
					default: "mce-item-anchor"
				});
				registerOption("iframe_aria_text", {
					processor: "string",
					default: "Rich Text Area. Press ALT-0 for help."
				});
				registerOption("setup", { processor: "function" });
				registerOption("init_instance_callback", { processor: "function" });
				registerOption("url_converter", {
					processor: "function",
					default: editor.convertURL
				});
				registerOption("url_converter_scope", {
					processor: "object",
					default: editor
				});
				registerOption("urlconverter_callback", { processor: "function" });
				registerOption("allow_conditional_comments", {
					processor: "boolean",
					default: false
				});
				registerOption("allow_html_data_urls", {
					processor: "boolean",
					default: false
				});
				registerOption("allow_svg_data_urls", { processor: "boolean" });
				registerOption("allow_html_in_named_anchor", {
					processor: "boolean",
					default: false
				});
				registerOption("allow_script_urls", {
					processor: "boolean",
					default: false
				});
				registerOption("allow_unsafe_link_target", {
					processor: "boolean",
					default: false
				});
				registerOption("convert_fonts_to_spans", {
					processor: "boolean",
					default: true,
					deprecated: true
				});
				registerOption("fix_list_elements", {
					processor: "boolean",
					default: false
				});
				registerOption("preserve_cdata", {
					processor: "boolean",
					default: false
				});
				registerOption("remove_trailing_brs", {
					processor: "boolean",
					default: true
				});
				registerOption("pad_empty_with_br", {
					processor: "boolean",
					default: false
				});
				registerOption("inline_styles", {
					processor: "boolean",
					default: true,
					deprecated: true
				});
				registerOption("element_format", {
					processor: "string",
					default: "html"
				});
				registerOption("entities", { processor: "string" });
				registerOption("schema", {
					processor: "string",
					default: "html5"
				});
				registerOption("convert_urls", {
					processor: "boolean",
					default: true
				});
				registerOption("relative_urls", {
					processor: "boolean",
					default: true
				});
				registerOption("remove_script_host", {
					processor: "boolean",
					default: true
				});
				registerOption("custom_elements", { processor: "string" });
				registerOption("extended_valid_elements", { processor: "string" });
				registerOption("invalid_elements", { processor: "string" });
				registerOption("invalid_styles", { processor: stringOrObjectProcessor });
				registerOption("valid_children", { processor: "string" });
				registerOption("valid_classes", { processor: stringOrObjectProcessor });
				registerOption("valid_elements", { processor: "string" });
				registerOption("valid_styles", { processor: stringOrObjectProcessor });
				registerOption("verify_html", {
					processor: "boolean",
					default: true
				});
				registerOption("auto_focus", { processor: (value$3) => isString(value$3) || value$3 === true });
				registerOption("browser_spellcheck", {
					processor: "boolean",
					default: false
				});
				registerOption("protect", { processor: "array" });
				registerOption("images_file_types", {
					processor: "string",
					default: "jpeg,jpg,jpe,jfi,jif,jfif,png,gif,bmp,webp"
				});
				registerOption("deprecation_warnings", {
					processor: "boolean",
					default: true
				});
				registerOption("a11y_advanced_options", {
					processor: "boolean",
					default: false
				});
				registerOption("api_key", { processor: "string" });
				registerOption("paste_block_drop", {
					processor: "boolean",
					default: false
				});
				registerOption("paste_data_images", {
					processor: "boolean",
					default: true
				});
				registerOption("paste_preprocess", { processor: "function" });
				registerOption("paste_postprocess", { processor: "function" });
				registerOption("paste_webkit_styles", {
					processor: "string",
					default: "none"
				});
				registerOption("paste_remove_styles_if_webkit", {
					processor: "boolean",
					default: true
				});
				registerOption("paste_merge_formats", {
					processor: "boolean",
					default: true
				});
				registerOption("smart_paste", {
					processor: "boolean",
					default: true
				});
				registerOption("paste_as_text", {
					processor: "boolean",
					default: false
				});
				registerOption("paste_tab_spaces", {
					processor: "number",
					default: 4
				});
				registerOption("text_patterns", {
					processor: (value$3) => {
						if (isArrayOf(value$3, isObject) || value$3 === false) return {
							value: fromRawPatterns(value$3 === false ? [] : value$3),
							valid: true
						};
						else return {
							valid: false,
							message: "Must be an array of objects or false."
						};
					},
					default: [
						{
							start: "*",
							end: "*",
							format: "italic"
						},
						{
							start: "**",
							end: "**",
							format: "bold"
						},
						{
							start: "#",
							format: "h1"
						},
						{
							start: "##",
							format: "h2"
						},
						{
							start: "###",
							format: "h3"
						},
						{
							start: "####",
							format: "h4"
						},
						{
							start: "#####",
							format: "h5"
						},
						{
							start: "######",
							format: "h6"
						},
						{
							start: "1. ",
							cmd: "InsertOrderedList"
						},
						{
							start: "* ",
							cmd: "InsertUnorderedList"
						},
						{
							start: "- ",
							cmd: "InsertUnorderedList"
						}
					]
				});
				registerOption("text_patterns_lookup", {
					processor: (value$3) => {
						if (isFunction(value$3)) return {
							value: fromRawPatternsLookup(value$3),
							valid: true
						};
						else return {
							valid: false,
							message: "Must be a single function"
						};
					},
					default: (_ctx) => []
				});
				registerOption("noneditable_class", {
					processor: "string",
					default: "mceNonEditable"
				});
				registerOption("editable_class", {
					processor: "string",
					default: "mceEditable"
				});
				registerOption("noneditable_regexp", {
					processor: (value$3) => {
						if (isArrayOf(value$3, isRegExp)) return {
							value: value$3,
							valid: true
						};
						else if (isRegExp(value$3)) return {
							value: [value$3],
							valid: true
						};
						else return {
							valid: false,
							message: "Must be a RegExp or an array of RegExp."
						};
					},
					default: []
				});
				registerOption("table_tab_navigation", {
					processor: "boolean",
					default: true
				});
				registerOption("highlight_on_focus", {
					processor: "boolean",
					default: false
				});
				registerOption("xss_sanitization", {
					processor: "boolean",
					default: true
				});
				registerOption("details_initial_state", {
					processor: (value$3) => {
						const valid = contains$2([
							"inherited",
							"collapsed",
							"expanded"
						], value$3);
						return valid ? {
							value: value$3,
							valid
						} : {
							valid: false,
							message: "Must be one of: inherited, collapsed, or expanded."
						};
					},
					default: "inherited"
				});
				registerOption("details_serialized_state", {
					processor: (value$3) => {
						const valid = contains$2([
							"inherited",
							"collapsed",
							"expanded"
						], value$3);
						return valid ? {
							value: value$3,
							valid
						} : {
							valid: false,
							message: "Must be one of: inherited, collapsed, or expanded."
						};
					},
					default: "inherited"
				});
				registerOption("init_content_sync", {
					processor: "boolean",
					default: false
				});
				registerOption("newdocument_content", {
					processor: "string",
					default: ""
				});
				editor.on("ScriptsLoaded", () => {
					registerOption("directionality", {
						processor: "string",
						default: I18n.isRtl() ? "rtl" : void 0
					});
					registerOption("placeholder", {
						processor: "string",
						default: DOM$a.getAttrib(editor.getElement(), "placeholder")
					});
				});
			};
			const getIframeAttrs = option("iframe_attrs");
			const getDocType = option("doctype");
			const getDocumentBaseUrl = option("document_base_url");
			const getBodyId = option("body_id");
			const getBodyClass = option("body_class");
			const getContentSecurityPolicy = option("content_security_policy");
			const shouldPutBrInPre$1 = option("br_in_pre");
			const getForcedRootBlock = option("forced_root_block");
			const getForcedRootBlockAttrs = option("forced_root_block_attrs");
			const getNewlineBehavior = option("newline_behavior");
			const getBrNewLineSelector = option("br_newline_selector");
			const getNoNewLineSelector = option("no_newline_selector");
			const shouldKeepStyles = option("keep_styles");
			const shouldEndContainerOnEmptyBlock = option("end_container_on_empty_block");
			const isAutomaticUploadsEnabled = option("automatic_uploads");
			const shouldReuseFileName = option("images_reuse_filename");
			const shouldReplaceBlobUris = option("images_replace_blob_uris");
			const getIconPackName = option("icons");
			const getIconsUrl = option("icons_url");
			const getImageUploadUrl = option("images_upload_url");
			const getImageUploadBasePath = option("images_upload_base_path");
			const getImagesUploadCredentials = option("images_upload_credentials");
			const getImagesUploadHandler = option("images_upload_handler");
			const shouldUseContentCssCors = option("content_css_cors");
			const getReferrerPolicy = option("referrer_policy");
			const getLanguageCode = option("language");
			const getLanguageUrl = option("language_url");
			const shouldIndentUseMargin = option("indent_use_margin");
			const getIndentation = option("indentation");
			const getContentCss = option("content_css");
			const getContentStyle = option("content_style");
			const getFontCss = option("font_css");
			const getDirectionality = option("directionality");
			const getInlineBoundarySelector = option("inline_boundaries_selector");
			const getObjectResizing = option("object_resizing");
			const getResizeImgProportional = option("resize_img_proportional");
			const getPlaceholder = option("placeholder");
			const getEventRoot = option("event_root");
			const getServiceMessage = option("service_message");
			const getTheme = option("theme");
			const getThemeUrl = option("theme_url");
			const getModel = option("model");
			const getModelUrl = option("model_url");
			const isInlineBoundariesEnabled = option("inline_boundaries");
			const getFormats = option("formats");
			const getPreviewStyles = option("preview_styles");
			const canFormatEmptyLines = option("format_empty_lines");
			const getFormatNoneditableSelector = option("format_noneditable_selector");
			const getCustomUiSelector = option("custom_ui_selector");
			const isInline = option("inline");
			const hasHiddenInput = option("hidden_input");
			const shouldPatchSubmit = option("submit_patch");
			const shouldAddFormSubmitTrigger = option("add_form_submit_trigger");
			const shouldAddUnloadTrigger = option("add_unload_trigger");
			const getCustomUndoRedoLevels = option("custom_undo_redo_levels");
			const shouldDisableNodeChange = option("disable_nodechange");
			const isReadOnly$1 = option("readonly");
			const hasEditableRoot$1 = option("editable_root");
			const hasContentCssCors = option("content_css_cors");
			const getPlugins = option("plugins");
			const getExternalPlugins$1 = option("external_plugins");
			const shouldBlockUnsupportedDrop = option("block_unsupported_drop");
			const isVisualAidsEnabled = option("visual");
			const getVisualAidsTableClass = option("visual_table_class");
			const getVisualAidsAnchorClass = option("visual_anchor_class");
			const getIframeAriaText = option("iframe_aria_text");
			const getSetupCallback = option("setup");
			const getInitInstanceCallback = option("init_instance_callback");
			const getUrlConverterCallback = option("urlconverter_callback");
			const getAutoFocus = option("auto_focus");
			const shouldBrowserSpellcheck = option("browser_spellcheck");
			const getProtect = option("protect");
			const shouldPasteBlockDrop = option("paste_block_drop");
			const shouldPasteDataImages = option("paste_data_images");
			const getPastePreProcess = option("paste_preprocess");
			const getPastePostProcess = option("paste_postprocess");
			const getNewDocumentContent = option("newdocument_content");
			const getPasteWebkitStyles = option("paste_webkit_styles");
			const shouldPasteRemoveWebKitStyles = option("paste_remove_styles_if_webkit");
			const shouldPasteMergeFormats = option("paste_merge_formats");
			const isSmartPasteEnabled = option("smart_paste");
			const isPasteAsTextEnabled = option("paste_as_text");
			const getPasteTabSpaces = option("paste_tab_spaces");
			const shouldAllowHtmlDataUrls = option("allow_html_data_urls");
			const getTextPatterns = option("text_patterns");
			const getTextPatternsLookup = option("text_patterns_lookup");
			const getNonEditableClass = option("noneditable_class");
			const getEditableClass = option("editable_class");
			const getNonEditableRegExps = option("noneditable_regexp");
			const shouldPreserveCData = option("preserve_cdata");
			const shouldHighlightOnFocus = option("highlight_on_focus");
			const shouldSanitizeXss = option("xss_sanitization");
			const shouldUseDocumentWrite = option("init_content_sync");
			const hasTextPatternsLookup = (editor) => editor.options.isSet("text_patterns_lookup");
			const getFontStyleValues = (editor) => Tools.explode(editor.options.get("font_size_style_values"));
			const getFontSizeClasses = (editor) => Tools.explode(editor.options.get("font_size_classes"));
			const isEncodingXml = (editor) => editor.options.get("encoding") === "xml";
			const getAllowedImageFileTypes = (editor) => Tools.explode(editor.options.get("images_file_types"));
			const hasTableTabNavigation = option("table_tab_navigation");
			const getDetailsInitialState = option("details_initial_state");
			const getDetailsSerializedState = option("details_serialized_state");
			const isElement$3 = isElement$6;
			const isText$5 = isText$a;
			const removeNode$1 = (node) => {
				const parentNode = node.parentNode;
				if (parentNode) parentNode.removeChild(node);
			};
			const trimCount = (text$1) => {
				const trimmedText = trim$1(text$1);
				return {
					count: text$1.length - trimmedText.length,
					text: trimmedText
				};
			};
			const deleteZwspChars = (caretContainer) => {
				let idx;
				while ((idx = caretContainer.data.lastIndexOf(ZWSP$1)) !== -1) caretContainer.deleteData(idx, 1);
			};
			const removeUnchanged = (caretContainer, pos) => {
				remove$3(caretContainer);
				return pos;
			};
			const removeTextAndReposition = (caretContainer, pos) => {
				const before$1 = trimCount(caretContainer.data.substr(0, pos.offset()));
				const after$1 = trimCount(caretContainer.data.substr(pos.offset()));
				if ((before$1.text + after$1.text).length > 0) {
					deleteZwspChars(caretContainer);
					return CaretPosition(caretContainer, pos.offset() - before$1.count);
				} else return pos;
			};
			const removeElementAndReposition = (caretContainer, pos) => {
				const parentNode = pos.container();
				const newPosition = indexOf$1(from(parentNode.childNodes), caretContainer).map((index) => {
					return index < pos.offset() ? CaretPosition(parentNode, pos.offset() - 1) : pos;
				}).getOr(pos);
				remove$3(caretContainer);
				return newPosition;
			};
			const removeTextCaretContainer = (caretContainer, pos) => isText$5(caretContainer) && pos.container() === caretContainer ? removeTextAndReposition(caretContainer, pos) : removeUnchanged(caretContainer, pos);
			const removeElementCaretContainer = (caretContainer, pos) => pos.container() === caretContainer.parentNode ? removeElementAndReposition(caretContainer, pos) : removeUnchanged(caretContainer, pos);
			const removeAndReposition = (container, pos) => CaretPosition.isTextPosition(pos) ? removeTextCaretContainer(container, pos) : removeElementCaretContainer(container, pos);
			const remove$3 = (caretContainerNode) => {
				if (isElement$3(caretContainerNode) && isCaretContainer$2(caretContainerNode)) if (hasContent(caretContainerNode)) caretContainerNode.removeAttribute("data-mce-caret");
				else removeNode$1(caretContainerNode);
				if (isText$5(caretContainerNode)) {
					deleteZwspChars(caretContainerNode);
					if (caretContainerNode.data.length === 0) removeNode$1(caretContainerNode);
				}
			};
			const isContentEditableFalse$8 = isContentEditableFalse$b;
			const isMedia$1 = isMedia$2;
			const isTableCell$1 = isTableCell$3;
			const inlineFakeCaretSelector = "*[contentEditable=false],video,audio,embed,object";
			const getAbsoluteClientRect = (root, element, before$1) => {
				const clientRect = collapse(element.getBoundingClientRect(), before$1);
				let scrollX;
				let scrollY;
				if (root.tagName === "BODY") {
					const docElm = root.ownerDocument.documentElement;
					scrollX = root.scrollLeft || docElm.scrollLeft;
					scrollY = root.scrollTop || docElm.scrollTop;
				} else {
					const rootRect = root.getBoundingClientRect();
					scrollX = root.scrollLeft - rootRect.left;
					scrollY = root.scrollTop - rootRect.top;
				}
				clientRect.left += scrollX;
				clientRect.right += scrollX;
				clientRect.top += scrollY;
				clientRect.bottom += scrollY;
				clientRect.width = 1;
				let margin = element.offsetWidth - element.clientWidth;
				if (margin > 0) {
					if (before$1) margin *= -1;
					clientRect.left += margin;
					clientRect.right += margin;
				}
				return clientRect;
			};
			const trimInlineCaretContainers = (root) => {
				var _a, _b;
				const fakeCaretTargetNodes = descendants(SugarElement.fromDom(root), inlineFakeCaretSelector);
				for (let i = 0; i < fakeCaretTargetNodes.length; i++) {
					const node = fakeCaretTargetNodes[i].dom;
					let sibling$2 = node.previousSibling;
					if (endsWithCaretContainer$1(sibling$2)) {
						const data$1 = sibling$2.data;
						if (data$1.length === 1) (_a = sibling$2.parentNode) === null || _a === void 0 || _a.removeChild(sibling$2);
						else sibling$2.deleteData(data$1.length - 1, 1);
					}
					sibling$2 = node.nextSibling;
					if (startsWithCaretContainer$1(sibling$2)) if (sibling$2.data.length === 1) (_b = sibling$2.parentNode) === null || _b === void 0 || _b.removeChild(sibling$2);
					else sibling$2.deleteData(0, 1);
				}
			};
			const FakeCaret = (editor, root, isBlock$3, hasFocus$2) => {
				const lastVisualCaret = value$2();
				let cursorInterval;
				let caretContainerNode;
				const caretBlock = getForcedRootBlock(editor);
				const dom$1 = editor.dom;
				const show = (before$1, element) => {
					let rng;
					hide();
					if (isTableCell$1(element)) return null;
					if (isBlock$3(element)) {
						const caretContainer = insertBlock(caretBlock, element, before$1);
						const clientRect = getAbsoluteClientRect(root, element, before$1);
						dom$1.setStyle(caretContainer, "top", clientRect.top);
						caretContainerNode = caretContainer;
						const caret = dom$1.create("div", {
							"class": "mce-visual-caret",
							"data-mce-bogus": "all"
						});
						dom$1.setStyles(caret, { ...clientRect });
						dom$1.add(root, caret);
						lastVisualCaret.set({
							caret,
							element,
							before: before$1
						});
						if (before$1) dom$1.addClass(caret, "mce-visual-caret-before");
						startBlink();
						rng = element.ownerDocument.createRange();
						rng.setStart(caretContainer, 0);
						rng.setEnd(caretContainer, 0);
					} else {
						caretContainerNode = insertInline$1(element, before$1);
						rng = element.ownerDocument.createRange();
						if (isInlineFakeCaretTarget(caretContainerNode.nextSibling)) {
							rng.setStart(caretContainerNode, 0);
							rng.setEnd(caretContainerNode, 0);
						} else {
							rng.setStart(caretContainerNode, 1);
							rng.setEnd(caretContainerNode, 1);
						}
						return rng;
					}
					return rng;
				};
				const hide = () => {
					trimInlineCaretContainers(root);
					if (caretContainerNode) {
						remove$3(caretContainerNode);
						caretContainerNode = null;
					}
					lastVisualCaret.on((caretState) => {
						dom$1.remove(caretState.caret);
						lastVisualCaret.clear();
					});
					if (cursorInterval) {
						clearInterval(cursorInterval);
						cursorInterval = void 0;
					}
				};
				const startBlink = () => {
					cursorInterval = setInterval(() => {
						lastVisualCaret.on((caretState) => {
							if (hasFocus$2()) dom$1.toggleClass(caretState.caret, "mce-visual-caret-hidden");
							else dom$1.addClass(caretState.caret, "mce-visual-caret-hidden");
						});
					}, 500);
				};
				const reposition$1 = () => {
					lastVisualCaret.on((caretState) => {
						const clientRect = getAbsoluteClientRect(root, caretState.element, caretState.before);
						dom$1.setStyles(caretState.caret, { ...clientRect });
					});
				};
				const destroy$1 = () => clearInterval(cursorInterval);
				const getCss = () => ".mce-visual-caret {position: absolute;background-color: black;background-color: currentcolor;}.mce-visual-caret-hidden {display: none;}*[data-mce-caret] {position: absolute;left: -1000px;right: auto;top: 0;margin: 0;padding: 0;}";
				return {
					show,
					hide,
					getCss,
					reposition: reposition$1,
					destroy: destroy$1
				};
			};
			const isFakeCaretTableBrowser = () => Env.browser.isFirefox();
			const isInlineFakeCaretTarget = (node) => isContentEditableFalse$8(node) || isMedia$1(node);
			const isFakeCaretTarget = (node) => {
				return (isInlineFakeCaretTarget(node) || isTable$2(node) && isFakeCaretTableBrowser()) && parentElement(SugarElement.fromDom(node)).exists(isEditable$3);
			};
			const isContentEditableTrue$1 = isContentEditableTrue$3;
			const isContentEditableFalse$7 = isContentEditableFalse$b;
			const isMedia = isMedia$2;
			const isBlockLike = matchStyleValues("display", "block table table-cell table-caption list-item");
			const isCaretContainer = isCaretContainer$2;
			const isCaretContainerBlock = isCaretContainerBlock$1;
			const isElement$2 = isElement$6;
			const isText$4 = isText$a;
			const isCaretCandidate$1 = isCaretCandidate$3;
			const isForwards = (direction) => direction > 0;
			const isBackwards = (direction) => direction < 0;
			const skipCaretContainers = (walk$5, shallow$2) => {
				let node;
				while (node = walk$5(shallow$2)) if (!isCaretContainerBlock(node)) return node;
				return null;
			};
			const findNode = (node, direction, predicateFn, rootNode, shallow$2) => {
				const walker = new DomTreeWalker(node, rootNode);
				const isCefOrCaretContainer = isContentEditableFalse$7(node) || isCaretContainerBlock(node);
				let tempNode;
				if (isBackwards(direction)) {
					if (isCefOrCaretContainer) {
						tempNode = skipCaretContainers(walker.prev.bind(walker), true);
						if (predicateFn(tempNode)) return tempNode;
					}
					while (tempNode = skipCaretContainers(walker.prev.bind(walker), shallow$2)) if (predicateFn(tempNode)) return tempNode;
				}
				if (isForwards(direction)) {
					if (isCefOrCaretContainer) {
						tempNode = skipCaretContainers(walker.next.bind(walker), true);
						if (predicateFn(tempNode)) return tempNode;
					}
					while (tempNode = skipCaretContainers(walker.next.bind(walker), shallow$2)) if (predicateFn(tempNode)) return tempNode;
				}
				return null;
			};
			const getEditingHost = (node, rootNode) => {
				const isCETrue = (node$1) => isContentEditableTrue$1(node$1.dom);
				const isRoot$2 = (node$1) => node$1.dom === rootNode;
				return ancestor$4(SugarElement.fromDom(node), isCETrue, isRoot$2).map((elm) => elm.dom).getOr(rootNode);
			};
			const getParentBlock$3 = (node, rootNode) => {
				while (node && node !== rootNode) {
					if (isBlockLike(node)) return node;
					node = node.parentNode;
				}
				return null;
			};
			const isInSameBlock = (caretPosition1, caretPosition2, rootNode) => getParentBlock$3(caretPosition1.container(), rootNode) === getParentBlock$3(caretPosition2.container(), rootNode);
			const getChildNodeAtRelativeOffset = (relativeOffset, caretPosition) => {
				if (!caretPosition) return Optional.none();
				const container = caretPosition.container();
				const offset = caretPosition.offset();
				if (!isElement$2(container)) return Optional.none();
				return Optional.from(container.childNodes[offset + relativeOffset]);
			};
			const beforeAfter = (before$1, node) => {
				var _a;
				const range = ((_a = node.ownerDocument) !== null && _a !== void 0 ? _a : document).createRange();
				if (before$1) {
					range.setStartBefore(node);
					range.setEndBefore(node);
				} else {
					range.setStartAfter(node);
					range.setEndAfter(node);
				}
				return range;
			};
			const isNodesInSameBlock = (root, node1, node2) => getParentBlock$3(node1, root) === getParentBlock$3(node2, root);
			const lean = (left, root, node) => {
				const siblingName = left ? "previousSibling" : "nextSibling";
				let tempNode = node;
				while (tempNode && tempNode !== root) {
					let sibling$2 = tempNode[siblingName];
					if (sibling$2 && isCaretContainer(sibling$2)) sibling$2 = sibling$2[siblingName];
					if (isContentEditableFalse$7(sibling$2) || isMedia(sibling$2)) {
						if (isNodesInSameBlock(root, sibling$2, tempNode)) return sibling$2;
						break;
					}
					if (isCaretCandidate$1(sibling$2)) break;
					tempNode = tempNode.parentNode;
				}
				return null;
			};
			const before$2 = curry(beforeAfter, true);
			const after$2 = curry(beforeAfter, false);
			const normalizeRange = (direction, root, range) => {
				let node;
				const leanLeft = curry(lean, true, root);
				const leanRight$1 = curry(lean, false, root);
				const container = range.startContainer;
				const offset = range.startOffset;
				if (isCaretContainerBlock$1(container)) {
					const block = isText$4(container) ? container.parentNode : container;
					const location = block.getAttribute("data-mce-caret");
					if (location === "before") {
						node = block.nextSibling;
						if (isFakeCaretTarget(node)) return before$2(node);
					}
					if (location === "after") {
						node = block.previousSibling;
						if (isFakeCaretTarget(node)) return after$2(node);
					}
				}
				if (!range.collapsed) return range;
				if (isText$a(container)) {
					if (isCaretContainer(container)) {
						if (direction === 1) {
							node = leanRight$1(container);
							if (node) return before$2(node);
							node = leanLeft(container);
							if (node) return after$2(node);
						}
						if (direction === -1) {
							node = leanLeft(container);
							if (node) return after$2(node);
							node = leanRight$1(container);
							if (node) return before$2(node);
						}
						return range;
					}
					if (endsWithCaretContainer$1(container) && offset >= container.data.length - 1) {
						if (direction === 1) {
							node = leanRight$1(container);
							if (node) return before$2(node);
						}
						return range;
					}
					if (startsWithCaretContainer$1(container) && offset <= 1) {
						if (direction === -1) {
							node = leanLeft(container);
							if (node) return after$2(node);
						}
						return range;
					}
					if (offset === container.data.length) {
						node = leanRight$1(container);
						if (node) return before$2(node);
						return range;
					}
					if (offset === 0) {
						node = leanLeft(container);
						if (node) return after$2(node);
						return range;
					}
				}
				return range;
			};
			const getRelativeCefElm = (forward, caretPosition) => getChildNodeAtRelativeOffset(forward ? 0 : -1, caretPosition).filter(isContentEditableFalse$7);
			const getNormalizedRangeEndPoint = (direction, root, range) => {
				const normalizedRange = normalizeRange(direction, root, range);
				return direction === -1 ? CaretPosition.fromRangeStart(normalizedRange) : CaretPosition.fromRangeEnd(normalizedRange);
			};
			const getElementFromPosition = (pos) => Optional.from(pos.getNode()).map(SugarElement.fromDom);
			const getElementFromPrevPosition = (pos) => Optional.from(pos.getNode(true)).map(SugarElement.fromDom);
			const getVisualCaretPosition = (walkFn, caretPosition) => {
				let pos = caretPosition;
				while (pos = walkFn(pos)) if (pos.isVisible()) return pos;
				return pos;
			};
			const isMoveInsideSameBlock = (from$1, to$1) => {
				const inSameBlock = isInSameBlock(from$1, to$1);
				if (!inSameBlock && isBr$6(from$1.getNode())) return true;
				return inSameBlock;
			};
			var HDirection;
			(function(HDirection$1) {
				HDirection$1[HDirection$1["Backwards"] = -1] = "Backwards";
				HDirection$1[HDirection$1["Forwards"] = 1] = "Forwards";
			})(HDirection || (HDirection = {}));
			const isContentEditableFalse$6 = isContentEditableFalse$b;
			const isText$3 = isText$a;
			const isElement$1 = isElement$6;
			const isBr$2 = isBr$6;
			const isCaretCandidate = isCaretCandidate$3;
			const isAtomic = isAtomic$1;
			const isEditableCaretCandidate = isEditableCaretCandidate$1;
			const getParents$3 = (node, root) => {
				const parents$2 = [];
				let tempNode = node;
				while (tempNode && tempNode !== root) {
					parents$2.push(tempNode);
					tempNode = tempNode.parentNode;
				}
				return parents$2;
			};
			const nodeAtIndex = (container, offset) => {
				if (container.hasChildNodes() && offset < container.childNodes.length) return container.childNodes[offset];
				return null;
			};
			const getCaretCandidatePosition = (direction, node) => {
				if (isForwards(direction)) {
					if (isCaretCandidate(node.previousSibling) && !isText$3(node.previousSibling)) return CaretPosition.before(node);
					if (isText$3(node)) return CaretPosition(node, 0);
				}
				if (isBackwards(direction)) {
					if (isCaretCandidate(node.nextSibling) && !isText$3(node.nextSibling)) return CaretPosition.after(node);
					if (isText$3(node)) return CaretPosition(node, node.data.length);
				}
				if (isBackwards(direction)) {
					if (isBr$2(node)) return CaretPosition.before(node);
					return CaretPosition.after(node);
				}
				return CaretPosition.before(node);
			};
			const moveForwardFromBr = (root, nextNode) => {
				const nextSibling$1 = nextNode.nextSibling;
				if (nextSibling$1 && isCaretCandidate(nextSibling$1)) if (isText$3(nextSibling$1)) return CaretPosition(nextSibling$1, 0);
				else return CaretPosition.before(nextSibling$1);
				else return findCaretPosition$1(HDirection.Forwards, CaretPosition.after(nextNode), root);
			};
			const findCaretPosition$1 = (direction, startPos, root) => {
				let node;
				let nextNode;
				let innerNode;
				let caretPosition;
				if (!isElement$1(root) || !startPos) return null;
				if (startPos.isEqual(CaretPosition.after(root)) && root.lastChild) {
					caretPosition = CaretPosition.after(root.lastChild);
					if (isBackwards(direction) && isCaretCandidate(root.lastChild) && isElement$1(root.lastChild)) return isBr$2(root.lastChild) ? CaretPosition.before(root.lastChild) : caretPosition;
				} else caretPosition = startPos;
				const container = caretPosition.container();
				let offset = caretPosition.offset();
				if (isText$3(container)) {
					if (isBackwards(direction) && offset > 0) return CaretPosition(container, --offset);
					if (isForwards(direction) && offset < container.length) return CaretPosition(container, ++offset);
					node = container;
				} else {
					if (isBackwards(direction) && offset > 0) {
						nextNode = nodeAtIndex(container, offset - 1);
						if (isCaretCandidate(nextNode)) {
							if (!isAtomic(nextNode)) {
								innerNode = findNode(nextNode, direction, isEditableCaretCandidate, nextNode);
								if (innerNode) {
									if (isText$3(innerNode)) return CaretPosition(innerNode, innerNode.data.length);
									return CaretPosition.after(innerNode);
								}
							}
							if (isText$3(nextNode)) return CaretPosition(nextNode, nextNode.data.length);
							return CaretPosition.before(nextNode);
						}
					}
					if (isForwards(direction) && offset < container.childNodes.length) {
						nextNode = nodeAtIndex(container, offset);
						if (isCaretCandidate(nextNode)) {
							if (isBr$2(nextNode)) return moveForwardFromBr(root, nextNode);
							if (!isAtomic(nextNode)) {
								innerNode = findNode(nextNode, direction, isEditableCaretCandidate, nextNode);
								if (innerNode) {
									if (isText$3(innerNode)) return CaretPosition(innerNode, 0);
									return CaretPosition.before(innerNode);
								}
							}
							if (isText$3(nextNode)) return CaretPosition(nextNode, 0);
							return CaretPosition.after(nextNode);
						}
					}
					node = nextNode ? nextNode : caretPosition.getNode();
				}
				if (node && (isForwards(direction) && caretPosition.isAtEnd() || isBackwards(direction) && caretPosition.isAtStart())) {
					node = findNode(node, direction, always, root, true);
					if (isEditableCaretCandidate(node, root)) return getCaretCandidatePosition(direction, node);
				}
				nextNode = node ? findNode(node, direction, isEditableCaretCandidate, root) : node;
				const rootContentEditableFalseElm = last$2(filter$5(getParents$3(container, root), isContentEditableFalse$6));
				if (rootContentEditableFalseElm && (!nextNode || !rootContentEditableFalseElm.contains(nextNode))) {
					if (isForwards(direction)) caretPosition = CaretPosition.after(rootContentEditableFalseElm);
					else caretPosition = CaretPosition.before(rootContentEditableFalseElm);
					return caretPosition;
				}
				if (nextNode) return getCaretCandidatePosition(direction, nextNode);
				return null;
			};
			const CaretWalker = (root) => ({
				next: (caretPosition) => {
					return findCaretPosition$1(HDirection.Forwards, caretPosition, root);
				},
				prev: (caretPosition) => {
					return findCaretPosition$1(HDirection.Backwards, caretPosition, root);
				}
			});
			const walkToPositionIn = (forward, root, start$2) => {
				return fromPosition(forward, root, forward ? CaretPosition.before(start$2) : CaretPosition.after(start$2));
			};
			const afterElement = (node) => isBr$6(node) ? CaretPosition.before(node) : CaretPosition.after(node);
			const isBeforeOrStart = (position) => {
				if (CaretPosition.isTextPosition(position)) return position.offset() === 0;
				else return isCaretCandidate$3(position.getNode());
			};
			const isAfterOrEnd = (position) => {
				if (CaretPosition.isTextPosition(position)) {
					const container = position.container();
					return position.offset() === container.data.length;
				} else return isCaretCandidate$3(position.getNode(true));
			};
			const isBeforeAfterSameElement = (from$1, to$1) => !CaretPosition.isTextPosition(from$1) && !CaretPosition.isTextPosition(to$1) && from$1.getNode() === to$1.getNode(true);
			const isAtBr = (position) => !CaretPosition.isTextPosition(position) && isBr$6(position.getNode());
			const shouldSkipPosition = (forward, from$1, to$1) => {
				if (forward) return !isBeforeAfterSameElement(from$1, to$1) && !isAtBr(from$1) && isAfterOrEnd(from$1) && isBeforeOrStart(to$1);
				else return !isBeforeAfterSameElement(to$1, from$1) && isBeforeOrStart(from$1) && isAfterOrEnd(to$1);
			};
			const fromPosition = (forward, root, pos) => {
				const walker = CaretWalker(root);
				return Optional.from(forward ? walker.next(pos) : walker.prev(pos));
			};
			const navigate = (forward, root, from$1) => fromPosition(forward, root, from$1).bind((to$1) => {
				if (isInSameBlock(from$1, to$1, root) && shouldSkipPosition(forward, from$1, to$1)) return fromPosition(forward, root, to$1);
				else return Optional.some(to$1);
			});
			const navigateIgnore = (forward, root, from$1, ignoreFilter) => navigate(forward, root, from$1).bind((pos) => ignoreFilter(pos) ? navigateIgnore(forward, root, pos, ignoreFilter) : Optional.some(pos));
			const positionIn = (forward, element) => {
				const startNode = forward ? element.firstChild : element.lastChild;
				if (isText$a(startNode)) return Optional.some(CaretPosition(startNode, forward ? 0 : startNode.data.length));
				else if (startNode) if (isCaretCandidate$3(startNode)) return Optional.some(forward ? CaretPosition.before(startNode) : afterElement(startNode));
				else return walkToPositionIn(forward, element, startNode);
				else return Optional.none();
			};
			const nextPosition = curry(fromPosition, true);
			const prevPosition = curry(fromPosition, false);
			const firstPositionIn = curry(positionIn, true);
			const lastPositionIn = curry(positionIn, false);
			const CARET_ID = "_mce_caret";
			const isCaretNode = (node) => isElement$6(node) && node.id === CARET_ID;
			const getParentCaretContainer = (body, node) => {
				let currentNode = node;
				while (currentNode && currentNode !== body) {
					if (isCaretNode(currentNode)) return currentNode;
					currentNode = currentNode.parentNode;
				}
				return null;
			};
			const isStringPathBookmark = (bookmark) => isString(bookmark.start);
			const isRangeBookmark = (bookmark) => has$2(bookmark, "rng");
			const isIdBookmark = (bookmark) => has$2(bookmark, "id");
			const isIndexBookmark = (bookmark) => has$2(bookmark, "name");
			const isPathBookmark = (bookmark) => Tools.isArray(bookmark.start);
			const isForwardBookmark = (bookmark) => !isIndexBookmark(bookmark) && isBoolean(bookmark.forward) ? bookmark.forward : true;
			const addBogus = (dom$1, node) => {
				if (isElement$6(node) && dom$1.isBlock(node) && !node.innerHTML) node.innerHTML = "<br data-mce-bogus=\"1\" />";
				return node;
			};
			const resolveCaretPositionBookmark = (dom$1, bookmark) => {
				return lift2(Optional.from(resolve$1(dom$1.getRoot(), bookmark.start)), Optional.from(resolve$1(dom$1.getRoot(), bookmark.end)), (start$2, end$1) => {
					const range = dom$1.createRng();
					range.setStart(start$2.container(), start$2.offset());
					range.setEnd(end$1.container(), end$1.offset());
					return {
						range,
						forward: isForwardBookmark(bookmark)
					};
				});
			};
			const insertZwsp = (node, rng) => {
				var _a;
				const textNode = ((_a = node.ownerDocument) !== null && _a !== void 0 ? _a : document).createTextNode(ZWSP$1);
				node.appendChild(textNode);
				rng.setStart(textNode, 0);
				rng.setEnd(textNode, 0);
			};
			const isEmpty$1 = (node) => !node.hasChildNodes();
			const tryFindRangePosition = (node, rng) => lastPositionIn(node).fold(never, (pos) => {
				rng.setStart(pos.container(), pos.offset());
				rng.setEnd(pos.container(), pos.offset());
				return true;
			});
			const padEmptyCaretContainer = (root, node, rng) => {
				if (isEmpty$1(node) && getParentCaretContainer(root, node)) {
					insertZwsp(node, rng);
					return true;
				} else return false;
			};
			const setEndPoint = (dom$1, start$2, bookmark, rng) => {
				const point$1 = bookmark[start$2 ? "start" : "end"];
				const root = dom$1.getRoot();
				if (point$1) {
					let node = root;
					let offset = point$1[0];
					for (let i = point$1.length - 1; node && i >= 1; i--) {
						const children$2 = node.childNodes;
						if (padEmptyCaretContainer(root, node, rng)) return true;
						if (point$1[i] > children$2.length - 1) {
							if (padEmptyCaretContainer(root, node, rng)) return true;
							return tryFindRangePosition(node, rng);
						}
						node = children$2[point$1[i]];
					}
					if (isText$a(node)) offset = Math.min(point$1[0], node.data.length);
					if (isElement$6(node)) offset = Math.min(point$1[0], node.childNodes.length);
					if (start$2) rng.setStart(node, offset);
					else rng.setEnd(node, offset);
				}
				return true;
			};
			const isValidTextNode = (node) => isText$a(node) && node.data.length > 0;
			const restoreEndPoint = (dom$1, suffix, bookmark) => {
				const marker = dom$1.get(bookmark.id + "_" + suffix);
				const markerParent = marker === null || marker === void 0 ? void 0 : marker.parentNode;
				const keep = bookmark.keep;
				if (marker && markerParent) {
					let container;
					let offset;
					if (suffix === "start") if (!keep) {
						container = markerParent;
						offset = dom$1.nodeIndex(marker);
					} else if (marker.hasChildNodes()) {
						container = marker.firstChild;
						offset = 1;
					} else if (isValidTextNode(marker.nextSibling)) {
						container = marker.nextSibling;
						offset = 0;
					} else if (isValidTextNode(marker.previousSibling)) {
						container = marker.previousSibling;
						offset = marker.previousSibling.data.length;
					} else {
						container = markerParent;
						offset = dom$1.nodeIndex(marker) + 1;
					}
					else if (!keep) {
						container = markerParent;
						offset = dom$1.nodeIndex(marker);
					} else if (marker.hasChildNodes()) {
						container = marker.firstChild;
						offset = 1;
					} else if (isValidTextNode(marker.previousSibling)) {
						container = marker.previousSibling;
						offset = marker.previousSibling.data.length;
					} else {
						container = markerParent;
						offset = dom$1.nodeIndex(marker);
					}
					if (!keep) {
						const prev$1 = marker.previousSibling;
						const next$1 = marker.nextSibling;
						Tools.each(Tools.grep(marker.childNodes), (node) => {
							if (isText$a(node)) node.data = node.data.replace(/\uFEFF/g, "");
						});
						let otherMarker;
						while (otherMarker = dom$1.get(bookmark.id + "_" + suffix)) dom$1.remove(otherMarker, true);
						if (isText$a(next$1) && isText$a(prev$1) && !Env.browser.isOpera()) {
							const idx = prev$1.data.length;
							prev$1.appendData(next$1.data);
							dom$1.remove(next$1);
							container = prev$1;
							offset = idx;
						}
					}
					return Optional.some(CaretPosition(container, offset));
				} else return Optional.none();
			};
			const resolvePaths = (dom$1, bookmark) => {
				const range = dom$1.createRng();
				if (setEndPoint(dom$1, true, bookmark, range) && setEndPoint(dom$1, false, bookmark, range)) return Optional.some({
					range,
					forward: isForwardBookmark(bookmark)
				});
				else return Optional.none();
			};
			const resolveId = (dom$1, bookmark) => {
				const startPos = restoreEndPoint(dom$1, "start", bookmark);
				return lift2(startPos, restoreEndPoint(dom$1, "end", bookmark).or(startPos), (spos, epos) => {
					const range = dom$1.createRng();
					range.setStart(addBogus(dom$1, spos.container()), spos.offset());
					range.setEnd(addBogus(dom$1, epos.container()), epos.offset());
					return {
						range,
						forward: isForwardBookmark(bookmark)
					};
				});
			};
			const resolveIndex = (dom$1, bookmark) => Optional.from(dom$1.select(bookmark.name)[bookmark.index]).map((elm) => {
				const range = dom$1.createRng();
				range.selectNode(elm);
				return {
					range,
					forward: true
				};
			});
			const resolve = (selection, bookmark) => {
				const dom$1 = selection.dom;
				if (bookmark) {
					if (isPathBookmark(bookmark)) return resolvePaths(dom$1, bookmark);
					else if (isStringPathBookmark(bookmark)) return resolveCaretPositionBookmark(dom$1, bookmark);
					else if (isIdBookmark(bookmark)) return resolveId(dom$1, bookmark);
					else if (isIndexBookmark(bookmark)) return resolveIndex(dom$1, bookmark);
					else if (isRangeBookmark(bookmark)) return Optional.some({
						range: bookmark.rng,
						forward: isForwardBookmark(bookmark)
					});
				}
				return Optional.none();
			};
			const getBookmark$1 = (selection, type$2, normalized) => {
				return getBookmark$2(selection, type$2, normalized);
			};
			const moveToBookmark = (selection, bookmark) => {
				resolve(selection, bookmark).each(({ range, forward }) => {
					selection.setRng(range, forward);
				});
			};
			const isBookmarkNode$1 = (node) => {
				return isElement$6(node) && node.tagName === "SPAN" && node.getAttribute("data-mce-type") === "bookmark";
			};
			const is = (expected) => (actual) => expected === actual;
			const isNbsp = is(nbsp);
			const isWhiteSpace = (chr) => chr !== "" && " \f\n\r	\v".indexOf(chr) !== -1;
			const isContent = (chr) => !isWhiteSpace(chr) && !isNbsp(chr) && !isZwsp$2(chr);
			const hexColour = (value$3) => ({ value: normalizeHex(value$3) });
			const normalizeHex = (hex) => removeLeading(hex, "#").toUpperCase();
			const toHex = (component) => {
				const hex = component.toString(16);
				return (hex.length === 1 ? "0" + hex : hex).toUpperCase();
			};
			const fromRgba = (rgbaColour$1) => {
				return hexColour(toHex(rgbaColour$1.red) + toHex(rgbaColour$1.green) + toHex(rgbaColour$1.blue));
			};
			const rgbRegex = /^\s*rgb\s*\(\s*(\d+)\s*,\s*(\d+)\s*,\s*(\d+)\s*\)\s*$/i;
			const rgbaRegex = /^\s*rgba\s*\(\s*(\d+)\s*,\s*(\d+)\s*,\s*(\d+)\s*,\s*(\d?(?:\.\d+)?)\s*\)\s*$/i;
			const rgbaColour = (red, green, blue, alpha) => ({
				red,
				green,
				blue,
				alpha
			});
			const fromStringValues = (red, green, blue, alpha) => {
				return rgbaColour(parseInt(red, 10), parseInt(green, 10), parseInt(blue, 10), parseFloat(alpha));
			};
			const fromString = (rgbaString) => {
				if (rgbaString === "transparent") return Optional.some(rgbaColour(0, 0, 0, 0));
				const rgbMatch = rgbRegex.exec(rgbaString);
				if (rgbMatch !== null) return Optional.some(fromStringValues(rgbMatch[1], rgbMatch[2], rgbMatch[3], "1"));
				const rgbaMatch = rgbaRegex.exec(rgbaString);
				if (rgbaMatch !== null) return Optional.some(fromStringValues(rgbaMatch[1], rgbaMatch[2], rgbaMatch[3], rgbaMatch[4]));
				return Optional.none();
			};
			const rgbaToHexString = (color) => fromString(color).map(fromRgba).map((h) => "#" + h.value).getOr(color);
			const getRanges$1 = (selection) => {
				const ranges = [];
				if (selection) for (let i = 0; i < selection.rangeCount; i++) ranges.push(selection.getRangeAt(i));
				return ranges;
			};
			const getSelectedNodes = (ranges) => {
				return bind$3(ranges, (range) => {
					const node = getSelectedNode(range);
					return node ? [SugarElement.fromDom(node)] : [];
				});
			};
			const hasMultipleRanges = (selection) => {
				return getRanges$1(selection).length > 1;
			};
			const getCellsFromRanges = (ranges) => filter$5(getSelectedNodes(ranges), isTableCell$2);
			const getCellsFromElement = (elm) => descendants(elm, "td[data-mce-selected],th[data-mce-selected]");
			const getCellsFromElementOrRanges = (ranges, element) => {
				const selectedCells = getCellsFromElement(element);
				return selectedCells.length > 0 ? selectedCells : getCellsFromRanges(ranges);
			};
			const getCellsFromEditor = (editor) => getCellsFromElementOrRanges(getRanges$1(editor.selection.getSel()), SugarElement.fromDom(editor.getBody()));
			const getClosestTable = (cell$1, isRoot$2) => ancestor$3(cell$1, "table", isRoot$2);
			const getStartNode = (rng) => {
				const sc = rng.startContainer, so = rng.startOffset;
				if (isText$a(sc)) return so === 0 ? Optional.some(SugarElement.fromDom(sc)) : Optional.none();
				else return Optional.from(sc.childNodes[so]).map(SugarElement.fromDom);
			};
			const getEndNode = (rng) => {
				const ec = rng.endContainer, eo = rng.endOffset;
				if (isText$a(ec)) return eo === ec.data.length ? Optional.some(SugarElement.fromDom(ec)) : Optional.none();
				else return Optional.from(ec.childNodes[eo - 1]).map(SugarElement.fromDom);
			};
			const getFirstChildren = (node) => {
				return firstChild(node).fold(constant([node]), (child$2) => {
					return [node].concat(getFirstChildren(child$2));
				});
			};
			const getLastChildren = (node) => {
				return lastChild(node).fold(constant([node]), (child$2) => {
					if (name(child$2) === "br") return prevSibling(child$2).map((sibling$2) => {
						return [node].concat(getLastChildren(sibling$2));
					}).getOr([]);
					else return [node].concat(getLastChildren(child$2));
				});
			};
			const hasAllContentsSelected = (elm, rng) => {
				return lift2(getStartNode(rng), getEndNode(rng), (startNode, endNode) => {
					const start$2 = find$2(getFirstChildren(elm), curry(eq, startNode));
					const end$1 = find$2(getLastChildren(elm), curry(eq, endNode));
					return start$2.isSome() && end$1.isSome();
				}).getOr(false);
			};
			const moveEndPoint = (dom$1, rng, node, start$2) => {
				const root = node;
				const walker = new DomTreeWalker(node, root);
				const moveCaretBeforeOnEnterElementsMap = filter$4(dom$1.schema.getMoveCaretBeforeOnEnterElements(), (_, name$1) => !contains$2([
					"td",
					"th",
					"table"
				], name$1.toLowerCase()));
				let currentNode = node;
				do {
					if (isText$a(currentNode) && Tools.trim(currentNode.data).length !== 0) {
						if (start$2) rng.setStart(currentNode, 0);
						else rng.setEnd(currentNode, currentNode.data.length);
						return;
					}
					if (moveCaretBeforeOnEnterElementsMap[currentNode.nodeName]) {
						if (start$2) rng.setStartBefore(currentNode);
						else if (currentNode.nodeName === "BR") rng.setEndBefore(currentNode);
						else rng.setEndAfter(currentNode);
						return;
					}
				} while (currentNode = start$2 ? walker.next() : walker.prev());
				if (root.nodeName === "BODY") if (start$2) rng.setStart(root, 0);
				else rng.setEnd(root, root.childNodes.length);
			};
			const hasAnyRanges = (editor) => {
				const sel = editor.selection.getSel();
				return isNonNullable(sel) && sel.rangeCount > 0;
			};
			const runOnRanges = (editor, executor) => {
				const fakeSelectionNodes = getCellsFromEditor(editor);
				if (fakeSelectionNodes.length > 0) each$e(fakeSelectionNodes, (elem) => {
					const node = elem.dom;
					const fakeNodeRng = editor.dom.createRng();
					fakeNodeRng.setStartBefore(node);
					fakeNodeRng.setEndAfter(node);
					executor(fakeNodeRng, true);
				});
				else executor(editor.selection.getRng(), false);
			};
			const preserve = (selection, fillBookmark, executor) => {
				const bookmark = getPersistentBookmark(selection, fillBookmark);
				executor(bookmark);
				selection.moveToBookmark(bookmark);
			};
			const isNode = (node) => isNumber(node === null || node === void 0 ? void 0 : node.nodeType);
			const isElementNode$1 = (node) => isElement$6(node) && !isBookmarkNode$1(node) && !isCaretNode(node) && !isBogus$2(node);
			const isElementDirectlySelected = (dom$1, node) => {
				if (isElementNode$1(node) && !/^(TD|TH)$/.test(node.nodeName)) {
					const selectedAttr = dom$1.getAttrib(node, "data-mce-selected");
					const value$3 = parseInt(selectedAttr, 10);
					return !isNaN(value$3) && value$3 > 0;
				} else return false;
			};
			const isEditable$2 = (elm) => elm.isContentEditable === true;
			const preserveSelection = (editor, action$1, shouldMoveStart) => {
				const { selection, dom: dom$1 } = editor;
				const selectedNodeBeforeAction = selection.getNode();
				const isSelectedBeforeNodeNoneditable = isContentEditableFalse$b(selectedNodeBeforeAction);
				preserve(selection, true, () => {
					action$1();
				});
				if (isSelectedBeforeNodeNoneditable && isContentEditableFalse$b(selectedNodeBeforeAction) && dom$1.isChildOf(selectedNodeBeforeAction, editor.getBody())) editor.selection.select(selectedNodeBeforeAction);
				else if (shouldMoveStart(selection.getStart())) moveStartToNearestText(dom$1, selection);
			};
			const moveStartToNearestText = (dom$1, selection) => {
				var _a, _b;
				const rng = selection.getRng();
				const { startContainer, startOffset } = rng;
				if (isElementDirectlySelected(dom$1, selection.getNode())) return;
				if (isElement$6(startContainer)) {
					const nodes = startContainer.childNodes;
					const root = dom$1.getRoot();
					let walker;
					if (startOffset < nodes.length) {
						const startNode = nodes[startOffset];
						walker = new DomTreeWalker(startNode, (_a = dom$1.getParent(startNode, dom$1.isBlock)) !== null && _a !== void 0 ? _a : root);
					} else {
						const startNode = nodes[nodes.length - 1];
						walker = new DomTreeWalker(startNode, (_b = dom$1.getParent(startNode, dom$1.isBlock)) !== null && _b !== void 0 ? _b : root);
						walker.next(true);
					}
					for (let node = walker.current(); node; node = walker.next()) if (dom$1.getContentEditable(node) === "false") return;
					else if (isText$a(node) && !isWhiteSpaceNode$1(node)) {
						rng.setStart(node, 0);
						selection.setRng(rng);
						return;
					}
				}
			};
			const getNonWhiteSpaceSibling = (node, next$1, inc) => {
				if (node) {
					const nextName = next$1 ? "nextSibling" : "previousSibling";
					for (node = inc ? node : node[nextName]; node; node = node[nextName]) if (isElement$6(node) || !isWhiteSpaceNode$1(node)) return node;
				}
			};
			const isTextBlock$1 = (schema, node) => !!schema.getTextBlockElements()[node.nodeName.toLowerCase()] || isTransparentBlock(schema, node);
			const isValid = (ed, parent$1, child$2) => {
				return ed.schema.isValidChild(parent$1, child$2);
			};
			const isWhiteSpaceNode$1 = (node, allowSpaces = false) => {
				if (isNonNullable(node) && isText$a(node)) return isWhitespaceText(allowSpaces ? node.data.replace(/ /g, "\xA0") : node.data);
				else return false;
			};
			const isEmptyTextNode$1 = (node) => {
				return isNonNullable(node) && isText$a(node) && node.length === 0;
			};
			const isWrapNoneditableTarget = (editor, node) => {
				const baseDataSelector = "[data-mce-cef-wrappable]";
				const formatNoneditableSelector = getFormatNoneditableSelector(editor);
				const selector = isEmpty$3(formatNoneditableSelector) ? baseDataSelector : `${baseDataSelector},${formatNoneditableSelector}`;
				return is$1(SugarElement.fromDom(node), selector);
			};
			const isWrappableNoneditable = (editor, node) => {
				const dom$1 = editor.dom;
				return isElementNode$1(node) && dom$1.getContentEditable(node) === "false" && isWrapNoneditableTarget(editor, node) && dom$1.select("[contenteditable=\"true\"]", node).length === 0;
			};
			const replaceVars = (value$3, vars) => {
				if (isFunction(value$3)) return value$3(vars);
				else if (isNonNullable(vars)) value$3 = value$3.replace(/%(\w+)/g, (str, name$1) => {
					return vars[name$1] || str;
				});
				return value$3;
			};
			const isEq$5 = (str1, str2) => {
				str1 = str1 || "";
				str2 = str2 || "";
				str1 = "" + (str1.nodeName || str1);
				str2 = "" + (str2.nodeName || str2);
				return str1.toLowerCase() === str2.toLowerCase();
			};
			const normalizeStyleValue = (value$3, name$1) => {
				if (isNullable(value$3)) return null;
				else {
					let strValue = String(value$3);
					if (name$1 === "color" || name$1 === "backgroundColor") strValue = rgbaToHexString(strValue);
					if (name$1 === "fontWeight" && value$3 === 700) strValue = "bold";
					if (name$1 === "fontFamily") strValue = strValue.replace(/[\'\"]/g, "").replace(/,\s+/g, ",");
					return strValue;
				}
			};
			const getStyle = (dom$1, node, name$1) => {
				return normalizeStyleValue(dom$1.getStyle(node, name$1), name$1);
			};
			const getTextDecoration = (dom$1, node) => {
				let decoration;
				dom$1.getParent(node, (n) => {
					if (isElement$6(n)) {
						decoration = dom$1.getStyle(n, "text-decoration");
						return !!decoration && decoration !== "none";
					} else return false;
				});
				return decoration;
			};
			const getParents$2 = (dom$1, node, selector) => {
				return dom$1.getParents(node, selector, dom$1.getRoot());
			};
			const isFormatPredicate = (editor, formatName, predicate) => {
				const formats = editor.formatter.get(formatName);
				return isNonNullable(formats) && exists(formats, predicate);
			};
			const isVariableFormatName = (editor, formatName) => {
				const hasVariableValues = (format) => {
					const isVariableValue = (val) => isFunction(val) || val.length > 1 && val.charAt(0) === "%";
					return exists(["styles", "attributes"], (key) => get$a(format, key).exists((field$2) => {
						return exists(isArray$1(field$2) ? field$2 : values(field$2), isVariableValue);
					}));
				};
				return isFormatPredicate(editor, formatName, hasVariableValues);
			};
			const areSimilarFormats = (editor, formatName, otherFormatName) => {
				const validKeys = [
					"inline",
					"block",
					"selector",
					"attributes",
					"styles",
					"classes"
				];
				const filterObj = (format) => filter$4(format, (_, key) => exists(validKeys, (validKey) => validKey === key));
				return isFormatPredicate(editor, formatName, (fmt1) => {
					const filteredFmt1 = filterObj(fmt1);
					return isFormatPredicate(editor, otherFormatName, (fmt2) => {
						return equal$1(filteredFmt1, filterObj(fmt2));
					});
				});
			};
			const isBlockFormat = (format) => hasNonNullableKey(format, "block");
			const isWrappingBlockFormat = (format) => isBlockFormat(format) && format.wrapper === true;
			const isNonWrappingBlockFormat = (format) => isBlockFormat(format) && format.wrapper !== true;
			const isSelectorFormat = (format) => hasNonNullableKey(format, "selector");
			const isInlineFormat = (format) => hasNonNullableKey(format, "inline");
			const isMixedFormat = (format) => isSelectorFormat(format) && isInlineFormat(format) && is$2(get$a(format, "mixed"), true);
			const shouldExpandToSelector = (format) => isSelectorFormat(format) && format.expand !== false && !isInlineFormat(format);
			const isBookmarkNode = isBookmarkNode$1;
			const getParents$1 = getParents$2;
			const isWhiteSpaceNode = isWhiteSpaceNode$1;
			const isTextBlock = isTextBlock$1;
			const isBogusBr = (node) => {
				return isBr$6(node) && node.getAttribute("data-mce-bogus") && !node.nextSibling;
			};
			const findParentContentEditable = (dom$1, node) => {
				let parent$1 = node;
				while (parent$1) {
					if (isElement$6(parent$1) && dom$1.getContentEditable(parent$1)) return dom$1.getContentEditable(parent$1) === "false" ? parent$1 : node;
					parent$1 = parent$1.parentNode;
				}
				return node;
			};
			const walkText = (start$2, node, offset, predicate) => {
				const str = node.data;
				if (start$2) {
					for (let i = offset; i > 0; i--) if (predicate(str.charAt(i - 1))) return i;
				} else for (let i = offset; i < str.length; i++) if (predicate(str.charAt(i))) return i;
				return -1;
			};
			const findSpace = (start$2, node, offset) => walkText(start$2, node, offset, (c) => isNbsp(c) || isWhiteSpace(c));
			const findContent = (start$2, node, offset) => walkText(start$2, node, offset, isContent);
			const findWordEndPoint = (dom$1, body, container, offset, start$2, includeTrailingSpaces) => {
				let lastTextNode;
				const rootNode = dom$1.getParent(container, dom$1.isBlock) || body;
				const walk$5 = (container$1, offset$1, pred) => {
					const textSeeker = TextSeeker(dom$1);
					const walker = start$2 ? textSeeker.backwards : textSeeker.forwards;
					return Optional.from(walker(container$1, offset$1, (text$1, textOffset) => {
						if (isBookmarkNode(text$1.parentNode)) return -1;
						else {
							lastTextNode = text$1;
							return pred(start$2, text$1, textOffset);
						}
					}, rootNode));
				};
				return walk$5(container, offset, findSpace).bind((result) => includeTrailingSpaces ? walk$5(result.container, result.offset + (start$2 ? -1 : 0), findContent) : Optional.some(result)).orThunk(() => lastTextNode ? Optional.some({
					container: lastTextNode,
					offset: start$2 ? 0 : lastTextNode.length
				}) : Optional.none());
			};
			const findSelectorEndPoint = (dom$1, formatList, rng, container, siblingName) => {
				const sibling$2 = container[siblingName];
				if (isText$a(container) && isEmpty$3(container.data) && sibling$2) container = sibling$2;
				const parents$2 = getParents$1(dom$1, container);
				for (let i = 0; i < parents$2.length; i++) for (let y = 0; y < formatList.length; y++) {
					const curFormat = formatList[y];
					if (isNonNullable(curFormat.collapsed) && curFormat.collapsed !== rng.collapsed) continue;
					if (isSelectorFormat(curFormat) && dom$1.is(parents$2[i], curFormat.selector)) return parents$2[i];
				}
				return container;
			};
			const findBlockEndPoint = (dom$1, formatList, container, siblingName) => {
				var _a;
				let node = container;
				const root = dom$1.getRoot();
				const format = formatList[0];
				if (isBlockFormat(format)) node = format.wrapper ? null : dom$1.getParent(container, format.block, root);
				if (!node) {
					const scopeRoot = (_a = dom$1.getParent(container, "LI,TD,TH")) !== null && _a !== void 0 ? _a : root;
					node = dom$1.getParent(isText$a(container) ? container.parentNode : container, (node$1) => node$1 !== root && isTextBlock(dom$1.schema, node$1), scopeRoot);
				}
				if (node && isBlockFormat(format) && format.wrapper) node = getParents$1(dom$1, node, "ul,ol").reverse()[0] || node;
				if (!node) {
					node = container;
					while (node && node[siblingName] && !dom$1.isBlock(node[siblingName])) {
						node = node[siblingName];
						if (isEq$5(node, "br")) break;
					}
				}
				return node || container;
			};
			const isAtBlockBoundary$1 = (dom$1, root, container, siblingName) => {
				const parent$1 = container.parentNode;
				if (isNonNullable(container[siblingName])) return false;
				else if (parent$1 === root || isNullable(parent$1) || dom$1.isBlock(parent$1)) return true;
				else return isAtBlockBoundary$1(dom$1, root, parent$1, siblingName);
			};
			const findParentContainer = (dom$1, formatList, container, offset, start$2) => {
				let parent$1 = container;
				const siblingName = start$2 ? "previousSibling" : "nextSibling";
				const root = dom$1.getRoot();
				if (isText$a(container) && !isWhiteSpaceNode(container)) {
					if (start$2 ? offset > 0 : offset < container.data.length) return container;
				}
				while (parent$1) {
					if (!formatList[0].block_expand && dom$1.isBlock(parent$1)) return parent$1;
					for (let sibling$2 = parent$1[siblingName]; sibling$2; sibling$2 = sibling$2[siblingName]) {
						const allowSpaces = isText$a(sibling$2) && !isAtBlockBoundary$1(dom$1, root, sibling$2, siblingName);
						if (!isBookmarkNode(sibling$2) && !isBogusBr(sibling$2) && !isWhiteSpaceNode(sibling$2, allowSpaces)) return parent$1;
					}
					if (parent$1 === root || parent$1.parentNode === root) {
						container = parent$1;
						break;
					}
					parent$1 = parent$1.parentNode;
				}
				return container;
			};
			const isSelfOrParentBookmark = (container) => isBookmarkNode(container.parentNode) || isBookmarkNode(container);
			const expandRng = (dom$1, rng, formatList, includeTrailingSpace = false) => {
				let { startContainer, startOffset, endContainer, endOffset } = rng;
				const format = formatList[0];
				if (isElement$6(startContainer) && startContainer.hasChildNodes()) {
					startContainer = getNode$1(startContainer, startOffset);
					if (isText$a(startContainer)) startOffset = 0;
				}
				if (isElement$6(endContainer) && endContainer.hasChildNodes()) {
					endContainer = getNode$1(endContainer, rng.collapsed ? endOffset : endOffset - 1);
					if (isText$a(endContainer)) endOffset = endContainer.data.length;
				}
				startContainer = findParentContentEditable(dom$1, startContainer);
				endContainer = findParentContentEditable(dom$1, endContainer);
				if (isSelfOrParentBookmark(startContainer)) {
					startContainer = isBookmarkNode(startContainer) ? startContainer : startContainer.parentNode;
					if (rng.collapsed) startContainer = startContainer.previousSibling || startContainer;
					else startContainer = startContainer.nextSibling || startContainer;
					if (isText$a(startContainer)) startOffset = rng.collapsed ? startContainer.length : 0;
				}
				if (isSelfOrParentBookmark(endContainer)) {
					endContainer = isBookmarkNode(endContainer) ? endContainer : endContainer.parentNode;
					if (rng.collapsed) endContainer = endContainer.nextSibling || endContainer;
					else endContainer = endContainer.previousSibling || endContainer;
					if (isText$a(endContainer)) endOffset = rng.collapsed ? 0 : endContainer.length;
				}
				if (rng.collapsed) {
					findWordEndPoint(dom$1, dom$1.getRoot(), startContainer, startOffset, true, includeTrailingSpace).each(({ container, offset }) => {
						startContainer = container;
						startOffset = offset;
					});
					findWordEndPoint(dom$1, dom$1.getRoot(), endContainer, endOffset, false, includeTrailingSpace).each(({ container, offset }) => {
						endContainer = container;
						endOffset = offset;
					});
				}
				if (isInlineFormat(format) || format.block_expand) {
					if (!isInlineFormat(format) || !isText$a(startContainer) || startOffset === 0) startContainer = findParentContainer(dom$1, formatList, startContainer, startOffset, true);
					if (!isInlineFormat(format) || !isText$a(endContainer) || endOffset === endContainer.data.length) endContainer = findParentContainer(dom$1, formatList, endContainer, endOffset, false);
				}
				if (shouldExpandToSelector(format)) {
					startContainer = findSelectorEndPoint(dom$1, formatList, rng, startContainer, "previousSibling");
					endContainer = findSelectorEndPoint(dom$1, formatList, rng, endContainer, "nextSibling");
				}
				if (isBlockFormat(format) || isSelectorFormat(format)) {
					startContainer = findBlockEndPoint(dom$1, formatList, startContainer, "previousSibling");
					endContainer = findBlockEndPoint(dom$1, formatList, endContainer, "nextSibling");
					if (isBlockFormat(format)) {
						if (!dom$1.isBlock(startContainer)) startContainer = findParentContainer(dom$1, formatList, startContainer, startOffset, true);
						if (!dom$1.isBlock(endContainer)) endContainer = findParentContainer(dom$1, formatList, endContainer, endOffset, false);
					}
				}
				if (isElement$6(startContainer) && startContainer.parentNode) {
					startOffset = dom$1.nodeIndex(startContainer);
					startContainer = startContainer.parentNode;
				}
				if (isElement$6(endContainer) && endContainer.parentNode) {
					endOffset = dom$1.nodeIndex(endContainer) + 1;
					endContainer = endContainer.parentNode;
				}
				return {
					startContainer,
					startOffset,
					endContainer,
					endOffset
				};
			};
			const walk$3 = (dom$1, rng, callback) => {
				var _a;
				const startOffset = rng.startOffset;
				const startContainer = getNode$1(rng.startContainer, startOffset);
				const endOffset = rng.endOffset;
				const endContainer = getNode$1(rng.endContainer, endOffset - 1);
				const exclude = (nodes) => {
					const firstNode = nodes[0];
					if (isText$a(firstNode) && firstNode === startContainer && startOffset >= firstNode.data.length) nodes.splice(0, 1);
					const lastNode = nodes[nodes.length - 1];
					if (endOffset === 0 && nodes.length > 0 && lastNode === endContainer && isText$a(lastNode)) nodes.splice(nodes.length - 1, 1);
					return nodes;
				};
				const collectSiblings = (node, name$1, endNode) => {
					const siblings$2 = [];
					for (; node && node !== endNode; node = node[name$1]) siblings$2.push(node);
					return siblings$2;
				};
				const findEndPoint = (node, root) => dom$1.getParent(node, (node$1) => node$1.parentNode === root, root);
				const walkBoundary = (startNode, endNode, next$1) => {
					const siblingName = next$1 ? "nextSibling" : "previousSibling";
					for (let node = startNode, parent$1 = node.parentNode; node && node !== endNode; node = parent$1) {
						parent$1 = node.parentNode;
						const siblings$2 = collectSiblings(node === startNode ? node : node[siblingName], siblingName);
						if (siblings$2.length) {
							if (!next$1) siblings$2.reverse();
							callback(exclude(siblings$2));
						}
					}
				};
				if (startContainer === endContainer) return callback(exclude([startContainer]));
				const ancestor$5 = (_a = dom$1.findCommonAncestor(startContainer, endContainer)) !== null && _a !== void 0 ? _a : dom$1.getRoot();
				if (dom$1.isChildOf(startContainer, endContainer)) return walkBoundary(startContainer, ancestor$5, true);
				if (dom$1.isChildOf(endContainer, startContainer)) return walkBoundary(endContainer, ancestor$5);
				const startPoint = findEndPoint(startContainer, ancestor$5) || startContainer;
				const endPoint = findEndPoint(endContainer, ancestor$5) || endContainer;
				walkBoundary(startContainer, startPoint, true);
				const siblings$1 = collectSiblings(startPoint === startContainer ? startPoint : startPoint.nextSibling, "nextSibling", endPoint === endContainer ? endPoint.nextSibling : endPoint);
				if (siblings$1.length) callback(exclude(siblings$1));
				walkBoundary(endContainer, endPoint);
			};
			const validBlocks = [
				"pre[class*=language-][contenteditable=\"false\"]",
				"figure.image",
				"div[data-ephox-embed-iri]",
				"div.tiny-pageembed",
				"div.mce-toc",
				"div[data-mce-toc]"
			];
			const isZeroWidth = (elem) => isText$b(elem) && get$3(elem) === ZWSP$1;
			const context = (editor, elem, wrapName, nodeName) => parent(elem).fold(() => "skipping", (parent$1) => {
				if (nodeName === "br" || isZeroWidth(elem)) return "valid";
				else if (isAnnotation(elem)) return "existing";
				else if (isCaretNode(elem.dom)) return "caret";
				else if (exists(validBlocks, (selector) => is$1(elem, selector))) return "valid-block";
				else if (!isValid(editor, wrapName, nodeName) || !isValid(editor, name(parent$1), wrapName)) return "invalid-child";
				else return "valid";
			});
			const applyWordGrab = (editor, rng) => {
				const r$1 = expandRng(editor.dom, rng, [{ inline: "span" }]);
				rng.setStart(r$1.startContainer, r$1.startOffset);
				rng.setEnd(r$1.endContainer, r$1.endOffset);
				editor.selection.setRng(rng);
			};
			const applyAnnotation = (elem, masterUId, data$1, annotationName, decorate, directAnnotation) => {
				const { uid: uid$1 = masterUId, ...otherData } = data$1;
				add$2(elem, annotation());
				set$3(elem, `${dataAnnotationId()}`, uid$1);
				set$3(elem, `${dataAnnotation()}`, annotationName);
				const { attributes = {}, classes = [] } = decorate(uid$1, otherData);
				setAll$1(elem, attributes);
				add(elem, classes);
				if (directAnnotation) {
					if (classes.length > 0) set$3(elem, `${dataAnnotationClasses()}`, classes.join(","));
					const attributeNames = keys(attributes);
					if (attributeNames.length > 0) set$3(elem, `${dataAnnotationAttributes()}`, attributeNames.join(","));
				}
			};
			const removeDirectAnnotation = (elem) => {
				remove$7(elem, annotation());
				remove$a(elem, `${dataAnnotationId()}`);
				remove$a(elem, `${dataAnnotation()}`);
				remove$a(elem, `${dataAnnotationActive()}`);
				const customAttrNames = getOpt(elem, `${dataAnnotationAttributes()}`).map((names) => names.split(",")).getOr([]);
				const customClasses = getOpt(elem, `${dataAnnotationClasses()}`).map((names) => names.split(",")).getOr([]);
				each$e(customAttrNames, (name$1) => remove$a(elem, name$1));
				remove$4(elem, customClasses);
				remove$a(elem, `${dataAnnotationClasses()}`);
				remove$a(elem, `${dataAnnotationAttributes()}`);
			};
			const makeAnnotation = (eDoc, uid$1, data$1, annotationName, decorate) => {
				const master = SugarElement.fromTag("span", eDoc);
				applyAnnotation(master, uid$1, data$1, annotationName, decorate, false);
				return master;
			};
			const annotate = (editor, rng, uid$1, annotationName, decorate, data$1) => {
				const newWrappers = [];
				const master = makeAnnotation(editor.getDoc(), uid$1, data$1, annotationName, decorate);
				const wrapper = value$2();
				const finishWrapper = () => {
					wrapper.clear();
				};
				const getOrOpenWrapper = () => wrapper.get().getOrThunk(() => {
					const nu$4 = shallow$1(master);
					newWrappers.push(nu$4);
					wrapper.set(nu$4);
					return nu$4;
				});
				const processElements = (elems) => {
					each$e(elems, processElement);
				};
				const processElement = (elem) => {
					switch (context(editor, elem, "span", name(elem))) {
						case "invalid-child":
							finishWrapper();
							processElements(children$1(elem));
							finishWrapper();
							break;
						case "valid-block":
							finishWrapper();
							applyAnnotation(elem, uid$1, data$1, annotationName, decorate, true);
							break;
						case "valid":
							wrap$2(elem, getOrOpenWrapper());
							break;
					}
				};
				const processNodes = (nodes) => {
					processElements(map$3(nodes, SugarElement.fromDom));
				};
				walk$3(editor.dom, rng, (nodes) => {
					finishWrapper();
					processNodes(nodes);
				});
				return newWrappers;
			};
			const annotateWithBookmark = (editor, name$1, settings, data$1) => {
				editor.undoManager.transact(() => {
					const selection = editor.selection;
					const initialRng = selection.getRng();
					const hasFakeSelection = getCellsFromEditor(editor).length > 0;
					const masterUid = generate$1("mce-annotation");
					if (initialRng.collapsed && !hasFakeSelection) applyWordGrab(editor, initialRng);
					if (selection.getRng().collapsed && !hasFakeSelection) {
						const wrapper = makeAnnotation(editor.getDoc(), masterUid, data$1, name$1, settings.decorate);
						set$1(wrapper, nbsp);
						selection.getRng().insertNode(wrapper.dom);
						selection.select(wrapper.dom);
					} else preserve(selection, false, () => {
						runOnRanges(editor, (selectionRng) => {
							annotate(editor, selectionRng, masterUid, name$1, settings.decorate, data$1);
						});
					});
				});
			};
			const Annotator = (editor) => {
				const registry$1 = create$c();
				setup$w(editor, registry$1);
				const changes = setup$x(editor, registry$1);
				const isSpan$1 = isTag("span");
				const removeAnnotations = (elements) => {
					each$e(elements, (element) => {
						if (isSpan$1(element)) unwrap(element);
						else removeDirectAnnotation(element);
					});
				};
				return {
					register: (name$1, settings) => {
						registry$1.register(name$1, settings);
					},
					annotate: (name$1, data$1) => {
						registry$1.lookup(name$1).each((settings) => {
							annotateWithBookmark(editor, name$1, settings, data$1);
						});
					},
					annotationChanged: (name$1, callback) => {
						changes.addListener(name$1, callback);
					},
					remove: (name$1) => {
						identify(editor, Optional.some(name$1)).each(({ elements }) => {
							const bookmark = editor.selection.getBookmark();
							removeAnnotations(elements);
							editor.selection.moveToBookmark(bookmark);
						});
					},
					removeAll: (name$1) => {
						const bookmark = editor.selection.getBookmark();
						each$d(findAll(editor, name$1), (elements, _) => {
							removeAnnotations(elements);
						});
						editor.selection.moveToBookmark(bookmark);
					},
					getAll: (name$1) => {
						return map$2(findAll(editor, name$1), (elems) => map$3(elems, (elem) => elem.dom));
					}
				};
			};
			const BookmarkManager = (selection) => {
				return {
					getBookmark: curry(getBookmark$1, selection),
					moveToBookmark: curry(moveToBookmark, selection)
				};
			};
			BookmarkManager.isBookmarkNode = isBookmarkNode$1;
			const isXYWithinRange = (clientX, clientY, range) => {
				if (range.collapsed) return false;
				else return exists(range.getClientRects(), (rect) => containsXY(rect, clientX, clientY));
			};
			const firePreProcess = (editor, args) => editor.dispatch("PreProcess", args);
			const firePostProcess = (editor, args) => editor.dispatch("PostProcess", args);
			const fireRemove = (editor) => {
				editor.dispatch("remove");
			};
			const fireDetach = (editor) => {
				editor.dispatch("detach");
			};
			const fireSwitchMode = (editor, mode) => {
				editor.dispatch("SwitchMode", { mode });
			};
			const fireObjectResizeStart = (editor, target, width, height, origin) => {
				editor.dispatch("ObjectResizeStart", {
					target,
					width,
					height,
					origin
				});
			};
			const fireObjectResized = (editor, target, width, height, origin) => {
				editor.dispatch("ObjectResized", {
					target,
					width,
					height,
					origin
				});
			};
			const firePreInit = (editor) => {
				editor.dispatch("PreInit");
			};
			const firePostRender = (editor) => {
				editor.dispatch("PostRender");
			};
			const fireInit = (editor) => {
				editor.dispatch("Init");
			};
			const firePlaceholderToggle = (editor, state) => {
				editor.dispatch("PlaceholderToggle", { state });
			};
			const fireError = (editor, errorType, error$1) => {
				editor.dispatch(errorType, error$1);
			};
			const fireFormatApply = (editor, format, node, vars) => {
				editor.dispatch("FormatApply", {
					format,
					node,
					vars
				});
			};
			const fireFormatRemove = (editor, format, node, vars) => {
				editor.dispatch("FormatRemove", {
					format,
					node,
					vars
				});
			};
			const fireBeforeSetContent = (editor, args) => editor.dispatch("BeforeSetContent", args);
			const fireSetContent = (editor, args) => editor.dispatch("SetContent", args);
			const fireBeforeGetContent = (editor, args) => editor.dispatch("BeforeGetContent", args);
			const fireGetContent = (editor, args) => editor.dispatch("GetContent", args);
			const fireAutocompleterStart = (editor, args) => {
				editor.dispatch("AutocompleterStart", args);
			};
			const fireAutocompleterUpdate = (editor, args) => {
				editor.dispatch("AutocompleterUpdate", args);
			};
			const fireAutocompleterEnd = (editor) => {
				editor.dispatch("AutocompleterEnd");
			};
			const firePastePreProcess = (editor, html$2, internal) => editor.dispatch("PastePreProcess", {
				content: html$2,
				internal
			});
			const firePastePostProcess = (editor, node, internal) => editor.dispatch("PastePostProcess", {
				node,
				internal
			});
			const firePastePlainTextToggle = (editor, state) => editor.dispatch("PastePlainTextToggle", { state });
			const fireEditableRootStateChange = (editor, state) => editor.dispatch("EditableRootStateChange", { state });
			const VK = {
				BACKSPACE: 8,
				DELETE: 46,
				DOWN: 40,
				ENTER: 13,
				ESC: 27,
				LEFT: 37,
				RIGHT: 39,
				SPACEBAR: 32,
				TAB: 9,
				UP: 38,
				PAGE_UP: 33,
				PAGE_DOWN: 34,
				END: 35,
				HOME: 36,
				modifierPressed: (e) => {
					return e.shiftKey || e.ctrlKey || e.altKey || VK.metaKeyPressed(e);
				},
				metaKeyPressed: (e) => {
					return Env.os.isMacOS() || Env.os.isiOS() ? e.metaKey : e.ctrlKey && !e.altKey;
				}
			};
			const elementSelectionAttr = "data-mce-selected";
			const controlElmSelector = "table,img,figure.image,hr,video,span.mce-preview-object,details";
			const abs = Math.abs;
			const round$1 = Math.round;
			const resizeHandles = {
				nw: [
					0,
					0,
					-1,
					-1
				],
				ne: [
					1,
					0,
					1,
					-1
				],
				se: [
					1,
					1,
					1,
					1
				],
				sw: [
					0,
					1,
					-1,
					1
				]
			};
			const isTouchEvent = (evt) => evt.type === "longpress" || evt.type.indexOf("touch") === 0;
			const ControlSelection = (selection, editor) => {
				const dom$1 = editor.dom;
				const editableDoc = editor.getDoc();
				const rootDocument = document;
				const rootElement = editor.getBody();
				let selectedElm, selectedElmGhost, resizeHelper, selectedHandle, resizeBackdrop;
				let startX, startY, selectedElmX, selectedElmY, startW, startH, ratio, resizeStarted;
				let width;
				let height;
				let startScrollWidth;
				let startScrollHeight;
				const isImage$1 = (elm) => isNonNullable(elm) && (isImg(elm) || dom$1.is(elm, "figure.image"));
				const isMedia$3 = (elm) => isMedia$2(elm) || dom$1.hasClass(elm, "mce-preview-object");
				const isEventOnImageOutsideRange = (evt, range) => {
					if (isTouchEvent(evt)) {
						const touch = evt.touches[0];
						return isImage$1(evt.target) && !isXYWithinRange(touch.clientX, touch.clientY, range);
					} else return isImage$1(evt.target) && !isXYWithinRange(evt.clientX, evt.clientY, range);
				};
				const contextMenuSelectImage = (evt) => {
					const target = evt.target;
					if (isEventOnImageOutsideRange(evt, editor.selection.getRng()) && !evt.isDefaultPrevented()) editor.selection.select(target);
				};
				const getResizeTargets = (elm) => {
					if (dom$1.hasClass(elm, "mce-preview-object") && isNonNullable(elm.firstElementChild)) return [elm, elm.firstElementChild];
					else if (dom$1.is(elm, "figure.image")) return [elm.querySelector("img")];
					else return [elm];
				};
				const isResizable = (elm) => {
					const selector = getObjectResizing(editor);
					if (!selector) return false;
					if (elm.getAttribute("data-mce-resize") === "false") return false;
					if (elm === editor.getBody()) return false;
					if (dom$1.hasClass(elm, "mce-preview-object") && isNonNullable(elm.firstElementChild)) return is$1(SugarElement.fromDom(elm.firstElementChild), selector);
					else return is$1(SugarElement.fromDom(elm), selector);
				};
				const createGhostElement = (elm) => {
					if (isMedia$3(elm)) return dom$1.create("img", { src: Env.transparentSrc });
					else return elm.cloneNode(true);
				};
				const setSizeProp = (element, name$1, value$3) => {
					if (isNonNullable(value$3)) each$e(getResizeTargets(element), (target) => {
						if (target.style[name$1] || !editor.schema.isValid(target.nodeName.toLowerCase(), name$1)) dom$1.setStyle(target, name$1, value$3);
						else dom$1.setAttrib(target, name$1, "" + value$3);
					});
				};
				const setGhostElmSize = (ghostElm, width$1, height$1) => {
					setSizeProp(ghostElm, "width", width$1);
					setSizeProp(ghostElm, "height", height$1);
				};
				const resizeGhostElement = (e) => {
					let deltaX, deltaY, proportional;
					let resizeHelperX, resizeHelperY;
					deltaX = e.screenX - startX;
					deltaY = e.screenY - startY;
					width = deltaX * selectedHandle[2] + startW;
					height = deltaY * selectedHandle[3] + startH;
					width = width < 5 ? 5 : width;
					height = height < 5 ? 5 : height;
					if ((isImage$1(selectedElm) || isMedia$3(selectedElm)) && getResizeImgProportional(editor) !== false) proportional = !VK.modifierPressed(e);
					else proportional = VK.modifierPressed(e);
					if (proportional) if (abs(deltaX) > abs(deltaY)) {
						height = round$1(width * ratio);
						width = round$1(height / ratio);
					} else {
						width = round$1(height / ratio);
						height = round$1(width * ratio);
					}
					setGhostElmSize(selectedElmGhost, width, height);
					resizeHelperX = selectedHandle.startPos.x + deltaX;
					resizeHelperY = selectedHandle.startPos.y + deltaY;
					resizeHelperX = resizeHelperX > 0 ? resizeHelperX : 0;
					resizeHelperY = resizeHelperY > 0 ? resizeHelperY : 0;
					dom$1.setStyles(resizeHelper, {
						left: resizeHelperX,
						top: resizeHelperY,
						display: "block"
					});
					resizeHelper.innerHTML = width + " &times; " + height;
					if (selectedHandle[2] < 0 && selectedElmGhost.clientWidth <= width) dom$1.setStyle(selectedElmGhost, "left", selectedElmX + (startW - width));
					if (selectedHandle[3] < 0 && selectedElmGhost.clientHeight <= height) dom$1.setStyle(selectedElmGhost, "top", selectedElmY + (startH - height));
					deltaX = rootElement.scrollWidth - startScrollWidth;
					deltaY = rootElement.scrollHeight - startScrollHeight;
					if (deltaX + deltaY !== 0) dom$1.setStyles(resizeHelper, {
						left: resizeHelperX - deltaX,
						top: resizeHelperY - deltaY
					});
					if (!resizeStarted) {
						fireObjectResizeStart(editor, selectedElm, startW, startH, "corner-" + selectedHandle.name);
						resizeStarted = true;
					}
				};
				const endGhostResize = () => {
					const wasResizeStarted = resizeStarted;
					resizeStarted = false;
					if (wasResizeStarted) {
						setSizeProp(selectedElm, "width", width);
						setSizeProp(selectedElm, "height", height);
					}
					dom$1.unbind(editableDoc, "mousemove", resizeGhostElement);
					dom$1.unbind(editableDoc, "mouseup", endGhostResize);
					if (rootDocument !== editableDoc) {
						dom$1.unbind(rootDocument, "mousemove", resizeGhostElement);
						dom$1.unbind(rootDocument, "mouseup", endGhostResize);
					}
					dom$1.remove(selectedElmGhost);
					dom$1.remove(resizeHelper);
					dom$1.remove(resizeBackdrop);
					showResizeRect(selectedElm);
					if (wasResizeStarted) {
						fireObjectResized(editor, selectedElm, width, height, "corner-" + selectedHandle.name);
						dom$1.setAttrib(selectedElm, "style", dom$1.getAttrib(selectedElm, "style"));
					}
					editor.nodeChanged();
				};
				const showResizeRect = (targetElm) => {
					unbindResizeHandleEvents();
					const position = dom$1.getPos(targetElm, rootElement);
					const selectedElmX$1 = position.x;
					const selectedElmY$1 = position.y;
					const rect = targetElm.getBoundingClientRect();
					const targetWidth = rect.width || rect.right - rect.left;
					const targetHeight = rect.height || rect.bottom - rect.top;
					if (selectedElm !== targetElm) {
						hideResizeRect();
						selectedElm = targetElm;
						width = height = 0;
					}
					const e = editor.dispatch("ObjectSelected", { target: targetElm });
					if (isResizable(targetElm) && !e.isDefaultPrevented()) each$d(resizeHandles, (handle$2, name$1) => {
						const startDrag = (e$1) => {
							const target = getResizeTargets(selectedElm)[0];
							startX = e$1.screenX;
							startY = e$1.screenY;
							startW = target.clientWidth;
							startH = target.clientHeight;
							ratio = startH / startW;
							selectedHandle = handle$2;
							selectedHandle.name = name$1;
							selectedHandle.startPos = {
								x: targetWidth * handle$2[0] + selectedElmX$1,
								y: targetHeight * handle$2[1] + selectedElmY$1
							};
							startScrollWidth = rootElement.scrollWidth;
							startScrollHeight = rootElement.scrollHeight;
							resizeBackdrop = dom$1.add(rootElement, "div", {
								"class": "mce-resize-backdrop",
								"data-mce-bogus": "all"
							});
							dom$1.setStyles(resizeBackdrop, {
								position: "fixed",
								left: "0",
								top: "0",
								width: "100%",
								height: "100%"
							});
							selectedElmGhost = createGhostElement(selectedElm);
							dom$1.addClass(selectedElmGhost, "mce-clonedresizable");
							dom$1.setAttrib(selectedElmGhost, "data-mce-bogus", "all");
							selectedElmGhost.contentEditable = "false";
							dom$1.setStyles(selectedElmGhost, {
								left: selectedElmX$1,
								top: selectedElmY$1,
								margin: 0
							});
							setGhostElmSize(selectedElmGhost, targetWidth, targetHeight);
							selectedElmGhost.removeAttribute(elementSelectionAttr);
							rootElement.appendChild(selectedElmGhost);
							dom$1.bind(editableDoc, "mousemove", resizeGhostElement);
							dom$1.bind(editableDoc, "mouseup", endGhostResize);
							if (rootDocument !== editableDoc) {
								dom$1.bind(rootDocument, "mousemove", resizeGhostElement);
								dom$1.bind(rootDocument, "mouseup", endGhostResize);
							}
							resizeHelper = dom$1.add(rootElement, "div", {
								"class": "mce-resize-helper",
								"data-mce-bogus": "all"
							}, startW + " &times; " + startH);
						};
						let handleElm = dom$1.get("mceResizeHandle" + name$1);
						if (handleElm) dom$1.remove(handleElm);
						handleElm = dom$1.add(rootElement, "div", {
							"id": "mceResizeHandle" + name$1,
							"data-mce-bogus": "all",
							"class": "mce-resizehandle",
							"unselectable": true,
							"style": "cursor:" + name$1 + "-resize; margin:0; padding:0"
						});
						dom$1.bind(handleElm, "mousedown", (e$1) => {
							e$1.stopImmediatePropagation();
							e$1.preventDefault();
							startDrag(e$1);
						});
						handle$2.elm = handleElm;
						dom$1.setStyles(handleElm, {
							left: targetWidth * handle$2[0] + selectedElmX$1 - handleElm.offsetWidth / 2,
							top: targetHeight * handle$2[1] + selectedElmY$1 - handleElm.offsetHeight / 2
						});
					});
					else hideResizeRect(false);
				};
				const throttledShowResizeRect = first$1(showResizeRect, 0);
				const hideResizeRect = (removeSelected = true) => {
					throttledShowResizeRect.cancel();
					unbindResizeHandleEvents();
					if (selectedElm && removeSelected) selectedElm.removeAttribute(elementSelectionAttr);
					each$d(resizeHandles, (value$3, name$1) => {
						const handleElm = dom$1.get("mceResizeHandle" + name$1);
						if (handleElm) {
							dom$1.unbind(handleElm);
							dom$1.remove(handleElm);
						}
					});
				};
				const isChildOrEqual = (node, parent$1) => dom$1.isChildOf(node, parent$1);
				const updateResizeRect = (e) => {
					if (resizeStarted || editor.removed || editor.composing) return;
					const targetElm = e.type === "mousedown" ? e.target : selection.getNode();
					const controlElm = closest$3(SugarElement.fromDom(targetElm), controlElmSelector).map((e$1) => e$1.dom).filter((e$1) => dom$1.isEditable(e$1.parentElement)).getOrUndefined();
					const selectedValue = isNonNullable(controlElm) ? dom$1.getAttrib(controlElm, elementSelectionAttr, "1") : "1";
					each$e(dom$1.select(`img[${elementSelectionAttr}],hr[${elementSelectionAttr}]`), (img) => {
						img.removeAttribute(elementSelectionAttr);
					});
					if (isNonNullable(controlElm) && isChildOrEqual(controlElm, rootElement) && editor.hasFocus()) {
						disableGeckoResize();
						if (isChildOrEqual(selection.getStart(true), controlElm) && isChildOrEqual(selection.getEnd(true), controlElm)) {
							dom$1.setAttrib(controlElm, elementSelectionAttr, selectedValue);
							throttledShowResizeRect.throttle(controlElm);
							return;
						}
					}
					hideResizeRect();
				};
				const unbindResizeHandleEvents = () => {
					each$d(resizeHandles, (handle$2) => {
						if (handle$2.elm) {
							dom$1.unbind(handle$2.elm);
							delete handle$2.elm;
						}
					});
				};
				const disableGeckoResize = () => {
					try {
						editor.getDoc().execCommand("enableObjectResizing", false, "false");
					} catch (ex) {}
				};
				editor.on("init", () => {
					disableGeckoResize();
					editor.on("NodeChange ResizeEditor ResizeWindow ResizeContent drop", updateResizeRect);
					editor.on("keyup compositionend", (e) => {
						if (selectedElm && selectedElm.nodeName === "TABLE") updateResizeRect(e);
					});
					editor.on("hide blur", hideResizeRect);
					editor.on("contextmenu longpress", contextMenuSelectImage, true);
				});
				editor.on("remove", unbindResizeHandleEvents);
				const destroy$1 = () => {
					throttledShowResizeRect.cancel();
					selectedElm = selectedElmGhost = resizeBackdrop = null;
				};
				return {
					isResizable,
					showResizeRect,
					hideResizeRect,
					updateResizeRect,
					destroy: destroy$1
				};
			};
			const setStart = (rng, situ) => {
				situ.fold((e) => {
					rng.setStartBefore(e.dom);
				}, (e, o) => {
					rng.setStart(e.dom, o);
				}, (e) => {
					rng.setStartAfter(e.dom);
				});
			};
			const setFinish = (rng, situ) => {
				situ.fold((e) => {
					rng.setEndBefore(e.dom);
				}, (e, o) => {
					rng.setEnd(e.dom, o);
				}, (e) => {
					rng.setEndAfter(e.dom);
				});
			};
			const relativeToNative = (win, startSitu, finishSitu) => {
				const range = win.document.createRange();
				setStart(range, startSitu);
				setFinish(range, finishSitu);
				return range;
			};
			const exactToNative = (win, start$2, soffset, finish, foffset) => {
				const rng = win.document.createRange();
				rng.setStart(start$2.dom, soffset);
				rng.setEnd(finish.dom, foffset);
				return rng;
			};
			const adt$3 = Adt.generate([{ ltr: [
				"start",
				"soffset",
				"finish",
				"foffset"
			] }, { rtl: [
				"start",
				"soffset",
				"finish",
				"foffset"
			] }]);
			const fromRange = (win, type$2, range) => type$2(SugarElement.fromDom(range.startContainer), range.startOffset, SugarElement.fromDom(range.endContainer), range.endOffset);
			const getRanges = (win, selection) => selection.match({
				domRange: (rng) => {
					return {
						ltr: constant(rng),
						rtl: Optional.none
					};
				},
				relative: (startSitu, finishSitu) => {
					return {
						ltr: cached(() => relativeToNative(win, startSitu, finishSitu)),
						rtl: cached(() => Optional.some(relativeToNative(win, finishSitu, startSitu)))
					};
				},
				exact: (start$2, soffset, finish, foffset) => {
					return {
						ltr: cached(() => exactToNative(win, start$2, soffset, finish, foffset)),
						rtl: cached(() => Optional.some(exactToNative(win, finish, foffset, start$2, soffset)))
					};
				}
			});
			const doDiagnose = (win, ranges) => {
				const rng = ranges.ltr();
				if (rng.collapsed) return ranges.rtl().filter((rev) => rev.collapsed === false).map((rev) => adt$3.rtl(SugarElement.fromDom(rev.endContainer), rev.endOffset, SugarElement.fromDom(rev.startContainer), rev.startOffset)).getOrThunk(() => fromRange(win, adt$3.ltr, rng));
				else return fromRange(win, adt$3.ltr, rng);
			};
			const diagnose = (win, selection) => {
				return doDiagnose(win, getRanges(win, selection));
			};
			adt$3.ltr;
			adt$3.rtl;
			const create$a = (start$2, soffset, finish, foffset) => ({
				start: start$2,
				soffset,
				finish,
				foffset
			});
			const SimRange = { create: create$a };
			const caretPositionFromPoint = (doc, x, y) => {
				var _a, _b;
				return Optional.from((_b = (_a = doc.dom).caretPositionFromPoint) === null || _b === void 0 ? void 0 : _b.call(_a, x, y)).bind((pos) => {
					if (pos.offsetNode === null) return Optional.none();
					const r$1 = doc.dom.createRange();
					r$1.setStart(pos.offsetNode, pos.offset);
					r$1.collapse();
					return Optional.some(r$1);
				});
			};
			const caretRangeFromPoint = (doc, x, y) => {
				var _a, _b;
				return Optional.from((_b = (_a = doc.dom).caretRangeFromPoint) === null || _b === void 0 ? void 0 : _b.call(_a, x, y));
			};
			const availableSearch = (() => {
				if (document.caretPositionFromPoint) return caretPositionFromPoint;
				else if (document.caretRangeFromPoint) return caretRangeFromPoint;
				else return Optional.none;
			})();
			const fromPoint$1 = (win, x, y) => {
				return availableSearch(SugarElement.fromDom(win.document), x, y).map((rng) => SimRange.create(SugarElement.fromDom(rng.startContainer), rng.startOffset, SugarElement.fromDom(rng.endContainer), rng.endOffset));
			};
			const adt$2 = Adt.generate([
				{ before: ["element"] },
				{ on: ["element", "offset"] },
				{ after: ["element"] }
			]);
			const cata = (subject, onBefore, onOn, onAfter) => subject.fold(onBefore, onOn, onAfter);
			const getStart$2 = (situ) => situ.fold(identity, identity, identity);
			const Situ = {
				before: adt$2.before,
				on: adt$2.on,
				after: adt$2.after,
				cata,
				getStart: getStart$2
			};
			const adt$1 = Adt.generate([
				{ domRange: ["rng"] },
				{ relative: ["startSitu", "finishSitu"] },
				{ exact: [
					"start",
					"soffset",
					"finish",
					"foffset"
				] }
			]);
			const exactFromRange = (simRange) => adt$1.exact(simRange.start, simRange.soffset, simRange.finish, simRange.foffset);
			const getStart$1 = (selection) => selection.match({
				domRange: (rng) => SugarElement.fromDom(rng.startContainer),
				relative: (startSitu, _finishSitu) => Situ.getStart(startSitu),
				exact: (start$2, _soffset, _finish, _foffset) => start$2
			});
			const domRange = adt$1.domRange;
			const relative = adt$1.relative;
			const exact = adt$1.exact;
			const getWin = (selection) => {
				return defaultView(getStart$1(selection));
			};
			const SimSelection = {
				domRange,
				relative,
				exact,
				exactFromRange,
				getWin,
				range: SimRange.create
			};
			const beforeSpecial = (element, offset) => {
				const name$1 = name(element);
				if ("input" === name$1) return Situ.after(element);
				else if (!contains$2(["br", "img"], name$1)) return Situ.on(element, offset);
				else return offset === 0 ? Situ.before(element) : Situ.after(element);
			};
			const preprocessRelative = (startSitu, finishSitu) => {
				const start$2 = startSitu.fold(Situ.before, beforeSpecial, Situ.after);
				const finish = finishSitu.fold(Situ.before, beforeSpecial, Situ.after);
				return SimSelection.relative(start$2, finish);
			};
			const preprocessExact = (start$2, soffset, finish, foffset) => {
				const startSitu = beforeSpecial(start$2, soffset);
				const finishSitu = beforeSpecial(finish, foffset);
				return SimSelection.relative(startSitu, finishSitu);
			};
			const preprocess = (selection) => selection.match({
				domRange: (rng) => {
					const start$2 = SugarElement.fromDom(rng.startContainer);
					const finish = SugarElement.fromDom(rng.endContainer);
					return preprocessExact(start$2, rng.startOffset, finish, rng.endOffset);
				},
				relative: preprocessRelative,
				exact: preprocessExact
			});
			const fromElements = (elements, scope) => {
				const fragment = (scope || document).createDocumentFragment();
				each$e(elements, (element) => {
					fragment.appendChild(element.dom);
				});
				return SugarElement.fromDom(fragment);
			};
			const toNative = (selection) => {
				const win = SimSelection.getWin(selection).dom;
				const getDomRange = (start$2, soffset, finish, foffset) => exactToNative(win, start$2, soffset, finish, foffset);
				return diagnose(win, preprocess(selection)).match({
					ltr: getDomRange,
					rtl: getDomRange
				});
			};
			const getAtPoint = (win, x, y) => fromPoint$1(win, x, y);
			const fromPoint = (clientX, clientY, doc) => {
				return getAtPoint(defaultView(SugarElement.fromDom(doc)).dom, clientX, clientY).map((simRange) => {
					const rng = doc.createRange();
					rng.setStart(simRange.start.dom, simRange.soffset);
					rng.setEnd(simRange.finish.dom, simRange.foffset);
					return rng;
				}).getOrUndefined();
			};
			const isEq$4 = (rng1, rng2) => {
				return isNonNullable(rng1) && isNonNullable(rng2) && rng1.startContainer === rng2.startContainer && rng1.startOffset === rng2.startOffset && rng1.endContainer === rng2.endContainer && rng1.endOffset === rng2.endOffset;
			};
			const findParent = (node, rootNode, predicate) => {
				let currentNode = node;
				while (currentNode && currentNode !== rootNode) {
					if (predicate(currentNode)) return currentNode;
					currentNode = currentNode.parentNode;
				}
				return null;
			};
			const hasParent$1 = (node, rootNode, predicate) => findParent(node, rootNode, predicate) !== null;
			const hasParentWithName = (node, rootNode, name$1) => hasParent$1(node, rootNode, (node$1) => node$1.nodeName === name$1);
			const isCeFalseCaretContainer = (node, rootNode) => isCaretContainer$2(node) && !hasParent$1(node, rootNode, isCaretNode);
			const hasBrBeforeAfter = (dom$1, node, left) => {
				const parentNode = node.parentNode;
				if (parentNode) {
					const walker = new DomTreeWalker(node, dom$1.getParent(parentNode, dom$1.isBlock) || dom$1.getRoot());
					let currentNode;
					while (currentNode = walker[left ? "prev" : "next"]()) if (isBr$6(currentNode)) return true;
				}
				return false;
			};
			const isPrevNode = (node, name$1) => {
				var _a;
				return ((_a = node.previousSibling) === null || _a === void 0 ? void 0 : _a.nodeName) === name$1;
			};
			const hasContentEditableFalseParent = (root, node) => {
				let currentNode = node;
				while (currentNode && currentNode !== root) {
					if (isContentEditableFalse$b(currentNode)) return true;
					currentNode = currentNode.parentNode;
				}
				return false;
			};
			const findTextNodeRelative = (dom$1, isAfterNode, collapsed, left, startNode) => {
				const body = dom$1.getRoot();
				const nonEmptyElementsMap = dom$1.schema.getNonEmptyElements();
				const parentNode = startNode.parentNode;
				let lastInlineElement;
				let node;
				if (!parentNode) return Optional.none();
				const parentBlockContainer = dom$1.getParent(parentNode, dom$1.isBlock) || body;
				if (left && isBr$6(startNode) && isAfterNode && dom$1.isEmpty(parentBlockContainer)) return Optional.some(CaretPosition(parentNode, dom$1.nodeIndex(startNode)));
				const walker = new DomTreeWalker(startNode, parentBlockContainer);
				while (node = walker[left ? "prev" : "next"]()) {
					if (dom$1.getContentEditableParent(node) === "false" || isCeFalseCaretContainer(node, body)) return Optional.none();
					if (isText$a(node) && node.data.length > 0) {
						if (!hasParentWithName(node, body, "A")) return Optional.some(CaretPosition(node, left ? node.data.length : 0));
						return Optional.none();
					}
					if (dom$1.isBlock(node) || nonEmptyElementsMap[node.nodeName.toLowerCase()]) return Optional.none();
					lastInlineElement = node;
				}
				if (isComment(lastInlineElement)) return Optional.none();
				if (collapsed && lastInlineElement) return Optional.some(CaretPosition(lastInlineElement, 0));
				return Optional.none();
			};
			const normalizeEndPoint = (dom$1, collapsed, start$2, rng) => {
				const body = dom$1.getRoot();
				let node;
				let normalized = false;
				let container = start$2 ? rng.startContainer : rng.endContainer;
				let offset = start$2 ? rng.startOffset : rng.endOffset;
				const isAfterNode = isElement$6(container) && offset === container.childNodes.length;
				const nonEmptyElementsMap = dom$1.schema.getNonEmptyElements();
				let directionLeft = start$2;
				if (isCaretContainer$2(container)) return Optional.none();
				if (isElement$6(container) && offset > container.childNodes.length - 1) directionLeft = false;
				if (isDocument$1(container)) {
					container = body;
					offset = 0;
				}
				if (container === body) {
					if (directionLeft) {
						node = container.childNodes[offset > 0 ? offset - 1 : 0];
						if (node) {
							if (isCaretContainer$2(node)) return Optional.none();
							if (nonEmptyElementsMap[node.nodeName] || isTable$2(node)) return Optional.none();
						}
					}
					if (container.hasChildNodes()) {
						offset = Math.min(!directionLeft && offset > 0 ? offset - 1 : offset, container.childNodes.length - 1);
						container = container.childNodes[offset];
						offset = isText$a(container) && isAfterNode ? container.data.length : 0;
						if (!collapsed && container === body.lastChild && isTable$2(container)) return Optional.none();
						if (hasContentEditableFalseParent(body, container) || isCaretContainer$2(container)) return Optional.none();
						if (container.hasChildNodes() && !isTable$2(container)) {
							node = container;
							const walker = new DomTreeWalker(container, body);
							do {
								if (isContentEditableFalse$b(node) || isCaretContainer$2(node)) {
									normalized = false;
									break;
								}
								if (isText$a(node) && node.data.length > 0) {
									offset = directionLeft ? 0 : node.data.length;
									container = node;
									normalized = true;
									break;
								}
								if (nonEmptyElementsMap[node.nodeName.toLowerCase()] && !isTableCellOrCaption(node)) {
									offset = dom$1.nodeIndex(node);
									container = node.parentNode;
									if (!directionLeft) offset++;
									normalized = true;
									break;
								}
							} while (node = directionLeft ? walker.next() : walker.prev());
						}
					}
				}
				if (collapsed) {
					if (isText$a(container) && offset === 0) findTextNodeRelative(dom$1, isAfterNode, collapsed, true, container).each((pos) => {
						container = pos.container();
						offset = pos.offset();
						normalized = true;
					});
					if (isElement$6(container)) {
						node = container.childNodes[offset];
						if (!node) node = container.childNodes[offset - 1];
						if (node && isBr$6(node) && !isPrevNode(node, "A") && !hasBrBeforeAfter(dom$1, node, false) && !hasBrBeforeAfter(dom$1, node, true)) findTextNodeRelative(dom$1, isAfterNode, collapsed, true, node).each((pos) => {
							container = pos.container();
							offset = pos.offset();
							normalized = true;
						});
					}
				}
				if (directionLeft && !collapsed && isText$a(container) && offset === container.data.length) findTextNodeRelative(dom$1, isAfterNode, collapsed, false, container).each((pos) => {
					container = pos.container();
					offset = pos.offset();
					normalized = true;
				});
				return normalized && container ? Optional.some(CaretPosition(container, offset)) : Optional.none();
			};
			const normalize$2 = (dom$1, rng) => {
				const collapsed = rng.collapsed, normRng = rng.cloneRange();
				const startPos = CaretPosition.fromRangeStart(rng);
				normalizeEndPoint(dom$1, collapsed, true, normRng).each((pos) => {
					if (!collapsed || !CaretPosition.isAbove(startPos, pos)) normRng.setStart(pos.container(), pos.offset());
				});
				if (!collapsed) normalizeEndPoint(dom$1, collapsed, false, normRng).each((pos) => {
					normRng.setEnd(pos.container(), pos.offset());
				});
				if (collapsed) normRng.collapse(true);
				return isEq$4(rng, normRng) ? Optional.none() : Optional.some(normRng);
			};
			const splitText = (node, offset) => {
				return node.splitText(offset);
			};
			const split = (rng) => {
				let startContainer = rng.startContainer, startOffset = rng.startOffset, endContainer = rng.endContainer, endOffset = rng.endOffset;
				if (startContainer === endContainer && isText$a(startContainer)) {
					if (startOffset > 0 && startOffset < startContainer.data.length) {
						endContainer = splitText(startContainer, startOffset);
						startContainer = endContainer.previousSibling;
						if (endOffset > startOffset) {
							endOffset = endOffset - startOffset;
							const newContainer = splitText(endContainer, endOffset).previousSibling;
							startContainer = endContainer = newContainer;
							endOffset = newContainer.data.length;
							startOffset = 0;
						} else endOffset = 0;
					}
				} else {
					if (isText$a(startContainer) && startOffset > 0 && startOffset < startContainer.data.length) {
						startContainer = splitText(startContainer, startOffset);
						startOffset = 0;
					}
					if (isText$a(endContainer) && endOffset > 0 && endOffset < endContainer.data.length) {
						const newContainer = splitText(endContainer, endOffset).previousSibling;
						endContainer = newContainer;
						endOffset = newContainer.data.length;
					}
				}
				return {
					startContainer,
					startOffset,
					endContainer,
					endOffset
				};
			};
			const RangeUtils = (dom$1) => {
				const walk$5 = (rng, callback) => {
					return walk$3(dom$1, rng, callback);
				};
				const split$1$1 = split;
				const normalize$5 = (rng) => {
					return normalize$2(dom$1, rng).fold(never, (normalizedRng) => {
						rng.setStart(normalizedRng.startContainer, normalizedRng.startOffset);
						rng.setEnd(normalizedRng.endContainer, normalizedRng.endOffset);
						return true;
					});
				};
				const expand = (rng, options = { type: "word" }) => {
					if (options.type === "word") {
						const rangeLike = expandRng(dom$1, rng, [{ inline: "span" }]);
						const newRange = dom$1.createRng();
						newRange.setStart(rangeLike.startContainer, rangeLike.startOffset);
						newRange.setEnd(rangeLike.endContainer, rangeLike.endOffset);
						return newRange;
					}
					return rng;
				};
				return {
					walk: walk$5,
					split: split$1$1,
					expand,
					normalize: normalize$5
				};
			};
			RangeUtils.compareRanges = isEq$4;
			RangeUtils.getCaretRangeFromPoint = fromPoint;
			RangeUtils.getSelectedNode = getSelectedNode;
			RangeUtils.getNode = getNode$1;
			const Dimension = (name$1, getOffset) => {
				const set$4 = (element, h) => {
					if (!isNumber(h) && !h.match(/^[0-9]+$/)) throw new Error(name$1 + ".set accepts only positive integer values. Value was " + h);
					const dom$1 = element.dom;
					if (isSupported(dom$1)) dom$1.style[name$1] = h + "px";
				};
				const get$10 = (element) => {
					const r$1 = getOffset(element);
					if (r$1 <= 0 || r$1 === null) {
						const css = get$7(element, name$1);
						return parseFloat(css) || 0;
					}
					return r$1;
				};
				const getOuter$1 = get$10;
				const aggregate = (element, properties) => foldl(properties, (acc, property) => {
					const val = get$7(element, property);
					const value$3 = val === void 0 ? 0 : parseInt(val, 10);
					return isNaN(value$3) ? acc : acc + value$3;
				}, 0);
				const max$1 = (element, value$3, properties) => {
					const cumulativeInclusions = aggregate(element, properties);
					return value$3 > cumulativeInclusions ? value$3 - cumulativeInclusions : 0;
				};
				return {
					set: set$4,
					get: get$10,
					getOuter: getOuter$1,
					aggregate,
					max: max$1
				};
			};
			const api = Dimension("height", (element) => {
				const dom$1 = element.dom;
				return inBody(element) ? dom$1.getBoundingClientRect().height : dom$1.offsetHeight;
			});
			const get$2 = (element) => api.get(element);
			const getDocument = () => SugarElement.fromDom(document);
			const walkUp = (navigation, doc) => {
				return navigation.view(doc).fold(constant([]), (f) => {
					const rest = walkUp(navigation, navigation.owner(f));
					return [f].concat(rest);
				});
			};
			const pathTo = (element, navigation) => {
				return walkUp(navigation, navigation.owner(element));
			};
			const view = (doc) => {
				var _a;
				return (doc.dom === document ? Optional.none() : Optional.from((_a = doc.dom.defaultView) === null || _a === void 0 ? void 0 : _a.frameElement)).map(SugarElement.fromDom);
			};
			const owner = (element) => documentOrOwner(element);
			var Navigation = /* @__PURE__ */ Object.freeze({
				__proto__: null,
				view,
				owner
			});
			const find = (element) => {
				const scroll = get$5(getDocument());
				const frames = pathTo(element, Navigation);
				const offset = viewport(element);
				const r$1 = foldr(frames, (b, a) => {
					const loc = viewport(a);
					return {
						left: b.left + loc.left,
						top: b.top + loc.top
					};
				}, {
					left: 0,
					top: 0
				});
				return SugarPosition(r$1.left + offset.left + scroll.left, r$1.top + offset.top + scroll.top);
			};
			const excludeFromDescend = (element) => name(element) === "textarea";
			const fireScrollIntoViewEvent = (editor, data$1) => {
				return editor.dispatch("ScrollIntoView", data$1).isDefaultPrevented();
			};
			const fireAfterScrollIntoViewEvent = (editor, data$1) => {
				editor.dispatch("AfterScrollIntoView", data$1);
			};
			const descend = (element, offset) => {
				const children$2 = children$1(element);
				if (children$2.length === 0 || excludeFromDescend(element)) return {
					element,
					offset
				};
				else if (offset < children$2.length && !excludeFromDescend(children$2[offset])) return {
					element: children$2[offset],
					offset: 0
				};
				else {
					const last$4 = children$2[children$2.length - 1];
					if (excludeFromDescend(last$4)) return {
						element,
						offset
					};
					else if (name(last$4) === "img") return {
						element: last$4,
						offset: 1
					};
					else if (isText$b(last$4)) return {
						element: last$4,
						offset: get$3(last$4).length
					};
					else return {
						element: last$4,
						offset: children$1(last$4).length
					};
				}
			};
			const markerInfo = (element, cleanupFun) => {
				const pos = absolute(element);
				const height = get$2(element);
				return {
					element,
					bottom: pos.top + height,
					height,
					pos,
					cleanup: cleanupFun
				};
			};
			const createMarker$1 = (element, offset) => {
				const startPoint = descend(element, offset);
				const span = SugarElement.fromHtml("<span data-mce-bogus=\"all\" style=\"display: inline-block;\">" + ZWSP$1 + "</span>");
				before$3(startPoint.element, span);
				return markerInfo(span, () => remove$5(span));
			};
			const elementMarker = (element) => markerInfo(SugarElement.fromDom(element), noop);
			const withMarker = (editor, f, rng, alignToTop) => {
				preserveWith(editor, (_s, _e) => applyWithMarker(editor, f, rng, alignToTop), rng);
			};
			const withScrollEvents = (editor, doc, f, marker, alignToTop) => {
				const data$1 = {
					elm: marker.element.dom,
					alignToTop
				};
				if (fireScrollIntoViewEvent(editor, data$1)) return;
				const scrollTop = get$5(doc).top;
				f(editor, doc, scrollTop, marker, alignToTop);
				fireAfterScrollIntoViewEvent(editor, data$1);
			};
			const applyWithMarker = (editor, f, rng, alignToTop) => {
				const body = SugarElement.fromDom(editor.getBody());
				const doc = SugarElement.fromDom(editor.getDoc());
				reflow(body);
				const marker = createMarker$1(SugarElement.fromDom(rng.startContainer), rng.startOffset);
				withScrollEvents(editor, doc, f, marker, alignToTop);
				marker.cleanup();
			};
			const withElement = (editor, element, f, alignToTop) => {
				withScrollEvents(editor, SugarElement.fromDom(editor.getDoc()), f, elementMarker(element), alignToTop);
			};
			const preserveWith = (editor, f, rng) => {
				const startElement = rng.startContainer;
				const startOffset = rng.startOffset;
				const endElement = rng.endContainer;
				const endOffset = rng.endOffset;
				f(SugarElement.fromDom(startElement), SugarElement.fromDom(endElement));
				const newRng = editor.dom.createRng();
				newRng.setStart(startElement, startOffset);
				newRng.setEnd(endElement, endOffset);
				editor.selection.setRng(rng);
			};
			const scrollToMarker = (editor, marker, viewHeight, alignToTop, doc) => {
				const pos = marker.pos;
				if (alignToTop) to(pos.left, pos.top, doc);
				else {
					const y = pos.top - viewHeight + marker.height;
					to(-editor.getBody().getBoundingClientRect().left, y, doc);
				}
			};
			const intoWindowIfNeeded = (editor, doc, scrollTop, viewHeight, marker, alignToTop) => {
				const viewportBottom = viewHeight + scrollTop;
				const markerTop = marker.pos.top;
				const markerBottom = marker.bottom;
				const largerThanViewport = markerBottom - markerTop >= viewHeight;
				if (markerTop < scrollTop) scrollToMarker(editor, marker, viewHeight, alignToTop !== false, doc);
				else if (markerTop > viewportBottom) scrollToMarker(editor, marker, viewHeight, largerThanViewport ? alignToTop !== false : alignToTop === true, doc);
				else if (markerBottom > viewportBottom && !largerThanViewport) scrollToMarker(editor, marker, viewHeight, alignToTop === true, doc);
			};
			const intoWindow = (editor, doc, scrollTop, marker, alignToTop) => {
				const viewHeight = defaultView(doc).dom.innerHeight;
				intoWindowIfNeeded(editor, doc, scrollTop, viewHeight, marker, alignToTop);
			};
			const intoFrame = (editor, doc, scrollTop, marker, alignToTop) => {
				const frameViewHeight = defaultView(doc).dom.innerHeight;
				intoWindowIfNeeded(editor, doc, scrollTop, frameViewHeight, marker, alignToTop);
				const op = find(marker.element);
				const viewportBounds = getBounds(window);
				if (op.top < viewportBounds.y) intoView(marker.element, alignToTop !== false);
				else if (op.top > viewportBounds.bottom) intoView(marker.element, alignToTop === true);
			};
			const rangeIntoWindow = (editor, rng, alignToTop) => withMarker(editor, intoWindow, rng, alignToTop);
			const elementIntoWindow = (editor, element, alignToTop) => withElement(editor, element, intoWindow, alignToTop);
			const rangeIntoFrame = (editor, rng, alignToTop) => withMarker(editor, intoFrame, rng, alignToTop);
			const elementIntoFrame = (editor, element, alignToTop) => withElement(editor, element, intoFrame, alignToTop);
			const scrollElementIntoView = (editor, element, alignToTop) => {
				(editor.inline ? elementIntoWindow : elementIntoFrame)(editor, element, alignToTop);
			};
			const scrollRangeIntoView = (editor, rng, alignToTop) => {
				(editor.inline ? rangeIntoWindow : rangeIntoFrame)(editor, rng, alignToTop);
			};
			const focus$1 = (element) => element.dom.focus();
			const hasFocus$1 = (element) => {
				const root = getRootNode(element).dom;
				return element.dom === root.activeElement;
			};
			const active$1 = (root = getDocument()) => Optional.from(root.dom.activeElement).map(SugarElement.fromDom);
			const search = (element) => active$1(getRootNode(element)).filter((e) => element.dom.contains(e.dom));
			const clamp$1 = (offset, element) => {
				const max$1 = isText$b(element) ? get$3(element).length : children$1(element).length + 1;
				if (offset > max$1) return max$1;
				else if (offset < 0) return 0;
				return offset;
			};
			const normalizeRng = (rng) => SimSelection.range(rng.start, clamp$1(rng.soffset, rng.start), rng.finish, clamp$1(rng.foffset, rng.finish));
			const isOrContains = (root, elm) => !isRestrictedNode(elm.dom) && (contains(root, elm) || eq(root, elm));
			const isRngInRoot = (root) => (rng) => isOrContains(root, rng.start) && isOrContains(root, rng.finish);
			const shouldStore = (editor) => editor.inline || Env.browser.isFirefox();
			const nativeRangeToSelectionRange = (r$1) => SimSelection.range(SugarElement.fromDom(r$1.startContainer), r$1.startOffset, SugarElement.fromDom(r$1.endContainer), r$1.endOffset);
			const readRange = (win) => {
				const selection = win.getSelection();
				return (!selection || selection.rangeCount === 0 ? Optional.none() : Optional.from(selection.getRangeAt(0))).map(nativeRangeToSelectionRange);
			};
			const getBookmark = (root) => {
				return readRange(defaultView(root).dom).filter(isRngInRoot(root));
			};
			const validate = (root, bookmark) => Optional.from(bookmark).filter(isRngInRoot(root)).map(normalizeRng);
			const bookmarkToNativeRng = (bookmark) => {
				const rng = document.createRange();
				try {
					rng.setStart(bookmark.start.dom, bookmark.soffset);
					rng.setEnd(bookmark.finish.dom, bookmark.foffset);
					return Optional.some(rng);
				} catch (_) {
					return Optional.none();
				}
			};
			const store = (editor) => {
				const newBookmark = shouldStore(editor) ? getBookmark(SugarElement.fromDom(editor.getBody())) : Optional.none();
				editor.bookmark = newBookmark.isSome() ? newBookmark : editor.bookmark;
			};
			const getRng = (editor) => {
				return (editor.bookmark ? editor.bookmark : Optional.none()).bind((x) => validate(SugarElement.fromDom(editor.getBody()), x)).bind(bookmarkToNativeRng);
			};
			const restore = (editor) => {
				getRng(editor).each((rng) => editor.selection.setRng(rng));
			};
			const isEditorUIElement$1 = (elm) => {
				const className = elm.className.toString();
				return className.indexOf("tox-") !== -1 || className.indexOf("mce-") !== -1;
			};
			const FocusManager = { isEditorUIElement: isEditorUIElement$1 };
			const wrappedSetTimeout = (callback, time) => {
				if (!isNumber(time)) time = 0;
				return setTimeout(callback, time);
			};
			const wrappedSetInterval = (callback, time) => {
				if (!isNumber(time)) time = 0;
				return setInterval(callback, time);
			};
			const Delay = {
				setEditorTimeout: (editor, callback, time) => {
					return wrappedSetTimeout(() => {
						if (!editor.removed) callback();
					}, time);
				},
				setEditorInterval: (editor, callback, time) => {
					const timer = wrappedSetInterval(() => {
						if (!editor.removed) callback();
						else clearInterval(timer);
					}, time);
					return timer;
				}
			};
			const isManualNodeChange = (e) => {
				return e.type === "nodechange" && e.selectionChange;
			};
			const registerPageMouseUp = (editor, throttledStore) => {
				const mouseUpPage = () => {
					throttledStore.throttle();
				};
				DOMUtils.DOM.bind(document, "mouseup", mouseUpPage);
				editor.on("remove", () => {
					DOMUtils.DOM.unbind(document, "mouseup", mouseUpPage);
				});
			};
			const registerMouseUp = (editor, throttledStore) => {
				editor.on("mouseup touchend", (_e) => {
					throttledStore.throttle();
				});
			};
			const registerEditorEvents = (editor, throttledStore) => {
				registerMouseUp(editor, throttledStore);
				editor.on("keyup NodeChange AfterSetSelectionRange", (e) => {
					if (!isManualNodeChange(e)) store(editor);
				});
			};
			const register$6 = (editor) => {
				const throttledStore = first$1(() => {
					store(editor);
				}, 0);
				editor.on("init", () => {
					if (editor.inline) registerPageMouseUp(editor, throttledStore);
					registerEditorEvents(editor, throttledStore);
				});
				editor.on("remove", () => {
					throttledStore.cancel();
				});
			};
			let documentFocusInHandler;
			const DOM$9 = DOMUtils.DOM;
			const isEditorUIElement = (elm) => {
				return isElement$6(elm) && FocusManager.isEditorUIElement(elm);
			};
			const isEditorContentAreaElement = (elm) => {
				const classList = elm.classList;
				if (classList !== void 0) return classList.contains("tox-edit-area") || classList.contains("tox-edit-area__iframe") || classList.contains("mce-content-body");
				else return false;
			};
			const isUIElement = (editor, elm) => {
				const customSelector = getCustomUiSelector(editor);
				return DOM$9.getParent(elm, (elm$1) => {
					return isEditorUIElement(elm$1) || (customSelector ? editor.dom.is(elm$1, customSelector) : false);
				}) !== null;
			};
			const getActiveElement = (editor) => {
				try {
					return active$1(getRootNode(SugarElement.fromDom(editor.getElement()))).fold(() => document.body, (x) => x.dom);
				} catch (ex) {
					return document.body;
				}
			};
			const registerEvents$1 = (editorManager, e) => {
				const editor = e.editor;
				register$6(editor);
				const toggleContentAreaOnFocus = (editor$1, fn) => {
					if (shouldHighlightOnFocus(editor$1) && editor$1.inline !== true) fn(SugarElement.fromDom(editor$1.getContainer()), "tox-edit-focus");
				};
				editor.on("focusin", () => {
					const focusedEditor = editorManager.focusedEditor;
					if (isEditorContentAreaElement(getActiveElement(editor))) toggleContentAreaOnFocus(editor, add$2);
					if (focusedEditor !== editor) {
						if (focusedEditor) focusedEditor.dispatch("blur", { focusedEditor: editor });
						editorManager.setActive(editor);
						editorManager.focusedEditor = editor;
						editor.dispatch("focus", { blurredEditor: focusedEditor });
						editor.focus(true);
					}
				});
				editor.on("focusout", () => {
					Delay.setEditorTimeout(editor, () => {
						const focusedEditor = editorManager.focusedEditor;
						if (!isEditorContentAreaElement(getActiveElement(editor)) || focusedEditor !== editor) toggleContentAreaOnFocus(editor, remove$7);
						if (!isUIElement(editor, getActiveElement(editor)) && focusedEditor === editor) {
							editor.dispatch("blur", { focusedEditor: null });
							editorManager.focusedEditor = null;
						}
					});
				});
				if (!documentFocusInHandler) {
					documentFocusInHandler = (e$1) => {
						const activeEditor = editorManager.activeEditor;
						if (activeEditor) getOriginalEventTarget(e$1).each((target) => {
							const elem = target;
							if (elem.ownerDocument === document) {
								if (elem !== document.body && !isUIElement(activeEditor, elem) && editorManager.focusedEditor === activeEditor) {
									activeEditor.dispatch("blur", { focusedEditor: null });
									editorManager.focusedEditor = null;
								}
							}
						});
					};
					DOM$9.bind(document, "focusin", documentFocusInHandler);
				}
			};
			const unregisterDocumentEvents = (editorManager, e) => {
				if (editorManager.focusedEditor === e.editor) editorManager.focusedEditor = null;
				if (!editorManager.activeEditor && documentFocusInHandler) {
					DOM$9.unbind(document, "focusin", documentFocusInHandler);
					documentFocusInHandler = null;
				}
			};
			const setup$v = (editorManager) => {
				editorManager.on("AddEditor", curry(registerEvents$1, editorManager));
				editorManager.on("RemoveEditor", curry(unregisterDocumentEvents, editorManager));
			};
			const getContentEditableHost = (editor, node) => editor.dom.getParent(node, (node$1) => editor.dom.getContentEditable(node$1) === "true");
			const getCollapsedNode = (rng) => rng.collapsed ? Optional.from(getNode$1(rng.startContainer, rng.startOffset)).map(SugarElement.fromDom) : Optional.none();
			const getFocusInElement = (root, rng) => getCollapsedNode(rng).bind((node) => {
				if (isTableSection(node)) return Optional.some(node);
				else if (!contains(root, node)) return Optional.some(root);
				else return Optional.none();
			});
			const normalizeSelection = (editor, rng) => {
				getFocusInElement(SugarElement.fromDom(editor.getBody()), rng).bind((elm) => {
					return firstPositionIn(elm.dom);
				}).fold(() => {
					editor.selection.normalize();
				}, (caretPos) => editor.selection.setRng(caretPos.toRange()));
			};
			const focusBody = (body) => {
				if (body.setActive) try {
					body.setActive();
				} catch (ex) {
					body.focus();
				}
				else body.focus();
			};
			const hasElementFocus = (elm) => hasFocus$1(elm) || search(elm).isSome();
			const hasIframeFocus = (editor) => isNonNullable(editor.iframeElement) && hasFocus$1(SugarElement.fromDom(editor.iframeElement));
			const hasInlineFocus = (editor) => {
				const rawBody = editor.getBody();
				return rawBody && hasElementFocus(SugarElement.fromDom(rawBody));
			};
			const hasUiFocus = (editor) => {
				return active$1(getRootNode(SugarElement.fromDom(editor.getElement()))).filter((elem) => !isEditorContentAreaElement(elem.dom) && isUIElement(editor, elem.dom)).isSome();
			};
			const hasFocus = (editor) => editor.inline ? hasInlineFocus(editor) : hasIframeFocus(editor);
			const hasEditorOrUiFocus = (editor) => hasFocus(editor) || hasUiFocus(editor);
			const focusEditor = (editor) => {
				const selection = editor.selection;
				const body = editor.getBody();
				let rng = selection.getRng();
				editor.quirks.refreshContentEditable();
				if (isNonNullable(editor.bookmark) && !hasFocus(editor)) getRng(editor).each((bookmarkRng) => {
					editor.selection.setRng(bookmarkRng);
					rng = bookmarkRng;
				});
				const contentEditableHost = getContentEditableHost(editor, selection.getNode());
				if (contentEditableHost && editor.dom.isChildOf(contentEditableHost, body)) {
					focusBody(contentEditableHost);
					normalizeSelection(editor, rng);
					activateEditor(editor);
					return;
				}
				if (!editor.inline) {
					if (!Env.browser.isOpera()) focusBody(body);
					editor.getWin().focus();
				}
				if (Env.browser.isFirefox() || editor.inline) {
					focusBody(body);
					normalizeSelection(editor, rng);
				}
				activateEditor(editor);
			};
			const activateEditor = (editor) => editor.editorManager.setActive(editor);
			const focus = (editor, skipFocus) => {
				if (editor.removed) return;
				if (skipFocus) activateEditor(editor);
				else focusEditor(editor);
			};
			const getEndpointElement = (root, rng, start$2, real, resolve$4) => {
				const container = start$2 ? rng.startContainer : rng.endContainer;
				const offset = start$2 ? rng.startOffset : rng.endOffset;
				return Optional.from(container).map(SugarElement.fromDom).map((elm) => !real || !rng.collapsed ? child$1(elm, resolve$4(elm, offset)).getOr(elm) : elm).bind((elm) => isElement$7(elm) ? Optional.some(elm) : parent(elm).filter(isElement$7)).map((elm) => elm.dom).getOr(root);
			};
			const getStart = (root, rng, real = false) => getEndpointElement(root, rng, true, real, (elm, offset) => Math.min(childNodesCount(elm), offset));
			const getEnd$1 = (root, rng, real = false) => getEndpointElement(root, rng, false, real, (elm, offset) => offset > 0 ? offset - 1 : offset);
			const skipEmptyTextNodes = (node, forwards) => {
				const orig = node;
				while (node && isText$a(node) && node.length === 0) node = forwards ? node.nextSibling : node.previousSibling;
				return node || orig;
			};
			const getNode = (root, rng) => {
				if (!rng) return root;
				let startContainer = rng.startContainer;
				let endContainer = rng.endContainer;
				const startOffset = rng.startOffset;
				const endOffset = rng.endOffset;
				let node = rng.commonAncestorContainer;
				if (!rng.collapsed) {
					if (startContainer === endContainer) {
						if (endOffset - startOffset < 2) {
							if (startContainer.hasChildNodes()) node = startContainer.childNodes[startOffset];
						}
					}
					if (isText$a(startContainer) && isText$a(endContainer)) {
						if (startContainer.length === startOffset) startContainer = skipEmptyTextNodes(startContainer.nextSibling, true);
						else startContainer = startContainer.parentNode;
						if (endOffset === 0) endContainer = skipEmptyTextNodes(endContainer.previousSibling, false);
						else endContainer = endContainer.parentNode;
						if (startContainer && startContainer === endContainer) node = startContainer;
					}
				}
				const elm = isText$a(node) ? node.parentNode : node;
				return isElement$6(elm) ? elm : root;
			};
			const getSelectedBlocks = (dom$1, rng, startElm, endElm) => {
				const selectedBlocks = [];
				const root = dom$1.getRoot();
				const start$2 = dom$1.getParent(startElm || getStart(root, rng, rng.collapsed), dom$1.isBlock);
				const end$1 = dom$1.getParent(endElm || getEnd$1(root, rng, rng.collapsed), dom$1.isBlock);
				if (start$2 && start$2 !== root) selectedBlocks.push(start$2);
				if (start$2 && end$1 && start$2 !== end$1) {
					let node;
					const walker = new DomTreeWalker(start$2, root);
					while ((node = walker.next()) && node !== end$1) if (dom$1.isBlock(node)) selectedBlocks.push(node);
				}
				if (end$1 && start$2 !== end$1 && end$1 !== root) selectedBlocks.push(end$1);
				return selectedBlocks;
			};
			const select = (dom$1, node, content) => Optional.from(node).bind((node$1) => Optional.from(node$1.parentNode).map((parent$1) => {
				const idx = dom$1.nodeIndex(node$1);
				const rng = dom$1.createRng();
				rng.setStart(parent$1, idx);
				rng.setEnd(parent$1, idx + 1);
				if (content) {
					moveEndPoint(dom$1, rng, node$1, true);
					moveEndPoint(dom$1, rng, node$1, false);
				}
				return rng;
			}));
			const processRanges = (editor, ranges) => map$3(ranges, (range) => {
				const evt = editor.dispatch("GetSelectionRange", { range });
				return evt.range !== range ? evt.range : range;
			});
			const getEnd = (element) => name(element) === "img" ? 1 : getOption(element).fold(() => children$1(element).length, (v) => v.length);
			const isTextNodeWithCursorPosition = (el) => getOption(el).filter((text$1) => text$1.trim().length !== 0 || text$1.indexOf(nbsp) > -1).isSome();
			const isContentEditableFalse$5 = (elem) => isHTMLElement(elem) && get$9(elem, "contenteditable") === "false";
			const elementsWithCursorPosition = ["img", "br"];
			const isCursorPosition = (elem) => {
				return isTextNodeWithCursorPosition(elem) || contains$2(elementsWithCursorPosition, name(elem)) || isContentEditableFalse$5(elem);
			};
			const first = (element) => descendant$1(element, isCursorPosition);
			const last = (element) => descendantRtl(element, isCursorPosition);
			const descendantRtl = (scope, predicate) => {
				const descend$1 = (element) => {
					const children$2 = children$1(element);
					for (let i = children$2.length - 1; i >= 0; i--) {
						const child$2 = children$2[i];
						if (predicate(child$2)) return Optional.some(child$2);
						const res = descend$1(child$2);
						if (res.isSome()) return res;
					}
					return Optional.none();
				};
				return descend$1(scope);
			};
			const autocompleteSelector = "[data-mce-autocompleter]";
			const create$9 = (editor, range) => {
				if (findIn(SugarElement.fromDom(editor.getBody())).isNone()) {
					const wrapper = SugarElement.fromHtml("<span data-mce-autocompleter=\"1\" data-mce-bogus=\"1\"></span>", editor.getDoc());
					append$1(wrapper, SugarElement.fromDom(range.extractContents()));
					range.insertNode(wrapper.dom);
					parent(wrapper).each((elm) => elm.dom.normalize());
					last(wrapper).map((last$4) => {
						editor.selection.setCursorLocation(last$4.dom, getEnd(last$4));
					});
				}
			};
			const detect$1 = (elm) => closest$3(elm, autocompleteSelector);
			const findIn = (elm) => descendant(elm, autocompleteSelector);
			const remove$2 = (editor, elm) => findIn(elm).each((wrapper) => {
				const bookmark = editor.selection.getBookmark();
				unwrap(wrapper);
				editor.selection.moveToBookmark(bookmark);
			});
			const typeLookup = {
				"#text": 3,
				"#comment": 8,
				"#cdata": 4,
				"#pi": 7,
				"#doctype": 10,
				"#document-fragment": 11
			};
			const walk$2 = (node, root, prev$1) => {
				const startName = prev$1 ? "lastChild" : "firstChild";
				const siblingName = prev$1 ? "prev" : "next";
				if (node[startName]) return node[startName];
				if (node !== root) {
					let sibling$2 = node[siblingName];
					if (sibling$2) return sibling$2;
					for (let parent$1 = node.parent; parent$1 && parent$1 !== root; parent$1 = parent$1.parent) {
						sibling$2 = parent$1[siblingName];
						if (sibling$2) return sibling$2;
					}
				}
			};
			const isEmptyTextNode = (node) => {
				var _a;
				const text$1 = (_a = node.value) !== null && _a !== void 0 ? _a : "";
				if (!isWhitespaceText(text$1)) return false;
				const parentNode = node.parent;
				if (parentNode && (parentNode.name !== "span" || parentNode.attr("style")) && /^[ ]+$/.test(text$1)) return false;
				return true;
			};
			const isNonEmptyElement = (node) => {
				const isNamedAnchor$1 = node.name === "a" && !node.attr("href") && node.attr("id");
				return node.attr("name") || node.attr("id") && !node.firstChild || node.attr("data-mce-bookmark") || isNamedAnchor$1;
			};
			class AstNode {
				static create(name$1, attrs) {
					const node = new AstNode(name$1, typeLookup[name$1] || 1);
					if (attrs) each$d(attrs, (value$3, attrName) => {
						node.attr(attrName, value$3);
					});
					return node;
				}
				constructor(name$1, type$2) {
					this.name = name$1;
					this.type = type$2;
					if (type$2 === 1) {
						this.attributes = [];
						this.attributes.map = {};
					}
				}
				replace(node) {
					const self = this;
					if (node.parent) node.remove();
					self.insert(node, self);
					self.remove();
					return self;
				}
				attr(name$1, value$3) {
					const self = this;
					if (!isString(name$1)) {
						if (isNonNullable(name$1)) each$d(name$1, (value$4, key) => {
							self.attr(key, value$4);
						});
						return self;
					}
					const attrs = self.attributes;
					if (attrs) {
						if (value$3 !== void 0) {
							if (value$3 === null) {
								if (name$1 in attrs.map) {
									delete attrs.map[name$1];
									let i = attrs.length;
									while (i--) if (attrs[i].name === name$1) {
										attrs.splice(i, 1);
										return self;
									}
								}
								return self;
							}
							if (name$1 in attrs.map) {
								let i = attrs.length;
								while (i--) if (attrs[i].name === name$1) {
									attrs[i].value = value$3;
									break;
								}
							} else attrs.push({
								name: name$1,
								value: value$3
							});
							attrs.map[name$1] = value$3;
							return self;
						}
						return attrs.map[name$1];
					}
				}
				clone() {
					const self = this;
					const clone$5 = new AstNode(self.name, self.type);
					const selfAttrs = self.attributes;
					if (selfAttrs) {
						const cloneAttrs = [];
						cloneAttrs.map = {};
						for (let i = 0, l = selfAttrs.length; i < l; i++) {
							const selfAttr = selfAttrs[i];
							if (selfAttr.name !== "id") {
								cloneAttrs[cloneAttrs.length] = {
									name: selfAttr.name,
									value: selfAttr.value
								};
								cloneAttrs.map[selfAttr.name] = selfAttr.value;
							}
						}
						clone$5.attributes = cloneAttrs;
					}
					clone$5.value = self.value;
					return clone$5;
				}
				wrap(wrapper) {
					const self = this;
					if (self.parent) {
						self.parent.insert(wrapper, self);
						wrapper.append(self);
					}
					return self;
				}
				unwrap() {
					const self = this;
					for (let node = self.firstChild; node;) {
						const next$1 = node.next;
						self.insert(node, self, true);
						node = next$1;
					}
					self.remove();
				}
				remove() {
					const self = this, parent$1 = self.parent, next$1 = self.next, prev$1 = self.prev;
					if (parent$1) {
						if (parent$1.firstChild === self) {
							parent$1.firstChild = next$1;
							if (next$1) next$1.prev = null;
						} else if (prev$1) prev$1.next = next$1;
						if (parent$1.lastChild === self) {
							parent$1.lastChild = prev$1;
							if (prev$1) prev$1.next = null;
						} else if (next$1) next$1.prev = prev$1;
						self.parent = self.next = self.prev = null;
					}
					return self;
				}
				append(node) {
					const self = this;
					if (node.parent) node.remove();
					const last$4 = self.lastChild;
					if (last$4) {
						last$4.next = node;
						node.prev = last$4;
						self.lastChild = node;
					} else self.lastChild = self.firstChild = node;
					node.parent = self;
					return node;
				}
				insert(node, refNode, before$1) {
					if (node.parent) node.remove();
					const parent$1 = refNode.parent || this;
					if (before$1) {
						if (refNode === parent$1.firstChild) parent$1.firstChild = node;
						else if (refNode.prev) refNode.prev.next = node;
						node.prev = refNode.prev;
						node.next = refNode;
						refNode.prev = node;
					} else {
						if (refNode === parent$1.lastChild) parent$1.lastChild = node;
						else if (refNode.next) refNode.next.prev = node;
						node.next = refNode.next;
						node.prev = refNode;
						refNode.next = node;
					}
					node.parent = parent$1;
					return node;
				}
				getAll(name$1) {
					const self = this;
					const collection = [];
					for (let node = self.firstChild; node; node = walk$2(node, self)) if (node.name === name$1) collection.push(node);
					return collection;
				}
				children() {
					const self = this;
					const collection = [];
					for (let node = self.firstChild; node; node = node.next) collection.push(node);
					return collection;
				}
				empty() {
					const self = this;
					if (self.firstChild) {
						const nodes = [];
						for (let node = self.firstChild; node; node = walk$2(node, self)) nodes.push(node);
						let i = nodes.length;
						while (i--) {
							const node = nodes[i];
							node.parent = node.firstChild = node.lastChild = node.next = node.prev = null;
						}
					}
					self.firstChild = self.lastChild = null;
					return self;
				}
				isEmpty(elements, whitespace = {}, predicate) {
					var _a;
					const self = this;
					let node = self.firstChild;
					if (isNonEmptyElement(self)) return false;
					if (node) do {
						if (node.type === 1) {
							if (node.attr("data-mce-bogus")) continue;
							if (elements[node.name]) return false;
							if (isNonEmptyElement(node)) return false;
						}
						if (node.type === 8) return false;
						if (node.type === 3 && !isEmptyTextNode(node)) return false;
						if (node.type === 3 && node.parent && whitespace[node.parent.name] && isWhitespaceText((_a = node.value) !== null && _a !== void 0 ? _a : "")) return false;
						if (predicate && predicate(node)) return false;
					} while (node = walk$2(node, self));
					return true;
				}
				walk(prev$1) {
					return walk$2(this, null, prev$1);
				}
			}
			const isConditionalComment = (html$2, startIndex) => /^\s*\[if [\w\W]+\]>.*<!\[endif\](--!?)?>/.test(html$2.substr(startIndex));
			const findCommentEndIndex = (html$2, isBogus$3, startIndex = 0) => {
				const lcHtml = html$2.toLowerCase();
				if (lcHtml.indexOf("[if ", startIndex) !== -1 && isConditionalComment(lcHtml, startIndex)) {
					const endIfIndex = lcHtml.indexOf("[endif]", startIndex);
					return lcHtml.indexOf(">", endIfIndex);
				} else if (isBogus$3) {
					const endIndex = lcHtml.indexOf(">", startIndex);
					return endIndex !== -1 ? endIndex : lcHtml.length;
				} else {
					const endCommentRegexp = /--!?>/g;
					endCommentRegexp.lastIndex = startIndex;
					const match$3 = endCommentRegexp.exec(html$2);
					return match$3 ? match$3.index + match$3[0].length : lcHtml.length;
				}
			};
			const findMatchingEndTagIndex = (schema, html$2, startIndex) => {
				const startTagRegExp = /<([!?\/])?([A-Za-z0-9\-_:.]+)/g;
				const endTagRegExp = /(?:\s(?:[^'">]+(?:"[^"]*"|'[^']*'))*[^"'>]*(?:"[^">]*|'[^'>]*)?|\s*|\/)>/g;
				const voidElements = schema.getVoidElements();
				let count$2 = 1, index = startIndex;
				while (count$2 !== 0) {
					startTagRegExp.lastIndex = index;
					while (true) {
						const startMatch = startTagRegExp.exec(html$2);
						if (startMatch === null) return index;
						else if (startMatch[1] === "!") {
							if (startsWith(startMatch[2], "--")) index = findCommentEndIndex(html$2, false, startMatch.index + 3);
							else index = findCommentEndIndex(html$2, true, startMatch.index + 1);
							break;
						} else {
							endTagRegExp.lastIndex = startTagRegExp.lastIndex;
							const endMatch = endTagRegExp.exec(html$2);
							if (isNull(endMatch) || endMatch.index !== startTagRegExp.lastIndex) continue;
							if (startMatch[1] === "/") count$2 -= 1;
							else if (!has$2(voidElements, startMatch[2])) count$2 += 1;
							index = startTagRegExp.lastIndex + endMatch[0].length;
							break;
						}
					}
				}
				return index;
			};
			const trimHtml$1 = (tempAttrs, html$2) => {
				const trimContentRegExp = new RegExp(["\\s?(" + tempAttrs.join("|") + ")=\"[^\"]+\""].join("|"), "gi");
				return html$2.replace(trimContentRegExp, "");
			};
			const trimInternal = (serializer, html$2) => {
				const bogusAllRegExp = /<(\w+) [^>]*data-mce-bogus="all"[^>]*>/g;
				const schema = serializer.schema;
				let content = trimHtml$1(serializer.getTempAttrs(), html$2);
				const voidElements = schema.getVoidElements();
				let matches;
				while (matches = bogusAllRegExp.exec(content)) {
					const index = bogusAllRegExp.lastIndex;
					const matchLength = matches[0].length;
					let endTagIndex;
					if (voidElements[matches[1]]) endTagIndex = index;
					else endTagIndex = findMatchingEndTagIndex(schema, content, index);
					content = content.substring(0, index - matchLength) + content.substring(endTagIndex);
					bogusAllRegExp.lastIndex = index - matchLength;
				}
				return trim$1(content);
			};
			const trimExternal = trimInternal;
			const cleanupBogusElements = (parent$1) => {
				each$e(descendants(parent$1, "[data-mce-bogus]"), (elem) => {
					if (get$9(elem, "data-mce-bogus") === "all") remove$5(elem);
					else if (isBr$5(elem)) {
						before$3(elem, SugarElement.fromText(zeroWidth));
						remove$5(elem);
					} else unwrap(elem);
				});
			};
			const cleanupInputNames = (parent$1) => {
				each$e(descendants(parent$1, "input"), (input) => {
					remove$a(input, "name");
				});
			};
			const trimEmptyContents = (editor, html$2) => {
				const blockName = getForcedRootBlock(editor);
				const emptyRegExp = /* @__PURE__ */ new RegExp(`^(<${blockName}[^>]*>(&nbsp;|&#160;|\\s|\u00a0|<br \\/>|)<\\/${blockName}>[\r\n]*|<br \\/>[\r\n]*)$`);
				return html$2.replace(emptyRegExp, "");
			};
			const getPlainTextContent = (editor, body) => {
				const doc = editor.getDoc();
				const dos = getRootNode(SugarElement.fromDom(editor.getBody()));
				const offscreenDiv = SugarElement.fromTag("div", doc);
				set$3(offscreenDiv, "data-mce-bogus", "all");
				setAll(offscreenDiv, {
					position: "fixed",
					left: "-9999999px",
					top: "0"
				});
				set$1(offscreenDiv, body.innerHTML);
				cleanupBogusElements(offscreenDiv);
				cleanupInputNames(offscreenDiv);
				append$1(getContentContainer(dos), offscreenDiv);
				const content = trim$1(offscreenDiv.dom.innerText);
				remove$5(offscreenDiv);
				return content;
			};
			const getContentFromBody = (editor, args, body) => {
				let content;
				if (args.format === "raw") content = Tools.trim(trimExternal(editor.serializer, body.innerHTML));
				else if (args.format === "text") content = getPlainTextContent(editor, body);
				else if (args.format === "tree") content = editor.serializer.serialize(body, args);
				else content = trimEmptyContents(editor, editor.serializer.serialize(body, args));
				return args.format !== "text" && !isWsPreserveElement(SugarElement.fromDom(body)) && isString(content) ? Tools.trim(content) : content;
			};
			const getContentInternal = (editor, args) => Optional.from(editor.getBody()).fold(constant(args.format === "tree" ? new AstNode("body", 11) : ""), (body) => getContentFromBody(editor, args, body));
			const makeMap$1 = Tools.makeMap;
			const Writer = (settings) => {
				const html$2 = [];
				settings = settings || {};
				const indent$1 = settings.indent;
				const indentBefore = makeMap$1(settings.indent_before || "");
				const indentAfter = makeMap$1(settings.indent_after || "");
				const encode = Entities.getEncodeFunc(settings.entity_encoding || "raw", settings.entities);
				const htmlOutput = settings.element_format !== "xhtml";
				return {
					start: (name$1, attrs, empty$1) => {
						if (indent$1 && indentBefore[name$1] && html$2.length > 0) {
							const value$3 = html$2[html$2.length - 1];
							if (value$3.length > 0 && value$3 !== "\n") html$2.push("\n");
						}
						html$2.push("<", name$1);
						if (attrs) for (let i = 0, l = attrs.length; i < l; i++) {
							const attr = attrs[i];
							html$2.push(" ", attr.name, "=\"", encode(attr.value, true), "\"");
						}
						if (!empty$1 || htmlOutput) html$2[html$2.length] = ">";
						else html$2[html$2.length] = " />";
						if (empty$1 && indent$1 && indentAfter[name$1] && html$2.length > 0) {
							const value$3 = html$2[html$2.length - 1];
							if (value$3.length > 0 && value$3 !== "\n") html$2.push("\n");
						}
					},
					end: (name$1) => {
						let value$3;
						html$2.push("</", name$1, ">");
						if (indent$1 && indentAfter[name$1] && html$2.length > 0) {
							value$3 = html$2[html$2.length - 1];
							if (value$3.length > 0 && value$3 !== "\n") html$2.push("\n");
						}
					},
					text: (text$1, raw) => {
						if (text$1.length > 0) html$2[html$2.length] = raw ? text$1 : encode(text$1);
					},
					cdata: (text$1) => {
						html$2.push("<![CDATA[", text$1, "]]>");
					},
					comment: (text$1) => {
						html$2.push("<!--", text$1, "-->");
					},
					pi: (name$1, text$1) => {
						if (text$1) html$2.push("<?", name$1, " ", encode(text$1), "?>");
						else html$2.push("<?", name$1, "?>");
						if (indent$1) html$2.push("\n");
					},
					doctype: (text$1) => {
						html$2.push("<!DOCTYPE", text$1, ">", indent$1 ? "\n" : "");
					},
					reset: () => {
						html$2.length = 0;
					},
					getContent: () => {
						return html$2.join("").replace(/\n$/, "");
					}
				};
			};
			const HtmlSerializer = (settings = {}, schema = Schema()) => {
				const writer = Writer(settings);
				settings.validate = "validate" in settings ? settings.validate : true;
				const serialize = (node) => {
					const validate$1 = settings.validate;
					const handlers = {
						3: (node$1) => {
							var _a;
							writer.text((_a = node$1.value) !== null && _a !== void 0 ? _a : "", node$1.raw);
						},
						8: (node$1) => {
							var _a;
							writer.comment((_a = node$1.value) !== null && _a !== void 0 ? _a : "");
						},
						7: (node$1) => {
							writer.pi(node$1.name, node$1.value);
						},
						10: (node$1) => {
							var _a;
							writer.doctype((_a = node$1.value) !== null && _a !== void 0 ? _a : "");
						},
						4: (node$1) => {
							var _a;
							writer.cdata((_a = node$1.value) !== null && _a !== void 0 ? _a : "");
						},
						11: (node$1) => {
							let tempNode = node$1;
							if (tempNode = tempNode.firstChild) do
								walk$5(tempNode);
							while (tempNode = tempNode.next);
						}
					};
					writer.reset();
					const walk$5 = (node$1) => {
						var _a;
						const handler = handlers[node$1.type];
						if (!handler) {
							const name$1 = node$1.name;
							const isEmpty$4 = name$1 in schema.getVoidElements();
							let attrs = node$1.attributes;
							if (validate$1 && attrs && attrs.length > 1) {
								const sortedAttrs = [];
								sortedAttrs.map = {};
								const elementRule = schema.getElementRule(node$1.name);
								if (elementRule) {
									for (let i = 0, l = elementRule.attributesOrder.length; i < l; i++) {
										const attrName = elementRule.attributesOrder[i];
										if (attrName in attrs.map) {
											const attrValue = attrs.map[attrName];
											sortedAttrs.map[attrName] = attrValue;
											sortedAttrs.push({
												name: attrName,
												value: attrValue
											});
										}
									}
									for (let i = 0, l = attrs.length; i < l; i++) {
										const attrName = attrs[i].name;
										if (!(attrName in sortedAttrs.map)) {
											const attrValue = attrs.map[attrName];
											sortedAttrs.map[attrName] = attrValue;
											sortedAttrs.push({
												name: attrName,
												value: attrValue
											});
										}
									}
									attrs = sortedAttrs;
								}
							}
							writer.start(name$1, attrs, isEmpty$4);
							if (!isEmpty$4) {
								let child$2 = node$1.firstChild;
								if (child$2) {
									if ((name$1 === "pre" || name$1 === "textarea") && child$2.type === 3 && ((_a = child$2.value) === null || _a === void 0 ? void 0 : _a[0]) === "\n") writer.text("\n", true);
									do
										walk$5(child$2);
									while (child$2 = child$2.next);
								}
								writer.end(name$1);
							}
						} else handler(node$1);
					};
					if (node.type === 1 && !settings.inner) walk$5(node);
					else if (node.type === 3) handlers[3](node);
					else handlers[11](node);
					return writer.getContent();
				};
				return { serialize };
			};
			const nonInheritableStyles = /* @__PURE__ */ new Set();
			each$e([
				"margin",
				"margin-left",
				"margin-right",
				"margin-top",
				"margin-bottom",
				"padding",
				"padding-left",
				"padding-right",
				"padding-top",
				"padding-bottom",
				"border",
				"border-width",
				"border-style",
				"border-color",
				"background",
				"background-attachment",
				"background-clip",
				"background-color",
				"background-image",
				"background-origin",
				"background-position",
				"background-repeat",
				"background-size",
				"float",
				"position",
				"left",
				"right",
				"top",
				"bottom",
				"z-index",
				"display",
				"transform",
				"width",
				"max-width",
				"min-width",
				"height",
				"max-height",
				"min-height",
				"overflow",
				"overflow-x",
				"overflow-y",
				"text-overflow",
				"vertical-align",
				"transition",
				"transition-delay",
				"transition-duration",
				"transition-property",
				"transition-timing-function"
			], (style) => {
				nonInheritableStyles.add(style);
			});
			const shorthandStyleProps = [
				"font",
				"text-decoration",
				"text-emphasis"
			];
			const getStyleProps = (dom$1, node) => keys(dom$1.parseStyle(dom$1.getAttrib(node, "style")));
			const isNonInheritableStyle = (style) => nonInheritableStyles.has(style);
			const hasInheritableStyles = (dom$1, node) => forall(getStyleProps(dom$1, node), (style) => !isNonInheritableStyle(style));
			const getLonghandStyleProps = (styles) => filter$5(styles, (style) => exists(shorthandStyleProps, (prop) => startsWith(style, prop)));
			const hasStyleConflict = (dom$1, node, parentNode) => {
				const nodeStyleProps = getStyleProps(dom$1, node);
				const parentNodeStyleProps = getStyleProps(dom$1, parentNode);
				const valueMismatch = (prop) => {
					var _a, _b;
					const nodeValue = (_a = dom$1.getStyle(node, prop)) !== null && _a !== void 0 ? _a : "";
					const parentValue = (_b = dom$1.getStyle(parentNode, prop)) !== null && _b !== void 0 ? _b : "";
					return isNotEmpty(nodeValue) && isNotEmpty(parentValue) && nodeValue !== parentValue;
				};
				return exists(nodeStyleProps, (nodeStyleProp) => {
					const propExists = (props) => exists(props, (prop) => prop === nodeStyleProp);
					if (!propExists(parentNodeStyleProps) && propExists(shorthandStyleProps)) return exists(getLonghandStyleProps(parentNodeStyleProps), valueMismatch);
					else return valueMismatch(nodeStyleProp);
				});
			};
			const isChar = (forward, predicate, pos) => Optional.from(pos.container()).filter(isText$a).exists((text$1) => {
				const delta = forward ? 0 : -1;
				return predicate(text$1.data.charAt(pos.offset() + delta));
			});
			const isBeforeSpace = curry(isChar, true, isWhiteSpace);
			const isAfterSpace = curry(isChar, false, isWhiteSpace);
			const isEmptyText = (pos) => {
				const container = pos.container();
				return isText$a(container) && (container.data.length === 0 || isZwsp$1(container.data) && BookmarkManager.isBookmarkNode(container.parentNode));
			};
			const matchesElementPosition = (before$1, predicate) => (pos) => getChildNodeAtRelativeOffset(before$1 ? 0 : -1, pos).filter(predicate).isSome();
			const isImageBlock = (node) => isImg(node) && get$7(SugarElement.fromDom(node), "display") === "block";
			const isCefNode = (node) => isContentEditableFalse$b(node) && !isBogusAll$1(node);
			const isBeforeImageBlock = matchesElementPosition(true, isImageBlock);
			const isAfterImageBlock = matchesElementPosition(false, isImageBlock);
			const isBeforeMedia = matchesElementPosition(true, isMedia$2);
			const isAfterMedia = matchesElementPosition(false, isMedia$2);
			const isBeforeTable = matchesElementPosition(true, isTable$2);
			const isAfterTable = matchesElementPosition(false, isTable$2);
			const isBeforeContentEditableFalse = matchesElementPosition(true, isCefNode);
			const isAfterContentEditableFalse = matchesElementPosition(false, isCefNode);
			const dropLast = (xs) => xs.slice(0, -1);
			const parentsUntil = (start$2, root, predicate) => {
				if (contains(root, start$2)) return dropLast(parents$1(start$2, (elm) => {
					return predicate(elm) || eq(elm, root);
				}));
				else return [];
			};
			const parents = (start$2, root) => parentsUntil(start$2, root, never);
			const parentsAndSelf = (start$2, root) => [start$2].concat(parents(start$2, root));
			const navigateIgnoreEmptyTextNodes = (forward, root, from$1) => navigateIgnore(forward, root, from$1, isEmptyText);
			const getClosestBlock$1 = (root, pos) => find$2(parentsAndSelf(SugarElement.fromDom(pos.container()), root), isBlock$2);
			const isAtBeforeAfterBlockBoundary = (forward, root, pos) => navigateIgnoreEmptyTextNodes(forward, root.dom, pos).forall((newPos) => getClosestBlock$1(root, pos).fold(() => !isInSameBlock(newPos, pos, root.dom), (fromBlock) => !isInSameBlock(newPos, pos, root.dom) && contains(fromBlock, SugarElement.fromDom(newPos.container()))));
			const isAtBlockBoundary = (forward, root, pos) => getClosestBlock$1(root, pos).fold(() => navigateIgnoreEmptyTextNodes(forward, root.dom, pos).forall((newPos) => !isInSameBlock(newPos, pos, root.dom)), (parent$1) => navigateIgnoreEmptyTextNodes(forward, parent$1.dom, pos).isNone());
			const isAtStartOfBlock = curry(isAtBlockBoundary, false);
			const isAtEndOfBlock = curry(isAtBlockBoundary, true);
			const isBeforeBlock = curry(isAtBeforeAfterBlockBoundary, false);
			const isAfterBlock = curry(isAtBeforeAfterBlockBoundary, true);
			const isBr$1 = (pos) => getElementFromPosition(pos).exists(isBr$5);
			const findBr = (forward, root, pos) => {
				return fromPosition(forward, head(filter$5(parentsAndSelf(SugarElement.fromDom(pos.container()), root), isBlock$2)).getOr(root).dom, pos).filter(isBr$1);
			};
			const isBeforeBr$1 = (root, pos) => getElementFromPosition(pos).exists(isBr$5) || findBr(true, root, pos).isSome();
			const isAfterBr = (root, pos) => getElementFromPrevPosition(pos).exists(isBr$5) || findBr(false, root, pos).isSome();
			const findPreviousBr = curry(findBr, false);
			const findNextBr = curry(findBr, true);
			const isInMiddleOfText = (pos) => CaretPosition.isTextPosition(pos) && !pos.isAtStart() && !pos.isAtEnd();
			const getClosestBlock = (root, pos) => {
				return head(filter$5(parentsAndSelf(SugarElement.fromDom(pos.container()), root), isBlock$2)).getOr(root);
			};
			const hasSpaceBefore = (root, pos) => {
				if (isInMiddleOfText(pos)) return isAfterSpace(pos);
				else return isAfterSpace(pos) || prevPosition(getClosestBlock(root, pos).dom, pos).exists(isAfterSpace);
			};
			const hasSpaceAfter = (root, pos) => {
				if (isInMiddleOfText(pos)) return isBeforeSpace(pos);
				else return isBeforeSpace(pos) || nextPosition(getClosestBlock(root, pos).dom, pos).exists(isBeforeSpace);
			};
			const isPreValue = (value$3) => contains$2(["pre", "pre-wrap"], value$3);
			const isInPre = (pos) => getElementFromPosition(pos).bind((elm) => closest$4(elm, isElement$7)).exists((elm) => isPreValue(get$7(elm, "white-space")));
			const isAtBeginningOfBody = (root, pos) => prevPosition(root.dom, pos).isNone();
			const isAtEndOfBody = (root, pos) => nextPosition(root.dom, pos).isNone();
			const isAtLineBoundary = (root, pos) => isAtBeginningOfBody(root, pos) || isAtEndOfBody(root, pos) || isAtStartOfBlock(root, pos) || isAtEndOfBlock(root, pos) || isAfterBr(root, pos) || isBeforeBr$1(root, pos);
			const isCefBlock = (node) => isNonNullable(node) && isContentEditableFalse$b(node) && isBlockLike(node);
			const isSiblingCefBlock = (root, direction) => (container) => {
				return isCefBlock(new DomTreeWalker(container, root)[direction]());
			};
			const isBeforeCefBlock = (root, pos) => {
				const nextPos = nextPosition(root.dom, pos).getOr(pos);
				const isNextCefBlock = isSiblingCefBlock(root.dom, "next");
				return pos.isAtEnd() && (isNextCefBlock(pos.container()) || isNextCefBlock(nextPos.container()));
			};
			const isAfterCefBlock = (root, pos) => {
				const prevPos = prevPosition(root.dom, pos).getOr(pos);
				const isPrevCefBlock = isSiblingCefBlock(root.dom, "prev");
				return pos.isAtStart() && (isPrevCefBlock(pos.container()) || isPrevCefBlock(prevPos.container()));
			};
			const needsToHaveNbsp = (root, pos) => {
				if (isInPre(pos)) return false;
				else return isAtLineBoundary(root, pos) || hasSpaceBefore(root, pos) || hasSpaceAfter(root, pos);
			};
			const needsToBeNbspLeft = (root, pos) => {
				if (isInPre(pos)) return false;
				else return isAtStartOfBlock(root, pos) || isBeforeBlock(root, pos) || isAfterBr(root, pos) || hasSpaceBefore(root, pos) || isAfterCefBlock(root, pos);
			};
			const leanRight = (pos) => {
				const container = pos.container();
				const offset = pos.offset();
				if (isText$a(container) && offset < container.data.length) return CaretPosition(container, offset + 1);
				else return pos;
			};
			const needsToBeNbspRight = (root, pos) => {
				if (isInPre(pos)) return false;
				else return isAtEndOfBlock(root, pos) || isAfterBlock(root, pos) || isBeforeBr$1(root, pos) || hasSpaceAfter(root, pos) || isBeforeCefBlock(root, pos);
			};
			const needsToBeNbsp = (root, pos) => needsToBeNbspLeft(root, pos) || needsToBeNbspRight(root, leanRight(pos));
			const isNbspAt = (text$1, offset) => isNbsp(text$1.charAt(offset));
			const isWhiteSpaceAt = (text$1, offset) => isWhiteSpace(text$1.charAt(offset));
			const hasNbsp = (pos) => {
				const container = pos.container();
				return isText$a(container) && contains$1(container.data, nbsp);
			};
			const normalizeNbspMiddle = (text$1) => {
				const chars = text$1.split("");
				return map$3(chars, (chr, i) => {
					if (isNbsp(chr) && i > 0 && i < chars.length - 1 && isContent(chars[i - 1]) && isContent(chars[i + 1])) return " ";
					else return chr;
				}).join("");
			};
			const normalizeNbspAtStart = (root, node, makeNbsp) => {
				const text$1 = node.data;
				const firstPos = CaretPosition(node, 0);
				if (!makeNbsp && isNbspAt(text$1, 0) && !needsToBeNbsp(root, firstPos)) {
					node.data = " " + text$1.slice(1);
					return true;
				} else if (makeNbsp && isWhiteSpaceAt(text$1, 0) && needsToBeNbspLeft(root, firstPos)) {
					node.data = nbsp + text$1.slice(1);
					return true;
				} else return false;
			};
			const normalizeNbspInMiddleOfTextNode = (node) => {
				const text$1 = node.data;
				const newText = normalizeNbspMiddle(text$1);
				if (newText !== text$1) {
					node.data = newText;
					return true;
				} else return false;
			};
			const normalizeNbspAtEnd = (root, node, makeNbsp) => {
				const text$1 = node.data;
				const lastPos = CaretPosition(node, text$1.length - 1);
				if (!makeNbsp && isNbspAt(text$1, text$1.length - 1) && !needsToBeNbsp(root, lastPos)) {
					node.data = text$1.slice(0, -1) + " ";
					return true;
				} else if (makeNbsp && isWhiteSpaceAt(text$1, text$1.length - 1) && needsToBeNbspRight(root, lastPos)) {
					node.data = text$1.slice(0, -1) + nbsp;
					return true;
				} else return false;
			};
			const normalizeNbsps = (root, pos) => {
				const container = pos.container();
				if (!isText$a(container)) return Optional.none();
				if (hasNbsp(pos)) return someIf(normalizeNbspAtStart(root, container, false) || normalizeNbspInMiddleOfTextNode(container) || normalizeNbspAtEnd(root, container, false), pos);
				else if (needsToBeNbsp(root, pos)) return someIf(normalizeNbspAtStart(root, container, true) || normalizeNbspAtEnd(root, container, true), pos);
				else return Optional.none();
			};
			const normalizeNbspsInEditor = (editor) => {
				const root = SugarElement.fromDom(editor.getBody());
				if (editor.selection.isCollapsed()) normalizeNbsps(root, CaretPosition.fromRangeStart(editor.selection.getRng())).each((pos) => {
					editor.selection.setRng(pos.toRange());
				});
			};
			const normalize$1 = (node, offset, count$2) => {
				if (count$2 === 0) return;
				const elm = SugarElement.fromDom(node);
				const root = ancestor$4(elm, isBlock$2).getOr(elm);
				const whitespace = node.data.slice(offset, offset + count$2);
				const isEndOfContent = offset + count$2 >= node.data.length && needsToBeNbspRight(root, CaretPosition(node, node.data.length));
				const isStartOfContent = offset === 0 && needsToBeNbspLeft(root, CaretPosition(node, 0));
				node.replaceData(offset, count$2, normalize$4(whitespace, 4, isStartOfContent, isEndOfContent));
			};
			const normalizeWhitespaceAfter = (node, offset) => {
				const content = node.data.slice(offset);
				normalize$1(node, offset, content.length - lTrim(content).length);
			};
			const normalizeWhitespaceBefore = (node, offset) => {
				const content = node.data.slice(0, offset);
				const whitespaceCount = content.length - rTrim(content).length;
				normalize$1(node, offset - whitespaceCount, whitespaceCount);
			};
			const mergeTextNodes = (prevNode, nextNode, normalizeWhitespace, mergeToPrev = true) => {
				const whitespaceOffset = rTrim(prevNode.data).length;
				const newNode = mergeToPrev ? prevNode : nextNode;
				const removeNode$2 = mergeToPrev ? nextNode : prevNode;
				if (mergeToPrev) newNode.appendData(removeNode$2.data);
				else newNode.insertData(0, removeNode$2.data);
				remove$5(SugarElement.fromDom(removeNode$2));
				if (normalizeWhitespace) normalizeWhitespaceAfter(newNode, whitespaceOffset);
				return newNode;
			};
			const needsReposition = (pos, elm) => {
				const container = pos.container();
				const offset = pos.offset();
				return !CaretPosition.isTextPosition(pos) && container === elm.parentNode && offset > CaretPosition.before(elm).offset();
			};
			const reposition = (elm, pos) => needsReposition(pos, elm) ? CaretPosition(pos.container(), pos.offset() - 1) : pos;
			const beforeOrStartOf = (node) => isText$a(node) ? CaretPosition(node, 0) : CaretPosition.before(node);
			const afterOrEndOf = (node) => isText$a(node) ? CaretPosition(node, node.data.length) : CaretPosition.after(node);
			const getPreviousSiblingCaretPosition = (elm) => {
				if (isCaretCandidate$3(elm.previousSibling)) return Optional.some(afterOrEndOf(elm.previousSibling));
				else return elm.previousSibling ? lastPositionIn(elm.previousSibling) : Optional.none();
			};
			const getNextSiblingCaretPosition = (elm) => {
				if (isCaretCandidate$3(elm.nextSibling)) return Optional.some(beforeOrStartOf(elm.nextSibling));
				else return elm.nextSibling ? firstPositionIn(elm.nextSibling) : Optional.none();
			};
			const findCaretPositionBackwardsFromElm = (rootElement, elm) => {
				return Optional.from(elm.previousSibling ? elm.previousSibling : elm.parentNode).bind((node) => prevPosition(rootElement, CaretPosition.before(node))).orThunk(() => nextPosition(rootElement, CaretPosition.after(elm)));
			};
			const findCaretPositionForwardsFromElm = (rootElement, elm) => nextPosition(rootElement, CaretPosition.after(elm)).orThunk(() => prevPosition(rootElement, CaretPosition.before(elm)));
			const findCaretPositionBackwards = (rootElement, elm) => getPreviousSiblingCaretPosition(elm).orThunk(() => getNextSiblingCaretPosition(elm)).orThunk(() => findCaretPositionBackwardsFromElm(rootElement, elm));
			const findCaretPositionForward = (rootElement, elm) => getNextSiblingCaretPosition(elm).orThunk(() => getPreviousSiblingCaretPosition(elm)).orThunk(() => findCaretPositionForwardsFromElm(rootElement, elm));
			const findCaretPosition = (forward, rootElement, elm) => forward ? findCaretPositionForward(rootElement, elm) : findCaretPositionBackwards(rootElement, elm);
			const findCaretPosOutsideElmAfterDelete = (forward, rootElement, elm) => findCaretPosition(forward, rootElement, elm).map(curry(reposition, elm));
			const setSelection$1 = (editor, forward, pos) => {
				pos.fold(() => {
					editor.focus();
				}, (pos$1) => {
					editor.selection.setRng(pos$1.toRange(), forward);
				});
			};
			const eqRawNode = (rawNode) => (elm) => elm.dom === rawNode;
			const isBlock = (editor, elm) => elm && has$2(editor.schema.getBlockElements(), name(elm));
			const paddEmptyBlock = (elm) => {
				if (isEmpty$2(elm)) {
					const br = SugarElement.fromHtml("<br data-mce-bogus=\"1\">");
					empty(elm);
					append$1(elm, br);
					return Optional.some(CaretPosition.before(br.dom));
				} else return Optional.none();
			};
			const deleteNormalized = (elm, afterDeletePosOpt, normalizeWhitespace) => {
				const prevTextOpt = prevSibling(elm).filter(isText$b);
				const nextTextOpt = nextSibling(elm).filter(isText$b);
				remove$5(elm);
				return lift3(prevTextOpt, nextTextOpt, afterDeletePosOpt, (prev$1, next$1, pos) => {
					const prevNode = prev$1.dom, nextNode = next$1.dom;
					const offset = prevNode.data.length;
					mergeTextNodes(prevNode, nextNode, normalizeWhitespace);
					return pos.container() === nextNode ? CaretPosition(prevNode, offset) : pos;
				}).orThunk(() => {
					if (normalizeWhitespace) {
						prevTextOpt.each((elm$1) => normalizeWhitespaceBefore(elm$1.dom, elm$1.dom.length));
						nextTextOpt.each((elm$1) => normalizeWhitespaceAfter(elm$1.dom, 0));
					}
					return afterDeletePosOpt;
				});
			};
			const isInlineElement = (editor, element) => has$2(editor.schema.getTextInlineElements(), name(element));
			const deleteElement$2 = (editor, forward, elm, moveCaret$1 = true) => {
				const afterDeletePos = findCaretPosOutsideElmAfterDelete(forward, editor.getBody(), elm.dom);
				const parentBlock = ancestor$4(elm, curry(isBlock, editor), eqRawNode(editor.getBody()));
				const normalizedAfterDeletePos = deleteNormalized(elm, afterDeletePos, isInlineElement(editor, elm));
				if (editor.dom.isEmpty(editor.getBody())) {
					editor.setContent("");
					editor.selection.setCursorLocation();
				} else parentBlock.bind(paddEmptyBlock).fold(() => {
					if (moveCaret$1) setSelection$1(editor, forward, normalizedAfterDeletePos);
				}, (paddPos) => {
					if (moveCaret$1) setSelection$1(editor, forward, Optional.some(paddPos));
				});
			};
			const strongRtl = /[\u0591-\u07FF\uFB1D-\uFDFF\uFE70-\uFEFC]/;
			const hasStrongRtl = (text$1) => strongRtl.test(text$1);
			const isInlineTarget = (editor, elm) => is$1(SugarElement.fromDom(elm), getInlineBoundarySelector(editor)) && !isTransparentBlock(editor.schema, elm) && editor.dom.isEditable(elm);
			const isRtl = (element) => {
				var _a;
				return DOMUtils.DOM.getStyle(element, "direction", true) === "rtl" || hasStrongRtl((_a = element.textContent) !== null && _a !== void 0 ? _a : "");
			};
			const findInlineParents = (isInlineTarget$1, rootNode, pos) => filter$5(DOMUtils.DOM.getParents(pos.container(), "*", rootNode), isInlineTarget$1);
			const findRootInline = (isInlineTarget$1, rootNode, pos) => {
				const parents$2 = findInlineParents(isInlineTarget$1, rootNode, pos);
				return Optional.from(parents$2[parents$2.length - 1]);
			};
			const hasSameParentBlock = (rootNode, node1, node2) => {
				const block1 = getParentBlock$3(node1, rootNode);
				const block2 = getParentBlock$3(node2, rootNode);
				return isNonNullable(block1) && block1 === block2;
			};
			const isAtZwsp = (pos) => isBeforeInline(pos) || isAfterInline(pos);
			const normalizePosition = (forward, pos) => {
				const container = pos.container(), offset = pos.offset();
				if (forward) if (isCaretContainerInline(container)) if (isText$a(container.nextSibling)) return CaretPosition(container.nextSibling, 0);
				else return CaretPosition.after(container);
				else return isBeforeInline(pos) ? CaretPosition(container, offset + 1) : pos;
				else if (isCaretContainerInline(container)) if (isText$a(container.previousSibling)) return CaretPosition(container.previousSibling, container.previousSibling.data.length);
				else return CaretPosition.before(container);
				else return isAfterInline(pos) ? CaretPosition(container, offset - 1) : pos;
			};
			const normalizeForwards = curry(normalizePosition, true);
			const normalizeBackwards = curry(normalizePosition, false);
			const execCommandIgnoreInputEvents = (editor, command) => {
				const inputBlocker = (e) => e.stopImmediatePropagation();
				editor.on("beforeinput input", inputBlocker, true);
				editor.getDoc().execCommand(command);
				editor.off("beforeinput input", inputBlocker);
			};
			const execEditorDeleteCommand = (editor) => {
				editor.execCommand("delete");
			};
			const execNativeDeleteCommand = (editor) => execCommandIgnoreInputEvents(editor, "Delete");
			const execNativeForwardDeleteCommand = (editor) => execCommandIgnoreInputEvents(editor, "ForwardDelete");
			const isBeforeRoot = (rootNode) => (elm) => is$2(parent(elm), rootNode, eq);
			const isTextBlockOrListItem = (element) => isTextBlock$2(element) || isListItem$1(element);
			const getParentBlock$2 = (rootNode, elm) => {
				if (contains(rootNode, elm)) return closest$4(elm, isTextBlockOrListItem, isBeforeRoot(rootNode));
				else return Optional.none();
			};
			const paddEmptyBody = (editor, moveSelection$1 = true) => {
				if (editor.dom.isEmpty(editor.getBody())) editor.setContent("", { no_selection: !moveSelection$1 });
			};
			const willDeleteLastPositionInElement = (forward, fromPos, elm) => lift2(firstPositionIn(elm), lastPositionIn(elm), (firstPos, lastPos) => {
				const normalizedFirstPos = normalizePosition(true, firstPos);
				const normalizedLastPos = normalizePosition(false, lastPos);
				const normalizedFromPos = normalizePosition(false, fromPos);
				if (forward) return nextPosition(elm, normalizedFromPos).exists((nextPos) => nextPos.isEqual(normalizedLastPos) && fromPos.isEqual(normalizedFirstPos));
				else return prevPosition(elm, normalizedFromPos).exists((prevPos) => prevPos.isEqual(normalizedFirstPos) && fromPos.isEqual(normalizedLastPos));
			}).getOr(true);
			const freefallRtl = (root) => {
				return (isComment$1(root) ? prevSibling(root) : lastChild(root)).bind(freefallRtl).orThunk(() => Optional.some(root));
			};
			const deleteRangeContents = (editor, rng, root, moveSelection$1 = true) => {
				var _a;
				rng.deleteContents();
				const lastNode = freefallRtl(root).getOr(root);
				const lastBlock = SugarElement.fromDom((_a = editor.dom.getParent(lastNode.dom, editor.dom.isBlock)) !== null && _a !== void 0 ? _a : root.dom);
				if (lastBlock.dom === editor.getBody()) paddEmptyBody(editor, moveSelection$1);
				else if (isEmpty$2(lastBlock)) {
					fillWithPaddingBr(lastBlock);
					if (moveSelection$1) editor.selection.setCursorLocation(lastBlock.dom, 0);
				}
				if (!eq(root, lastBlock)) each$e((is$2(parent(lastBlock), root) ? [] : siblings(lastBlock)).concat(children$1(root)), (node) => {
					if (!eq(node, lastBlock) && !contains(node, lastBlock) && isEmpty$2(node)) remove$5(node);
				});
			};
			const isRootFromElement = (root) => (cur) => eq(root, cur);
			const getTableCells = (table$1) => descendants(table$1, "td,th");
			const getTableDetailsFromRange = (rng, isRoot$2) => {
				const getTable$1 = (node) => getClosestTable(SugarElement.fromDom(node), isRoot$2);
				const startTable = getTable$1(rng.startContainer);
				const endTable = getTable$1(rng.endContainer);
				const isStartInTable = startTable.isSome();
				const isEndInTable = endTable.isSome();
				const isSameTable = lift2(startTable, endTable, eq).getOr(false);
				return {
					startTable,
					endTable,
					isStartInTable,
					isEndInTable,
					isSameTable,
					isMultiTable: !isSameTable && isStartInTable && isEndInTable
				};
			};
			const tableCellRng = (start$2, end$1) => ({
				start: start$2,
				end: end$1
			});
			const tableSelection = (rng, table$1, cells$1) => ({
				rng,
				table: table$1,
				cells: cells$1
			});
			const deleteAction = Adt.generate([
				{ singleCellTable: ["rng", "cell"] },
				{ fullTable: ["table"] },
				{ partialTable: ["cells", "outsideDetails"] },
				{ multiTable: [
					"startTableCells",
					"endTableCells",
					"betweenRng"
				] }
			]);
			const getClosestCell$1 = (container, isRoot$2) => closest$3(SugarElement.fromDom(container), "td,th", isRoot$2);
			const isExpandedCellRng = (cellRng) => !eq(cellRng.start, cellRng.end);
			const getTableFromCellRng = (cellRng, isRoot$2) => getClosestTable(cellRng.start, isRoot$2).bind((startParentTable) => getClosestTable(cellRng.end, isRoot$2).bind((endParentTable) => someIf(eq(startParentTable, endParentTable), startParentTable)));
			const isSingleCellTable = (cellRng, isRoot$2) => !isExpandedCellRng(cellRng) && getTableFromCellRng(cellRng, isRoot$2).exists((table$1) => {
				const rows = table$1.dom.rows;
				return rows.length === 1 && rows[0].cells.length === 1;
			});
			const getCellRng = (rng, isRoot$2) => {
				return lift2(getClosestCell$1(rng.startContainer, isRoot$2), getClosestCell$1(rng.endContainer, isRoot$2), tableCellRng);
			};
			const getCellRangeFromStartTable = (isRoot$2) => (startCell) => getClosestTable(startCell, isRoot$2).bind((table$1) => last$3(getTableCells(table$1)).map((endCell) => tableCellRng(startCell, endCell)));
			const getCellRangeFromEndTable = (isRoot$2) => (endCell) => getClosestTable(endCell, isRoot$2).bind((table$1) => head(getTableCells(table$1)).map((startCell) => tableCellRng(startCell, endCell)));
			const getTableSelectionFromCellRng = (isRoot$2) => (cellRng) => getTableFromCellRng(cellRng, isRoot$2).map((table$1) => tableSelection(cellRng, table$1, getTableCells(table$1)));
			const getTableSelections = (cellRng, selectionDetails, rng, isRoot$2) => {
				if (rng.collapsed || !cellRng.forall(isExpandedCellRng)) return Optional.none();
				else if (selectionDetails.isSameTable) {
					const sameTableSelection = cellRng.bind(getTableSelectionFromCellRng(isRoot$2));
					return Optional.some({
						start: sameTableSelection,
						end: sameTableSelection
					});
				} else {
					const startCell = getClosestCell$1(rng.startContainer, isRoot$2);
					const endCell = getClosestCell$1(rng.endContainer, isRoot$2);
					const startTableSelection = startCell.bind(getCellRangeFromStartTable(isRoot$2)).bind(getTableSelectionFromCellRng(isRoot$2));
					const endTableSelection = endCell.bind(getCellRangeFromEndTable(isRoot$2)).bind(getTableSelectionFromCellRng(isRoot$2));
					return Optional.some({
						start: startTableSelection,
						end: endTableSelection
					});
				}
			};
			const getCellIndex = (cells$1, cell$1) => findIndex$2(cells$1, (x) => eq(x, cell$1));
			const getSelectedCells = (tableSelection$1) => lift2(getCellIndex(tableSelection$1.cells, tableSelection$1.rng.start), getCellIndex(tableSelection$1.cells, tableSelection$1.rng.end), (startIndex, endIndex) => tableSelection$1.cells.slice(startIndex, endIndex + 1));
			const isSingleCellTableContentSelected = (optCellRng, rng, isRoot$2) => optCellRng.exists((cellRng) => isSingleCellTable(cellRng, isRoot$2) && hasAllContentsSelected(cellRng.start, rng));
			const unselectCells = (rng, selectionDetails) => {
				const { startTable, endTable } = selectionDetails;
				const otherContentRng = rng.cloneRange();
				startTable.each((table$1) => otherContentRng.setStartAfter(table$1.dom));
				endTable.each((table$1) => otherContentRng.setEndBefore(table$1.dom));
				return otherContentRng;
			};
			const handleSingleTable = (cellRng, selectionDetails, rng, isRoot$2) => getTableSelections(cellRng, selectionDetails, rng, isRoot$2).bind(({ start: start$2, end: end$1 }) => start$2.or(end$1)).bind((tableSelection$1) => {
				const { isSameTable } = selectionDetails;
				const selectedCells = getSelectedCells(tableSelection$1).getOr([]);
				if (isSameTable && tableSelection$1.cells.length === selectedCells.length) return Optional.some(deleteAction.fullTable(tableSelection$1.table));
				else if (selectedCells.length > 0) if (isSameTable) return Optional.some(deleteAction.partialTable(selectedCells, Optional.none()));
				else {
					const otherContentRng = unselectCells(rng, selectionDetails);
					return Optional.some(deleteAction.partialTable(selectedCells, Optional.some({
						...selectionDetails,
						rng: otherContentRng
					})));
				}
				else return Optional.none();
			});
			const handleMultiTable = (cellRng, selectionDetails, rng, isRoot$2) => getTableSelections(cellRng, selectionDetails, rng, isRoot$2).bind(({ start: start$2, end: end$1 }) => {
				const startTableSelectedCells = start$2.bind(getSelectedCells).getOr([]);
				const endTableSelectedCells = end$1.bind(getSelectedCells).getOr([]);
				if (startTableSelectedCells.length > 0 && endTableSelectedCells.length > 0) {
					const otherContentRng = unselectCells(rng, selectionDetails);
					return Optional.some(deleteAction.multiTable(startTableSelectedCells, endTableSelectedCells, otherContentRng));
				} else return Optional.none();
			});
			const getActionFromRange = (root, rng) => {
				const isRoot$2 = isRootFromElement(root);
				const optCellRng = getCellRng(rng, isRoot$2);
				const selectionDetails = getTableDetailsFromRange(rng, isRoot$2);
				if (isSingleCellTableContentSelected(optCellRng, rng, isRoot$2)) return optCellRng.map((cellRng) => deleteAction.singleCellTable(rng, cellRng.start));
				else if (selectionDetails.isMultiTable) return handleMultiTable(optCellRng, selectionDetails, rng, isRoot$2);
				else return handleSingleTable(optCellRng, selectionDetails, rng, isRoot$2);
			};
			const cleanCells = (cells$1) => each$e(cells$1, (cell$1) => {
				remove$a(cell$1, "contenteditable");
				fillWithPaddingBr(cell$1);
			});
			const getOutsideBlock = (editor, container) => Optional.from(editor.dom.getParent(container, editor.dom.isBlock)).map(SugarElement.fromDom);
			const handleEmptyBlock = (editor, startInTable, emptyBlock$1) => {
				emptyBlock$1.each((block) => {
					if (startInTable) remove$5(block);
					else {
						fillWithPaddingBr(block);
						editor.selection.setCursorLocation(block.dom, 0);
					}
				});
			};
			const deleteContentInsideCell = (editor, cell$1, rng, isFirstCellInSelection) => {
				const insideTableRng = rng.cloneRange();
				if (isFirstCellInSelection) {
					insideTableRng.setStart(rng.startContainer, rng.startOffset);
					insideTableRng.setEndAfter(cell$1.dom.lastChild);
				} else {
					insideTableRng.setStartBefore(cell$1.dom.firstChild);
					insideTableRng.setEnd(rng.endContainer, rng.endOffset);
				}
				deleteCellContents(editor, insideTableRng, cell$1, false).each((action$1) => action$1());
			};
			const collapseAndRestoreCellSelection = (editor) => {
				const selectedCells = getCellsFromEditor(editor);
				const selectedNode = SugarElement.fromDom(editor.selection.getNode());
				if (isTableCell$3(selectedNode.dom) && isEmpty$2(selectedNode)) editor.selection.setCursorLocation(selectedNode.dom, 0);
				else editor.selection.collapse(true);
				if (selectedCells.length > 1 && exists(selectedCells, (cell$1) => eq(cell$1, selectedNode))) set$3(selectedNode, "data-mce-selected", "1");
			};
			const emptySingleTableCells = (editor, cells$1, outsideDetails) => Optional.some(() => {
				const editorRng = editor.selection.getRng();
				cleanCells(outsideDetails.bind(({ rng, isStartInTable }) => {
					const outsideBlock = getOutsideBlock(editor, isStartInTable ? rng.endContainer : rng.startContainer);
					rng.deleteContents();
					handleEmptyBlock(editor, isStartInTable, outsideBlock.filter(isEmpty$2));
					const endPointCell = isStartInTable ? cells$1[0] : cells$1[cells$1.length - 1];
					deleteContentInsideCell(editor, endPointCell, editorRng, isStartInTable);
					if (!isEmpty$2(endPointCell)) return Optional.some(isStartInTable ? cells$1.slice(1) : cells$1.slice(0, -1));
					else return Optional.none();
				}).getOr(cells$1));
				collapseAndRestoreCellSelection(editor);
			});
			const emptyMultiTableCells = (editor, startTableCells, endTableCells, betweenRng) => Optional.some(() => {
				const rng = editor.selection.getRng();
				const startCell = startTableCells[0];
				const endCell = endTableCells[endTableCells.length - 1];
				deleteContentInsideCell(editor, startCell, rng, true);
				deleteContentInsideCell(editor, endCell, rng, false);
				const startTableCellsToClean = isEmpty$2(startCell) ? startTableCells : startTableCells.slice(1);
				const endTableCellsToClean = isEmpty$2(endCell) ? endTableCells : endTableCells.slice(0, -1);
				cleanCells(startTableCellsToClean.concat(endTableCellsToClean));
				betweenRng.deleteContents();
				collapseAndRestoreCellSelection(editor);
			});
			const deleteCellContents = (editor, rng, cell$1, moveSelection$1 = true) => Optional.some(() => {
				deleteRangeContents(editor, rng, cell$1, moveSelection$1);
			});
			const deleteTableElement = (editor, table$1) => Optional.some(() => deleteElement$2(editor, false, table$1));
			const deleteCellRange = (editor, rootElm, rng) => getActionFromRange(rootElm, rng).bind((action$1) => action$1.fold(curry(deleteCellContents, editor), curry(deleteTableElement, editor), curry(emptySingleTableCells, editor), curry(emptyMultiTableCells, editor)));
			const deleteCaptionRange = (editor, caption) => emptyElement(editor, caption);
			const deleteTableRange = (editor, rootElm, rng, startElm) => getParentCaption(rootElm, startElm).fold(() => deleteCellRange(editor, rootElm, rng), (caption) => deleteCaptionRange(editor, caption));
			const deleteRange$3 = (editor, startElm, selectedCells) => {
				const rootNode = SugarElement.fromDom(editor.getBody());
				const rng = editor.selection.getRng();
				return selectedCells.length !== 0 ? emptySingleTableCells(editor, selectedCells, Optional.none()) : deleteTableRange(editor, rootNode, rng, startElm);
			};
			const getParentCell = (rootElm, elm) => find$2(parentsAndSelf(elm, rootElm), isTableCell$2);
			const getParentCaption = (rootElm, elm) => find$2(parentsAndSelf(elm, rootElm), isTag("caption"));
			const deleteBetweenCells = (editor, rootElm, forward, fromCell, from$1) => navigate(forward, editor.getBody(), from$1).bind((to$1) => getParentCell(rootElm, SugarElement.fromDom(to$1.getNode())).bind((toCell) => eq(toCell, fromCell) ? Optional.none() : Optional.some(noop)));
			const emptyElement = (editor, elm) => Optional.some(() => {
				fillWithPaddingBr(elm);
				editor.selection.setCursorLocation(elm.dom, 0);
			});
			const isDeleteOfLastCharPos = (fromCaption, forward, from$1, to$1) => firstPositionIn(fromCaption.dom).bind((first$2) => lastPositionIn(fromCaption.dom).map((last$4) => forward ? from$1.isEqual(first$2) && to$1.isEqual(last$4) : from$1.isEqual(last$4) && to$1.isEqual(first$2))).getOr(true);
			const emptyCaretCaption = (editor, elm) => emptyElement(editor, elm);
			const validateCaretCaption = (rootElm, fromCaption, to$1) => getParentCaption(rootElm, SugarElement.fromDom(to$1.getNode())).fold(() => Optional.some(noop), (toCaption) => someIf(!eq(toCaption, fromCaption), noop));
			const deleteCaretInsideCaption = (editor, rootElm, forward, fromCaption, from$1) => navigate(forward, editor.getBody(), from$1).fold(() => Optional.some(noop), (to$1) => isDeleteOfLastCharPos(fromCaption, forward, from$1, to$1) ? emptyCaretCaption(editor, fromCaption) : validateCaretCaption(rootElm, fromCaption, to$1));
			const deleteCaretCells = (editor, forward, rootElm, startElm) => {
				const from$1 = CaretPosition.fromRangeStart(editor.selection.getRng());
				return getParentCell(rootElm, startElm).bind((fromCell) => isEmpty$2(fromCell) ? emptyElement(editor, fromCell) : deleteBetweenCells(editor, rootElm, forward, fromCell, from$1));
			};
			const deleteCaretCaption = (editor, forward, rootElm, fromCaption) => {
				const from$1 = CaretPosition.fromRangeStart(editor.selection.getRng());
				return isEmpty$2(fromCaption) ? emptyElement(editor, fromCaption) : deleteCaretInsideCaption(editor, rootElm, forward, fromCaption, from$1);
			};
			const isNearTable = (forward, pos) => forward ? isBeforeTable(pos) : isAfterTable(pos);
			const isBeforeOrAfterTable = (editor, forward) => {
				const fromPos = CaretPosition.fromRangeStart(editor.selection.getRng());
				return isNearTable(forward, fromPos) || fromPosition(forward, editor.getBody(), fromPos).exists((pos) => isNearTable(forward, pos));
			};
			const deleteCaret$3 = (editor, forward, startElm) => {
				const rootElm = SugarElement.fromDom(editor.getBody());
				return getParentCaption(rootElm, startElm).fold(() => deleteCaretCells(editor, forward, rootElm, startElm).orThunk(() => someIf(isBeforeOrAfterTable(editor, forward), noop)), (fromCaption) => deleteCaretCaption(editor, forward, rootElm, fromCaption));
			};
			const backspaceDelete$a = (editor, forward) => {
				const startElm = SugarElement.fromDom(editor.selection.getStart(true));
				const cells$1 = getCellsFromEditor(editor);
				return editor.selection.isCollapsed() && cells$1.length === 0 ? deleteCaret$3(editor, forward, startElm) : deleteRange$3(editor, startElm, cells$1);
			};
			const getContentEditableRoot$1 = (root, node) => {
				let tempNode = node;
				while (tempNode && tempNode !== root) {
					if (isContentEditableTrue$3(tempNode) || isContentEditableFalse$b(tempNode)) return tempNode;
					tempNode = tempNode.parentNode;
				}
				return null;
			};
			const internalAttributesPrefixes = [
				"data-ephox-",
				"data-mce-",
				"data-alloy-",
				"data-snooker-",
				"_"
			];
			const each$9 = Tools.each;
			const ElementUtils = (editor) => {
				const dom$1 = editor.dom;
				const internalAttributes = new Set(editor.serializer.getTempAttrs());
				const compare = (node1, node2) => {
					if (node1.nodeName !== node2.nodeName || node1.nodeType !== node2.nodeType) return false;
					const getAttribs = (node) => {
						const attribs = {};
						each$9(dom$1.getAttribs(node), (attr) => {
							const name$1 = attr.nodeName.toLowerCase();
							if (name$1 !== "style" && !isAttributeInternal(name$1)) attribs[name$1] = dom$1.getAttrib(node, name$1);
						});
						return attribs;
					};
					const compareObjects = (obj1, obj2) => {
						for (const name$1 in obj1) if (has$2(obj1, name$1)) {
							const value$3 = obj2[name$1];
							if (isUndefined(value$3)) return false;
							if (obj1[name$1] !== value$3) return false;
							delete obj2[name$1];
						}
						for (const name$1 in obj2) if (has$2(obj2, name$1)) return false;
						return true;
					};
					if (isElement$6(node1) && isElement$6(node2)) {
						if (!compareObjects(getAttribs(node1), getAttribs(node2))) return false;
						if (!compareObjects(dom$1.parseStyle(dom$1.getAttrib(node1, "style")), dom$1.parseStyle(dom$1.getAttrib(node2, "style")))) return false;
					}
					return !isBookmarkNode$1(node1) && !isBookmarkNode$1(node2);
				};
				const isAttributeInternal = (attributeName) => exists(internalAttributesPrefixes, (value$3) => startsWith(attributeName, value$3)) || internalAttributes.has(attributeName);
				return {
					compare,
					isAttributeInternal
				};
			};
			const traverse = (root, fn) => {
				let node = root;
				while (node = node.walk()) fn(node);
			};
			const matchNode$1 = (nodeFilters, attributeFilters, node, matches) => {
				const name$1 = node.name;
				for (let ni = 0, nl = nodeFilters.length; ni < nl; ni++) {
					const filter$6 = nodeFilters[ni];
					if (filter$6.name === name$1) {
						const match$3 = matches.nodes[name$1];
						if (match$3) match$3.nodes.push(node);
						else matches.nodes[name$1] = {
							filter: filter$6,
							nodes: [node]
						};
					}
				}
				if (node.attributes) for (let ai = 0, al = attributeFilters.length; ai < al; ai++) {
					const filter$6 = attributeFilters[ai];
					const attrName = filter$6.name;
					if (attrName in node.attributes.map) {
						const match$3 = matches.attributes[attrName];
						if (match$3) match$3.nodes.push(node);
						else matches.attributes[attrName] = {
							filter: filter$6,
							nodes: [node]
						};
					}
				}
			};
			const findMatchingNodes = (nodeFilters, attributeFilters, node) => {
				const matches = {
					nodes: {},
					attributes: {}
				};
				if (node.firstChild) traverse(node, (childNode) => {
					matchNode$1(nodeFilters, attributeFilters, childNode, matches);
				});
				return matches;
			};
			const runFilters = (matches, args) => {
				const run = (matchRecord, filteringAttributes) => {
					each$d(matchRecord, (match$3) => {
						const nodes = from(match$3.nodes);
						each$e(match$3.filter.callbacks, (callback) => {
							for (let i = nodes.length - 1; i >= 0; i--) {
								const node = nodes[i];
								if (!(filteringAttributes ? node.attr(match$3.filter.name) !== void 0 : node.name === match$3.filter.name) || isNullable(node.parent)) nodes.splice(i, 1);
							}
							if (nodes.length > 0) callback(nodes, match$3.filter.name, args);
						});
					});
				};
				run(matches.nodes, false);
				run(matches.attributes, true);
			};
			const filter$2 = (nodeFilters, attributeFilters, node, args = {}) => {
				runFilters(findMatchingNodes(nodeFilters, attributeFilters, node), args);
			};
			const paddEmptyNode = (settings, args, isBlock$3, node) => {
				if ((settings.pad_empty_with_br || args.insert) && isBlock$3(node)) {
					const astNode = new AstNode("br", 1);
					if (args.insert) astNode.attr("data-mce-bogus", "1");
					node.empty().append(astNode);
				} else node.empty().append(new AstNode("#text", 3)).value = nbsp;
			};
			const isPaddedWithNbsp = (node) => {
				var _a;
				return hasOnlyChild(node, "#text") && ((_a = node === null || node === void 0 ? void 0 : node.firstChild) === null || _a === void 0 ? void 0 : _a.value) === nbsp;
			};
			const hasOnlyChild = (node, name$1) => {
				const firstChild$1 = node === null || node === void 0 ? void 0 : node.firstChild;
				return isNonNullable(firstChild$1) && firstChild$1 === node.lastChild && firstChild$1.name === name$1;
			};
			const isPadded = (schema, node) => {
				const rule = schema.getElementRule(node.name);
				return (rule === null || rule === void 0 ? void 0 : rule.paddEmpty) === true;
			};
			const isEmpty = (schema, nonEmptyElements, whitespaceElements, node) => node.isEmpty(nonEmptyElements, whitespaceElements, (node$1) => isPadded(schema, node$1));
			const isLineBreakNode = (node, isBlock$3) => isNonNullable(node) && (isBlock$3(node) || node.name === "br");
			const findClosestEditingHost = (scope) => {
				let editableNode;
				for (let node = scope; node; node = node.parent) {
					const contentEditable = node.attr("contenteditable");
					if (contentEditable === "false") break;
					else if (contentEditable === "true") editableNode = node;
				}
				return Optional.from(editableNode);
			};
			const removeOrUnwrapInvalidNode = (node, schema, originalNodeParent = node.parent) => {
				if (schema.getSpecialElements()[node.name]) node.empty().remove();
				else {
					const children$2 = node.children();
					for (const childNode of children$2) if (originalNodeParent && !schema.isValidChild(originalNodeParent.name, childNode.name)) removeOrUnwrapInvalidNode(childNode, schema, originalNodeParent);
					node.unwrap();
				}
			};
			const cleanInvalidNodes = (nodes, schema, rootNode, onCreate = noop) => {
				const textBlockElements = schema.getTextBlockElements();
				const nonEmptyElements = schema.getNonEmptyElements();
				const whitespaceElements = schema.getWhitespaceElements();
				const nonSplittableElements = Tools.makeMap("tr,td,th,tbody,thead,tfoot,table,summary");
				const fixed = /* @__PURE__ */ new Set();
				const isSplittableElement = (node) => node !== rootNode && !nonSplittableElements[node.name];
				for (let ni = 0; ni < nodes.length; ni++) {
					const node = nodes[ni];
					let parent$1;
					let newParent;
					let tempNode;
					if (!node.parent || fixed.has(node)) continue;
					if (textBlockElements[node.name] && node.parent.name === "li") {
						let sibling$2 = node.next;
						while (sibling$2) {
							if (textBlockElements[sibling$2.name]) {
								sibling$2.name = "li";
								fixed.add(sibling$2);
								node.parent.insert(sibling$2, node.parent);
							} else break;
							sibling$2 = sibling$2.next;
						}
						node.unwrap();
						continue;
					}
					const parents$2 = [node];
					for (parent$1 = node.parent; parent$1 && !schema.isValidChild(parent$1.name, node.name) && isSplittableElement(parent$1); parent$1 = parent$1.parent) parents$2.push(parent$1);
					if (parent$1 && parents$2.length > 1) if (schema.isValidChild(parent$1.name, node.name)) {
						parents$2.reverse();
						newParent = parents$2[0].clone();
						onCreate(newParent);
						let currentNode = newParent;
						for (let i = 0; i < parents$2.length - 1; i++) {
							if (schema.isValidChild(currentNode.name, parents$2[i].name) && i > 0) {
								tempNode = parents$2[i].clone();
								onCreate(tempNode);
								currentNode.append(tempNode);
							} else tempNode = currentNode;
							for (let childNode = parents$2[i].firstChild; childNode && childNode !== parents$2[i + 1];) {
								const nextNode = childNode.next;
								tempNode.append(childNode);
								childNode = nextNode;
							}
							currentNode = tempNode;
						}
						if (!isEmpty(schema, nonEmptyElements, whitespaceElements, newParent)) {
							parent$1.insert(newParent, parents$2[0], true);
							parent$1.insert(node, newParent);
						} else parent$1.insert(node, parents$2[0], true);
						parent$1 = parents$2[0];
						if (isEmpty(schema, nonEmptyElements, whitespaceElements, parent$1) || hasOnlyChild(parent$1, "br")) parent$1.empty().remove();
					} else removeOrUnwrapInvalidNode(node, schema);
					else if (node.parent) {
						if (node.name === "li") {
							let sibling$2 = node.prev;
							if (sibling$2 && (sibling$2.name === "ul" || sibling$2.name === "ol")) {
								sibling$2.append(node);
								continue;
							}
							sibling$2 = node.next;
							if (sibling$2 && (sibling$2.name === "ul" || sibling$2.name === "ol") && sibling$2.firstChild) {
								sibling$2.insert(node, sibling$2.firstChild, true);
								continue;
							}
							const wrapper = new AstNode("ul", 1);
							onCreate(wrapper);
							node.wrap(wrapper);
							continue;
						}
						if (schema.isValidChild(node.parent.name, "div") && schema.isValidChild("div", node.name)) {
							const wrapper = new AstNode("div", 1);
							onCreate(wrapper);
							node.wrap(wrapper);
						} else removeOrUnwrapInvalidNode(node, schema);
					}
				}
			};
			const hasClosest = (node, parentName) => {
				let tempNode = node;
				while (tempNode) {
					if (tempNode.name === parentName) return true;
					tempNode = tempNode.parent;
				}
				return false;
			};
			const isInvalid = (schema, node, parent$1 = node.parent) => {
				if (parent$1 && schema.children[node.name] && !schema.isValidChild(parent$1.name, node.name)) return true;
				else if (parent$1 && node.name === "a" && hasClosest(parent$1, "a")) return true;
				else return false;
			};
			const createRange = (sc, so, ec, eo) => {
				const rng = document.createRange();
				rng.setStart(sc, so);
				rng.setEnd(ec, eo);
				return rng;
			};
			const normalizeBlockSelectionRange = (rng) => {
				const startPos = CaretPosition.fromRangeStart(rng);
				const endPos = CaretPosition.fromRangeEnd(rng);
				const rootNode = rng.commonAncestorContainer;
				return fromPosition(false, rootNode, endPos).map((newEndPos) => {
					if (!isInSameBlock(startPos, endPos, rootNode) && isInSameBlock(startPos, newEndPos, rootNode)) return createRange(startPos.container(), startPos.offset(), newEndPos.container(), newEndPos.offset());
					else return rng;
				}).getOr(rng);
			};
			const normalize = (rng) => rng.collapsed ? rng : normalizeBlockSelectionRange(rng);
			const hasOnlyOneChild$1 = (node) => {
				return isNonNullable(node.firstChild) && node.firstChild === node.lastChild;
			};
			const isPaddingNode = (node) => {
				return node.name === "br" || node.value === nbsp;
			};
			const isPaddedEmptyBlock = (schema, node) => {
				return schema.getBlockElements()[node.name] && hasOnlyOneChild$1(node) && isPaddingNode(node.firstChild);
			};
			const isEmptyFragmentElement = (schema, node) => {
				const nonEmptyElements = schema.getNonEmptyElements();
				return isNonNullable(node) && (node.isEmpty(nonEmptyElements) || isPaddedEmptyBlock(schema, node));
			};
			const isListFragment = (schema, fragment) => {
				let firstChild$1 = fragment.firstChild;
				let lastChild$1 = fragment.lastChild;
				if (firstChild$1 && firstChild$1.name === "meta") firstChild$1 = firstChild$1.next;
				if (lastChild$1 && lastChild$1.attr("id") === "mce_marker") lastChild$1 = lastChild$1.prev;
				if (isEmptyFragmentElement(schema, lastChild$1)) lastChild$1 = lastChild$1 === null || lastChild$1 === void 0 ? void 0 : lastChild$1.prev;
				if (!firstChild$1 || firstChild$1 !== lastChild$1) return false;
				return firstChild$1.name === "ul" || firstChild$1.name === "ol";
			};
			const cleanupDomFragment = (domFragment) => {
				var _a, _b;
				const firstChild$1 = domFragment.firstChild;
				const lastChild$1 = domFragment.lastChild;
				if (firstChild$1 && firstChild$1.nodeName === "META") (_a = firstChild$1.parentNode) === null || _a === void 0 || _a.removeChild(firstChild$1);
				if (lastChild$1 && lastChild$1.id === "mce_marker") (_b = lastChild$1.parentNode) === null || _b === void 0 || _b.removeChild(lastChild$1);
				return domFragment;
			};
			const toDomFragment = (dom$1, serializer, fragment) => {
				const html$2 = serializer.serialize(fragment);
				return cleanupDomFragment(dom$1.createFragment(html$2));
			};
			const listItems = (elm) => {
				var _a;
				return filter$5((_a = elm === null || elm === void 0 ? void 0 : elm.childNodes) !== null && _a !== void 0 ? _a : [], (child$2) => {
					return child$2.nodeName === "LI";
				});
			};
			const isPadding = (node) => {
				return node.data === nbsp || isBr$6(node);
			};
			const isListItemPadded = (node) => {
				return isNonNullable(node === null || node === void 0 ? void 0 : node.firstChild) && node.firstChild === node.lastChild && isPadding(node.firstChild);
			};
			const isEmptyOrPadded = (elm) => {
				return !elm.firstChild || isListItemPadded(elm);
			};
			const trimListItems = (elms) => {
				return elms.length > 0 && isEmptyOrPadded(elms[elms.length - 1]) ? elms.slice(0, -1) : elms;
			};
			const getParentLi = (dom$1, node) => {
				const parentBlock = dom$1.getParent(node, dom$1.isBlock);
				return parentBlock && parentBlock.nodeName === "LI" ? parentBlock : null;
			};
			const isParentBlockLi = (dom$1, node) => {
				return !!getParentLi(dom$1, node);
			};
			const getSplit = (parentNode, rng) => {
				const beforeRng = rng.cloneRange();
				const afterRng = rng.cloneRange();
				beforeRng.setStartBefore(parentNode);
				afterRng.setEndAfter(parentNode);
				return [beforeRng.cloneContents(), afterRng.cloneContents()];
			};
			const findFirstIn = (node, rootNode) => {
				const caretPos = CaretPosition.before(node);
				const newCaretPos = CaretWalker(rootNode).next(caretPos);
				return newCaretPos ? newCaretPos.toRange() : null;
			};
			const findLastOf = (node, rootNode) => {
				const caretPos = CaretPosition.after(node);
				const newCaretPos = CaretWalker(rootNode).prev(caretPos);
				return newCaretPos ? newCaretPos.toRange() : null;
			};
			const insertMiddle = (target, elms, rootNode, rng) => {
				const parts = getSplit(target, rng);
				const parentElm = target.parentNode;
				if (parentElm) {
					parentElm.insertBefore(parts[0], target);
					Tools.each(elms, (li) => {
						parentElm.insertBefore(li, target);
					});
					parentElm.insertBefore(parts[1], target);
					parentElm.removeChild(target);
				}
				return findLastOf(elms[elms.length - 1], rootNode);
			};
			const insertBefore$2 = (target, elms, rootNode) => {
				const parentElm = target.parentNode;
				if (parentElm) Tools.each(elms, (elm) => {
					parentElm.insertBefore(elm, target);
				});
				return findFirstIn(target, rootNode);
			};
			const insertAfter$2 = (target, elms, rootNode, dom$1) => {
				dom$1.insertAfter(elms.reverse(), target);
				return findLastOf(elms[0], rootNode);
			};
			const insertAtCaret$1 = (serializer, dom$1, rng, fragment) => {
				const domFragment = toDomFragment(dom$1, serializer, fragment);
				const liTarget = getParentLi(dom$1, rng.startContainer);
				const liElms = trimListItems(listItems(domFragment.firstChild));
				const BEGINNING = 1, END = 2;
				const rootNode = dom$1.getRoot();
				const isAt = (location) => {
					const caretPos = CaretPosition.fromRangeStart(rng);
					const caretWalker = CaretWalker(dom$1.getRoot());
					const newPos = location === BEGINNING ? caretWalker.prev(caretPos) : caretWalker.next(caretPos);
					const newPosNode = newPos === null || newPos === void 0 ? void 0 : newPos.getNode();
					return newPosNode ? getParentLi(dom$1, newPosNode) !== liTarget : true;
				};
				if (!liTarget) return null;
				else if (isAt(BEGINNING)) return insertBefore$2(liTarget, liElms, rootNode);
				else if (isAt(END)) return insertAfter$2(liTarget, liElms, rootNode, dom$1);
				else return insertMiddle(liTarget, liElms, rootNode, rng);
			};
			const mergeableWrappedElements = ["pre"];
			const shouldPasteContentOnly = (dom$1, fragment, parentNode, root) => {
				var _a;
				const firstNode = fragment.firstChild;
				const lastNode = fragment.lastChild;
				const isPastingSingleElement = firstNode === (lastNode.attr("data-mce-type") === "bookmark" ? lastNode.prev : lastNode);
				const isWrappedElement = contains$2(mergeableWrappedElements, firstNode.name);
				if (isPastingSingleElement && isWrappedElement) {
					const isContentEditable$1 = firstNode.attr("contenteditable") !== "false";
					const isPastingInTheSameBlockTag = ((_a = dom$1.getParent(parentNode, dom$1.isBlock)) === null || _a === void 0 ? void 0 : _a.nodeName.toLowerCase()) === firstNode.name;
					const isPastingInContentEditable = Optional.from(getContentEditableRoot$1(root, parentNode)).forall(isContentEditableTrue$3);
					return isContentEditable$1 && isPastingInTheSameBlockTag && isPastingInContentEditable;
				} else return false;
			};
			const isTableCell = isTableCell$3;
			const isTableCellContentSelected = (dom$1, rng, cell$1) => {
				if (isNonNullable(cell$1)) return cell$1 === dom$1.getParent(rng.endContainer, isTableCell) && hasAllContentsSelected(SugarElement.fromDom(cell$1), rng);
				else return false;
			};
			const validInsertion = (editor, value$3, parentNode) => {
				var _a;
				if (parentNode.getAttribute("data-mce-bogus") === "all") (_a = parentNode.parentNode) === null || _a === void 0 || _a.insertBefore(editor.dom.createFragment(value$3), parentNode);
				else {
					const node = parentNode.firstChild;
					const node2 = parentNode.lastChild;
					if (!node || node === node2 && node.nodeName === "BR") editor.dom.setHTML(parentNode, value$3);
					else editor.selection.setContent(value$3, { no_events: true });
				}
			};
			const trimBrsFromTableCell = (dom$1, elm) => {
				Optional.from(dom$1.getParent(elm, "td,th")).map(SugarElement.fromDom).each(trimBlockTrailingBr);
			};
			const reduceInlineTextElements = (editor, merge$2) => {
				const textInlineElements = editor.schema.getTextInlineElements();
				const dom$1 = editor.dom;
				if (merge$2) {
					const root = editor.getBody();
					const elementUtils = ElementUtils(editor);
					Tools.each(dom$1.select("*[data-mce-fragment]"), (node) => {
						if (isNonNullable(textInlineElements[node.nodeName.toLowerCase()]) && hasInheritableStyles(dom$1, node)) for (let parentNode = node.parentElement; isNonNullable(parentNode) && parentNode !== root; parentNode = parentNode.parentElement) {
							if (hasStyleConflict(dom$1, node, parentNode)) break;
							if (elementUtils.compare(parentNode, node)) {
								dom$1.remove(node, true);
								break;
							}
						}
					});
				}
			};
			const markFragmentElements = (fragment) => {
				let node = fragment;
				while (node = node.walk()) if (node.type === 1) node.attr("data-mce-fragment", "1");
			};
			const unmarkFragmentElements = (elm) => {
				Tools.each(elm.getElementsByTagName("*"), (elm$1) => {
					elm$1.removeAttribute("data-mce-fragment");
				});
			};
			const isPartOfFragment = (node) => {
				return !!node.getAttribute("data-mce-fragment");
			};
			const canHaveChildren = (editor, node) => {
				return isNonNullable(node) && !editor.schema.getVoidElements()[node.nodeName];
			};
			const moveSelectionToMarker = (editor, marker) => {
				var _a, _b, _c;
				let nextRng;
				const dom$1 = editor.dom;
				const selection = editor.selection;
				if (!marker) return;
				selection.scrollIntoView(marker);
				const parentEditableElm = getContentEditableRoot$1(editor.getBody(), marker);
				if (parentEditableElm && dom$1.getContentEditable(parentEditableElm) === "false") {
					dom$1.remove(marker);
					selection.select(parentEditableElm);
					return;
				}
				let rng = dom$1.createRng();
				const node = marker.previousSibling;
				if (isText$a(node)) {
					rng.setStart(node, (_b = (_a = node.nodeValue) === null || _a === void 0 ? void 0 : _a.length) !== null && _b !== void 0 ? _b : 0);
					const node2 = marker.nextSibling;
					if (isText$a(node2)) {
						node.appendData(node2.data);
						(_c = node2.parentNode) === null || _c === void 0 || _c.removeChild(node2);
					}
				} else {
					rng.setStartBefore(marker);
					rng.setEndBefore(marker);
				}
				const findNextCaretRng = (rng$1) => {
					let caretPos = CaretPosition.fromRangeStart(rng$1);
					caretPos = CaretWalker(editor.getBody()).next(caretPos);
					return caretPos === null || caretPos === void 0 ? void 0 : caretPos.toRange();
				};
				const parentBlock = dom$1.getParent(marker, dom$1.isBlock);
				dom$1.remove(marker);
				if (parentBlock && dom$1.isEmpty(parentBlock)) {
					const isCell = isTableCell(parentBlock);
					empty(SugarElement.fromDom(parentBlock));
					rng.setStart(parentBlock, 0);
					rng.setEnd(parentBlock, 0);
					if (!isCell && !isPartOfFragment(parentBlock) && (nextRng = findNextCaretRng(rng))) {
						rng = nextRng;
						dom$1.remove(parentBlock);
					} else dom$1.add(parentBlock, dom$1.create("br", isCell ? {} : { "data-mce-bogus": "1" }));
				}
				selection.setRng(rng);
			};
			const deleteSelectedContent = (editor) => {
				const dom$1 = editor.dom;
				const rng = normalize(editor.selection.getRng());
				editor.selection.setRng(rng);
				const startCell = dom$1.getParent(rng.startContainer, isTableCell);
				if (isTableCellContentSelected(dom$1, rng, startCell)) deleteCellContents(editor, rng, SugarElement.fromDom(startCell));
				else if (rng.startContainer === rng.endContainer && rng.endOffset - rng.startOffset === 1 && isText$a(rng.startContainer.childNodes[rng.startOffset])) rng.deleteContents();
				else editor.getDoc().execCommand("Delete", false);
			};
			const findMarkerNode = (scope) => {
				for (let markerNode = scope; markerNode; markerNode = markerNode.walk()) if (markerNode.attr("id") === "mce_marker") return Optional.some(markerNode);
				return Optional.none();
			};
			const insertHtmlAtCaret = (editor, value$3, details) => {
				var _a, _b;
				const selection = editor.selection;
				const dom$1 = editor.dom;
				const parser = editor.parser;
				const merge$2 = details.merge;
				const serializer = HtmlSerializer({ validate: true }, editor.schema);
				const bookmarkHtml = "<span id=\"mce_marker\" data-mce-type=\"bookmark\">&#xFEFF;</span>";
				if (value$3.indexOf("{$caret}") === -1) value$3 += "{$caret}";
				value$3 = value$3.replace(/\{\$caret\}/, bookmarkHtml);
				let rng = selection.getRng();
				const caretElement = rng.startContainer;
				const body = editor.getBody();
				if (caretElement === body && selection.isCollapsed()) {
					if (dom$1.isBlock(body.firstChild) && canHaveChildren(editor, body.firstChild) && dom$1.isEmpty(body.firstChild)) {
						rng = dom$1.createRng();
						rng.setStart(body.firstChild, 0);
						rng.setEnd(body.firstChild, 0);
						selection.setRng(rng);
					}
				}
				if (!selection.isCollapsed()) deleteSelectedContent(editor);
				const parentNode = selection.getNode();
				const parserArgs = {
					context: parentNode.nodeName.toLowerCase(),
					data: details.data,
					insert: true
				};
				const fragment = parser.parse(value$3, parserArgs);
				if (details.paste === true && isListFragment(editor.schema, fragment) && isParentBlockLi(dom$1, parentNode)) {
					rng = insertAtCaret$1(serializer, dom$1, selection.getRng(), fragment);
					if (rng) selection.setRng(rng);
					return value$3;
				}
				if (details.paste === true && shouldPasteContentOnly(dom$1, fragment, parentNode, editor.getBody())) (_a = fragment.firstChild) === null || _a === void 0 || _a.unwrap();
				markFragmentElements(fragment);
				let node = fragment.lastChild;
				if (node && node.attr("id") === "mce_marker") {
					const marker = node;
					for (node = node.prev; node; node = node.walk(true)) if (node.type === 3 || !dom$1.isBlock(node.name)) {
						if (node.parent && editor.schema.isValidChild(node.parent.name, "span")) node.parent.insert(marker, node, node.name === "br");
						break;
					}
				}
				editor._selectionOverrides.showBlockCaretContainer(parentNode);
				if (!parserArgs.invalid) {
					value$3 = serializer.serialize(fragment);
					validInsertion(editor, value$3, parentNode);
				} else {
					editor.selection.setContent(bookmarkHtml);
					let parentNode$1 = selection.getNode();
					let tempNode;
					const rootNode = editor.getBody();
					if (isDocument$1(parentNode$1)) parentNode$1 = tempNode = rootNode;
					else tempNode = parentNode$1;
					while (tempNode && tempNode !== rootNode) {
						parentNode$1 = tempNode;
						tempNode = tempNode.parentNode;
					}
					value$3 = parentNode$1 === rootNode ? rootNode.innerHTML : dom$1.getOuterHTML(parentNode$1);
					const root = parser.parse(value$3);
					const markerNode = findMarkerNode(root);
					const editingHost = markerNode.bind(findClosestEditingHost).getOr(root);
					markerNode.each((marker) => marker.replace(fragment));
					const toExtract = fragment.children();
					const parent$1 = (_b = fragment.parent) !== null && _b !== void 0 ? _b : root;
					fragment.unwrap();
					cleanInvalidNodes(filter$5(toExtract, (node$1) => isInvalid(editor.schema, node$1, parent$1)), editor.schema, editingHost);
					filter$2(parser.getNodeFilters(), parser.getAttributeFilters(), root);
					value$3 = serializer.serialize(root);
					if (parentNode$1 === rootNode) dom$1.setHTML(rootNode, value$3);
					else dom$1.setOuterHTML(parentNode$1, value$3);
				}
				reduceInlineTextElements(editor, merge$2);
				moveSelectionToMarker(editor, dom$1.get("mce_marker"));
				unmarkFragmentElements(editor.getBody());
				trimBrsFromTableCell(dom$1, selection.getStart());
				updateCaret(editor.schema, editor.getBody(), selection.getStart());
				return value$3;
			};
			const isTreeNode = (content) => content instanceof AstNode;
			const moveSelection = (editor) => {
				if (hasFocus(editor)) firstPositionIn(editor.getBody()).each((pos) => {
					const node = pos.getNode();
					const caretPos = isTable$2(node) ? firstPositionIn(node).getOr(pos) : pos;
					editor.selection.setRng(caretPos.toRange());
				});
			};
			const setEditorHtml = (editor, html$2, noSelection) => {
				editor.dom.setHTML(editor.getBody(), html$2);
				if (noSelection !== true) moveSelection(editor);
			};
			const setContentString = (editor, body, content, args) => {
				if (content.length === 0 || /^\s+$/.test(content)) {
					const padd = "<br data-mce-bogus=\"1\">";
					if (body.nodeName === "TABLE") content = "<tr><td>" + padd + "</td></tr>";
					else if (/^(UL|OL)$/.test(body.nodeName)) content = "<li>" + padd + "</li>";
					const forcedRootBlockName = getForcedRootBlock(editor);
					if (editor.schema.isValidChild(body.nodeName.toLowerCase(), forcedRootBlockName.toLowerCase())) {
						content = padd;
						content = editor.dom.createHTML(forcedRootBlockName, getForcedRootBlockAttrs(editor), content);
					} else if (!content) content = padd;
					setEditorHtml(editor, content, args.no_selection);
					return {
						content,
						html: content
					};
				} else {
					if (args.format !== "raw") content = HtmlSerializer({ validate: false }, editor.schema).serialize(editor.parser.parse(content, {
						isRootContent: true,
						insert: true
					}));
					const trimmedHtml = isWsPreserveElement(SugarElement.fromDom(body)) ? content : Tools.trim(content);
					setEditorHtml(editor, trimmedHtml, args.no_selection);
					return {
						content: trimmedHtml,
						html: trimmedHtml
					};
				}
			};
			const setContentTree = (editor, body, content, args) => {
				filter$2(editor.parser.getNodeFilters(), editor.parser.getAttributeFilters(), content);
				const html$2 = HtmlSerializer({ validate: false }, editor.schema).serialize(content);
				const trimmedHtml = isWsPreserveElement(SugarElement.fromDom(body)) ? html$2 : Tools.trim(html$2);
				setEditorHtml(editor, trimmedHtml, args.no_selection);
				return {
					content,
					html: trimmedHtml
				};
			};
			const setContentInternal = (editor, content, args) => {
				return Optional.from(editor.getBody()).map((body) => {
					if (isTreeNode(content)) return setContentTree(editor, body, content, args);
					else return setContentString(editor, body, content, args);
				}).getOr({
					content,
					html: isTreeNode(args.content) ? "" : args.content
				});
			};
			const ancestor$1 = (scope, predicate, isRoot$2) => ancestor$4(scope, predicate, isRoot$2).isSome();
			const sibling = (scope, predicate) => sibling$1(scope, predicate).isSome();
			const ensureIsRoot = (isRoot$2) => isFunction(isRoot$2) ? isRoot$2 : never;
			const ancestor = (scope, transform, isRoot$2) => {
				let element = scope.dom;
				const stop$1 = ensureIsRoot(isRoot$2);
				while (element.parentNode) {
					element = element.parentNode;
					const el = SugarElement.fromDom(element);
					const transformed = transform(el);
					if (transformed.isSome()) return transformed;
					else if (stop$1(el)) break;
				}
				return Optional.none();
			};
			const closest$1 = (scope, transform, isRoot$2) => {
				const current = transform(scope);
				const stop$1 = ensureIsRoot(isRoot$2);
				return current.orThunk(() => stop$1(scope) ? Optional.none() : ancestor(scope, transform, stop$1));
			};
			const isEq$3 = isEq$5;
			const matchesUnInheritedFormatSelector = (ed, node, name$1) => {
				const formatList = ed.formatter.get(name$1);
				if (formatList) for (let i = 0; i < formatList.length; i++) {
					const format = formatList[i];
					if (isSelectorFormat(format) && format.inherit === false && ed.dom.is(node, format.selector)) return true;
				}
				return false;
			};
			const matchParents = (editor, node, name$1, vars, similar) => {
				const root = editor.dom.getRoot();
				if (node === root) return false;
				return !!matchNode(editor, editor.dom.getParent(node, (elm) => {
					if (matchesUnInheritedFormatSelector(editor, elm, name$1)) return true;
					return elm.parentNode === root || !!matchNode(editor, elm, name$1, vars, true);
				}), name$1, vars, similar);
			};
			const matchName = (dom$1, node, format) => {
				if (isInlineFormat(format) && isEq$3(node, format.inline)) return true;
				if (isBlockFormat(format) && isEq$3(node, format.block)) return true;
				if (isSelectorFormat(format)) return isElement$6(node) && dom$1.is(node, format.selector);
				return false;
			};
			const matchItems = (dom$1, node, format, itemName, similar, vars) => {
				const items = format[itemName];
				const matchAttributes = itemName === "attributes";
				if (isFunction(format.onmatch)) return format.onmatch(node, format, itemName);
				if (items) {
					if (!isArrayLike(items)) {
						for (const key in items) if (has$2(items, key)) {
							const value$3 = matchAttributes ? dom$1.getAttrib(node, key) : getStyle(dom$1, node, key);
							const expectedValue = replaceVars(items[key], vars);
							const isEmptyValue = isNullable(value$3) || isEmpty$3(value$3);
							if (isEmptyValue && isNullable(expectedValue)) continue;
							if (similar && isEmptyValue && !format.exact) return false;
							if ((!similar || format.exact) && !isEq$3(value$3, normalizeStyleValue(expectedValue, key))) return false;
						}
					} else for (let i = 0; i < items.length; i++) if (matchAttributes ? dom$1.getAttrib(node, items[i]) : getStyle(dom$1, node, items[i])) return true;
				}
				return true;
			};
			const matchNode = (ed, node, name$1, vars, similar) => {
				const formatList = ed.formatter.get(name$1);
				const dom$1 = ed.dom;
				if (formatList && isElement$6(node)) for (let i = 0; i < formatList.length; i++) {
					const format = formatList[i];
					if (matchName(ed.dom, node, format) && matchItems(dom$1, node, format, "attributes", similar, vars) && matchItems(dom$1, node, format, "styles", similar, vars)) {
						const classes = format.classes;
						if (classes) {
							for (let x = 0; x < classes.length; x++) if (!ed.dom.hasClass(node, replaceVars(classes[x], vars))) return;
						}
						return format;
					}
				}
			};
			const match$2 = (editor, name$1, vars, node, similar) => {
				if (node) return matchParents(editor, node, name$1, vars, similar);
				node = editor.selection.getNode();
				if (matchParents(editor, node, name$1, vars, similar)) return true;
				const startNode = editor.selection.getStart();
				if (startNode !== node) {
					if (matchParents(editor, startNode, name$1, vars, similar)) return true;
				}
				return false;
			};
			const matchAll = (editor, names, vars) => {
				const matchedFormatNames = [];
				const checkedMap = {};
				const startElement = editor.selection.getStart();
				editor.dom.getParent(startElement, (node) => {
					for (let i = 0; i < names.length; i++) {
						const name$1 = names[i];
						if (!checkedMap[name$1] && matchNode(editor, node, name$1, vars)) {
							checkedMap[name$1] = true;
							matchedFormatNames.push(name$1);
						}
					}
				}, editor.dom.getRoot());
				return matchedFormatNames;
			};
			const closest = (editor, names) => {
				const isRoot$2 = (elm) => eq(elm, SugarElement.fromDom(editor.getBody()));
				const match$3 = (elm, name$1) => matchNode(editor, elm.dom, name$1) ? Optional.some(name$1) : Optional.none();
				return Optional.from(editor.selection.getStart(true)).bind((rawElm) => closest$1(SugarElement.fromDom(rawElm), (elm) => findMap(names, (name$1) => match$3(elm, name$1)), isRoot$2)).getOrNull();
			};
			const canApply = (editor, name$1) => {
				const formatList = editor.formatter.get(name$1);
				const dom$1 = editor.dom;
				if (formatList && editor.selection.isEditable()) {
					const parents$2 = getParents$2(dom$1, editor.selection.getStart());
					for (let x = formatList.length - 1; x >= 0; x--) {
						const format = formatList[x];
						if (!isSelectorFormat(format)) return true;
						for (let i = parents$2.length - 1; i >= 0; i--) if (dom$1.is(parents$2[i], format.selector)) return true;
					}
				}
				return false;
			};
			const matchAllOnNode = (editor, node, formatNames) => foldl(formatNames, (acc, name$1) => {
				const matchSimilar = isVariableFormatName(editor, name$1);
				if (editor.formatter.matchNode(node, name$1, {}, matchSimilar)) return acc.concat([name$1]);
				else return acc;
			}, []);
			const ZWSP = ZWSP$1;
			const importNode = (ownerDocument, node) => {
				return ownerDocument.importNode(node, true);
			};
			const getEmptyCaretContainers = (node) => {
				const nodes = [];
				let tempNode = node;
				while (tempNode) {
					if (isText$a(tempNode) && tempNode.data !== ZWSP || tempNode.childNodes.length > 1) return [];
					if (isElement$6(tempNode)) nodes.push(tempNode);
					tempNode = tempNode.firstChild;
				}
				return nodes;
			};
			const isCaretContainerEmpty = (node) => {
				return getEmptyCaretContainers(node).length > 0;
			};
			const findFirstTextNode = (node) => {
				if (node) {
					const walker = new DomTreeWalker(node, node);
					for (let tempNode = walker.current(); tempNode; tempNode = walker.next()) if (isText$a(tempNode)) return tempNode;
				}
				return null;
			};
			const createCaretContainer = (fill) => {
				const caretContainer = SugarElement.fromTag("span");
				setAll$1(caretContainer, {
					"id": CARET_ID,
					"data-mce-bogus": "1",
					"data-mce-type": "format-caret"
				});
				if (fill) append$1(caretContainer, SugarElement.fromText(ZWSP));
				return caretContainer;
			};
			const trimZwspFromCaretContainer = (caretContainerNode) => {
				const textNode = findFirstTextNode(caretContainerNode);
				if (textNode && textNode.data.charAt(0) === ZWSP) textNode.deleteData(0, 1);
				return textNode;
			};
			const removeCaretContainerNode = (editor, node, moveCaret$1 = true) => {
				const dom$1 = editor.dom, selection = editor.selection;
				if (isCaretContainerEmpty(node)) deleteElement$2(editor, false, SugarElement.fromDom(node), moveCaret$1);
				else {
					const rng = selection.getRng();
					const block = dom$1.getParent(node, dom$1.isBlock);
					const startContainer = rng.startContainer;
					const startOffset = rng.startOffset;
					const endContainer = rng.endContainer;
					const endOffset = rng.endOffset;
					const textNode = trimZwspFromCaretContainer(node);
					dom$1.remove(node, true);
					if (startContainer === textNode && startOffset > 0) rng.setStart(textNode, startOffset - 1);
					if (endContainer === textNode && endOffset > 0) rng.setEnd(textNode, endOffset - 1);
					if (block && dom$1.isEmpty(block)) fillWithPaddingBr(SugarElement.fromDom(block));
					selection.setRng(rng);
				}
			};
			const removeCaretContainer = (editor, node, moveCaret$1 = true) => {
				const dom$1 = editor.dom, selection = editor.selection;
				if (!node) {
					node = getParentCaretContainer(editor.getBody(), selection.getStart());
					if (!node) while (node = dom$1.get(CARET_ID)) removeCaretContainerNode(editor, node, moveCaret$1);
				} else removeCaretContainerNode(editor, node, moveCaret$1);
			};
			const insertCaretContainerNode = (editor, caretContainer, formatNode) => {
				var _a, _b;
				const dom$1 = editor.dom;
				const block = dom$1.getParent(formatNode, curry(isTextBlock$1, editor.schema));
				if (block && dom$1.isEmpty(block)) (_a = formatNode.parentNode) === null || _a === void 0 || _a.replaceChild(caretContainer, formatNode);
				else {
					removeTrailingBr(SugarElement.fromDom(formatNode));
					if (dom$1.isEmpty(formatNode)) (_b = formatNode.parentNode) === null || _b === void 0 || _b.replaceChild(caretContainer, formatNode);
					else dom$1.insertAfter(caretContainer, formatNode);
				}
			};
			const appendNode = (parentNode, node) => {
				parentNode.appendChild(node);
				return node;
			};
			const insertFormatNodesIntoCaretContainer = (formatNodes, caretContainer) => {
				var _a;
				const innerMostFormatNode = foldr(formatNodes, (parentNode, formatNode) => {
					return appendNode(parentNode, formatNode.cloneNode(false));
				}, caretContainer);
				return appendNode(innerMostFormatNode, ((_a = innerMostFormatNode.ownerDocument) !== null && _a !== void 0 ? _a : document).createTextNode(ZWSP));
			};
			const cleanFormatNode = (editor, caretContainer, formatNode, name$1, vars, similar) => {
				const formatter = editor.formatter;
				const dom$1 = editor.dom;
				if (filter$5(matchAllOnNode(editor, formatNode, filter$5(keys(formatter.get()), (formatName) => formatName !== name$1 && !contains$1(formatName, "removeformat"))), (fmtName) => !areSimilarFormats(editor, fmtName, name$1)).length > 0) {
					const clonedFormatNode = formatNode.cloneNode(false);
					dom$1.add(caretContainer, clonedFormatNode);
					formatter.remove(name$1, vars, clonedFormatNode, similar);
					dom$1.remove(clonedFormatNode);
					return Optional.some(clonedFormatNode);
				} else return Optional.none();
			};
			const applyCaretFormat = (editor, name$1, vars) => {
				let caretContainer;
				const selection = editor.selection;
				const formatList = editor.formatter.get(name$1);
				if (!formatList) return;
				const selectionRng = selection.getRng();
				let offset = selectionRng.startOffset;
				const text$1 = selectionRng.startContainer.nodeValue;
				caretContainer = getParentCaretContainer(editor.getBody(), selection.getStart());
				const wordcharRegex = /[^\s\u00a0\u00ad\u200b\ufeff]/;
				if (text$1 && offset > 0 && offset < text$1.length && wordcharRegex.test(text$1.charAt(offset)) && wordcharRegex.test(text$1.charAt(offset - 1))) {
					const bookmark = selection.getBookmark();
					selectionRng.collapse(true);
					let rng = expandRng(editor.dom, selectionRng, formatList);
					rng = split(rng);
					editor.formatter.apply(name$1, vars, rng);
					selection.moveToBookmark(bookmark);
				} else {
					let textNode = caretContainer ? findFirstTextNode(caretContainer) : null;
					if (!caretContainer || (textNode === null || textNode === void 0 ? void 0 : textNode.data) !== ZWSP) {
						caretContainer = importNode(editor.getDoc(), createCaretContainer(true).dom);
						textNode = caretContainer.firstChild;
						selectionRng.insertNode(caretContainer);
						offset = 1;
						editor.formatter.apply(name$1, vars, caretContainer);
					} else editor.formatter.apply(name$1, vars, caretContainer);
					selection.setCursorLocation(textNode, offset);
				}
			};
			const removeCaretFormat = (editor, name$1, vars, similar) => {
				const dom$1 = editor.dom;
				const selection = editor.selection;
				let hasContentAfter = false;
				const formatList = editor.formatter.get(name$1);
				if (!formatList) return;
				const rng = selection.getRng();
				const container = rng.startContainer;
				const offset = rng.startOffset;
				let node = container;
				if (isText$a(container)) {
					if (offset !== container.data.length) hasContentAfter = true;
					node = node.parentNode;
				}
				const parents$2 = [];
				let formatNode;
				while (node) {
					if (matchNode(editor, node, name$1, vars, similar)) {
						formatNode = node;
						break;
					}
					if (node.nextSibling) hasContentAfter = true;
					parents$2.push(node);
					node = node.parentNode;
				}
				if (!formatNode) return;
				if (hasContentAfter) {
					const bookmark = selection.getBookmark();
					rng.collapse(true);
					let expandedRng = expandRng(dom$1, rng, formatList, true);
					expandedRng = split(expandedRng);
					editor.formatter.remove(name$1, vars, expandedRng, similar);
					selection.moveToBookmark(bookmark);
				} else {
					const caretContainer = getParentCaretContainer(editor.getBody(), formatNode);
					const newCaretContainer = createCaretContainer(false).dom;
					insertCaretContainerNode(editor, newCaretContainer, caretContainer !== null && caretContainer !== void 0 ? caretContainer : formatNode);
					const cleanedFormatNode = cleanFormatNode(editor, newCaretContainer, formatNode, name$1, vars, similar);
					const caretTextNode = insertFormatNodesIntoCaretContainer(parents$2.concat(cleanedFormatNode.toArray()), newCaretContainer);
					if (caretContainer) removeCaretContainerNode(editor, caretContainer, false);
					selection.setCursorLocation(caretTextNode, 1);
					if (dom$1.isEmpty(formatNode)) dom$1.remove(formatNode);
				}
			};
			const disableCaretContainer = (editor, keyCode, moveCaret$1) => {
				const selection = editor.selection, body = editor.getBody();
				removeCaretContainer(editor, null, moveCaret$1);
				if ((keyCode === 8 || keyCode === 46) && selection.isCollapsed() && selection.getStart().innerHTML === ZWSP) removeCaretContainer(editor, getParentCaretContainer(body, selection.getStart()));
				if (keyCode === 37 || keyCode === 39) removeCaretContainer(editor, getParentCaretContainer(body, selection.getStart()));
			};
			const endsWithNbsp = (element) => isText$a(element) && endsWith(element.data, nbsp);
			const setup$u = (editor) => {
				editor.on("mouseup keydown", (e) => {
					disableCaretContainer(editor, e.keyCode, endsWithNbsp(editor.selection.getRng().endContainer));
				});
			};
			const createCaretFormat = (formatNodes) => {
				const caretContainer = createCaretContainer(false);
				return {
					caretContainer,
					caretPosition: CaretPosition(insertFormatNodesIntoCaretContainer(formatNodes, caretContainer.dom), 0)
				};
			};
			const replaceWithCaretFormat = (targetNode, formatNodes) => {
				const { caretContainer, caretPosition } = createCaretFormat(formatNodes);
				before$3(SugarElement.fromDom(targetNode), caretContainer);
				remove$5(SugarElement.fromDom(targetNode));
				return caretPosition;
			};
			const createCaretFormatAtStart$1 = (rng, formatNodes) => {
				const { caretContainer, caretPosition } = createCaretFormat(formatNodes);
				rng.insertNode(caretContainer.dom);
				return caretPosition;
			};
			const isFormatElement = (editor, element) => {
				return has$2(editor.schema.getTextInlineElements(), name(element)) && !isCaretNode(element.dom) && !isBogus$2(element.dom);
			};
			const isEmptyCaretFormatElement = (element) => {
				return isCaretNode(element.dom) && isCaretContainerEmpty(element.dom);
			};
			const postProcessHooks = {};
			const isPre = matchNodeNames(["pre"]);
			const addPostProcessHook = (name$1, hook) => {
				if (!postProcessHooks[name$1]) postProcessHooks[name$1] = [];
				postProcessHooks[name$1].push(hook);
			};
			const postProcess$1 = (name$1, editor) => {
				if (has$2(postProcessHooks, name$1)) each$e(postProcessHooks[name$1], (hook) => {
					hook(editor);
				});
			};
			addPostProcessHook("pre", (editor) => {
				const rng = editor.selection.getRng();
				const hasPreSibling = (blocks$1) => (pre) => {
					const prev$1 = pre.previousSibling;
					return isPre(prev$1) && contains$2(blocks$1, prev$1);
				};
				const joinPre = (pre1, pre2) => {
					const sPre2 = SugarElement.fromDom(pre2);
					const doc = documentOrOwner(sPre2).dom;
					remove$5(sPre2);
					append(SugarElement.fromDom(pre1), [
						SugarElement.fromTag("br", doc),
						SugarElement.fromTag("br", doc),
						...children$1(sPre2)
					]);
				};
				if (!rng.collapsed) {
					const blocks$1 = editor.selection.getSelectedBlocks();
					each$e(filter$5(filter$5(blocks$1, isPre), hasPreSibling(blocks$1)), (pre) => {
						joinPre(pre.previousSibling, pre);
					});
				}
			});
			const listItemStyles = [
				"fontWeight",
				"fontStyle",
				"color",
				"fontSize",
				"fontFamily"
			];
			const hasListStyles = (fmt) => isObject(fmt.styles) && exists(keys(fmt.styles), (name$1) => contains$2(listItemStyles, name$1));
			const findExpandedListItemFormat = (formats) => find$2(formats, (fmt) => isInlineFormat(fmt) && fmt.inline === "span" && hasListStyles(fmt));
			const getExpandedListItemFormat = (formatter, format) => {
				const formatList = formatter.get(format);
				return isArray$1(formatList) ? findExpandedListItemFormat(formatList) : Optional.none();
			};
			const isRngStartAtStartOfElement = (rng, elm) => prevPosition(elm, CaretPosition.fromRangeStart(rng)).isNone();
			const isRngEndAtEndOfElement = (rng, elm) => {
				return nextPosition(elm, CaretPosition.fromRangeEnd(rng)).exists((pos) => !isBr$6(pos.getNode()) || nextPosition(elm, pos).isSome()) === false;
			};
			const isEditableListItem = (dom$1) => (elm) => isListItem$2(elm) && dom$1.isEditable(elm);
			const getFullySelectedBlocks = (selection) => {
				const blocks$1 = selection.getSelectedBlocks();
				const rng = selection.getRng();
				if (selection.isCollapsed()) return [];
				if (blocks$1.length === 1) return isRngStartAtStartOfElement(rng, blocks$1[0]) && isRngEndAtEndOfElement(rng, blocks$1[0]) ? blocks$1 : [];
				else {
					const first$2 = head(blocks$1).filter((elm) => isRngStartAtStartOfElement(rng, elm)).toArray();
					const last$4 = last$3(blocks$1).filter((elm) => isRngEndAtEndOfElement(rng, elm)).toArray();
					const middle = blocks$1.slice(1, -1);
					return first$2.concat(middle).concat(last$4);
				}
			};
			const getFullySelectedListItems = (selection) => filter$5(getFullySelectedBlocks(selection), isEditableListItem(selection.dom));
			const getPartiallySelectedListItems = (selection) => filter$5(selection.getSelectedBlocks(), isEditableListItem(selection.dom));
			const each$8 = Tools.each;
			const isElementNode = (node) => isElement$6(node) && !isBookmarkNode$1(node) && !isCaretNode(node) && !isBogus$2(node);
			const findElementSibling = (node, siblingName) => {
				for (let sibling$2 = node; sibling$2; sibling$2 = sibling$2[siblingName]) {
					if (isText$a(sibling$2) && isNotEmpty(sibling$2.data)) return node;
					if (isElement$6(sibling$2) && !isBookmarkNode$1(sibling$2)) return sibling$2;
				}
				return node;
			};
			const mergeSiblingsNodes = (editor, prev$1, next$1) => {
				const elementUtils = ElementUtils(editor);
				const isPrevEditable = isElement$6(prev$1) && isEditable$2(prev$1);
				const isNextEditable = isElement$6(next$1) && isEditable$2(next$1);
				if (isPrevEditable && isNextEditable) {
					const prevSibling$1 = findElementSibling(prev$1, "previousSibling");
					const nextSibling$1 = findElementSibling(next$1, "nextSibling");
					if (elementUtils.compare(prevSibling$1, nextSibling$1)) {
						for (let sibling$2 = prevSibling$1.nextSibling; sibling$2 && sibling$2 !== nextSibling$1;) {
							const tmpSibling = sibling$2;
							sibling$2 = sibling$2.nextSibling;
							prevSibling$1.appendChild(tmpSibling);
						}
						editor.dom.remove(nextSibling$1);
						Tools.each(Tools.grep(nextSibling$1.childNodes), (node) => {
							prevSibling$1.appendChild(node);
						});
						return prevSibling$1;
					}
				}
				return next$1;
			};
			const mergeSiblings = (editor, format, vars, node) => {
				var _a;
				if (node && format.merge_siblings !== false) {
					const newNode = (_a = mergeSiblingsNodes(editor, getNonWhiteSpaceSibling(node), node)) !== null && _a !== void 0 ? _a : node;
					mergeSiblingsNodes(editor, newNode, getNonWhiteSpaceSibling(newNode, true));
				}
			};
			const clearChildStyles = (dom$1, format, node) => {
				if (format.clear_child_styles) {
					const selector = format.links ? "*:not(a)" : "*";
					each$8(dom$1.select(selector, node), (childNode) => {
						if (isElementNode(childNode) && isEditable$2(childNode)) each$8(format.styles, (_value, name$1) => {
							dom$1.setStyle(childNode, name$1, "");
						});
					});
				}
			};
			const processChildElements = (node, filter$6, process$2) => {
				each$8(node.childNodes, (node$1) => {
					if (isElementNode(node$1)) {
						if (filter$6(node$1)) process$2(node$1);
						if (node$1.hasChildNodes()) processChildElements(node$1, filter$6, process$2);
					}
				});
			};
			const unwrapEmptySpan = (dom$1, node) => {
				if (node.nodeName === "SPAN" && dom$1.getAttribs(node).length === 0) dom$1.remove(node, true);
			};
			const hasStyle = (dom$1, name$1) => (node) => !!(node && getStyle(dom$1, node, name$1));
			const applyStyle = (dom$1, name$1, value$3) => (node) => {
				dom$1.setStyle(node, name$1, value$3);
				if (node.getAttribute("style") === "") node.removeAttribute("style");
				unwrapEmptySpan(dom$1, node);
			};
			const removeResult = Adt.generate([
				{ keep: [] },
				{ rename: ["name"] },
				{ removed: [] }
			]);
			const MCE_ATTR_RE = /^(src|href|style)$/;
			const each$7 = Tools.each;
			const isEq$2 = isEq$5;
			const isTableCellOrRow = (node) => /^(TR|TH|TD)$/.test(node.nodeName);
			const isChildOfInlineParent = (dom$1, node, parent$1) => dom$1.isChildOf(node, parent$1) && node !== parent$1 && !dom$1.isBlock(parent$1);
			const getContainer = (ed, rng, start$2) => {
				let container = rng[start$2 ? "startContainer" : "endContainer"];
				let offset = rng[start$2 ? "startOffset" : "endOffset"];
				if (isElement$6(container)) {
					const lastIdx = container.childNodes.length - 1;
					if (!start$2 && offset) offset--;
					container = container.childNodes[offset > lastIdx ? lastIdx : offset];
				}
				if (isText$a(container) && start$2 && offset >= container.data.length) container = new DomTreeWalker(container, ed.getBody()).next() || container;
				if (isText$a(container) && !start$2 && offset === 0) container = new DomTreeWalker(container, ed.getBody()).prev() || container;
				return container;
			};
			const normalizeTableSelection = (node, start$2) => {
				const prop = start$2 ? "firstChild" : "lastChild";
				const childNode = node[prop];
				if (isTableCellOrRow(node) && childNode) if (node.nodeName === "TR") return childNode[prop] || childNode;
				else return childNode;
				return node;
			};
			const wrap$1 = (dom$1, node, name$1, attrs) => {
				var _a;
				const wrapper = dom$1.create(name$1, attrs);
				(_a = node.parentNode) === null || _a === void 0 || _a.insertBefore(wrapper, node);
				wrapper.appendChild(node);
				return wrapper;
			};
			const wrapWithSiblings = (dom$1, node, next$1, name$1, attrs) => {
				const start$2 = SugarElement.fromDom(node);
				const wrapper = SugarElement.fromDom(dom$1.create(name$1, attrs));
				append(wrapper, next$1 ? nextSiblings(start$2) : prevSiblings(start$2));
				if (next$1) {
					before$3(start$2, wrapper);
					prepend(wrapper, start$2);
				} else {
					after$4(start$2, wrapper);
					append$1(wrapper, start$2);
				}
				return wrapper.dom;
			};
			const isColorFormatAndAnchor = (node, format) => format.links && node.nodeName === "A";
			const removeNode = (ed, node, format) => {
				const parentNode = node.parentNode;
				let rootBlockElm;
				const dom$1 = ed.dom;
				const forcedRootBlock = getForcedRootBlock(ed);
				if (isBlockFormat(format)) {
					if (parentNode === dom$1.getRoot()) {
						if (!format.list_block || !isEq$2(node, format.list_block)) each$e(from(node.childNodes), (node$1) => {
							if (isValid(ed, forcedRootBlock, node$1.nodeName.toLowerCase())) if (!rootBlockElm) {
								rootBlockElm = wrap$1(dom$1, node$1, forcedRootBlock);
								dom$1.setAttribs(rootBlockElm, getForcedRootBlockAttrs(ed));
							} else rootBlockElm.appendChild(node$1);
							else rootBlockElm = null;
						});
					}
				}
				if (isMixedFormat(format) && !isEq$2(format.inline, node)) return;
				dom$1.remove(node, true);
			};
			const processFormatAttrOrStyle = (name$1, value$3, vars) => {
				if (isNumber(name$1)) return {
					name: value$3,
					value: null
				};
				else return {
					name: name$1,
					value: replaceVars(value$3, vars)
				};
			};
			const removeEmptyStyleAttributeIfNeeded = (dom$1, elm) => {
				if (dom$1.getAttrib(elm, "style") === "") {
					elm.removeAttribute("style");
					elm.removeAttribute("data-mce-style");
				}
			};
			const removeStyles = (dom$1, elm, format, vars, compareNode) => {
				let stylesModified = false;
				each$7(format.styles, (value$3, name$1) => {
					const { name: styleName, value: styleValue } = processFormatAttrOrStyle(name$1, value$3, vars);
					const normalizedStyleValue = normalizeStyleValue(styleValue, styleName);
					if (format.remove_similar || isNull(styleValue) || !isElement$6(compareNode) || isEq$2(getStyle(dom$1, compareNode, styleName), normalizedStyleValue)) dom$1.setStyle(elm, styleName, "");
					stylesModified = true;
				});
				if (stylesModified) removeEmptyStyleAttributeIfNeeded(dom$1, elm);
			};
			const removeListStyleFormats = (editor, name$1, vars) => {
				if (name$1 === "removeformat") each$e(getPartiallySelectedListItems(editor.selection), (li) => {
					each$e(listItemStyles, (name$2) => editor.dom.setStyle(li, name$2, ""));
					removeEmptyStyleAttributeIfNeeded(editor.dom, li);
				});
				else getExpandedListItemFormat(editor.formatter, name$1).each((liFmt) => {
					each$e(getPartiallySelectedListItems(editor.selection), (li) => removeStyles(editor.dom, li, liFmt, vars, null));
				});
			};
			const removeNodeFormatInternal = (ed, format, vars, node, compareNode) => {
				const dom$1 = ed.dom;
				const elementUtils = ElementUtils(ed);
				const schema = ed.schema;
				if (isInlineFormat(format) && isTransparentElementName(schema, format.inline) && isTransparentBlock(schema, node) && node.parentElement === ed.getBody()) {
					removeNode(ed, node, format);
					return removeResult.removed();
				}
				if (!format.ceFalseOverride && node && dom$1.getContentEditableParent(node) === "false") return removeResult.keep();
				if (node && !matchName(dom$1, node, format) && !isColorFormatAndAnchor(node, format)) return removeResult.keep();
				const elm = node;
				const preserveAttributes = format.preserve_attributes;
				if (isInlineFormat(format) && format.remove === "all" && isArray$1(preserveAttributes)) {
					const attrsToPreserve = filter$5(dom$1.getAttribs(elm), (attr) => contains$2(preserveAttributes, attr.name.toLowerCase()));
					dom$1.removeAllAttribs(elm);
					each$e(attrsToPreserve, (attr) => dom$1.setAttrib(elm, attr.name, attr.value));
					if (attrsToPreserve.length > 0) return removeResult.rename("span");
				}
				if (format.remove !== "all") {
					removeStyles(dom$1, elm, format, vars, compareNode);
					each$7(format.attributes, (value$3, name$1) => {
						const { name: attrName, value: attrValue } = processFormatAttrOrStyle(name$1, value$3, vars);
						if (format.remove_similar || isNull(attrValue) || !isElement$6(compareNode) || isEq$2(dom$1.getAttrib(compareNode, attrName), attrValue)) {
							if (attrName === "class") {
								const currentValue = dom$1.getAttrib(elm, attrName);
								if (currentValue) {
									let valueOut = "";
									each$e(currentValue.split(/\s+/), (cls) => {
										if (/mce\-\w+/.test(cls)) valueOut += (valueOut ? " " : "") + cls;
									});
									if (valueOut) {
										dom$1.setAttrib(elm, attrName, valueOut);
										return;
									}
								}
							}
							if (MCE_ATTR_RE.test(attrName)) elm.removeAttribute("data-mce-" + attrName);
							if (attrName === "style" && matchNodeNames(["li"])(elm) && dom$1.getStyle(elm, "list-style-type") === "none") {
								elm.removeAttribute(attrName);
								dom$1.setStyle(elm, "list-style-type", "none");
								return;
							}
							if (attrName === "class") elm.removeAttribute("className");
							elm.removeAttribute(attrName);
						}
					});
					each$7(format.classes, (value$3) => {
						value$3 = replaceVars(value$3, vars);
						if (!isElement$6(compareNode) || dom$1.hasClass(compareNode, value$3)) dom$1.removeClass(elm, value$3);
					});
					const attrs = dom$1.getAttribs(elm);
					for (let i = 0; i < attrs.length; i++) {
						const attrName = attrs[i].nodeName;
						if (!elementUtils.isAttributeInternal(attrName)) return removeResult.keep();
					}
				}
				if (format.remove !== "none") {
					removeNode(ed, elm, format);
					return removeResult.removed();
				}
				return removeResult.keep();
			};
			const findFormatRoot = (editor, container, name$1, vars, similar) => {
				let formatRoot;
				if (container.parentNode) each$e(getParents$2(editor.dom, container.parentNode).reverse(), (parent$1) => {
					if (!formatRoot && isElement$6(parent$1) && parent$1.id !== "_start" && parent$1.id !== "_end") {
						const format = matchNode(editor, parent$1, name$1, vars, similar);
						if (format && format.split !== false) formatRoot = parent$1;
					}
				});
				return formatRoot;
			};
			const removeNodeFormatFromClone = (editor, format, vars, clone$5) => removeNodeFormatInternal(editor, format, vars, clone$5, clone$5).fold(constant(clone$5), (newName) => {
				editor.dom.createFragment().appendChild(clone$5);
				return editor.dom.rename(clone$5, newName);
			}, constant(null));
			const wrapAndSplit = (editor, formatList, formatRoot, container, target, split$3, format, vars) => {
				var _a, _b;
				let lastClone;
				let firstClone;
				const dom$1 = editor.dom;
				if (formatRoot) {
					const formatRootParent = formatRoot.parentNode;
					for (let parent$1 = container.parentNode; parent$1 && parent$1 !== formatRootParent; parent$1 = parent$1.parentNode) {
						let clone$5 = dom$1.clone(parent$1, false);
						for (let i = 0; i < formatList.length; i++) {
							clone$5 = removeNodeFormatFromClone(editor, formatList[i], vars, clone$5);
							if (clone$5 === null) break;
						}
						if (clone$5) {
							if (lastClone) clone$5.appendChild(lastClone);
							if (!firstClone) firstClone = clone$5;
							lastClone = clone$5;
						}
					}
					if (split$3 && (!format.mixed || !dom$1.isBlock(formatRoot))) container = (_a = dom$1.split(formatRoot, container)) !== null && _a !== void 0 ? _a : container;
					if (lastClone && firstClone) {
						(_b = target.parentNode) === null || _b === void 0 || _b.insertBefore(lastClone, target);
						firstClone.appendChild(target);
						if (isInlineFormat(format)) mergeSiblings(editor, format, vars, lastClone);
					}
				}
				return container;
			};
			const removeFormatInternal = (ed, name$1, vars, node, similar) => {
				const formatList = ed.formatter.get(name$1);
				const format = formatList[0];
				const dom$1 = ed.dom;
				const selection = ed.selection;
				const splitToFormatRoot = (container) => {
					return wrapAndSplit(ed, formatList, findFormatRoot(ed, container, name$1, vars, similar), container, container, true, format, vars);
				};
				const isRemoveBookmarkNode = (node$1) => isBookmarkNode$1(node$1) && isElement$6(node$1) && (node$1.id === "_start" || node$1.id === "_end");
				const removeFormatOnNode = (node$1) => exists(formatList, (fmt) => removeNodeFormat(ed, fmt, vars, node$1, node$1));
				const process$2 = (node$1) => {
					const children$2 = from(node$1.childNodes);
					const currentNodeMatches = removeFormatOnNode(node$1) || exists(formatList, (f) => matchName(dom$1, node$1, f));
					const parentNode = node$1.parentNode;
					if (!currentNodeMatches && isNonNullable(parentNode) && shouldExpandToSelector(format)) removeFormatOnNode(parentNode);
					if (format.deep) {
						if (children$2.length) for (let i = 0; i < children$2.length; i++) process$2(children$2[i]);
					}
					each$e([
						"underline",
						"line-through",
						"overline"
					], (decoration) => {
						if (isElement$6(node$1) && ed.dom.getStyle(node$1, "text-decoration") === decoration && node$1.parentNode && getTextDecoration(dom$1, node$1.parentNode) === decoration) removeNodeFormat(ed, {
							deep: false,
							exact: true,
							inline: "span",
							styles: { textDecoration: decoration }
						}, void 0, node$1);
					});
				};
				const unwrap$1 = (start$2) => {
					const node$1 = dom$1.get(start$2 ? "_start" : "_end");
					if (node$1) {
						let out = node$1[start$2 ? "firstChild" : "lastChild"];
						if (isRemoveBookmarkNode(out)) out = out[start$2 ? "firstChild" : "lastChild"];
						if (isText$a(out) && out.data.length === 0) out = start$2 ? node$1.previousSibling || node$1.nextSibling : node$1.nextSibling || node$1.previousSibling;
						dom$1.remove(node$1, true);
						return out;
					} else return null;
				};
				const removeRngStyle = (rng) => {
					let startContainer;
					let endContainer;
					let expandedRng = expandRng(dom$1, rng, formatList, rng.collapsed);
					if (format.split) {
						expandedRng = split(expandedRng);
						startContainer = getContainer(ed, expandedRng, true);
						endContainer = getContainer(ed, expandedRng);
						if (startContainer !== endContainer) {
							startContainer = normalizeTableSelection(startContainer, true);
							endContainer = normalizeTableSelection(endContainer, false);
							if (isChildOfInlineParent(dom$1, startContainer, endContainer)) {
								splitToFormatRoot(wrapWithSiblings(dom$1, Optional.from(startContainer.firstChild).getOr(startContainer), true, "span", {
									"id": "_start",
									"data-mce-type": "bookmark"
								}));
								unwrap$1(true);
								return;
							}
							if (isChildOfInlineParent(dom$1, endContainer, startContainer)) {
								splitToFormatRoot(wrapWithSiblings(dom$1, Optional.from(endContainer.lastChild).getOr(endContainer), false, "span", {
									"id": "_end",
									"data-mce-type": "bookmark"
								}));
								unwrap$1(false);
								return;
							}
							startContainer = wrap$1(dom$1, startContainer, "span", {
								"id": "_start",
								"data-mce-type": "bookmark"
							});
							endContainer = wrap$1(dom$1, endContainer, "span", {
								"id": "_end",
								"data-mce-type": "bookmark"
							});
							const newRng = dom$1.createRng();
							newRng.setStartAfter(startContainer);
							newRng.setEndBefore(endContainer);
							walk$3(dom$1, newRng, (nodes) => {
								each$e(nodes, (n) => {
									if (!isBookmarkNode$1(n) && !isBookmarkNode$1(n.parentNode)) splitToFormatRoot(n);
								});
							});
							splitToFormatRoot(startContainer);
							splitToFormatRoot(endContainer);
							startContainer = unwrap$1(true);
							endContainer = unwrap$1();
						} else startContainer = endContainer = splitToFormatRoot(startContainer);
						expandedRng.startContainer = startContainer.parentNode ? startContainer.parentNode : startContainer;
						expandedRng.startOffset = dom$1.nodeIndex(startContainer);
						expandedRng.endContainer = endContainer.parentNode ? endContainer.parentNode : endContainer;
						expandedRng.endOffset = dom$1.nodeIndex(endContainer) + 1;
					}
					walk$3(dom$1, expandedRng, (nodes) => {
						each$e(nodes, process$2);
					});
				};
				if (node) {
					if (isNode(node)) {
						const rng = dom$1.createRng();
						rng.setStartBefore(node);
						rng.setEndAfter(node);
						removeRngStyle(rng);
					} else removeRngStyle(node);
					fireFormatRemove(ed, name$1, node, vars);
					return;
				}
				if (!selection.isCollapsed() || !isInlineFormat(format) || getCellsFromEditor(ed).length) {
					preserveSelection(ed, () => runOnRanges(ed, removeRngStyle), (startNode) => isInlineFormat(format) && match$2(ed, name$1, vars, startNode));
					ed.nodeChanged();
				} else removeCaretFormat(ed, name$1, vars, similar);
				removeListStyleFormats(ed, name$1, vars);
				fireFormatRemove(ed, name$1, node, vars);
			};
			const removeFormat$1 = (ed, name$1, vars, node, similar) => {
				if (node || ed.selection.isEditable()) removeFormatInternal(ed, name$1, vars, node, similar);
			};
			const removeNodeFormat = (editor, format, vars, node, compareNode) => {
				return removeNodeFormatInternal(editor, format, vars, node, compareNode).fold(never, (newName) => {
					editor.dom.rename(node, newName);
					return true;
				}, always);
			};
			const each$6 = Tools.each;
			const mergeTextDecorationsAndColor = (dom$1, format, vars, node) => {
				const processTextDecorationsAndColor = (n) => {
					if (isElement$6(n) && isElement$6(n.parentNode) && isEditable$2(n)) {
						const parentTextDecoration = getTextDecoration(dom$1, n.parentNode);
						if (dom$1.getStyle(n, "color") && parentTextDecoration) dom$1.setStyle(n, "text-decoration", parentTextDecoration);
						else if (dom$1.getStyle(n, "text-decoration") === parentTextDecoration) dom$1.setStyle(n, "text-decoration", null);
					}
				};
				if (format.styles && (format.styles.color || format.styles.textDecoration)) {
					Tools.walk(node, processTextDecorationsAndColor, "childNodes");
					processTextDecorationsAndColor(node);
				}
			};
			const mergeBackgroundColorAndFontSize = (dom$1, format, vars, node) => {
				if (format.styles && format.styles.backgroundColor) {
					const hasFontSize = hasStyle(dom$1, "fontSize");
					processChildElements(node, (elm) => hasFontSize(elm) && isEditable$2(elm), applyStyle(dom$1, "backgroundColor", replaceVars(format.styles.backgroundColor, vars)));
				}
			};
			const mergeSubSup = (dom$1, format, vars, node) => {
				if (isInlineFormat(format) && (format.inline === "sub" || format.inline === "sup")) {
					const hasFontSize = hasStyle(dom$1, "fontSize");
					processChildElements(node, (elm) => hasFontSize(elm) && isEditable$2(elm), applyStyle(dom$1, "fontSize", ""));
					const inverseTagDescendants = filter$5(dom$1.select(format.inline === "sup" ? "sub" : "sup", node), isEditable$2);
					dom$1.remove(inverseTagDescendants, true);
				}
			};
			const mergeWithChildren = (editor, formatList, vars, node) => {
				each$6(formatList, (format) => {
					if (isInlineFormat(format)) each$6(editor.dom.select(format.inline, node), (child$2) => {
						if (isElementNode(child$2)) removeNodeFormat(editor, format, vars, child$2, format.exact ? child$2 : null);
					});
					clearChildStyles(editor.dom, format, node);
				});
			};
			const mergeWithParents = (editor, format, name$1, vars, node) => {
				const parentNode = node.parentNode;
				if (matchNode(editor, parentNode, name$1, vars)) {
					if (removeNodeFormat(editor, format, vars, node)) return;
				}
				if (format.merge_with_parents && parentNode) editor.dom.getParent(parentNode, (parent$1) => {
					if (matchNode(editor, parent$1, name$1, vars)) {
						removeNodeFormat(editor, format, vars, node);
						return true;
					} else return false;
				});
			};
			const each$5 = Tools.each;
			const canFormatBR = (editor, format, node, parentName) => {
				if (canFormatEmptyLines(editor) && isInlineFormat(format) && node.parentNode) {
					const validBRParentElements = getTextRootBlockElements(editor.schema);
					const hasCaretNodeSibling = sibling(SugarElement.fromDom(node), (sibling$2) => isCaretNode(sibling$2.dom));
					return hasNonNullableKey(validBRParentElements, parentName) && isEmpty$2(SugarElement.fromDom(node.parentNode), false) && !hasCaretNodeSibling;
				} else return false;
			};
			const applyStyles = (dom$1, elm, format, vars) => {
				each$5(format.styles, (value$3, name$1) => {
					dom$1.setStyle(elm, name$1, replaceVars(value$3, vars));
				});
				if (format.styles) {
					const styleVal = dom$1.getAttrib(elm, "style");
					if (styleVal) dom$1.setAttrib(elm, "data-mce-style", styleVal);
				}
			};
			const applyFormatAction = (ed, name$1, vars, node) => {
				const formatList = ed.formatter.get(name$1);
				const format = formatList[0];
				const isCollapsed = !node && ed.selection.isCollapsed();
				const dom$1 = ed.dom;
				const selection = ed.selection;
				const setElementFormat = (elm, fmt = format) => {
					if (isFunction(fmt.onformat)) fmt.onformat(elm, fmt, vars, node);
					applyStyles(dom$1, elm, fmt, vars);
					each$5(fmt.attributes, (value$3, name$2) => {
						dom$1.setAttrib(elm, name$2, replaceVars(value$3, vars));
					});
					each$5(fmt.classes, (value$3) => {
						const newValue = replaceVars(value$3, vars);
						if (!dom$1.hasClass(elm, newValue)) dom$1.addClass(elm, newValue);
					});
				};
				const applyNodeStyle = (formatList$1, node$1) => {
					let found = false;
					each$5(formatList$1, (format$1) => {
						if (!isSelectorFormat(format$1)) return false;
						if (dom$1.getContentEditable(node$1) === "false" && !format$1.ceFalseOverride) return true;
						if (isNonNullable(format$1.collapsed) && format$1.collapsed !== isCollapsed) return true;
						if (dom$1.is(node$1, format$1.selector) && !isCaretNode(node$1)) {
							setElementFormat(node$1, format$1);
							found = true;
							return false;
						}
						return true;
					});
					return found;
				};
				const createWrapElement = (wrapName) => {
					if (isString(wrapName)) {
						const wrapElm = dom$1.create(wrapName);
						setElementFormat(wrapElm);
						return wrapElm;
					} else return null;
				};
				const applyRngStyle = (dom$2, rng, nodeSpecific) => {
					const newWrappers = [];
					let contentEditable = true;
					const wrapName = format.inline || format.block;
					const wrapElm = createWrapElement(wrapName);
					const isMatchingWrappingBlock = (node$1) => isWrappingBlockFormat(format) && matchNode(ed, node$1, name$1, vars);
					const canRenameBlock = (node$1, parentName, isEditableDescendant) => {
						const isValidBlockFormatForNode = isNonWrappingBlockFormat(format) && isTextBlock$1(ed.schema, node$1) && isValid(ed, parentName, wrapName);
						return isEditableDescendant && isValidBlockFormatForNode;
					};
					const canWrapNode = (node$1, parentName, isEditableDescendant, isWrappableNoneditableElm) => {
						const isValidWrapNode = isValid(ed, wrapName, node$1.nodeName.toLowerCase()) && isValid(ed, parentName, wrapName);
						const isZwsp$3 = !nodeSpecific && isText$a(node$1) && isZwsp$1(node$1.data);
						const isCaret = isCaretNode(node$1);
						const isCorrectFormatForNode = !isInlineFormat(format) || !dom$2.isBlock(node$1);
						return (isEditableDescendant || isWrappableNoneditableElm) && isValidWrapNode && !isZwsp$3 && !isCaret && isCorrectFormatForNode;
					};
					walk$3(dom$2, rng, (nodes) => {
						let currentWrapElm;
						const process$2 = (node$1) => {
							let hasContentEditableState$1 = false;
							let lastContentEditable = contentEditable;
							let isWrappableNoneditableElm = false;
							const parentNode = node$1.parentNode;
							const parentName = parentNode.nodeName.toLowerCase();
							const contentEditableValue = dom$2.getContentEditable(node$1);
							if (isNonNullable(contentEditableValue)) {
								lastContentEditable = contentEditable;
								contentEditable = contentEditableValue === "true";
								hasContentEditableState$1 = true;
								isWrappableNoneditableElm = isWrappableNoneditable(ed, node$1);
							}
							const isEditableDescendant = contentEditable && !hasContentEditableState$1;
							if (isBr$6(node$1) && !canFormatBR(ed, format, node$1, parentName)) {
								currentWrapElm = null;
								if (isBlockFormat(format)) dom$2.remove(node$1);
								return;
							}
							if (isMatchingWrappingBlock(node$1)) {
								currentWrapElm = null;
								return;
							}
							if (canRenameBlock(node$1, parentName, isEditableDescendant)) {
								const elm = dom$2.rename(node$1, wrapName);
								setElementFormat(elm);
								newWrappers.push(elm);
								currentWrapElm = null;
								return;
							}
							if (isSelectorFormat(format)) {
								let found = applyNodeStyle(formatList, node$1);
								if (!found && isNonNullable(parentNode) && shouldExpandToSelector(format)) found = applyNodeStyle(formatList, parentNode);
								if (!isInlineFormat(format) || found) {
									currentWrapElm = null;
									return;
								}
							}
							if (isNonNullable(wrapElm) && canWrapNode(node$1, parentName, isEditableDescendant, isWrappableNoneditableElm)) {
								if (!currentWrapElm) {
									currentWrapElm = dom$2.clone(wrapElm, false);
									parentNode.insertBefore(currentWrapElm, node$1);
									newWrappers.push(currentWrapElm);
								}
								if (isWrappableNoneditableElm && hasContentEditableState$1) contentEditable = lastContentEditable;
								currentWrapElm.appendChild(node$1);
							} else {
								currentWrapElm = null;
								each$e(from(node$1.childNodes), process$2);
								if (hasContentEditableState$1) contentEditable = lastContentEditable;
								currentWrapElm = null;
							}
						};
						each$e(nodes, process$2);
					});
					if (format.links === true) each$e(newWrappers, (node$1) => {
						const process$2 = (node$2) => {
							if (node$2.nodeName === "A") setElementFormat(node$2, format);
							each$e(from(node$2.childNodes), process$2);
						};
						process$2(node$1);
					});
					each$e(newWrappers, (node$1) => {
						const getChildCount = (node$2) => {
							let count$2 = 0;
							each$e(node$2.childNodes, (node$3) => {
								if (!isEmptyTextNode$1(node$3) && !isBookmarkNode$1(node$3)) count$2++;
							});
							return count$2;
						};
						const mergeStyles = (node$2) => {
							return find$2(node$2.childNodes, isElementNode$1).filter((child$2) => dom$2.getContentEditable(child$2) !== "false" && matchName(dom$2, child$2, format)).map((child$2) => {
								const clone$5 = dom$2.clone(child$2, false);
								setElementFormat(clone$5);
								dom$2.replace(clone$5, node$2, true);
								dom$2.remove(child$2, true);
								return clone$5;
							}).getOr(node$2);
						};
						const childCount = getChildCount(node$1);
						if ((newWrappers.length > 1 || !dom$2.isBlock(node$1)) && childCount === 0) {
							dom$2.remove(node$1, true);
							return;
						}
						if (isInlineFormat(format) || isBlockFormat(format) && format.wrapper) {
							if (!format.exact && childCount === 1) node$1 = mergeStyles(node$1);
							mergeWithChildren(ed, formatList, vars, node$1);
							mergeWithParents(ed, format, name$1, vars, node$1);
							mergeBackgroundColorAndFontSize(dom$2, format, vars, node$1);
							mergeTextDecorationsAndColor(dom$2, format, vars, node$1);
							mergeSubSup(dom$2, format, vars, node$1);
							mergeSiblings(ed, format, vars, node$1);
						}
					});
				};
				const targetNode = isNode(node) ? node : selection.getNode();
				if (dom$1.getContentEditable(targetNode) === "false" && !isWrappableNoneditable(ed, targetNode)) {
					node = targetNode;
					applyNodeStyle(formatList, node);
					fireFormatApply(ed, name$1, node, vars);
					return;
				}
				if (format) {
					if (node) if (isNode(node)) {
						if (!applyNodeStyle(formatList, node)) {
							const rng = dom$1.createRng();
							rng.setStartBefore(node);
							rng.setEndAfter(node);
							applyRngStyle(dom$1, expandRng(dom$1, rng, formatList), true);
						}
					} else applyRngStyle(dom$1, node, true);
					else {
						if (!isCollapsed || !isInlineFormat(format) || getCellsFromEditor(ed).length) {
							selection.setRng(normalize(selection.getRng()));
							preserveSelection(ed, () => {
								runOnRanges(ed, (selectionRng, fake) => {
									applyRngStyle(dom$1, fake ? selectionRng : expandRng(dom$1, selectionRng, formatList), false);
								});
							}, always);
							ed.nodeChanged();
						} else applyCaretFormat(ed, name$1, vars);
						getExpandedListItemFormat(ed.formatter, name$1).each((liFmt) => {
							each$e(getFullySelectedListItems(ed.selection), (li) => applyStyles(dom$1, li, liFmt, vars));
						});
					}
					postProcess$1(name$1, ed);
				}
				fireFormatApply(ed, name$1, node, vars);
			};
			const applyFormat$1 = (editor, name$1, vars, node) => {
				if (node || editor.selection.isEditable()) applyFormatAction(editor, name$1, vars, node);
			};
			const hasVars = (value$3) => has$2(value$3, "vars");
			const setup$t = (registeredFormatListeners, editor) => {
				registeredFormatListeners.set({});
				editor.on("NodeChange", (e) => {
					updateAndFireChangeCallbacks(editor, e.element, registeredFormatListeners.get());
				});
				editor.on("FormatApply FormatRemove", (e) => {
					updateAndFireChangeCallbacks(editor, Optional.from(e.node).map((nodeOrRange) => isNode(nodeOrRange) ? nodeOrRange : nodeOrRange.startContainer).bind((node) => isElement$6(node) ? Optional.some(node) : Optional.from(node.parentElement)).getOrThunk(() => fallbackElement(editor)), registeredFormatListeners.get());
				});
			};
			const fallbackElement = (editor) => editor.selection.getStart();
			const matchingNode = (editor, parents$2, format, similar, vars) => {
				const isMatchingNode = (node) => {
					return !isUndefined(editor.formatter.matchNode(node, format, vars !== null && vars !== void 0 ? vars : {}, similar));
				};
				const isUnableToMatch = (node) => {
					if (matchesUnInheritedFormatSelector(editor, node, format)) return true;
					else if (!similar) return isNonNullable(editor.formatter.matchNode(node, format, vars, true));
					else return false;
				};
				return findUntil$1(parents$2, isMatchingNode, isUnableToMatch);
			};
			const getParents = (editor, elm) => {
				const element = elm !== null && elm !== void 0 ? elm : fallbackElement(editor);
				return filter$5(getParents$2(editor.dom, element), (node) => isElement$6(node) && !isBogus$2(node));
			};
			const updateAndFireChangeCallbacks = (editor, elm, registeredCallbacks) => {
				const parents$2 = getParents(editor, elm);
				each$d(registeredCallbacks, (data$1, format) => {
					const runIfChanged = (spec) => {
						const match$3 = matchingNode(editor, parents$2, format, spec.similar, hasVars(spec) ? spec.vars : void 0);
						const isSet = match$3.isSome();
						if (spec.state.get() !== isSet) {
							spec.state.set(isSet);
							const node = match$3.getOr(elm);
							if (hasVars(spec)) spec.callback(isSet, {
								node,
								format,
								parents: parents$2
							});
							else each$e(spec.callbacks, (callback) => callback(isSet, {
								node,
								format,
								parents: parents$2
							}));
						}
					};
					each$e([data$1.withSimilar, data$1.withoutSimilar], runIfChanged);
					each$e(data$1.withVars, runIfChanged);
				});
			};
			const addListeners = (editor, registeredFormatListeners, formats, callback, similar, vars) => {
				const formatChangeItems = registeredFormatListeners.get();
				each$e(formats.split(","), (format) => {
					const group = get$a(formatChangeItems, format).getOrThunk(() => {
						const base = {
							withSimilar: {
								state: Cell(false),
								similar: true,
								callbacks: []
							},
							withoutSimilar: {
								state: Cell(false),
								similar: false,
								callbacks: []
							},
							withVars: []
						};
						formatChangeItems[format] = base;
						return base;
					});
					const getCurrent = () => {
						return matchingNode(editor, getParents(editor), format, similar, vars).isSome();
					};
					if (isUndefined(vars)) {
						const toAppendTo = similar ? group.withSimilar : group.withoutSimilar;
						toAppendTo.callbacks.push(callback);
						if (toAppendTo.callbacks.length === 1) toAppendTo.state.set(getCurrent());
					} else group.withVars.push({
						state: Cell(getCurrent()),
						similar,
						vars,
						callback
					});
				});
				registeredFormatListeners.set(formatChangeItems);
			};
			const removeListeners = (registeredFormatListeners, formats, callback) => {
				const formatChangeItems = registeredFormatListeners.get();
				each$e(formats.split(","), (format) => get$a(formatChangeItems, format).each((group) => {
					formatChangeItems[format] = {
						withSimilar: {
							...group.withSimilar,
							callbacks: filter$5(group.withSimilar.callbacks, (cb) => cb !== callback)
						},
						withoutSimilar: {
							...group.withoutSimilar,
							callbacks: filter$5(group.withoutSimilar.callbacks, (cb) => cb !== callback)
						},
						withVars: filter$5(group.withVars, (item) => item.callback !== callback)
					};
				}));
				registeredFormatListeners.set(formatChangeItems);
			};
			const formatChangedInternal = (editor, registeredFormatListeners, formats, callback, similar, vars) => {
				addListeners(editor, registeredFormatListeners, formats, callback, similar, vars);
				return { unbind: () => removeListeners(registeredFormatListeners, formats, callback) };
			};
			const toggle = (editor, name$1, vars, node) => {
				const fmt = editor.formatter.get(name$1);
				if (fmt) if (match$2(editor, name$1, vars, node) && (!("toggle" in fmt[0]) || fmt[0].toggle)) removeFormat$1(editor, name$1, vars, node);
				else applyFormat$1(editor, name$1, vars, node);
			};
			const explode$1 = Tools.explode;
			const create$8 = () => {
				const filters = {};
				const addFilter = (name$1, callback) => {
					each$e(explode$1(name$1), (name$2) => {
						if (!has$2(filters, name$2)) filters[name$2] = {
							name: name$2,
							callbacks: []
						};
						filters[name$2].callbacks.push(callback);
					});
				};
				const getFilters = () => values(filters);
				const removeFilter = (name$1, callback) => {
					each$e(explode$1(name$1), (name$2) => {
						if (has$2(filters, name$2)) if (isNonNullable(callback)) {
							const filter$6 = filters[name$2];
							const newCallbacks = filter$5(filter$6.callbacks, (c) => c !== callback);
							if (newCallbacks.length > 0) filter$6.callbacks = newCallbacks;
							else delete filters[name$2];
						} else delete filters[name$2];
					});
				};
				return {
					addFilter,
					getFilters,
					removeFilter
				};
			};
			const removeAttrs = (node, names) => {
				each$e(names, (name$1) => {
					node.attr(name$1, null);
				});
			};
			const addFontToSpansFilter = (domParser, styles, fontSizes) => {
				domParser.addNodeFilter("font", (nodes) => {
					each$e(nodes, (node) => {
						const props = styles.parse(node.attr("style"));
						const color = node.attr("color");
						const face = node.attr("face");
						const size = node.attr("size");
						if (color) props.color = color;
						if (face) props["font-family"] = face;
						if (size) toInt(size).each((num) => {
							props["font-size"] = fontSizes[num - 1];
						});
						node.name = "span";
						node.attr("style", styles.serialize(props));
						removeAttrs(node, [
							"color",
							"face",
							"size"
						]);
					});
				});
			};
			const addStrikeFilter = (domParser, schema, styles) => {
				domParser.addNodeFilter("strike", (nodes) => {
					const convertToSTag = schema.type !== "html4";
					each$e(nodes, (node) => {
						if (convertToSTag) node.name = "s";
						else {
							const props = styles.parse(node.attr("style"));
							props["text-decoration"] = "line-through";
							node.name = "span";
							node.attr("style", styles.serialize(props));
						}
					});
				});
			};
			const addFilters = (domParser, settings, schema) => {
				var _a;
				const styles = Styles();
				if (settings.convert_fonts_to_spans) addFontToSpansFilter(domParser, styles, Tools.explode((_a = settings.font_size_legacy_values) !== null && _a !== void 0 ? _a : ""));
				addStrikeFilter(domParser, schema, styles);
			};
			const register$5 = (domParser, settings, schema) => {
				if (settings.inline_styles) addFilters(domParser, settings, schema);
			};
			const addNodeFilter = (settings, htmlParser, schema) => {
				htmlParser.addNodeFilter("br", (nodes, _, args) => {
					const blockElements = Tools.extend({}, schema.getBlockElements());
					const nonEmptyElements = schema.getNonEmptyElements();
					const whitespaceElements = schema.getWhitespaceElements();
					blockElements.body = 1;
					const isBlock$3 = (node) => node.name in blockElements || isTransparentAstBlock(schema, node);
					for (let i = 0, l = nodes.length; i < l; i++) {
						let node = nodes[i];
						let parent$1 = node.parent;
						if (parent$1 && isBlock$3(parent$1) && node === parent$1.lastChild) {
							let prev$1 = node.prev;
							while (prev$1) {
								const prevName = prev$1.name;
								if (prevName !== "span" || prev$1.attr("data-mce-type") !== "bookmark") {
									if (prevName === "br") node = null;
									break;
								}
								prev$1 = prev$1.prev;
							}
							if (node) {
								node.remove();
								if (isEmpty(schema, nonEmptyElements, whitespaceElements, parent$1)) {
									const elementRule = schema.getElementRule(parent$1.name);
									if (elementRule) {
										if (elementRule.removeEmpty) parent$1.remove();
										else if (elementRule.paddEmpty) paddEmptyNode(settings, args, isBlock$3, parent$1);
									}
								}
							}
						} else {
							let lastParent = node;
							while (parent$1 && parent$1.firstChild === lastParent && parent$1.lastChild === lastParent) {
								lastParent = parent$1;
								if (blockElements[parent$1.name]) break;
								parent$1 = parent$1.parent;
							}
							if (lastParent === parent$1) {
								const textNode = new AstNode("#text", 3);
								textNode.value = nbsp;
								node.replace(textNode);
							}
						}
					}
				});
			};
			const blobUriToBlob = (url) => fetch(url).then((res) => res.ok ? res.blob() : Promise.reject()).catch(() => Promise.reject({
				message: `Cannot convert ${url} to Blob. Resource might not exist or is inaccessible.`,
				uriType: "blob"
			}));
			const extractBase64Data = (data$1) => {
				const matches = /([a-z0-9+\/=\s]+)/i.exec(data$1);
				return matches ? matches[1] : "";
			};
			const parseDataUri = (uri) => {
				const [type$2, ...rest] = uri.split(",");
				const data$1 = rest.join(",");
				const matches = /data:([^/]+\/[^;]+)(;.+)?/.exec(type$2);
				if (matches) {
					const base64Encoded = matches[2] === ";base64";
					const extractedData = base64Encoded ? extractBase64Data(data$1) : decodeURIComponent(data$1);
					return Optional.some({
						type: matches[1],
						data: extractedData,
						base64Encoded
					});
				} else return Optional.none();
			};
			const buildBlob = (type$2, data$1, base64Encoded = true) => {
				let str = data$1;
				if (base64Encoded) try {
					str = atob(data$1);
				} catch (e) {
					return Optional.none();
				}
				const arr = new Uint8Array(str.length);
				for (let i = 0; i < arr.length; i++) arr[i] = str.charCodeAt(i);
				return Optional.some(new Blob([arr], { type: type$2 }));
			};
			const dataUriToBlob = (uri) => {
				return new Promise((resolve$4, reject) => {
					parseDataUri(uri).bind(({ type: type$2, data: data$1, base64Encoded }) => buildBlob(type$2, data$1, base64Encoded)).fold(() => reject("Invalid data URI"), resolve$4);
				});
			};
			const uriToBlob = (url) => {
				if (startsWith(url, "blob:")) return blobUriToBlob(url);
				else if (startsWith(url, "data:")) return dataUriToBlob(url);
				else return Promise.reject("Unknown URI format");
			};
			const blobToDataUri = (blob) => {
				return new Promise((resolve$4, reject) => {
					const reader = new FileReader();
					reader.onloadend = () => {
						resolve$4(reader.result);
					};
					reader.onerror = () => {
						var _a;
						reject((_a = reader.error) === null || _a === void 0 ? void 0 : _a.message);
					};
					reader.readAsDataURL(blob);
				});
			};
			let count$1 = 0;
			const uniqueId$1 = (prefix) => {
				return (prefix || "blobid") + count$1++;
			};
			const processDataUri = (dataUri, base64Only, generateBlobInfo) => {
				return parseDataUri(dataUri).bind(({ data: data$1, type: type$2, base64Encoded }) => {
					if (base64Only && !base64Encoded) return Optional.none();
					else return generateBlobInfo(base64Encoded ? data$1 : btoa(data$1), type$2);
				});
			};
			const createBlobInfo$1 = (blobCache, blob, base64) => {
				const blobInfo = blobCache.create(uniqueId$1(), blob, base64);
				blobCache.add(blobInfo);
				return blobInfo;
			};
			const dataUriToBlobInfo = (blobCache, dataUri, base64Only = false) => {
				return processDataUri(dataUri, base64Only, (base64, type$2) => Optional.from(blobCache.getByData(base64, type$2)).orThunk(() => buildBlob(type$2, base64).map((blob) => createBlobInfo$1(blobCache, blob, base64))));
			};
			const imageToBlobInfo = (blobCache, imageSrc) => {
				const invalidDataUri = () => Promise.reject("Invalid data URI");
				if (startsWith(imageSrc, "blob:")) {
					const blobInfo = blobCache.getByUri(imageSrc);
					if (isNonNullable(blobInfo)) return Promise.resolve(blobInfo);
					else return uriToBlob(imageSrc).then((blob) => {
						return blobToDataUri(blob).then((dataUri) => {
							return processDataUri(dataUri, false, (base64) => {
								return Optional.some(createBlobInfo$1(blobCache, blob, base64));
							}).getOrThunk(invalidDataUri);
						});
					});
				} else if (startsWith(imageSrc, "data:")) return dataUriToBlobInfo(blobCache, imageSrc).fold(invalidDataUri, (blobInfo) => Promise.resolve(blobInfo));
				else return Promise.reject("Unknown image data format");
			};
			const isBogusImage = (img) => isNonNullable(img.attr("data-mce-bogus"));
			const isInternalImageSource = (img) => img.attr("src") === Env.transparentSrc || isNonNullable(img.attr("data-mce-placeholder"));
			const registerBase64ImageFilter = (parser, settings) => {
				const { blob_cache: blobCache } = settings;
				if (blobCache) {
					const processImage = (img) => {
						const inputSrc = img.attr("src");
						if (isInternalImageSource(img) || isBogusImage(img) || isNullable(inputSrc)) return;
						dataUriToBlobInfo(blobCache, inputSrc, true).each((blobInfo) => {
							img.attr("src", blobInfo.blobUri());
						});
					};
					parser.addAttributeFilter("src", (nodes) => each$e(nodes, processImage));
				}
			};
			const register$4 = (parser, settings) => {
				const schema = parser.schema;
				if (settings.remove_trailing_brs) addNodeFilter(settings, parser, schema);
				parser.addAttributeFilter("href", (nodes) => {
					let i = nodes.length;
					const appendRel = (rel) => {
						return rel.split(" ").filter((p) => p.length > 0).concat(["noopener"]).sort().join(" ");
					};
					const addNoOpener = (rel) => {
						const newRel = rel ? Tools.trim(rel) : "";
						if (!/\b(noopener)\b/g.test(newRel)) return appendRel(newRel);
						else return newRel;
					};
					if (!settings.allow_unsafe_link_target) while (i--) {
						const node = nodes[i];
						if (node.name === "a" && node.attr("target") === "_blank") node.attr("rel", addNoOpener(node.attr("rel")));
					}
				});
				if (!settings.allow_html_in_named_anchor) parser.addAttributeFilter("id,name", (nodes) => {
					let i = nodes.length, sibling$2, prevSibling$1, parent$1, node;
					while (i--) {
						node = nodes[i];
						if (node.name === "a" && node.firstChild && !node.attr("href")) {
							parent$1 = node.parent;
							sibling$2 = node.lastChild;
							while (sibling$2 && parent$1) {
								prevSibling$1 = sibling$2.prev;
								parent$1.insert(sibling$2, node);
								sibling$2 = prevSibling$1;
							}
						}
					}
				});
				if (settings.fix_list_elements) parser.addNodeFilter("ul,ol", (nodes) => {
					let i = nodes.length, node, parentNode;
					while (i--) {
						node = nodes[i];
						parentNode = node.parent;
						if (parentNode && (parentNode.name === "ul" || parentNode.name === "ol")) if (node.prev && node.prev.name === "li") node.prev.append(node);
						else {
							const li = new AstNode("li", 1);
							li.attr("style", "list-style-type: none");
							node.wrap(li);
						}
					}
				});
				const validClasses = schema.getValidClasses();
				if (settings.validate && validClasses) parser.addAttributeFilter("class", (nodes) => {
					var _a;
					let i = nodes.length;
					while (i--) {
						const node = nodes[i];
						const clazz = (_a = node.attr("class")) !== null && _a !== void 0 ? _a : "";
						const classList = Tools.explode(clazz, " ");
						let classValue = "";
						for (let ci = 0; ci < classList.length; ci++) {
							const className = classList[ci];
							let valid = false;
							let validClassesMap = validClasses["*"];
							if (validClassesMap && validClassesMap[className]) valid = true;
							validClassesMap = validClasses[node.name];
							if (!valid && validClassesMap && validClassesMap[className]) valid = true;
							if (valid) {
								if (classValue) classValue += " ";
								classValue += className;
							}
						}
						if (!classValue.length) classValue = null;
						node.attr("class", classValue);
					}
				});
				registerBase64ImageFilter(parser, settings);
			};
			function _typeof(obj) {
				"@babel/helpers - typeof";
				return _typeof = "function" == typeof Symbol && "symbol" == typeof Symbol.iterator ? function(obj$1) {
					return typeof obj$1;
				} : function(obj$1) {
					return obj$1 && "function" == typeof Symbol && obj$1.constructor === Symbol && obj$1 !== Symbol.prototype ? "symbol" : typeof obj$1;
				}, _typeof(obj);
			}
			function _setPrototypeOf(o, p) {
				_setPrototypeOf = Object.setPrototypeOf || function _setPrototypeOf$1(o$1, p$1) {
					o$1.__proto__ = p$1;
					return o$1;
				};
				return _setPrototypeOf(o, p);
			}
			function _isNativeReflectConstruct() {
				if (typeof Reflect === "undefined" || !Reflect.construct) return false;
				if (Reflect.construct.sham) return false;
				if (typeof Proxy === "function") return true;
				try {
					Boolean.prototype.valueOf.call(Reflect.construct(Boolean, [], function() {}));
					return true;
				} catch (e) {
					return false;
				}
			}
			function _construct(Parent, args, Class) {
				if (_isNativeReflectConstruct()) _construct = Reflect.construct;
				else _construct = function _construct$1(Parent$1, args$1, Class$1) {
					var a = [null];
					a.push.apply(a, args$1);
					var instance$1 = new (Function.bind.apply(Parent$1, a))();
					if (Class$1) _setPrototypeOf(instance$1, Class$1.prototype);
					return instance$1;
				};
				return _construct.apply(null, arguments);
			}
			function _toConsumableArray(arr) {
				return _arrayWithoutHoles(arr) || _iterableToArray(arr) || _unsupportedIterableToArray(arr) || _nonIterableSpread();
			}
			function _arrayWithoutHoles(arr) {
				if (Array.isArray(arr)) return _arrayLikeToArray(arr);
			}
			function _iterableToArray(iter) {
				if (typeof Symbol !== "undefined" && iter[Symbol.iterator] != null || iter["@@iterator"] != null) return Array.from(iter);
			}
			function _unsupportedIterableToArray(o, minLen) {
				if (!o) return;
				if (typeof o === "string") return _arrayLikeToArray(o, minLen);
				var n = Object.prototype.toString.call(o).slice(8, -1);
				if (n === "Object" && o.constructor) n = o.constructor.name;
				if (n === "Map" || n === "Set") return Array.from(o);
				if (n === "Arguments" || /^(?:Ui|I)nt(?:8|16|32)(?:Clamped)?Array$/.test(n)) return _arrayLikeToArray(o, minLen);
			}
			function _arrayLikeToArray(arr, len) {
				if (len == null || len > arr.length) len = arr.length;
				for (var i = 0, arr2 = new Array(len); i < len; i++) arr2[i] = arr[i];
				return arr2;
			}
			function _nonIterableSpread() {
				throw new TypeError("Invalid attempt to spread non-iterable instance.\nIn order to be iterable, non-array objects must have a [Symbol.iterator]() method.");
			}
			var hasOwnProperty = Object.hasOwnProperty, setPrototypeOf = Object.setPrototypeOf, isFrozen = Object.isFrozen, getPrototypeOf = Object.getPrototypeOf, getOwnPropertyDescriptor = Object.getOwnPropertyDescriptor;
			var freeze = Object.freeze, seal = Object.seal, create$7 = Object.create;
			var _ref = typeof Reflect !== "undefined" && Reflect, apply = _ref.apply, construct = _ref.construct;
			if (!apply) apply = function apply$2(fun, thisValue, args) {
				return fun.apply(thisValue, args);
			};
			if (!freeze) freeze = function freeze$1(x) {
				return x;
			};
			if (!seal) seal = function seal$1(x) {
				return x;
			};
			if (!construct) construct = function construct$1(Func, args) {
				return _construct(Func, _toConsumableArray(args));
			};
			var arrayForEach = unapply(Array.prototype.forEach);
			var arrayPop = unapply(Array.prototype.pop);
			var arrayPush = unapply(Array.prototype.push);
			var stringToLowerCase = unapply(String.prototype.toLowerCase);
			var stringMatch = unapply(String.prototype.match);
			var stringReplace = unapply(String.prototype.replace);
			var stringIndexOf = unapply(String.prototype.indexOf);
			var stringTrim = unapply(String.prototype.trim);
			var regExpTest = unapply(RegExp.prototype.test);
			var typeErrorCreate = unconstruct(TypeError);
			function unapply(func) {
				return function(thisArg) {
					for (var _len = arguments.length, args = new Array(_len > 1 ? _len - 1 : 0), _key = 1; _key < _len; _key++) args[_key - 1] = arguments[_key];
					return apply(func, thisArg, args);
				};
			}
			function unconstruct(func) {
				return function() {
					for (var _len2 = arguments.length, args = new Array(_len2), _key2 = 0; _key2 < _len2; _key2++) args[_key2] = arguments[_key2];
					return construct(func, args);
				};
			}
			function addToSet(set$4, array) {
				if (setPrototypeOf) setPrototypeOf(set$4, null);
				var l = array.length;
				while (l--) {
					var element = array[l];
					if (typeof element === "string") {
						var lcElement = stringToLowerCase(element);
						if (lcElement !== element) {
							if (!isFrozen(array)) array[l] = lcElement;
							element = lcElement;
						}
					}
					set$4[element] = true;
				}
				return set$4;
			}
			function clone(object) {
				var newObject = create$7(null);
				var property;
				for (property in object) if (apply(hasOwnProperty, object, [property])) newObject[property] = object[property];
				return newObject;
			}
			function lookupGetter(object, prop) {
				while (object !== null) {
					var desc = getOwnPropertyDescriptor(object, prop);
					if (desc) {
						if (desc.get) return unapply(desc.get);
						if (typeof desc.value === "function") return unapply(desc.value);
					}
					object = getPrototypeOf(object);
				}
				function fallbackValue(element) {
					console.warn("fallback value for", element);
					return null;
				}
				return fallbackValue;
			}
			var html$1 = freeze([
				"a",
				"abbr",
				"acronym",
				"address",
				"area",
				"article",
				"aside",
				"audio",
				"b",
				"bdi",
				"bdo",
				"big",
				"blink",
				"blockquote",
				"body",
				"br",
				"button",
				"canvas",
				"caption",
				"center",
				"cite",
				"code",
				"col",
				"colgroup",
				"content",
				"data",
				"datalist",
				"dd",
				"decorator",
				"del",
				"details",
				"dfn",
				"dialog",
				"dir",
				"div",
				"dl",
				"dt",
				"element",
				"em",
				"fieldset",
				"figcaption",
				"figure",
				"font",
				"footer",
				"form",
				"h1",
				"h2",
				"h3",
				"h4",
				"h5",
				"h6",
				"head",
				"header",
				"hgroup",
				"hr",
				"html",
				"i",
				"img",
				"input",
				"ins",
				"kbd",
				"label",
				"legend",
				"li",
				"main",
				"map",
				"mark",
				"marquee",
				"menu",
				"menuitem",
				"meter",
				"nav",
				"nobr",
				"ol",
				"optgroup",
				"option",
				"output",
				"p",
				"picture",
				"pre",
				"progress",
				"q",
				"rp",
				"rt",
				"ruby",
				"s",
				"samp",
				"section",
				"select",
				"shadow",
				"small",
				"source",
				"spacer",
				"span",
				"strike",
				"strong",
				"style",
				"sub",
				"summary",
				"sup",
				"table",
				"tbody",
				"td",
				"template",
				"textarea",
				"tfoot",
				"th",
				"thead",
				"time",
				"tr",
				"track",
				"tt",
				"u",
				"ul",
				"var",
				"video",
				"wbr"
			]);
			var svg$1 = freeze([
				"svg",
				"a",
				"altglyph",
				"altglyphdef",
				"altglyphitem",
				"animatecolor",
				"animatemotion",
				"animatetransform",
				"circle",
				"clippath",
				"defs",
				"desc",
				"ellipse",
				"filter",
				"font",
				"g",
				"glyph",
				"glyphref",
				"hkern",
				"image",
				"line",
				"lineargradient",
				"marker",
				"mask",
				"metadata",
				"mpath",
				"path",
				"pattern",
				"polygon",
				"polyline",
				"radialgradient",
				"rect",
				"stop",
				"style",
				"switch",
				"symbol",
				"text",
				"textpath",
				"title",
				"tref",
				"tspan",
				"view",
				"vkern"
			]);
			var svgFilters = freeze([
				"feBlend",
				"feColorMatrix",
				"feComponentTransfer",
				"feComposite",
				"feConvolveMatrix",
				"feDiffuseLighting",
				"feDisplacementMap",
				"feDistantLight",
				"feFlood",
				"feFuncA",
				"feFuncB",
				"feFuncG",
				"feFuncR",
				"feGaussianBlur",
				"feImage",
				"feMerge",
				"feMergeNode",
				"feMorphology",
				"feOffset",
				"fePointLight",
				"feSpecularLighting",
				"feSpotLight",
				"feTile",
				"feTurbulence"
			]);
			var svgDisallowed = freeze([
				"animate",
				"color-profile",
				"cursor",
				"discard",
				"fedropshadow",
				"font-face",
				"font-face-format",
				"font-face-name",
				"font-face-src",
				"font-face-uri",
				"foreignobject",
				"hatch",
				"hatchpath",
				"mesh",
				"meshgradient",
				"meshpatch",
				"meshrow",
				"missing-glyph",
				"script",
				"set",
				"solidcolor",
				"unknown",
				"use"
			]);
			var mathMl$1 = freeze([
				"math",
				"menclose",
				"merror",
				"mfenced",
				"mfrac",
				"mglyph",
				"mi",
				"mlabeledtr",
				"mmultiscripts",
				"mn",
				"mo",
				"mover",
				"mpadded",
				"mphantom",
				"mroot",
				"mrow",
				"ms",
				"mspace",
				"msqrt",
				"mstyle",
				"msub",
				"msup",
				"msubsup",
				"mtable",
				"mtd",
				"mtext",
				"mtr",
				"munder",
				"munderover"
			]);
			var mathMlDisallowed = freeze([
				"maction",
				"maligngroup",
				"malignmark",
				"mlongdiv",
				"mscarries",
				"mscarry",
				"msgroup",
				"mstack",
				"msline",
				"msrow",
				"semantics",
				"annotation",
				"annotation-xml",
				"mprescripts",
				"none"
			]);
			var text = freeze(["#text"]);
			var html = freeze([
				"accept",
				"action",
				"align",
				"alt",
				"autocapitalize",
				"autocomplete",
				"autopictureinpicture",
				"autoplay",
				"background",
				"bgcolor",
				"border",
				"capture",
				"cellpadding",
				"cellspacing",
				"checked",
				"cite",
				"class",
				"clear",
				"color",
				"cols",
				"colspan",
				"controls",
				"controlslist",
				"coords",
				"crossorigin",
				"datetime",
				"decoding",
				"default",
				"dir",
				"disabled",
				"disablepictureinpicture",
				"disableremoteplayback",
				"download",
				"draggable",
				"enctype",
				"enterkeyhint",
				"face",
				"for",
				"headers",
				"height",
				"hidden",
				"high",
				"href",
				"hreflang",
				"id",
				"inputmode",
				"integrity",
				"ismap",
				"kind",
				"label",
				"lang",
				"list",
				"loading",
				"loop",
				"low",
				"max",
				"maxlength",
				"media",
				"method",
				"min",
				"minlength",
				"multiple",
				"muted",
				"name",
				"nonce",
				"noshade",
				"novalidate",
				"nowrap",
				"open",
				"optimum",
				"pattern",
				"placeholder",
				"playsinline",
				"poster",
				"preload",
				"pubdate",
				"radiogroup",
				"readonly",
				"rel",
				"required",
				"rev",
				"reversed",
				"role",
				"rows",
				"rowspan",
				"spellcheck",
				"scope",
				"selected",
				"shape",
				"size",
				"sizes",
				"span",
				"srclang",
				"start",
				"src",
				"srcset",
				"step",
				"style",
				"summary",
				"tabindex",
				"title",
				"translate",
				"type",
				"usemap",
				"valign",
				"value",
				"width",
				"xmlns",
				"slot"
			]);
			var svg = freeze([
				"accent-height",
				"accumulate",
				"additive",
				"alignment-baseline",
				"ascent",
				"attributename",
				"attributetype",
				"azimuth",
				"basefrequency",
				"baseline-shift",
				"begin",
				"bias",
				"by",
				"class",
				"clip",
				"clippathunits",
				"clip-path",
				"clip-rule",
				"color",
				"color-interpolation",
				"color-interpolation-filters",
				"color-profile",
				"color-rendering",
				"cx",
				"cy",
				"d",
				"dx",
				"dy",
				"diffuseconstant",
				"direction",
				"display",
				"divisor",
				"dur",
				"edgemode",
				"elevation",
				"end",
				"fill",
				"fill-opacity",
				"fill-rule",
				"filter",
				"filterunits",
				"flood-color",
				"flood-opacity",
				"font-family",
				"font-size",
				"font-size-adjust",
				"font-stretch",
				"font-style",
				"font-variant",
				"font-weight",
				"fx",
				"fy",
				"g1",
				"g2",
				"glyph-name",
				"glyphref",
				"gradientunits",
				"gradienttransform",
				"height",
				"href",
				"id",
				"image-rendering",
				"in",
				"in2",
				"k",
				"k1",
				"k2",
				"k3",
				"k4",
				"kerning",
				"keypoints",
				"keysplines",
				"keytimes",
				"lang",
				"lengthadjust",
				"letter-spacing",
				"kernelmatrix",
				"kernelunitlength",
				"lighting-color",
				"local",
				"marker-end",
				"marker-mid",
				"marker-start",
				"markerheight",
				"markerunits",
				"markerwidth",
				"maskcontentunits",
				"maskunits",
				"max",
				"mask",
				"media",
				"method",
				"mode",
				"min",
				"name",
				"numoctaves",
				"offset",
				"operator",
				"opacity",
				"order",
				"orient",
				"orientation",
				"origin",
				"overflow",
				"paint-order",
				"path",
				"pathlength",
				"patterncontentunits",
				"patterntransform",
				"patternunits",
				"points",
				"preservealpha",
				"preserveaspectratio",
				"primitiveunits",
				"r",
				"rx",
				"ry",
				"radius",
				"refx",
				"refy",
				"repeatcount",
				"repeatdur",
				"restart",
				"result",
				"rotate",
				"scale",
				"seed",
				"shape-rendering",
				"specularconstant",
				"specularexponent",
				"spreadmethod",
				"startoffset",
				"stddeviation",
				"stitchtiles",
				"stop-color",
				"stop-opacity",
				"stroke-dasharray",
				"stroke-dashoffset",
				"stroke-linecap",
				"stroke-linejoin",
				"stroke-miterlimit",
				"stroke-opacity",
				"stroke",
				"stroke-width",
				"style",
				"surfacescale",
				"systemlanguage",
				"tabindex",
				"targetx",
				"targety",
				"transform",
				"transform-origin",
				"text-anchor",
				"text-decoration",
				"text-rendering",
				"textlength",
				"type",
				"u1",
				"u2",
				"unicode",
				"values",
				"viewbox",
				"visibility",
				"version",
				"vert-adv-y",
				"vert-origin-x",
				"vert-origin-y",
				"width",
				"word-spacing",
				"wrap",
				"writing-mode",
				"xchannelselector",
				"ychannelselector",
				"x",
				"x1",
				"x2",
				"xmlns",
				"y",
				"y1",
				"y2",
				"z",
				"zoomandpan"
			]);
			var mathMl = freeze([
				"accent",
				"accentunder",
				"align",
				"bevelled",
				"close",
				"columnsalign",
				"columnlines",
				"columnspan",
				"denomalign",
				"depth",
				"dir",
				"display",
				"displaystyle",
				"encoding",
				"fence",
				"frame",
				"height",
				"href",
				"id",
				"largeop",
				"length",
				"linethickness",
				"lspace",
				"lquote",
				"mathbackground",
				"mathcolor",
				"mathsize",
				"mathvariant",
				"maxsize",
				"minsize",
				"movablelimits",
				"notation",
				"numalign",
				"open",
				"rowalign",
				"rowlines",
				"rowspacing",
				"rowspan",
				"rspace",
				"rquote",
				"scriptlevel",
				"scriptminsize",
				"scriptsizemultiplier",
				"selection",
				"separator",
				"separators",
				"stretchy",
				"subscriptshift",
				"supscriptshift",
				"symmetric",
				"voffset",
				"width",
				"xmlns"
			]);
			var xml = freeze([
				"xlink:href",
				"xml:id",
				"xlink:title",
				"xml:space",
				"xmlns:xlink"
			]);
			var MUSTACHE_EXPR = seal(/\{\{[\w\W]*|[\w\W]*\}\}/gm);
			var ERB_EXPR = seal(/<%[\w\W]*|[\w\W]*%>/gm);
			var DATA_ATTR = seal(/^data-[\-\w.\u00B7-\uFFFF]/);
			var ARIA_ATTR = seal(/^aria-[\-\w]+$/);
			var IS_ALLOWED_URI = seal(/^(?:(?:(?:f|ht)tps?|mailto|tel|callto|cid|xmpp):|[^a-z]|[a-z+.\-]+(?:[^a-z+.\-:]|$))/i);
			var IS_SCRIPT_OR_DATA = seal(/^(?:\w+script|data):/i);
			var ATTR_WHITESPACE = seal(/[\u0000-\u0020\u00A0\u1680\u180E\u2000-\u2029\u205F\u3000]/g);
			var DOCTYPE_NAME = seal(/^html$/i);
			var getGlobal = function getGlobal$1() {
				return typeof window === "undefined" ? null : window;
			};
			var _createTrustedTypesPolicy = function _createTrustedTypesPolicy$1(trustedTypes, document$1) {
				if (_typeof(trustedTypes) !== "object" || typeof trustedTypes.createPolicy !== "function") return null;
				var suffix = null;
				var ATTR_NAME = "data-tt-policy-suffix";
				if (document$1.currentScript && document$1.currentScript.hasAttribute(ATTR_NAME)) suffix = document$1.currentScript.getAttribute(ATTR_NAME);
				var policyName = "dompurify" + (suffix ? "#" + suffix : "");
				try {
					return trustedTypes.createPolicy(policyName, { createHTML: function createHTML(html$2) {
						return html$2;
					} });
				} catch (_) {
					console.warn("TrustedTypes policy " + policyName + " could not be created.");
					return null;
				}
			};
			function createDOMPurify() {
				var window$1 = arguments.length > 0 && arguments[0] !== void 0 ? arguments[0] : getGlobal();
				var DOMPurify = function DOMPurify$1(root) {
					return createDOMPurify(root);
				};
				DOMPurify.version = "2.3.8";
				DOMPurify.removed = [];
				if (!window$1 || !window$1.document || window$1.document.nodeType !== 9) {
					DOMPurify.isSupported = false;
					return DOMPurify;
				}
				var originalDocument = window$1.document;
				var document$1 = window$1.document;
				var DocumentFragment = window$1.DocumentFragment, HTMLTemplateElement = window$1.HTMLTemplateElement, Node$1 = window$1.Node, Element$1 = window$1.Element, NodeFilter$1 = window$1.NodeFilter, _window$NamedNodeMap = window$1.NamedNodeMap, NamedNodeMap = _window$NamedNodeMap === void 0 ? window$1.NamedNodeMap || window$1.MozNamedAttrMap : _window$NamedNodeMap, HTMLFormElement = window$1.HTMLFormElement, DOMParser$1 = window$1.DOMParser, trustedTypes = window$1.trustedTypes;
				var ElementPrototype = Element$1.prototype;
				var cloneNode = lookupGetter(ElementPrototype, "cloneNode");
				var getNextSibling = lookupGetter(ElementPrototype, "nextSibling");
				var getChildNodes$1 = lookupGetter(ElementPrototype, "childNodes");
				var getParentNode = lookupGetter(ElementPrototype, "parentNode");
				if (typeof HTMLTemplateElement === "function") {
					var template = document$1.createElement("template");
					if (template.content && template.content.ownerDocument) document$1 = template.content.ownerDocument;
				}
				var trustedTypesPolicy = _createTrustedTypesPolicy(trustedTypes, originalDocument);
				var emptyHTML = trustedTypesPolicy ? trustedTypesPolicy.createHTML("") : "";
				var _document = document$1, implementation = _document.implementation, createNodeIterator = _document.createNodeIterator, createDocumentFragment = _document.createDocumentFragment, getElementsByTagName = _document.getElementsByTagName;
				var importNode$1 = originalDocument.importNode;
				var documentMode = {};
				try {
					documentMode = clone(document$1).documentMode ? document$1.documentMode : {};
				} catch (_) {}
				var hooks = {};
				DOMPurify.isSupported = typeof getParentNode === "function" && implementation && typeof implementation.createHTMLDocument !== "undefined" && documentMode !== 9;
				var MUSTACHE_EXPR$1 = MUSTACHE_EXPR, ERB_EXPR$1 = ERB_EXPR, DATA_ATTR$1 = DATA_ATTR, ARIA_ATTR$1 = ARIA_ATTR, IS_SCRIPT_OR_DATA$1 = IS_SCRIPT_OR_DATA, ATTR_WHITESPACE$1 = ATTR_WHITESPACE;
				var IS_ALLOWED_URI$1 = IS_ALLOWED_URI;
				var ALLOWED_TAGS = null;
				var DEFAULT_ALLOWED_TAGS = addToSet({}, [].concat(_toConsumableArray(html$1), _toConsumableArray(svg$1), _toConsumableArray(svgFilters), _toConsumableArray(mathMl$1), _toConsumableArray(text)));
				var ALLOWED_ATTR = null;
				var DEFAULT_ALLOWED_ATTR = addToSet({}, [].concat(_toConsumableArray(html), _toConsumableArray(svg), _toConsumableArray(mathMl), _toConsumableArray(xml)));
				var CUSTOM_ELEMENT_HANDLING = Object.seal(Object.create(null, {
					tagNameCheck: {
						writable: true,
						configurable: false,
						enumerable: true,
						value: null
					},
					attributeNameCheck: {
						writable: true,
						configurable: false,
						enumerable: true,
						value: null
					},
					allowCustomizedBuiltInElements: {
						writable: true,
						configurable: false,
						enumerable: true,
						value: false
					}
				}));
				var FORBID_TAGS = null;
				var FORBID_ATTR = null;
				var ALLOW_ARIA_ATTR = true;
				var ALLOW_DATA_ATTR = true;
				var ALLOW_UNKNOWN_PROTOCOLS = false;
				var SAFE_FOR_TEMPLATES = false;
				var WHOLE_DOCUMENT = false;
				var SET_CONFIG = false;
				var FORCE_BODY = false;
				var RETURN_DOM = false;
				var RETURN_DOM_FRAGMENT = false;
				var RETURN_TRUSTED_TYPE = false;
				var SANITIZE_DOM = true;
				var KEEP_CONTENT = true;
				var IN_PLACE = false;
				var USE_PROFILES = {};
				var FORBID_CONTENTS = null;
				var DEFAULT_FORBID_CONTENTS = addToSet({}, [
					"annotation-xml",
					"audio",
					"colgroup",
					"desc",
					"foreignobject",
					"head",
					"iframe",
					"math",
					"mi",
					"mn",
					"mo",
					"ms",
					"mtext",
					"noembed",
					"noframes",
					"noscript",
					"plaintext",
					"script",
					"style",
					"svg",
					"template",
					"thead",
					"title",
					"video",
					"xmp"
				]);
				var DATA_URI_TAGS = null;
				var DEFAULT_DATA_URI_TAGS = addToSet({}, [
					"audio",
					"video",
					"img",
					"source",
					"image",
					"track"
				]);
				var URI_SAFE_ATTRIBUTES = null;
				var DEFAULT_URI_SAFE_ATTRIBUTES = addToSet({}, [
					"alt",
					"class",
					"for",
					"id",
					"label",
					"name",
					"pattern",
					"placeholder",
					"role",
					"summary",
					"title",
					"value",
					"style",
					"xmlns"
				]);
				var MATHML_NAMESPACE = "http://www.w3.org/1998/Math/MathML";
				var SVG_NAMESPACE = "http://www.w3.org/2000/svg";
				var HTML_NAMESPACE = "http://www.w3.org/1999/xhtml";
				var NAMESPACE = HTML_NAMESPACE;
				var IS_EMPTY_INPUT = false;
				var PARSER_MEDIA_TYPE;
				var SUPPORTED_PARSER_MEDIA_TYPES = ["application/xhtml+xml", "text/html"];
				var DEFAULT_PARSER_MEDIA_TYPE = "text/html";
				var transformCaseFunc;
				var CONFIG = null;
				var formElement = document$1.createElement("form");
				var isRegexOrFunction = function isRegexOrFunction$1(testValue) {
					return testValue instanceof RegExp || testValue instanceof Function;
				};
				var _parseConfig = function _parseConfig$1(cfg) {
					if (CONFIG && CONFIG === cfg) return;
					if (!cfg || _typeof(cfg) !== "object") cfg = {};
					cfg = clone(cfg);
					ALLOWED_TAGS = "ALLOWED_TAGS" in cfg ? addToSet({}, cfg.ALLOWED_TAGS) : DEFAULT_ALLOWED_TAGS;
					ALLOWED_ATTR = "ALLOWED_ATTR" in cfg ? addToSet({}, cfg.ALLOWED_ATTR) : DEFAULT_ALLOWED_ATTR;
					URI_SAFE_ATTRIBUTES = "ADD_URI_SAFE_ATTR" in cfg ? addToSet(clone(DEFAULT_URI_SAFE_ATTRIBUTES), cfg.ADD_URI_SAFE_ATTR) : DEFAULT_URI_SAFE_ATTRIBUTES;
					DATA_URI_TAGS = "ADD_DATA_URI_TAGS" in cfg ? addToSet(clone(DEFAULT_DATA_URI_TAGS), cfg.ADD_DATA_URI_TAGS) : DEFAULT_DATA_URI_TAGS;
					FORBID_CONTENTS = "FORBID_CONTENTS" in cfg ? addToSet({}, cfg.FORBID_CONTENTS) : DEFAULT_FORBID_CONTENTS;
					FORBID_TAGS = "FORBID_TAGS" in cfg ? addToSet({}, cfg.FORBID_TAGS) : {};
					FORBID_ATTR = "FORBID_ATTR" in cfg ? addToSet({}, cfg.FORBID_ATTR) : {};
					USE_PROFILES = "USE_PROFILES" in cfg ? cfg.USE_PROFILES : false;
					ALLOW_ARIA_ATTR = cfg.ALLOW_ARIA_ATTR !== false;
					ALLOW_DATA_ATTR = cfg.ALLOW_DATA_ATTR !== false;
					ALLOW_UNKNOWN_PROTOCOLS = cfg.ALLOW_UNKNOWN_PROTOCOLS || false;
					SAFE_FOR_TEMPLATES = cfg.SAFE_FOR_TEMPLATES || false;
					WHOLE_DOCUMENT = cfg.WHOLE_DOCUMENT || false;
					RETURN_DOM = cfg.RETURN_DOM || false;
					RETURN_DOM_FRAGMENT = cfg.RETURN_DOM_FRAGMENT || false;
					RETURN_TRUSTED_TYPE = cfg.RETURN_TRUSTED_TYPE || false;
					FORCE_BODY = cfg.FORCE_BODY || false;
					SANITIZE_DOM = cfg.SANITIZE_DOM !== false;
					KEEP_CONTENT = cfg.KEEP_CONTENT !== false;
					IN_PLACE = cfg.IN_PLACE || false;
					IS_ALLOWED_URI$1 = cfg.ALLOWED_URI_REGEXP || IS_ALLOWED_URI$1;
					NAMESPACE = cfg.NAMESPACE || HTML_NAMESPACE;
					if (cfg.CUSTOM_ELEMENT_HANDLING && isRegexOrFunction(cfg.CUSTOM_ELEMENT_HANDLING.tagNameCheck)) CUSTOM_ELEMENT_HANDLING.tagNameCheck = cfg.CUSTOM_ELEMENT_HANDLING.tagNameCheck;
					if (cfg.CUSTOM_ELEMENT_HANDLING && isRegexOrFunction(cfg.CUSTOM_ELEMENT_HANDLING.attributeNameCheck)) CUSTOM_ELEMENT_HANDLING.attributeNameCheck = cfg.CUSTOM_ELEMENT_HANDLING.attributeNameCheck;
					if (cfg.CUSTOM_ELEMENT_HANDLING && typeof cfg.CUSTOM_ELEMENT_HANDLING.allowCustomizedBuiltInElements === "boolean") CUSTOM_ELEMENT_HANDLING.allowCustomizedBuiltInElements = cfg.CUSTOM_ELEMENT_HANDLING.allowCustomizedBuiltInElements;
					PARSER_MEDIA_TYPE = SUPPORTED_PARSER_MEDIA_TYPES.indexOf(cfg.PARSER_MEDIA_TYPE) === -1 ? PARSER_MEDIA_TYPE = DEFAULT_PARSER_MEDIA_TYPE : PARSER_MEDIA_TYPE = cfg.PARSER_MEDIA_TYPE;
					transformCaseFunc = PARSER_MEDIA_TYPE === "application/xhtml+xml" ? function(x) {
						return x;
					} : stringToLowerCase;
					if (SAFE_FOR_TEMPLATES) ALLOW_DATA_ATTR = false;
					if (RETURN_DOM_FRAGMENT) RETURN_DOM = true;
					if (USE_PROFILES) {
						ALLOWED_TAGS = addToSet({}, _toConsumableArray(text));
						ALLOWED_ATTR = [];
						if (USE_PROFILES.html === true) {
							addToSet(ALLOWED_TAGS, html$1);
							addToSet(ALLOWED_ATTR, html);
						}
						if (USE_PROFILES.svg === true) {
							addToSet(ALLOWED_TAGS, svg$1);
							addToSet(ALLOWED_ATTR, svg);
							addToSet(ALLOWED_ATTR, xml);
						}
						if (USE_PROFILES.svgFilters === true) {
							addToSet(ALLOWED_TAGS, svgFilters);
							addToSet(ALLOWED_ATTR, svg);
							addToSet(ALLOWED_ATTR, xml);
						}
						if (USE_PROFILES.mathMl === true) {
							addToSet(ALLOWED_TAGS, mathMl$1);
							addToSet(ALLOWED_ATTR, mathMl);
							addToSet(ALLOWED_ATTR, xml);
						}
					}
					if (cfg.ADD_TAGS) {
						if (ALLOWED_TAGS === DEFAULT_ALLOWED_TAGS) ALLOWED_TAGS = clone(ALLOWED_TAGS);
						addToSet(ALLOWED_TAGS, cfg.ADD_TAGS);
					}
					if (cfg.ADD_ATTR) {
						if (ALLOWED_ATTR === DEFAULT_ALLOWED_ATTR) ALLOWED_ATTR = clone(ALLOWED_ATTR);
						addToSet(ALLOWED_ATTR, cfg.ADD_ATTR);
					}
					if (cfg.ADD_URI_SAFE_ATTR) addToSet(URI_SAFE_ATTRIBUTES, cfg.ADD_URI_SAFE_ATTR);
					if (cfg.FORBID_CONTENTS) {
						if (FORBID_CONTENTS === DEFAULT_FORBID_CONTENTS) FORBID_CONTENTS = clone(FORBID_CONTENTS);
						addToSet(FORBID_CONTENTS, cfg.FORBID_CONTENTS);
					}
					if (KEEP_CONTENT) ALLOWED_TAGS["#text"] = true;
					if (WHOLE_DOCUMENT) addToSet(ALLOWED_TAGS, [
						"html",
						"head",
						"body"
					]);
					if (ALLOWED_TAGS.table) {
						addToSet(ALLOWED_TAGS, ["tbody"]);
						delete FORBID_TAGS.tbody;
					}
					if (freeze) freeze(cfg);
					CONFIG = cfg;
				};
				var MATHML_TEXT_INTEGRATION_POINTS = addToSet({}, [
					"mi",
					"mo",
					"mn",
					"ms",
					"mtext"
				]);
				var HTML_INTEGRATION_POINTS = addToSet({}, [
					"foreignobject",
					"desc",
					"title",
					"annotation-xml"
				]);
				var COMMON_SVG_AND_HTML_ELEMENTS = addToSet({}, [
					"title",
					"style",
					"font",
					"a",
					"script"
				]);
				var ALL_SVG_TAGS = addToSet({}, svg$1);
				addToSet(ALL_SVG_TAGS, svgFilters);
				addToSet(ALL_SVG_TAGS, svgDisallowed);
				var ALL_MATHML_TAGS = addToSet({}, mathMl$1);
				addToSet(ALL_MATHML_TAGS, mathMlDisallowed);
				var _checkValidNamespace = function _checkValidNamespace$1(element) {
					var parent$1 = getParentNode(element);
					if (!parent$1 || !parent$1.tagName) parent$1 = {
						namespaceURI: HTML_NAMESPACE,
						tagName: "template"
					};
					var tagName = stringToLowerCase(element.tagName);
					var parentTagName = stringToLowerCase(parent$1.tagName);
					if (element.namespaceURI === SVG_NAMESPACE) {
						if (parent$1.namespaceURI === HTML_NAMESPACE) return tagName === "svg";
						if (parent$1.namespaceURI === MATHML_NAMESPACE) return tagName === "svg" && (parentTagName === "annotation-xml" || MATHML_TEXT_INTEGRATION_POINTS[parentTagName]);
						return Boolean(ALL_SVG_TAGS[tagName]);
					}
					if (element.namespaceURI === MATHML_NAMESPACE) {
						if (parent$1.namespaceURI === HTML_NAMESPACE) return tagName === "math";
						if (parent$1.namespaceURI === SVG_NAMESPACE) return tagName === "math" && HTML_INTEGRATION_POINTS[parentTagName];
						return Boolean(ALL_MATHML_TAGS[tagName]);
					}
					if (element.namespaceURI === HTML_NAMESPACE) {
						if (parent$1.namespaceURI === SVG_NAMESPACE && !HTML_INTEGRATION_POINTS[parentTagName]) return false;
						if (parent$1.namespaceURI === MATHML_NAMESPACE && !MATHML_TEXT_INTEGRATION_POINTS[parentTagName]) return false;
						return !ALL_MATHML_TAGS[tagName] && (COMMON_SVG_AND_HTML_ELEMENTS[tagName] || !ALL_SVG_TAGS[tagName]);
					}
					return false;
				};
				var _forceRemove = function _forceRemove$1(node) {
					arrayPush(DOMPurify.removed, { element: node });
					try {
						node.parentNode.removeChild(node);
					} catch (_) {
						try {
							node.outerHTML = emptyHTML;
						} catch (_$1) {
							node.remove();
						}
					}
				};
				var _removeAttribute = function _removeAttribute$1(name$1, node) {
					try {
						arrayPush(DOMPurify.removed, {
							attribute: node.getAttributeNode(name$1),
							from: node
						});
					} catch (_) {
						arrayPush(DOMPurify.removed, {
							attribute: null,
							from: node
						});
					}
					node.removeAttribute(name$1);
					if (name$1 === "is" && !ALLOWED_ATTR[name$1]) if (RETURN_DOM || RETURN_DOM_FRAGMENT) try {
						_forceRemove(node);
					} catch (_) {}
					else try {
						node.setAttribute(name$1, "");
					} catch (_) {}
				};
				var _initDocument = function _initDocument$1(dirty) {
					var doc;
					var leadingWhitespace;
					if (FORCE_BODY) dirty = "<remove></remove>" + dirty;
					else {
						var matches = stringMatch(dirty, /^[\r\n\t ]+/);
						leadingWhitespace = matches && matches[0];
					}
					if (PARSER_MEDIA_TYPE === "application/xhtml+xml") dirty = "<html xmlns=\"http://www.w3.org/1999/xhtml\"><head></head><body>" + dirty + "</body></html>";
					var dirtyPayload = trustedTypesPolicy ? trustedTypesPolicy.createHTML(dirty) : dirty;
					if (NAMESPACE === HTML_NAMESPACE) try {
						doc = new DOMParser$1().parseFromString(dirtyPayload, PARSER_MEDIA_TYPE);
					} catch (_) {}
					if (!doc || !doc.documentElement) {
						doc = implementation.createDocument(NAMESPACE, "template", null);
						try {
							doc.documentElement.innerHTML = IS_EMPTY_INPUT ? "" : dirtyPayload;
						} catch (_) {}
					}
					var body = doc.body || doc.documentElement;
					if (dirty && leadingWhitespace) body.insertBefore(document$1.createTextNode(leadingWhitespace), body.childNodes[0] || null);
					if (NAMESPACE === HTML_NAMESPACE) return getElementsByTagName.call(doc, WHOLE_DOCUMENT ? "html" : "body")[0];
					return WHOLE_DOCUMENT ? doc.documentElement : body;
				};
				var _createIterator = function _createIterator$1(root) {
					return createNodeIterator.call(root.ownerDocument || root, root, NodeFilter$1.SHOW_ELEMENT | NodeFilter$1.SHOW_COMMENT | NodeFilter$1.SHOW_TEXT, null, false);
				};
				var _isClobbered = function _isClobbered$1(elm) {
					return elm instanceof HTMLFormElement && (typeof elm.nodeName !== "string" || typeof elm.textContent !== "string" || typeof elm.removeChild !== "function" || !(elm.attributes instanceof NamedNodeMap) || typeof elm.removeAttribute !== "function" || typeof elm.setAttribute !== "function" || typeof elm.namespaceURI !== "string" || typeof elm.insertBefore !== "function");
				};
				var _isNode = function _isNode$1(object) {
					return _typeof(Node$1) === "object" ? object instanceof Node$1 : object && _typeof(object) === "object" && typeof object.nodeType === "number" && typeof object.nodeName === "string";
				};
				var _executeHook = function _executeHook$1(entryPoint, currentNode, data$1) {
					if (!hooks[entryPoint]) return;
					arrayForEach(hooks[entryPoint], function(hook) {
						hook.call(DOMPurify, currentNode, data$1, CONFIG);
					});
				};
				var _sanitizeElements = function _sanitizeElements$1(currentNode) {
					var content;
					_executeHook("beforeSanitizeElements", currentNode, null);
					if (_isClobbered(currentNode)) {
						_forceRemove(currentNode);
						return true;
					}
					if (regExpTest(/[\u0080-\uFFFF]/, currentNode.nodeName)) {
						_forceRemove(currentNode);
						return true;
					}
					var tagName = transformCaseFunc(currentNode.nodeName);
					_executeHook("uponSanitizeElement", currentNode, {
						tagName,
						allowedTags: ALLOWED_TAGS
					});
					if (currentNode.hasChildNodes() && !_isNode(currentNode.firstElementChild) && (!_isNode(currentNode.content) || !_isNode(currentNode.content.firstElementChild)) && regExpTest(/<[/\w]/g, currentNode.innerHTML) && regExpTest(/<[/\w]/g, currentNode.textContent)) {
						_forceRemove(currentNode);
						return true;
					}
					if (tagName === "select" && regExpTest(/<template/i, currentNode.innerHTML)) {
						_forceRemove(currentNode);
						return true;
					}
					if (!ALLOWED_TAGS[tagName] || FORBID_TAGS[tagName]) {
						if (!FORBID_TAGS[tagName] && _basicCustomElementTest(tagName)) {
							if (CUSTOM_ELEMENT_HANDLING.tagNameCheck instanceof RegExp && regExpTest(CUSTOM_ELEMENT_HANDLING.tagNameCheck, tagName)) return false;
							if (CUSTOM_ELEMENT_HANDLING.tagNameCheck instanceof Function && CUSTOM_ELEMENT_HANDLING.tagNameCheck(tagName)) return false;
						}
						if (KEEP_CONTENT && !FORBID_CONTENTS[tagName]) {
							var parentNode = getParentNode(currentNode) || currentNode.parentNode;
							var childNodes = getChildNodes$1(currentNode) || currentNode.childNodes;
							if (childNodes && parentNode) for (var i = childNodes.length - 1; i >= 0; --i) parentNode.insertBefore(cloneNode(childNodes[i], true), getNextSibling(currentNode));
						}
						_forceRemove(currentNode);
						return true;
					}
					if (currentNode instanceof Element$1 && !_checkValidNamespace(currentNode)) {
						_forceRemove(currentNode);
						return true;
					}
					if ((tagName === "noscript" || tagName === "noembed") && regExpTest(/<\/no(script|embed)/i, currentNode.innerHTML)) {
						_forceRemove(currentNode);
						return true;
					}
					if (SAFE_FOR_TEMPLATES && currentNode.nodeType === 3) {
						content = currentNode.textContent;
						content = stringReplace(content, MUSTACHE_EXPR$1, " ");
						content = stringReplace(content, ERB_EXPR$1, " ");
						if (currentNode.textContent !== content) {
							arrayPush(DOMPurify.removed, { element: currentNode.cloneNode() });
							currentNode.textContent = content;
						}
					}
					_executeHook("afterSanitizeElements", currentNode, null);
					return false;
				};
				var _isValidAttribute = function _isValidAttribute$1(lcTag, lcName, value$3) {
					if (SANITIZE_DOM && (lcName === "id" || lcName === "name") && (value$3 in document$1 || value$3 in formElement)) return false;
					if (ALLOW_DATA_ATTR && !FORBID_ATTR[lcName] && regExpTest(DATA_ATTR$1, lcName));
					else if (ALLOW_ARIA_ATTR && regExpTest(ARIA_ATTR$1, lcName));
					else if (!ALLOWED_ATTR[lcName] || FORBID_ATTR[lcName]) if (_basicCustomElementTest(lcTag) && (CUSTOM_ELEMENT_HANDLING.tagNameCheck instanceof RegExp && regExpTest(CUSTOM_ELEMENT_HANDLING.tagNameCheck, lcTag) || CUSTOM_ELEMENT_HANDLING.tagNameCheck instanceof Function && CUSTOM_ELEMENT_HANDLING.tagNameCheck(lcTag)) && (CUSTOM_ELEMENT_HANDLING.attributeNameCheck instanceof RegExp && regExpTest(CUSTOM_ELEMENT_HANDLING.attributeNameCheck, lcName) || CUSTOM_ELEMENT_HANDLING.attributeNameCheck instanceof Function && CUSTOM_ELEMENT_HANDLING.attributeNameCheck(lcName)) || lcName === "is" && CUSTOM_ELEMENT_HANDLING.allowCustomizedBuiltInElements && (CUSTOM_ELEMENT_HANDLING.tagNameCheck instanceof RegExp && regExpTest(CUSTOM_ELEMENT_HANDLING.tagNameCheck, value$3) || CUSTOM_ELEMENT_HANDLING.tagNameCheck instanceof Function && CUSTOM_ELEMENT_HANDLING.tagNameCheck(value$3)));
					else return false;
					else if (URI_SAFE_ATTRIBUTES[lcName]);
					else if (regExpTest(IS_ALLOWED_URI$1, stringReplace(value$3, ATTR_WHITESPACE$1, "")));
					else if ((lcName === "src" || lcName === "xlink:href" || lcName === "href") && lcTag !== "script" && stringIndexOf(value$3, "data:") === 0 && DATA_URI_TAGS[lcTag]);
					else if (ALLOW_UNKNOWN_PROTOCOLS && !regExpTest(IS_SCRIPT_OR_DATA$1, stringReplace(value$3, ATTR_WHITESPACE$1, "")));
					else if (!value$3);
					else return false;
					return true;
				};
				var _basicCustomElementTest = function _basicCustomElementTest$1(tagName) {
					return tagName.indexOf("-") > 0;
				};
				var _sanitizeAttributes = function _sanitizeAttributes$1(currentNode) {
					var attr;
					var value$3;
					var lcName;
					var l;
					_executeHook("beforeSanitizeAttributes", currentNode, null);
					var attributes = currentNode.attributes;
					if (!attributes) return;
					var hookEvent = {
						attrName: "",
						attrValue: "",
						keepAttr: true,
						allowedAttributes: ALLOWED_ATTR
					};
					l = attributes.length;
					while (l--) {
						attr = attributes[l];
						var _attr = attr, name$1 = _attr.name, namespaceURI = _attr.namespaceURI;
						value$3 = name$1 === "value" ? attr.value : stringTrim(attr.value);
						lcName = transformCaseFunc(name$1);
						var initValue = value$3;
						hookEvent.attrName = lcName;
						hookEvent.attrValue = value$3;
						hookEvent.keepAttr = true;
						hookEvent.forceKeepAttr = void 0;
						_executeHook("uponSanitizeAttribute", currentNode, hookEvent);
						value$3 = hookEvent.attrValue;
						if (hookEvent.forceKeepAttr) continue;
						if (!hookEvent.keepAttr) {
							_removeAttribute(name$1, currentNode);
							continue;
						}
						if (regExpTest(/\/>/i, value$3)) {
							_removeAttribute(name$1, currentNode);
							continue;
						}
						if (SAFE_FOR_TEMPLATES) {
							value$3 = stringReplace(value$3, MUSTACHE_EXPR$1, " ");
							value$3 = stringReplace(value$3, ERB_EXPR$1, " ");
						}
						if (!_isValidAttribute(transformCaseFunc(currentNode.nodeName), lcName, value$3)) {
							_removeAttribute(name$1, currentNode);
							continue;
						}
						if (value$3 !== initValue) try {
							if (namespaceURI) currentNode.setAttributeNS(namespaceURI, name$1, value$3);
							else currentNode.setAttribute(name$1, value$3);
						} catch (_) {
							_removeAttribute(name$1, currentNode);
						}
					}
					_executeHook("afterSanitizeAttributes", currentNode, null);
				};
				var _sanitizeShadowDOM = function _sanitizeShadowDOM$1(fragment) {
					var shadowNode;
					var shadowIterator = _createIterator(fragment);
					_executeHook("beforeSanitizeShadowDOM", fragment, null);
					while (shadowNode = shadowIterator.nextNode()) {
						_executeHook("uponSanitizeShadowNode", shadowNode, null);
						if (_sanitizeElements(shadowNode)) continue;
						if (shadowNode.content instanceof DocumentFragment) _sanitizeShadowDOM$1(shadowNode.content);
						_sanitizeAttributes(shadowNode);
					}
					_executeHook("afterSanitizeShadowDOM", fragment, null);
				};
				DOMPurify.sanitize = function(dirty, cfg) {
					var body;
					var importedNode;
					var currentNode;
					var oldNode;
					var returnNode;
					IS_EMPTY_INPUT = !dirty;
					if (IS_EMPTY_INPUT) dirty = "<!-->";
					if (typeof dirty !== "string" && !_isNode(dirty)) if (typeof dirty.toString !== "function") throw typeErrorCreate("toString is not a function");
					else {
						dirty = dirty.toString();
						if (typeof dirty !== "string") throw typeErrorCreate("dirty is not a string, aborting");
					}
					if (!DOMPurify.isSupported) {
						if (_typeof(window$1.toStaticHTML) === "object" || typeof window$1.toStaticHTML === "function") {
							if (typeof dirty === "string") return window$1.toStaticHTML(dirty);
							if (_isNode(dirty)) return window$1.toStaticHTML(dirty.outerHTML);
						}
						return dirty;
					}
					if (!SET_CONFIG) _parseConfig(cfg);
					DOMPurify.removed = [];
					if (typeof dirty === "string") IN_PLACE = false;
					if (IN_PLACE) {
						if (dirty.nodeName) {
							var tagName = transformCaseFunc(dirty.nodeName);
							if (!ALLOWED_TAGS[tagName] || FORBID_TAGS[tagName]) throw typeErrorCreate("root node is forbidden and cannot be sanitized in-place");
						}
					} else if (dirty instanceof Node$1) {
						body = _initDocument("<!---->");
						importedNode = body.ownerDocument.importNode(dirty, true);
						if (importedNode.nodeType === 1 && importedNode.nodeName === "BODY") body = importedNode;
						else if (importedNode.nodeName === "HTML") body = importedNode;
						else body.appendChild(importedNode);
					} else {
						if (!RETURN_DOM && !SAFE_FOR_TEMPLATES && !WHOLE_DOCUMENT && dirty.indexOf("<") === -1) return trustedTypesPolicy && RETURN_TRUSTED_TYPE ? trustedTypesPolicy.createHTML(dirty) : dirty;
						body = _initDocument(dirty);
						if (!body) return RETURN_DOM ? null : RETURN_TRUSTED_TYPE ? emptyHTML : "";
					}
					if (body && FORCE_BODY) _forceRemove(body.firstChild);
					var nodeIterator = _createIterator(IN_PLACE ? dirty : body);
					while (currentNode = nodeIterator.nextNode()) {
						if (currentNode.nodeType === 3 && currentNode === oldNode) continue;
						if (_sanitizeElements(currentNode)) continue;
						if (currentNode.content instanceof DocumentFragment) _sanitizeShadowDOM(currentNode.content);
						_sanitizeAttributes(currentNode);
						oldNode = currentNode;
					}
					oldNode = null;
					if (IN_PLACE) return dirty;
					if (RETURN_DOM) {
						if (RETURN_DOM_FRAGMENT) {
							returnNode = createDocumentFragment.call(body.ownerDocument);
							while (body.firstChild) returnNode.appendChild(body.firstChild);
						} else returnNode = body;
						if (ALLOWED_ATTR.shadowroot) returnNode = importNode$1.call(originalDocument, returnNode, true);
						return returnNode;
					}
					var serializedHTML = WHOLE_DOCUMENT ? body.outerHTML : body.innerHTML;
					if (WHOLE_DOCUMENT && ALLOWED_TAGS["!doctype"] && body.ownerDocument && body.ownerDocument.doctype && body.ownerDocument.doctype.name && regExpTest(DOCTYPE_NAME, body.ownerDocument.doctype.name)) serializedHTML = "<!DOCTYPE " + body.ownerDocument.doctype.name + ">\n" + serializedHTML;
					if (SAFE_FOR_TEMPLATES) {
						serializedHTML = stringReplace(serializedHTML, MUSTACHE_EXPR$1, " ");
						serializedHTML = stringReplace(serializedHTML, ERB_EXPR$1, " ");
					}
					return trustedTypesPolicy && RETURN_TRUSTED_TYPE ? trustedTypesPolicy.createHTML(serializedHTML) : serializedHTML;
				};
				DOMPurify.setConfig = function(cfg) {
					_parseConfig(cfg);
					SET_CONFIG = true;
				};
				DOMPurify.clearConfig = function() {
					CONFIG = null;
					SET_CONFIG = false;
				};
				DOMPurify.isValidAttribute = function(tag, attr, value$3) {
					if (!CONFIG) _parseConfig({});
					return _isValidAttribute(transformCaseFunc(tag), transformCaseFunc(attr), value$3);
				};
				DOMPurify.addHook = function(entryPoint, hookFunction) {
					if (typeof hookFunction !== "function") return;
					hooks[entryPoint] = hooks[entryPoint] || [];
					arrayPush(hooks[entryPoint], hookFunction);
				};
				DOMPurify.removeHook = function(entryPoint) {
					if (hooks[entryPoint]) return arrayPop(hooks[entryPoint]);
				};
				DOMPurify.removeHooks = function(entryPoint) {
					if (hooks[entryPoint]) hooks[entryPoint] = [];
				};
				DOMPurify.removeAllHooks = function() {
					hooks = {};
				};
				return DOMPurify;
			}
			var purify = createDOMPurify();
			const each$4 = Tools.each, trim = Tools.trim;
			const queryParts = [
				"source",
				"protocol",
				"authority",
				"userInfo",
				"user",
				"password",
				"host",
				"port",
				"relative",
				"path",
				"directory",
				"file",
				"query",
				"anchor"
			];
			const DEFAULT_PORTS = {
				ftp: 21,
				http: 80,
				https: 443,
				mailto: 25
			};
			const safeSvgDataUrlElements = ["img", "video"];
			const blockSvgDataUris = (allowSvgDataUrls, tagName) => {
				if (isNonNullable(allowSvgDataUrls)) return !allowSvgDataUrls;
				else return isNonNullable(tagName) ? !contains$2(safeSvgDataUrlElements, tagName) : true;
			};
			const decodeUri = (encodedUri) => {
				try {
					return decodeURIComponent(encodedUri);
				} catch (ex) {
					return unescape(encodedUri);
				}
			};
			const isInvalidUri = (settings, uri, tagName) => {
				const decodedUri = decodeUri(uri).replace(/\s/g, "");
				if (settings.allow_script_urls) return false;
				else if (/((java|vb)script|mhtml):/i.test(decodedUri)) return true;
				else if (settings.allow_html_data_urls) return false;
				else if (/^data:image\//i.test(decodedUri)) return blockSvgDataUris(settings.allow_svg_data_urls, tagName) && /^data:image\/svg\+xml/i.test(decodedUri);
				else return /^data:/i.test(decodedUri);
			};
			class URI {
				static parseDataUri(uri) {
					let type$2;
					const uriComponents = decodeURIComponent(uri).split(",");
					const matches = /data:([^;]+)/.exec(uriComponents[0]);
					if (matches) type$2 = matches[1];
					return {
						type: type$2,
						data: uriComponents[1]
					};
				}
				static isDomSafe(uri, context$1, options = {}) {
					if (options.allow_script_urls) return true;
					else return !isInvalidUri(options, Entities.decode(uri).replace(/[\s\u0000-\u001F]+/g, ""), context$1);
				}
				static getDocumentBaseUrl(loc) {
					var _a;
					let baseUrl;
					if (loc.protocol.indexOf("http") !== 0 && loc.protocol !== "file:") baseUrl = (_a = loc.href) !== null && _a !== void 0 ? _a : "";
					else baseUrl = loc.protocol + "//" + loc.host + loc.pathname;
					if (/^[^:]+:\/\/\/?[^\/]+\//.test(baseUrl)) {
						baseUrl = baseUrl.replace(/[\?#].*$/, "").replace(/[\/\\][^\/]+$/, "");
						if (!/[\/\\]$/.test(baseUrl)) baseUrl += "/";
					}
					return baseUrl;
				}
				constructor(url, settings = {}) {
					this.path = "";
					this.directory = "";
					url = trim(url);
					this.settings = settings;
					const baseUri = settings.base_uri;
					const self = this;
					if (/^([\w\-]+):([^\/]{2})/i.test(url) || /^\s*#/.test(url)) {
						self.source = url;
						return;
					}
					const isProtocolRelative = url.indexOf("//") === 0;
					if (url.indexOf("/") === 0 && !isProtocolRelative) url = (baseUri ? baseUri.protocol || "http" : "http") + "://mce_host" + url;
					if (!/^[\w\-]*:?\/\//.test(url)) {
						const baseUrl = baseUri ? baseUri.path : new URI(document.location.href).directory;
						if ((baseUri === null || baseUri === void 0 ? void 0 : baseUri.protocol) === "") url = "//mce_host" + self.toAbsPath(baseUrl, url);
						else {
							const match$3 = /([^#?]*)([#?]?.*)/.exec(url);
							if (match$3) url = (baseUri && baseUri.protocol || "http") + "://mce_host" + self.toAbsPath(baseUrl, match$3[1]) + match$3[2];
						}
					}
					url = url.replace(/@@/g, "(mce_at)");
					const urlMatch = /^(?:(?![^:@]+:[^:@\/]*@)([^:\/?#.]+):)?(?:\/\/)?((?:(([^:@\/]*):?([^:@\/]*))?@)?(\[[a-zA-Z0-9:.%]+\]|[^:\/?#]*)(?::(\d*))?)(((\/(?:[^?#](?![^?#\/]*\.[^?#\/.]+(?:[?#]|$)))*\/?)?([^?#\/]*))(?:\?([^#]*))?(?:#(.*))?)/.exec(url);
					if (urlMatch) each$4(queryParts, (v, i) => {
						let part = urlMatch[i];
						if (part) part = part.replace(/\(mce_at\)/g, "@@");
						self[v] = part;
					});
					if (baseUri) {
						if (!self.protocol) self.protocol = baseUri.protocol;
						if (!self.userInfo) self.userInfo = baseUri.userInfo;
						if (!self.port && self.host === "mce_host") self.port = baseUri.port;
						if (!self.host || self.host === "mce_host") self.host = baseUri.host;
						self.source = "";
					}
					if (isProtocolRelative) self.protocol = "";
				}
				setPath(path$1) {
					const pathMatch = /^(.*?)\/?(\w+)?$/.exec(path$1);
					if (pathMatch) {
						this.path = pathMatch[0];
						this.directory = pathMatch[1];
						this.file = pathMatch[2];
					}
					this.source = "";
					this.getURI();
				}
				toRelative(uri) {
					if (uri === "./") return uri;
					const relativeUri = new URI(uri, { base_uri: this });
					if (relativeUri.host !== "mce_host" && this.host !== relativeUri.host && relativeUri.host || this.port !== relativeUri.port || this.protocol !== relativeUri.protocol && relativeUri.protocol !== "") return relativeUri.getURI();
					const tu = this.getURI(), uu = relativeUri.getURI();
					if (tu === uu || tu.charAt(tu.length - 1) === "/" && tu.substr(0, tu.length - 1) === uu) return tu;
					let output = this.toRelPath(this.path, relativeUri.path);
					if (relativeUri.query) output += "?" + relativeUri.query;
					if (relativeUri.anchor) output += "#" + relativeUri.anchor;
					return output;
				}
				toAbsolute(uri, noHost) {
					const absoluteUri = new URI(uri, { base_uri: this });
					return absoluteUri.getURI(noHost && this.isSameOrigin(absoluteUri));
				}
				isSameOrigin(uri) {
					if (this.host == uri.host && this.protocol == uri.protocol) {
						if (this.port == uri.port) return true;
						const defaultPort = this.protocol ? DEFAULT_PORTS[this.protocol] : null;
						if (defaultPort && (this.port || defaultPort) == (uri.port || defaultPort)) return true;
					}
					return false;
				}
				toRelPath(base, path$1) {
					let breakPoint = 0, out = "", i, l;
					const normalizedBase = base.substring(0, base.lastIndexOf("/")).split("/");
					const items = path$1.split("/");
					if (normalizedBase.length >= items.length) {
						for (i = 0, l = normalizedBase.length; i < l; i++) if (i >= items.length || normalizedBase[i] !== items[i]) {
							breakPoint = i + 1;
							break;
						}
					}
					if (normalizedBase.length < items.length) {
						for (i = 0, l = items.length; i < l; i++) if (i >= normalizedBase.length || normalizedBase[i] !== items[i]) {
							breakPoint = i + 1;
							break;
						}
					}
					if (breakPoint === 1) return path$1;
					for (i = 0, l = normalizedBase.length - (breakPoint - 1); i < l; i++) out += "../";
					for (i = breakPoint - 1, l = items.length; i < l; i++) if (i !== breakPoint - 1) out += "/" + items[i];
					else out += items[i];
					return out;
				}
				toAbsPath(base, path$1) {
					let nb = 0;
					const tr = /\/$/.test(path$1) ? "/" : "";
					const normalizedBase = base.split("/");
					const normalizedPath = path$1.split("/");
					const baseParts = [];
					each$4(normalizedBase, (k) => {
						if (k) baseParts.push(k);
					});
					const pathParts = [];
					for (let i$1 = normalizedPath.length - 1; i$1 >= 0; i$1--) {
						if (normalizedPath[i$1].length === 0 || normalizedPath[i$1] === ".") continue;
						if (normalizedPath[i$1] === "..") {
							nb++;
							continue;
						}
						if (nb > 0) {
							nb--;
							continue;
						}
						pathParts.push(normalizedPath[i$1]);
					}
					const i = baseParts.length - nb;
					let outPath;
					if (i <= 0) outPath = reverse(pathParts).join("/");
					else outPath = baseParts.slice(0, i).join("/") + "/" + reverse(pathParts).join("/");
					if (outPath.indexOf("/") !== 0) outPath = "/" + outPath;
					if (tr && outPath.lastIndexOf("/") !== outPath.length - 1) outPath += tr;
					return outPath;
				}
				getURI(noProtoHost = false) {
					let s;
					if (!this.source || noProtoHost) {
						s = "";
						if (!noProtoHost) {
							if (this.protocol) s += this.protocol + "://";
							else s += "//";
							if (this.userInfo) s += this.userInfo + "@";
							if (this.host) s += this.host;
							if (this.port) s += ":" + this.port;
						}
						if (this.path) s += this.path;
						if (this.query) s += "?" + this.query;
						if (this.anchor) s += "#" + this.anchor;
						this.source = s;
					}
					return this.source;
				}
			}
			const filteredUrlAttrs = Tools.makeMap("src,href,data,background,action,formaction,poster,xlink:href");
			const internalElementAttr = "data-mce-type";
			let uid = 0;
			const processNode = (node, settings, schema, evt) => {
				var _a, _b, _c, _d;
				const validate$1 = settings.validate;
				const specialElements = schema.getSpecialElements();
				if (node.nodeType === COMMENT && !settings.allow_conditional_comments && /^\[if/i.test((_a = node.nodeValue) !== null && _a !== void 0 ? _a : "")) node.nodeValue = " " + node.nodeValue;
				const lcTagName = (_b = evt === null || evt === void 0 ? void 0 : evt.tagName) !== null && _b !== void 0 ? _b : node.nodeName.toLowerCase();
				if (node.nodeType !== ELEMENT || lcTagName === "body") return;
				const element = SugarElement.fromDom(node);
				const isInternalElement = has$1(element, internalElementAttr);
				const bogus = get$9(element, "data-mce-bogus");
				if (!isInternalElement && isString(bogus)) {
					if (bogus === "all") remove$5(element);
					else unwrap(element);
					return;
				}
				const rule = schema.getElementRule(lcTagName);
				if (validate$1 && !rule) {
					if (has$2(specialElements, lcTagName)) remove$5(element);
					else unwrap(element);
					return;
				} else if (isNonNullable(evt)) evt.allowedTags[lcTagName] = true;
				if (validate$1 && rule && !isInternalElement) {
					each$e((_c = rule.attributesForced) !== null && _c !== void 0 ? _c : [], (attr) => {
						set$3(element, attr.name, attr.value === "{$uid}" ? `mce_${uid++}` : attr.value);
					});
					each$e((_d = rule.attributesDefault) !== null && _d !== void 0 ? _d : [], (attr) => {
						if (!has$1(element, attr.name)) set$3(element, attr.name, attr.value === "{$uid}" ? `mce_${uid++}` : attr.value);
					});
					if (rule.attributesRequired && !exists(rule.attributesRequired, (attr) => has$1(element, attr))) {
						unwrap(element);
						return;
					}
					if (rule.removeEmptyAttrs && hasNone(element)) {
						unwrap(element);
						return;
					}
					if (rule.outputName && rule.outputName !== lcTagName) mutate(element, rule.outputName);
				}
			};
			const shouldKeepAttribute = (settings, schema, tagName, attrName, attrValue) => !(attrName in filteredUrlAttrs && isInvalidUri(settings, attrValue, tagName)) && (!settings.validate || schema.isValid(tagName, attrName) || startsWith(attrName, "data-") || startsWith(attrName, "aria-"));
			const isRequiredAttributeOfInternalElement = (ele, attrName) => ele.hasAttribute(internalElementAttr) && (attrName === "id" || attrName === "class" || attrName === "style");
			const isBooleanAttribute = (attrName, schema) => attrName in schema.getBoolAttrs();
			const filterAttributes = (ele, settings, schema) => {
				const { attributes } = ele;
				for (let i = attributes.length - 1; i >= 0; i--) {
					const attr = attributes[i];
					const attrName = attr.name;
					const attrValue = attr.value;
					if (!shouldKeepAttribute(settings, schema, ele.tagName.toLowerCase(), attrName, attrValue) && !isRequiredAttributeOfInternalElement(ele, attrName)) ele.removeAttribute(attrName);
					else if (isBooleanAttribute(attrName, schema)) ele.setAttribute(attrName, attrName);
				}
			};
			const setupPurify = (settings, schema) => {
				const purify$1 = purify();
				purify$1.addHook("uponSanitizeElement", (ele, evt) => {
					processNode(ele, settings, schema, evt);
				});
				purify$1.addHook("uponSanitizeAttribute", (ele, evt) => {
					const tagName = ele.tagName.toLowerCase();
					const { attrName, attrValue } = evt;
					evt.keepAttr = shouldKeepAttribute(settings, schema, tagName, attrName, attrValue);
					if (evt.keepAttr) {
						evt.allowedAttributes[attrName] = true;
						if (isBooleanAttribute(attrName, schema)) evt.attrValue = attrName;
						if (settings.allow_svg_data_urls && startsWith(attrValue, "data:image/svg+xml")) evt.forceKeepAttr = true;
					} else if (isRequiredAttributeOfInternalElement(ele, attrName)) evt.forceKeepAttr = true;
				});
				return purify$1;
			};
			const getPurifyConfig = (settings, mimeType) => {
				const config = {
					IN_PLACE: true,
					ALLOW_UNKNOWN_PROTOCOLS: true,
					ALLOWED_TAGS: [
						"#comment",
						"#cdata-section",
						"body"
					],
					ALLOWED_ATTR: []
				};
				config.PARSER_MEDIA_TYPE = mimeType;
				if (settings.allow_script_urls) config.ALLOWED_URI_REGEXP = /.*/;
				else if (settings.allow_html_data_urls) config.ALLOWED_URI_REGEXP = /^(?!(\w+script|mhtml):)/i;
				return config;
			};
			const getSanitizer = (settings, schema) => {
				if (settings.sanitize) {
					const purify$1 = setupPurify(settings, schema);
					return (body, mimeType) => {
						purify$1.sanitize(body, getPurifyConfig(settings, mimeType));
						purify$1.removed = [];
					};
				} else return (body, _) => {
					const nodeIterator = document.createNodeIterator(body, NodeFilter.SHOW_ELEMENT | NodeFilter.SHOW_COMMENT | NodeFilter.SHOW_TEXT);
					let node;
					while (node = nodeIterator.nextNode()) {
						processNode(node, settings, schema);
						if (isElement$6(node)) filterAttributes(node, settings, schema);
					}
				};
			};
			const makeMap = Tools.makeMap, extend$1 = Tools.extend;
			const transferChildren = (parent$1, nativeParent, specialElements) => {
				const parentName = parent$1.name;
				const isSpecial = parentName in specialElements && parentName !== "title" && parentName !== "textarea";
				const childNodes = nativeParent.childNodes;
				for (let ni = 0, nl = childNodes.length; ni < nl; ni++) {
					const nativeChild = childNodes[ni];
					const child$2 = new AstNode(nativeChild.nodeName.toLowerCase(), nativeChild.nodeType);
					if (isElement$6(nativeChild)) {
						const attributes = nativeChild.attributes;
						for (let ai = 0, al = attributes.length; ai < al; ai++) {
							const attr = attributes[ai];
							child$2.attr(attr.name, attr.value);
						}
					} else if (isText$a(nativeChild)) {
						child$2.value = nativeChild.data;
						if (isSpecial) child$2.raw = true;
					} else if (isComment(nativeChild) || isCData(nativeChild) || isPi(nativeChild)) child$2.value = nativeChild.data;
					transferChildren(child$2, nativeChild, specialElements);
					parent$1.append(child$2);
				}
			};
			const walkTree = (root, preprocessors, postprocessors) => {
				const traverseOrder = [];
				for (let node = root, lastNode = node; node; lastNode = node, node = node.walk()) {
					const tempNode = node;
					each$e(preprocessors, (preprocess$1) => preprocess$1(tempNode));
					if (isNullable(tempNode.parent) && tempNode !== root) node = lastNode;
					else traverseOrder.push(tempNode);
				}
				for (let i = traverseOrder.length - 1; i >= 0; i--) {
					const node = traverseOrder[i];
					each$e(postprocessors, (postprocess) => postprocess(node));
				}
			};
			const whitespaceCleaner = (root, schema, settings, args) => {
				const validate$1 = settings.validate;
				const nonEmptyElements = schema.getNonEmptyElements();
				const whitespaceElements = schema.getWhitespaceElements();
				const blockElements = extend$1(makeMap("script,style,head,html,body,title,meta,param"), schema.getBlockElements());
				const textRootBlockElements = getTextRootBlockElements(schema);
				const allWhiteSpaceRegExp = /[ \t\r\n]+/g;
				const startWhiteSpaceRegExp = /^[ \t\r\n]+/;
				const endWhiteSpaceRegExp = /[ \t\r\n]+$/;
				const hasWhitespaceParent = (node) => {
					let tempNode = node.parent;
					while (isNonNullable(tempNode)) if (tempNode.name in whitespaceElements) return true;
					else tempNode = tempNode.parent;
					return false;
				};
				const isTextRootBlockEmpty = (node) => {
					let tempNode = node;
					while (isNonNullable(tempNode)) if (tempNode.name in textRootBlockElements) return isEmpty(schema, nonEmptyElements, whitespaceElements, tempNode);
					else tempNode = tempNode.parent;
					return false;
				};
				const isBlock$3 = (node) => node.name in blockElements || isTransparentAstBlock(schema, node);
				const isAtEdgeOfBlock = (node, start$2) => {
					if (isNonNullable(start$2 ? node.prev : node.next) || isNullable(node.parent)) return false;
					return isBlock$3(node.parent) && (node.parent !== root || args.isRootContent === true);
				};
				const preprocess$1 = (node) => {
					var _a;
					if (node.type === 3) {
						if (!hasWhitespaceParent(node)) {
							let text$1 = (_a = node.value) !== null && _a !== void 0 ? _a : "";
							text$1 = text$1.replace(allWhiteSpaceRegExp, " ");
							if (isLineBreakNode(node.prev, isBlock$3) || isAtEdgeOfBlock(node, true)) text$1 = text$1.replace(startWhiteSpaceRegExp, "");
							if (text$1.length === 0) node.remove();
							else node.value = text$1;
						}
					}
				};
				const postprocess = (node) => {
					var _a;
					if (node.type === 1) {
						const elementRule = schema.getElementRule(node.name);
						if (validate$1 && elementRule) {
							const isNodeEmpty = isEmpty(schema, nonEmptyElements, whitespaceElements, node);
							if (elementRule.paddInEmptyBlock && isNodeEmpty && isTextRootBlockEmpty(node)) paddEmptyNode(settings, args, isBlock$3, node);
							else if (elementRule.removeEmpty && isNodeEmpty) if (isBlock$3(node)) node.remove();
							else node.unwrap();
							else if (elementRule.paddEmpty && (isNodeEmpty || isPaddedWithNbsp(node))) paddEmptyNode(settings, args, isBlock$3, node);
						}
					} else if (node.type === 3) {
						if (!hasWhitespaceParent(node)) {
							let text$1 = (_a = node.value) !== null && _a !== void 0 ? _a : "";
							if (node.next && isBlock$3(node.next) || isAtEdgeOfBlock(node, false)) text$1 = text$1.replace(endWhiteSpaceRegExp, "");
							if (text$1.length === 0) node.remove();
							else node.value = text$1;
						}
					}
				};
				return [preprocess$1, postprocess];
			};
			const getRootBlockName = (settings, args) => {
				var _a;
				const name$1 = (_a = args.forced_root_block) !== null && _a !== void 0 ? _a : settings.forced_root_block;
				if (name$1 === false) return "";
				else if (name$1 === true) return "p";
				else return name$1;
			};
			const DomParser = (settings = {}, schema = Schema()) => {
				const nodeFilterRegistry = create$8();
				const attributeFilterRegistry = create$8();
				const defaultedSettings = {
					validate: true,
					root_name: "body",
					sanitize: true,
					...settings
				};
				const parser = new DOMParser();
				const sanitize = getSanitizer(defaultedSettings, schema);
				const parseAndSanitizeWithContext = (html$2, rootName, format = "html") => {
					const mimeType = format === "xhtml" ? "application/xhtml+xml" : "text/html";
					const isSpecialRoot = has$2(schema.getSpecialElements(), rootName.toLowerCase());
					const content = isSpecialRoot ? `<${rootName}>${html$2}</${rootName}>` : html$2;
					const wrappedHtml = format === "xhtml" ? `<html xmlns="http://www.w3.org/1999/xhtml"><head></head><body>${content}</body></html>` : `<body>${content}</body>`;
					const body = parser.parseFromString(wrappedHtml, mimeType).body;
					sanitize(body, mimeType);
					return isSpecialRoot ? body.firstChild : body;
				};
				const addNodeFilter$1 = nodeFilterRegistry.addFilter;
				const getNodeFilters = nodeFilterRegistry.getFilters;
				const removeNodeFilter = nodeFilterRegistry.removeFilter;
				const addAttributeFilter = attributeFilterRegistry.addFilter;
				const getAttributeFilters = attributeFilterRegistry.getFilters;
				const removeAttributeFilter = attributeFilterRegistry.removeFilter;
				const findInvalidChildren = (node, invalidChildren) => {
					if (isInvalid(schema, node)) invalidChildren.push(node);
				};
				const isWrappableNode = (blockElements, node) => {
					const isInternalElement = isString(node.attr(internalElementAttr));
					const isInlineElement$1 = node.type === 1 && !has$2(blockElements, node.name) && !isTransparentAstBlock(schema, node);
					return node.type === 3 || isInlineElement$1 && !isInternalElement;
				};
				const addRootBlocks$1 = (rootNode, rootBlockName) => {
					const blockElements = extend$1(makeMap("script,style,head,html,body,title,meta,param"), schema.getBlockElements());
					const startWhiteSpaceRegExp = /^[ \t\r\n]+/;
					const endWhiteSpaceRegExp = /[ \t\r\n]+$/;
					let node = rootNode.firstChild, rootBlockNode = null;
					const trim$4 = (rootBlock) => {
						var _a, _b;
						if (rootBlock) {
							node = rootBlock.firstChild;
							if (node && node.type === 3) node.value = (_a = node.value) === null || _a === void 0 ? void 0 : _a.replace(startWhiteSpaceRegExp, "");
							node = rootBlock.lastChild;
							if (node && node.type === 3) node.value = (_b = node.value) === null || _b === void 0 ? void 0 : _b.replace(endWhiteSpaceRegExp, "");
						}
					};
					if (!schema.isValidChild(rootNode.name, rootBlockName.toLowerCase())) return;
					while (node) {
						const next$1 = node.next;
						if (isWrappableNode(blockElements, node)) if (!rootBlockNode) {
							rootBlockNode = new AstNode(rootBlockName, 1);
							rootBlockNode.attr(defaultedSettings.forced_root_block_attrs);
							rootNode.insert(rootBlockNode, node);
							rootBlockNode.append(node);
						} else rootBlockNode.append(node);
						else {
							trim$4(rootBlockNode);
							rootBlockNode = null;
						}
						node = next$1;
					}
					trim$4(rootBlockNode);
				};
				const parse = (html$2, args = {}) => {
					var _a;
					const validate$1 = defaultedSettings.validate;
					const rootName = (_a = args.context) !== null && _a !== void 0 ? _a : defaultedSettings.root_name;
					const element = parseAndSanitizeWithContext(html$2, rootName, args.format);
					updateChildren(schema, element);
					const rootNode = new AstNode(rootName, 11);
					transferChildren(rootNode, element, schema.getSpecialElements());
					element.innerHTML = "";
					const [whitespacePre, whitespacePost] = whitespaceCleaner(rootNode, schema, defaultedSettings, args);
					const invalidChildren = [];
					const invalidFinder = validate$1 ? (node) => findInvalidChildren(node, invalidChildren) : noop;
					const matches = {
						nodes: {},
						attributes: {}
					};
					const matchFinder = (node) => matchNode$1(getNodeFilters(), getAttributeFilters(), node, matches);
					walkTree(rootNode, [whitespacePre, matchFinder], [whitespacePost, invalidFinder]);
					invalidChildren.reverse();
					if (validate$1 && invalidChildren.length > 0) if (args.context) {
						const { pass: topLevelChildren, fail: otherChildren } = partition$2(invalidChildren, (child$2) => child$2.parent === rootNode);
						cleanInvalidNodes(otherChildren, schema, rootNode, matchFinder);
						args.invalid = topLevelChildren.length > 0;
					} else cleanInvalidNodes(invalidChildren, schema, rootNode, matchFinder);
					const rootBlockName = getRootBlockName(defaultedSettings, args);
					if (rootBlockName && (rootNode.name === "body" || args.isRootContent)) addRootBlocks$1(rootNode, rootBlockName);
					if (!args.invalid) runFilters(matches, args);
					return rootNode;
				};
				const exports$1 = {
					schema,
					addAttributeFilter,
					getAttributeFilters,
					removeAttributeFilter,
					addNodeFilter: addNodeFilter$1,
					getNodeFilters,
					removeNodeFilter,
					parse
				};
				register$4(exports$1, defaultedSettings);
				register$5(exports$1, defaultedSettings, schema);
				return exports$1;
			};
			const serializeContent = (content) => isTreeNode(content) ? HtmlSerializer({ validate: false }).serialize(content) : content;
			const withSerializedContent = (content, fireEvent$1, sanitize) => {
				const serializedContent = serializeContent(content);
				const eventArgs = fireEvent$1(serializedContent);
				if (eventArgs.isDefaultPrevented()) return eventArgs;
				else if (isTreeNode(content)) if (eventArgs.content !== serializedContent) {
					const rootNode = DomParser({
						validate: false,
						forced_root_block: false,
						sanitize
					}).parse(eventArgs.content, { context: content.name });
					return {
						...eventArgs,
						content: rootNode
					};
				} else return {
					...eventArgs,
					content
				};
				else return eventArgs;
			};
			const preProcessGetContent = (editor, args) => {
				if (args.no_events) return Result.value(args);
				else {
					const eventArgs = fireBeforeGetContent(editor, args);
					if (eventArgs.isDefaultPrevented()) return Result.error(fireGetContent(editor, {
						content: "",
						...eventArgs
					}).content);
					else return Result.value(eventArgs);
				}
			};
			const postProcessGetContent = (editor, content, args) => {
				if (args.no_events) return content;
				else return withSerializedContent(content, (content$1) => fireGetContent(editor, {
					...args,
					content: content$1
				}), shouldSanitizeXss(editor)).content;
			};
			const preProcessSetContent = (editor, args) => {
				if (args.no_events) return Result.value(args);
				else {
					const processedEventArgs = withSerializedContent(args.content, (content) => fireBeforeSetContent(editor, {
						...args,
						content
					}), shouldSanitizeXss(editor));
					if (processedEventArgs.isDefaultPrevented()) {
						fireSetContent(editor, processedEventArgs);
						return Result.error(void 0);
					} else return Result.value(processedEventArgs);
				}
			};
			const postProcessSetContent = (editor, content, args) => {
				if (!args.no_events) fireSetContent(editor, {
					...args,
					content
				});
			};
			const tableModel = (element, width, rows) => ({
				element,
				width,
				rows
			});
			const tableRow = (element, cells$1) => ({
				element,
				cells: cells$1
			});
			const cellPosition = (x, y) => ({
				x,
				y
			});
			const getSpan = (td, key) => {
				return getOpt(td, key).bind(toInt).getOr(1);
			};
			const fillout = (table$1, x, y, tr, td) => {
				const rowspan = getSpan(td, "rowspan");
				const colspan = getSpan(td, "colspan");
				const rows = table$1.rows;
				for (let y2 = y; y2 < y + rowspan; y2++) {
					if (!rows[y2]) rows[y2] = tableRow(deep$1(tr), []);
					for (let x2 = x; x2 < x + colspan; x2++) {
						const cells$1 = rows[y2].cells;
						cells$1[x2] = y2 === y && x2 === x ? td : shallow$1(td);
					}
				}
			};
			const cellExists = (table$1, x, y) => {
				const rows = table$1.rows;
				return !!(rows[y] ? rows[y].cells : [])[x];
			};
			const skipCellsX = (table$1, x, y) => {
				while (cellExists(table$1, x, y)) x++;
				return x;
			};
			const getWidth = (rows) => {
				return foldl(rows, (acc, row) => {
					return row.cells.length > acc ? row.cells.length : acc;
				}, 0);
			};
			const findElementPos = (table$1, element) => {
				const rows = table$1.rows;
				for (let y = 0; y < rows.length; y++) {
					const cells$1 = rows[y].cells;
					for (let x = 0; x < cells$1.length; x++) if (eq(cells$1[x], element)) return Optional.some(cellPosition(x, y));
				}
				return Optional.none();
			};
			const extractRows = (table$1, sx, sy, ex, ey) => {
				const newRows = [];
				const rows = table$1.rows;
				for (let y = sy; y <= ey; y++) {
					const cells$1 = rows[y].cells;
					const slice = sx < ex ? cells$1.slice(sx, ex + 1) : cells$1.slice(ex, sx + 1);
					newRows.push(tableRow(rows[y].element, slice));
				}
				return newRows;
			};
			const subTable = (table$1, startPos, endPos) => {
				const sx = startPos.x, sy = startPos.y;
				const ex = endPos.x, ey = endPos.y;
				const newRows = sy < ey ? extractRows(table$1, sx, sy, ex, ey) : extractRows(table$1, sx, ey, ex, sy);
				return tableModel(table$1.element, getWidth(newRows), newRows);
			};
			const createDomTable = (table$1, rows) => {
				const tableElement = shallow$1(table$1.element);
				const tableBody = SugarElement.fromTag("tbody");
				append(tableBody, rows);
				append$1(tableElement, tableBody);
				return tableElement;
			};
			const modelRowsToDomRows = (table$1) => {
				return map$3(table$1.rows, (row) => {
					const cells$1 = map$3(row.cells, (cell$1) => {
						const td = deep$1(cell$1);
						remove$a(td, "colspan");
						remove$a(td, "rowspan");
						return td;
					});
					const tr = shallow$1(row.element);
					append(tr, cells$1);
					return tr;
				});
			};
			const fromDom = (tableElm) => {
				const table$1 = tableModel(shallow$1(tableElm), 0, []);
				each$e(descendants(tableElm, "tr"), (tr, y) => {
					each$e(descendants(tr, "td,th"), (td, x) => {
						fillout(table$1, skipCellsX(table$1, x, y), y, tr, td);
					});
				});
				return tableModel(table$1.element, getWidth(table$1.rows), table$1.rows);
			};
			const toDom = (table$1) => {
				return createDomTable(table$1, modelRowsToDomRows(table$1));
			};
			const subsection = (table$1, startElement, endElement) => {
				return findElementPos(table$1, startElement).bind((startPos) => {
					return findElementPos(table$1, endElement).map((endPos) => {
						return subTable(table$1, startPos, endPos);
					});
				});
			};
			const findParentListContainer = (parents$2) => find$2(parents$2, (elm) => name(elm) === "ul" || name(elm) === "ol");
			const getFullySelectedListWrappers = (parents$2, rng) => find$2(parents$2, (elm) => name(elm) === "li" && hasAllContentsSelected(elm, rng)).fold(constant([]), (_li) => findParentListContainer(parents$2).map((listCont) => {
				const listElm = SugarElement.fromTag(name(listCont));
				setAll(listElm, filter$4(getAllRaw(listCont), (_style, name$1) => startsWith(name$1, "list-style")));
				return [SugarElement.fromTag("li"), listElm];
			}).getOr([]));
			const wrap = (innerElm, elms) => {
				const wrapped = foldl(elms, (acc, elm) => {
					append$1(elm, acc);
					return elm;
				}, innerElm);
				return elms.length > 0 ? fromElements([wrapped]) : wrapped;
			};
			const directListWrappers = (commonAnchorContainer) => {
				if (isListItem$1(commonAnchorContainer)) return parent(commonAnchorContainer).filter(isList).fold(constant([]), (listElm) => [commonAnchorContainer, listElm]);
				else return isList(commonAnchorContainer) ? [commonAnchorContainer] : [];
			};
			const getWrapElements = (rootNode, rng) => {
				const commonAnchorContainer = SugarElement.fromDom(rng.commonAncestorContainer);
				const parents$2 = parentsAndSelf(commonAnchorContainer, rootNode);
				const wrapElements = filter$5(parents$2, isWrapElement);
				const listWrappers = getFullySelectedListWrappers(parents$2, rng);
				return map$3(wrapElements.concat(listWrappers.length ? listWrappers : directListWrappers(commonAnchorContainer)), shallow$1);
			};
			const emptyFragment = () => fromElements([]);
			const getFragmentFromRange = (rootNode, rng) => wrap(SugarElement.fromDom(rng.cloneContents()), getWrapElements(rootNode, rng));
			const getParentTable = (rootElm, cell$1) => ancestor$3(cell$1, "table", curry(eq, rootElm));
			const getTableFragment = (rootNode, selectedTableCells) => getParentTable(rootNode, selectedTableCells[0]).bind((tableElm) => {
				const firstCell = selectedTableCells[0];
				const lastCell = selectedTableCells[selectedTableCells.length - 1];
				return subsection(fromDom(tableElm), firstCell, lastCell).map((sectionedTableModel) => fromElements([toDom(sectionedTableModel)]));
			}).getOrThunk(emptyFragment);
			const getSelectionFragment = (rootNode, ranges) => ranges.length > 0 && ranges[0].collapsed ? emptyFragment() : getFragmentFromRange(rootNode, ranges[0]);
			const read$3 = (rootNode, ranges) => {
				const selectedCells = getCellsFromElementOrRanges(ranges, rootNode);
				return selectedCells.length > 0 ? getTableFragment(rootNode, selectedCells) : getSelectionFragment(rootNode, ranges);
			};
			const isCollapsibleWhitespace = (text$1, index) => index >= 0 && index < text$1.length && isWhiteSpace(text$1.charAt(index));
			const getInnerText = (bin) => {
				return trim$1(bin.innerText);
			};
			const getContextNodeName = (parentBlockOpt) => parentBlockOpt.map((block) => block.nodeName).getOr("div").toLowerCase();
			const getTextContent = (editor) => Optional.from(editor.selection.getRng()).map((rng) => {
				var _a;
				const parentBlockOpt = Optional.from(editor.dom.getParent(rng.commonAncestorContainer, editor.dom.isBlock));
				const body = editor.getBody();
				const contextNodeName = getContextNodeName(parentBlockOpt);
				const rangeContentClone = SugarElement.fromDom(rng.cloneContents());
				cleanupBogusElements(rangeContentClone);
				cleanupInputNames(rangeContentClone);
				const bin = editor.dom.add(body, contextNodeName, {
					"data-mce-bogus": "all",
					"style": "overflow: hidden; opacity: 0;"
				}, rangeContentClone.dom);
				const text$1 = getInnerText(bin);
				const nonRenderedText = trim$1((_a = bin.textContent) !== null && _a !== void 0 ? _a : "");
				editor.dom.remove(bin);
				if (isCollapsibleWhitespace(nonRenderedText, 0) || isCollapsibleWhitespace(nonRenderedText, nonRenderedText.length - 1)) {
					const parentBlockText = getInnerText(parentBlockOpt.getOr(body));
					const textIndex = parentBlockText.indexOf(text$1);
					if (textIndex === -1) return text$1;
					else {
						const hasProceedingSpace = isCollapsibleWhitespace(parentBlockText, textIndex - 1);
						const hasTrailingSpace = isCollapsibleWhitespace(parentBlockText, textIndex + text$1.length);
						return (hasProceedingSpace ? " " : "") + text$1 + (hasTrailingSpace ? " " : "");
					}
				} else return text$1;
			}).getOr("");
			const getSerializedContent = (editor, args) => {
				const rng = editor.selection.getRng(), tmpElm = editor.dom.create("body");
				const ranges = processRanges(editor, getRanges$1(editor.selection.getSel()));
				const fragment = args.contextual ? read$3(SugarElement.fromDom(editor.getBody()), ranges).dom : rng.cloneContents();
				if (fragment) tmpElm.appendChild(fragment);
				return editor.selection.serializer.serialize(tmpElm, args);
			};
			const extractSelectedContent = (editor, args) => {
				if (args.format === "text") return getTextContent(editor);
				else {
					const content = getSerializedContent(editor, args);
					if (args.format === "tree") return content;
					else return editor.selection.isCollapsed() ? "" : content;
				}
			};
			const setupArgs$3 = (args, format) => ({
				...args,
				format,
				get: true,
				selection: true,
				getInner: true
			});
			const getSelectedContentInternal = (editor, format, args = {}) => {
				return preProcessGetContent(editor, setupArgs$3(args, format)).fold(identity, (updatedArgs) => {
					return postProcessGetContent(editor, extractSelectedContent(editor, updatedArgs), updatedArgs);
				});
			};
			const KEEP = 0, INSERT = 1, DELETE = 2;
			const diff = (left, right) => {
				const size = left.length + right.length + 2;
				const vDown = new Array(size);
				const vUp = new Array(size);
				const snake = (start$2, end$1, diag) => {
					return {
						start: start$2,
						end: end$1,
						diag
					};
				};
				const buildScript = (start1, end1, start2, end2, script$1) => {
					const middle = getMiddleSnake(start1, end1, start2, end2);
					if (middle === null || middle.start === end1 && middle.diag === end1 - end2 || middle.end === start1 && middle.diag === start1 - start2) {
						let i = start1;
						let j = start2;
						while (i < end1 || j < end2) if (i < end1 && j < end2 && left[i] === right[j]) {
							script$1.push([KEEP, left[i]]);
							++i;
							++j;
						} else if (end1 - start1 > end2 - start2) {
							script$1.push([DELETE, left[i]]);
							++i;
						} else {
							script$1.push([INSERT, right[j]]);
							++j;
						}
					} else {
						buildScript(start1, middle.start, start2, middle.start - middle.diag, script$1);
						for (let i2 = middle.start; i2 < middle.end; ++i2) script$1.push([KEEP, left[i2]]);
						buildScript(middle.end, end1, middle.end - middle.diag, end2, script$1);
					}
				};
				const buildSnake = (start$2, diag, end1, end2) => {
					let end$1 = start$2;
					while (end$1 - diag < end2 && end$1 < end1 && left[end$1] === right[end$1 - diag]) ++end$1;
					return snake(start$2, end$1, diag);
				};
				const getMiddleSnake = (start1, end1, start2, end2) => {
					const m = end1 - start1;
					const n = end2 - start2;
					if (m === 0 || n === 0) return null;
					const delta = m - n;
					const sum = n + m;
					const offset = (sum % 2 === 0 ? sum : sum + 1) / 2;
					vDown[1 + offset] = start1;
					vUp[1 + offset] = end1 + 1;
					let d, k, i, x, y;
					for (d = 0; d <= offset; ++d) {
						for (k = -d; k <= d; k += 2) {
							i = k + offset;
							if (k === -d || k !== d && vDown[i - 1] < vDown[i + 1]) vDown[i] = vDown[i + 1];
							else vDown[i] = vDown[i - 1] + 1;
							x = vDown[i];
							y = x - start1 + start2 - k;
							while (x < end1 && y < end2 && left[x] === right[y]) {
								vDown[i] = ++x;
								++y;
							}
							if (delta % 2 !== 0 && delta - d <= k && k <= delta + d) {
								if (vUp[i - delta] <= vDown[i]) return buildSnake(vUp[i - delta], k + start1 - start2, end1, end2);
							}
						}
						for (k = delta - d; k <= delta + d; k += 2) {
							i = k + offset - delta;
							if (k === delta - d || k !== delta + d && vUp[i + 1] <= vUp[i - 1]) vUp[i] = vUp[i + 1] - 1;
							else vUp[i] = vUp[i - 1];
							x = vUp[i] - 1;
							y = x - start1 + start2 - k;
							while (x >= start1 && y >= start2 && left[x] === right[y]) {
								vUp[i] = x--;
								y--;
							}
							if (delta % 2 === 0 && -d <= k && k <= d) {
								if (vUp[i] <= vDown[i + delta]) return buildSnake(vUp[i], k + start1 - start2, end1, end2);
							}
						}
					}
					return null;
				};
				const script = [];
				buildScript(0, left.length, 0, right.length, script);
				return script;
			};
			const getOuterHtml = (elm) => {
				if (isElement$6(elm)) return elm.outerHTML;
				else if (isText$a(elm)) return Entities.encodeRaw(elm.data, false);
				else if (isComment(elm)) return "<!--" + elm.data + "-->";
				return "";
			};
			const createFragment = (html$2) => {
				let node;
				const container = document.createElement("div");
				const frag = document.createDocumentFragment();
				if (html$2) container.innerHTML = html$2;
				while (node = container.firstChild) frag.appendChild(node);
				return frag;
			};
			const insertAt = (elm, html$2, index) => {
				const fragment = createFragment(html$2);
				if (elm.hasChildNodes() && index < elm.childNodes.length) {
					const target = elm.childNodes[index];
					elm.insertBefore(fragment, target);
				} else elm.appendChild(fragment);
			};
			const removeAt = (elm, index) => {
				if (elm.hasChildNodes() && index < elm.childNodes.length) {
					const target = elm.childNodes[index];
					elm.removeChild(target);
				}
			};
			const applyDiff = (diff$1, elm) => {
				let index = 0;
				each$e(diff$1, (action$1) => {
					if (action$1[0] === KEEP) index++;
					else if (action$1[0] === INSERT) {
						insertAt(elm, action$1[1], index);
						index++;
					} else if (action$1[0] === DELETE) removeAt(elm, index);
				});
			};
			const read$2 = (elm) => {
				return filter$5(map$3(from(elm.childNodes), getOuterHtml), (item) => {
					return item.length > 0;
				});
			};
			const write = (fragments, elm) => {
				applyDiff(diff(map$3(from(elm.childNodes), getOuterHtml), fragments), elm);
				return elm;
			};
			const lazyTempDocument = cached(() => document.implementation.createHTMLDocument("undo"));
			const hasIframes = (html$2) => {
				return html$2.indexOf("</iframe>") !== -1;
			};
			const createFragmentedLevel = (fragments) => {
				return {
					type: "fragmented",
					fragments,
					content: "",
					bookmark: null,
					beforeBookmark: null
				};
			};
			const createCompleteLevel = (content) => {
				return {
					type: "complete",
					fragments: null,
					content,
					bookmark: null,
					beforeBookmark: null
				};
			};
			const createFromEditor = (editor) => {
				const trimmedFragments = bind$3(read$2(editor.getBody()), (html$2) => {
					const trimmed = trimInternal(editor.serializer, html$2);
					return trimmed.length > 0 ? [trimmed] : [];
				});
				const content = trimmedFragments.join("");
				return hasIframes(content) ? createFragmentedLevel(trimmedFragments) : createCompleteLevel(content);
			};
			const applyToEditor = (editor, level, before$1) => {
				const bookmark = before$1 ? level.beforeBookmark : level.bookmark;
				if (level.type === "fragmented") write(level.fragments, editor.getBody());
				else editor.setContent(level.content, {
					format: "raw",
					no_selection: isNonNullable(bookmark) && isPathBookmark(bookmark) ? !bookmark.isFakeCaret : true
				});
				if (bookmark) {
					editor.selection.moveToBookmark(bookmark);
					editor.selection.scrollIntoView();
				}
			};
			const getLevelContent = (level) => {
				return level.type === "fragmented" ? level.fragments.join("") : level.content;
			};
			const getCleanLevelContent = (level) => {
				const elm = SugarElement.fromTag("body", lazyTempDocument());
				set$1(elm, getLevelContent(level));
				each$e(descendants(elm, "*[data-mce-bogus]"), unwrap);
				return get$6(elm);
			};
			const hasEqualContent = (level1, level2) => getLevelContent(level1) === getLevelContent(level2);
			const hasEqualCleanedContent = (level1, level2) => getCleanLevelContent(level1) === getCleanLevelContent(level2);
			const isEq$1 = (level1, level2) => {
				if (!level1 || !level2) return false;
				else if (hasEqualContent(level1, level2)) return true;
				else return hasEqualCleanedContent(level1, level2);
			};
			const isUnlocked = (locks) => locks.get() === 0;
			const setTyping = (undoManager, typing, locks) => {
				if (isUnlocked(locks)) undoManager.typing = typing;
			};
			const endTyping = (undoManager, locks) => {
				if (undoManager.typing) {
					setTyping(undoManager, false, locks);
					undoManager.add();
				}
			};
			const endTypingLevelIgnoreLocks = (undoManager) => {
				if (undoManager.typing) {
					undoManager.typing = false;
					undoManager.add();
				}
			};
			const beforeChange$1 = (editor, locks, beforeBookmark) => {
				if (isUnlocked(locks)) beforeBookmark.set(getUndoBookmark(editor.selection));
			};
			const addUndoLevel$1 = (editor, undoManager, index, locks, beforeBookmark, level, event) => {
				const currentLevel = createFromEditor(editor);
				const newLevel = Tools.extend(level || {}, currentLevel);
				if (!isUnlocked(locks) || editor.removed) return null;
				const lastLevel = undoManager.data[index.get()];
				if (editor.dispatch("BeforeAddUndo", {
					level: newLevel,
					lastLevel,
					originalEvent: event
				}).isDefaultPrevented()) return null;
				if (lastLevel && isEq$1(lastLevel, newLevel)) return null;
				if (undoManager.data[index.get()]) beforeBookmark.get().each((bm) => {
					undoManager.data[index.get()].beforeBookmark = bm;
				});
				const customUndoRedoLevels = getCustomUndoRedoLevels(editor);
				if (customUndoRedoLevels) {
					if (undoManager.data.length > customUndoRedoLevels) {
						for (let i = 0; i < undoManager.data.length - 1; i++) undoManager.data[i] = undoManager.data[i + 1];
						undoManager.data.length--;
						index.set(undoManager.data.length);
					}
				}
				newLevel.bookmark = getUndoBookmark(editor.selection);
				if (index.get() < undoManager.data.length - 1) undoManager.data.length = index.get() + 1;
				undoManager.data.push(newLevel);
				index.set(undoManager.data.length - 1);
				const args = {
					level: newLevel,
					lastLevel,
					originalEvent: event
				};
				if (index.get() > 0) {
					editor.setDirty(true);
					editor.dispatch("AddUndo", args);
					editor.dispatch("change", args);
				} else editor.dispatch("AddUndo", args);
				return newLevel;
			};
			const clear$1 = (editor, undoManager, index) => {
				undoManager.data = [];
				index.set(0);
				undoManager.typing = false;
				editor.dispatch("ClearUndos");
			};
			const extra$1 = (editor, undoManager, index, callback1, callback2) => {
				if (undoManager.transact(callback1)) {
					const bookmark = undoManager.data[index.get()].bookmark;
					const lastLevel = undoManager.data[index.get() - 1];
					applyToEditor(editor, lastLevel, true);
					if (undoManager.transact(callback2)) undoManager.data[index.get() - 1].beforeBookmark = bookmark;
				}
			};
			const redo$1 = (editor, index, data$1) => {
				let level;
				if (index.get() < data$1.length - 1) {
					index.set(index.get() + 1);
					level = data$1[index.get()];
					applyToEditor(editor, level, false);
					editor.setDirty(true);
					editor.dispatch("Redo", { level });
				}
				return level;
			};
			const undo$1 = (editor, undoManager, locks, index) => {
				let level;
				if (undoManager.typing) {
					undoManager.add();
					undoManager.typing = false;
					setTyping(undoManager, false, locks);
				}
				if (index.get() > 0) {
					index.set(index.get() - 1);
					level = undoManager.data[index.get()];
					applyToEditor(editor, level, true);
					editor.setDirty(true);
					editor.dispatch("Undo", { level });
				}
				return level;
			};
			const reset$1 = (undoManager) => {
				undoManager.clear();
				undoManager.add();
			};
			const hasUndo$1 = (editor, undoManager, index) => index.get() > 0 || undoManager.typing && undoManager.data[0] && !isEq$1(createFromEditor(editor), undoManager.data[0]);
			const hasRedo$1 = (undoManager, index) => index.get() < undoManager.data.length - 1 && !undoManager.typing;
			const transact$1 = (undoManager, locks, callback) => {
				endTyping(undoManager, locks);
				undoManager.beforeChange();
				undoManager.ignore(callback);
				return undoManager.add();
			};
			const ignore$1 = (locks, callback) => {
				try {
					locks.set(locks.get() + 1);
					callback();
				} finally {
					locks.set(locks.get() - 1);
				}
			};
			const addVisualInternal = (editor, elm) => {
				const dom$1 = editor.dom;
				const scope = isNonNullable(elm) ? elm : editor.getBody();
				each$e(dom$1.select("table,a", scope), (matchedElm) => {
					switch (matchedElm.nodeName) {
						case "TABLE":
							const cls = getVisualAidsTableClass(editor);
							const value$3 = dom$1.getAttrib(matchedElm, "border");
							if ((!value$3 || value$3 === "0") && editor.hasVisual) dom$1.addClass(matchedElm, cls);
							else dom$1.removeClass(matchedElm, cls);
							break;
						case "A":
							if (!dom$1.getAttrib(matchedElm, "href")) {
								const value$4 = dom$1.getAttrib(matchedElm, "name") || matchedElm.id;
								const cls$1 = getVisualAidsAnchorClass(editor);
								if (value$4 && editor.hasVisual) dom$1.addClass(matchedElm, cls$1);
								else dom$1.removeClass(matchedElm, cls$1);
							}
							break;
					}
				});
				editor.dispatch("VisualAid", {
					element: elm,
					hasVisual: editor.hasVisual
				});
			};
			const makePlainAdaptor = (editor) => ({
				init: { bindEvents: noop },
				undoManager: {
					beforeChange: (locks, beforeBookmark) => beforeChange$1(editor, locks, beforeBookmark),
					add: (undoManager, index, locks, beforeBookmark, level, event) => addUndoLevel$1(editor, undoManager, index, locks, beforeBookmark, level, event),
					undo: (undoManager, locks, index) => undo$1(editor, undoManager, locks, index),
					redo: (index, data$1) => redo$1(editor, index, data$1),
					clear: (undoManager, index) => clear$1(editor, undoManager, index),
					reset: (undoManager) => reset$1(undoManager),
					hasUndo: (undoManager, index) => hasUndo$1(editor, undoManager, index),
					hasRedo: (undoManager, index) => hasRedo$1(undoManager, index),
					transact: (undoManager, locks, callback) => transact$1(undoManager, locks, callback),
					ignore: (locks, callback) => ignore$1(locks, callback),
					extra: (undoManager, index, callback1, callback2) => extra$1(editor, undoManager, index, callback1, callback2)
				},
				formatter: {
					match: (name$1, vars, node, similar) => match$2(editor, name$1, vars, node, similar),
					matchAll: (names, vars) => matchAll(editor, names, vars),
					matchNode: (node, name$1, vars, similar) => matchNode(editor, node, name$1, vars, similar),
					canApply: (name$1) => canApply(editor, name$1),
					closest: (names) => closest(editor, names),
					apply: (name$1, vars, node) => applyFormat$1(editor, name$1, vars, node),
					remove: (name$1, vars, node, similar) => removeFormat$1(editor, name$1, vars, node, similar),
					toggle: (name$1, vars, node) => toggle(editor, name$1, vars, node),
					formatChanged: (registeredFormatListeners, formats, callback, similar, vars) => formatChangedInternal(editor, registeredFormatListeners, formats, callback, similar, vars)
				},
				editor: {
					getContent: (args) => getContentInternal(editor, args),
					setContent: (content, args) => setContentInternal(editor, content, args),
					insertContent: (value$3, details) => insertHtmlAtCaret(editor, value$3, details),
					addVisual: (elm) => addVisualInternal(editor, elm)
				},
				selection: { getContent: (format, args) => getSelectedContentInternal(editor, format, args) },
				autocompleter: {
					addDecoration: (range) => create$9(editor, range),
					removeDecoration: () => remove$2(editor, SugarElement.fromDom(editor.getBody()))
				},
				raw: { getModel: () => Optional.none() }
			});
			const makeRtcAdaptor = (rtcEditor) => {
				const defaultVars = (vars) => isObject(vars) ? vars : {};
				const { init: init$3, undoManager, formatter, editor, selection, autocompleter, raw } = rtcEditor;
				return {
					init: { bindEvents: init$3.bindEvents },
					undoManager: {
						beforeChange: undoManager.beforeChange,
						add: undoManager.add,
						undo: undoManager.undo,
						redo: undoManager.redo,
						clear: undoManager.clear,
						reset: undoManager.reset,
						hasUndo: undoManager.hasUndo,
						hasRedo: undoManager.hasRedo,
						transact: (_undoManager, _locks, fn) => undoManager.transact(fn),
						ignore: (_locks, callback) => undoManager.ignore(callback),
						extra: (_undoManager, _index, callback1, callback2) => undoManager.extra(callback1, callback2)
					},
					formatter: {
						match: (name$1, vars, _node, similar) => formatter.match(name$1, defaultVars(vars), similar),
						matchAll: formatter.matchAll,
						matchNode: formatter.matchNode,
						canApply: (name$1) => formatter.canApply(name$1),
						closest: (names) => formatter.closest(names),
						apply: (name$1, vars, _node) => formatter.apply(name$1, defaultVars(vars)),
						remove: (name$1, vars, _node, _similar) => formatter.remove(name$1, defaultVars(vars)),
						toggle: (name$1, vars, _node) => formatter.toggle(name$1, defaultVars(vars)),
						formatChanged: (_rfl, formats, callback, similar, vars) => formatter.formatChanged(formats, callback, similar, vars)
					},
					editor: {
						getContent: (args) => editor.getContent(args),
						setContent: (content, args) => {
							return {
								content: editor.setContent(content, args),
								html: ""
							};
						},
						insertContent: (content, _details) => {
							editor.insertContent(content);
							return "";
						},
						addVisual: editor.addVisual
					},
					selection: { getContent: (_format, args) => selection.getContent(args) },
					autocompleter: {
						addDecoration: autocompleter.addDecoration,
						removeDecoration: autocompleter.removeDecoration
					},
					raw: { getModel: () => Optional.some(raw.getRawModel()) }
				};
			};
			const makeNoopAdaptor = () => {
				const nul = constant(null);
				const empty$1 = constant("");
				return {
					init: { bindEvents: noop },
					undoManager: {
						beforeChange: noop,
						add: nul,
						undo: nul,
						redo: nul,
						clear: noop,
						reset: noop,
						hasUndo: never,
						hasRedo: never,
						transact: nul,
						ignore: noop,
						extra: noop
					},
					formatter: {
						match: never,
						matchAll: constant([]),
						matchNode: constant(void 0),
						canApply: never,
						closest: empty$1,
						apply: noop,
						remove: noop,
						toggle: noop,
						formatChanged: constant({ unbind: noop })
					},
					editor: {
						getContent: empty$1,
						setContent: constant({
							content: "",
							html: ""
						}),
						insertContent: constant(""),
						addVisual: noop
					},
					selection: { getContent: empty$1 },
					autocompleter: {
						addDecoration: noop,
						removeDecoration: noop
					},
					raw: { getModel: constant(Optional.none()) }
				};
			};
			const isRtc = (editor) => has$2(editor.plugins, "rtc");
			const getRtcSetup = (editor) => get$a(editor.plugins, "rtc").bind((rtcPlugin) => Optional.from(rtcPlugin.setup));
			const setup$s = (editor) => {
				const editorCast = editor;
				return getRtcSetup(editor).fold(() => {
					editorCast.rtcInstance = makePlainAdaptor(editor);
					return Optional.none();
				}, (setup$10) => {
					editorCast.rtcInstance = makeNoopAdaptor();
					return Optional.some(() => setup$10().then((rtcEditor) => {
						editorCast.rtcInstance = makeRtcAdaptor(rtcEditor);
						return rtcEditor.rtc.isRemote;
					}));
				});
			};
			const getRtcInstanceWithFallback = (editor) => editor.rtcInstance ? editor.rtcInstance : makePlainAdaptor(editor);
			const getRtcInstanceWithError = (editor) => {
				const rtcInstance = editor.rtcInstance;
				if (!rtcInstance) throw new Error("Failed to get RTC instance not yet initialized.");
				else return rtcInstance;
			};
			const beforeChange = (editor, locks, beforeBookmark) => {
				getRtcInstanceWithError(editor).undoManager.beforeChange(locks, beforeBookmark);
			};
			const addUndoLevel = (editor, undoManager, index, locks, beforeBookmark, level, event) => getRtcInstanceWithError(editor).undoManager.add(undoManager, index, locks, beforeBookmark, level, event);
			const undo = (editor, undoManager, locks, index) => getRtcInstanceWithError(editor).undoManager.undo(undoManager, locks, index);
			const redo = (editor, index, data$1) => getRtcInstanceWithError(editor).undoManager.redo(index, data$1);
			const clear = (editor, undoManager, index) => {
				getRtcInstanceWithError(editor).undoManager.clear(undoManager, index);
			};
			const reset = (editor, undoManager) => {
				getRtcInstanceWithError(editor).undoManager.reset(undoManager);
			};
			const hasUndo = (editor, undoManager, index) => getRtcInstanceWithError(editor).undoManager.hasUndo(undoManager, index);
			const hasRedo = (editor, undoManager, index) => getRtcInstanceWithError(editor).undoManager.hasRedo(undoManager, index);
			const transact = (editor, undoManager, locks, callback) => getRtcInstanceWithError(editor).undoManager.transact(undoManager, locks, callback);
			const ignore = (editor, locks, callback) => {
				getRtcInstanceWithError(editor).undoManager.ignore(locks, callback);
			};
			const extra = (editor, undoManager, index, callback1, callback2) => {
				getRtcInstanceWithError(editor).undoManager.extra(undoManager, index, callback1, callback2);
			};
			const matchFormat = (editor, name$1, vars, node, similar) => getRtcInstanceWithError(editor).formatter.match(name$1, vars, node, similar);
			const matchAllFormats = (editor, names, vars) => getRtcInstanceWithError(editor).formatter.matchAll(names, vars);
			const matchNodeFormat = (editor, node, name$1, vars, similar) => getRtcInstanceWithError(editor).formatter.matchNode(node, name$1, vars, similar);
			const canApplyFormat = (editor, name$1) => getRtcInstanceWithError(editor).formatter.canApply(name$1);
			const closestFormat = (editor, names) => getRtcInstanceWithError(editor).formatter.closest(names);
			const applyFormat = (editor, name$1, vars, node) => {
				getRtcInstanceWithError(editor).formatter.apply(name$1, vars, node);
			};
			const removeFormat = (editor, name$1, vars, node, similar) => {
				getRtcInstanceWithError(editor).formatter.remove(name$1, vars, node, similar);
			};
			const toggleFormat = (editor, name$1, vars, node) => {
				getRtcInstanceWithError(editor).formatter.toggle(name$1, vars, node);
			};
			const formatChanged = (editor, registeredFormatListeners, formats, callback, similar, vars) => getRtcInstanceWithError(editor).formatter.formatChanged(registeredFormatListeners, formats, callback, similar, vars);
			const getContent$2 = (editor, args) => getRtcInstanceWithFallback(editor).editor.getContent(args);
			const setContent$2 = (editor, content, args) => getRtcInstanceWithFallback(editor).editor.setContent(content, args);
			const insertContent$1 = (editor, value$3, details) => getRtcInstanceWithFallback(editor).editor.insertContent(value$3, details);
			const getSelectedContent = (editor, format, args) => getRtcInstanceWithError(editor).selection.getContent(format, args);
			const addVisual$1 = (editor, elm) => getRtcInstanceWithError(editor).editor.addVisual(elm);
			const bindEvents = (editor) => getRtcInstanceWithError(editor).init.bindEvents();
			const addAutocompleterDecoration = (editor, range) => getRtcInstanceWithError(editor).autocompleter.addDecoration(range);
			const removeAutocompleterDecoration = (editor) => getRtcInstanceWithError(editor).autocompleter.removeDecoration();
			const getContent$1 = (editor, args = {}) => {
				return getSelectedContent(editor, args.format ? args.format : "html", args);
			};
			const removeEmpty = (text$1) => {
				if (text$1.dom.length === 0) {
					remove$5(text$1);
					return Optional.none();
				} else return Optional.some(text$1);
			};
			const walkPastBookmark = (node, start$2) => node.filter((elm) => BookmarkManager.isBookmarkNode(elm.dom)).bind(start$2 ? nextSibling : prevSibling);
			const merge$1 = (outer, inner, rng, start$2) => {
				const outerElm = outer.dom;
				const innerElm = inner.dom;
				const oldLength = start$2 ? outerElm.length : innerElm.length;
				if (start$2) {
					mergeTextNodes(outerElm, innerElm, false, !start$2);
					rng.setStart(innerElm, oldLength);
				} else {
					mergeTextNodes(innerElm, outerElm, false, !start$2);
					rng.setEnd(innerElm, oldLength);
				}
			};
			const normalizeTextIfRequired = (inner, start$2) => {
				parent(inner).each((root) => {
					const text$1 = inner.dom;
					if (start$2 && needsToBeNbspLeft(root, CaretPosition(text$1, 0))) normalizeWhitespaceAfter(text$1, 0);
					else if (!start$2 && needsToBeNbspRight(root, CaretPosition(text$1, text$1.length))) normalizeWhitespaceBefore(text$1, text$1.length);
				});
			};
			const mergeAndNormalizeText = (outerNode, innerNode, rng, start$2) => {
				outerNode.bind((outer) => {
					(start$2 ? normalizeWhitespaceBefore : normalizeWhitespaceAfter)(outer.dom, start$2 ? outer.dom.length : 0);
					return innerNode.filter(isText$b).map((inner) => merge$1(outer, inner, rng, start$2));
				}).orThunk(() => {
					return walkPastBookmark(innerNode, start$2).or(innerNode).filter(isText$b).map((inner) => normalizeTextIfRequired(inner, start$2));
				});
			};
			const rngSetContent = (rng, fragment) => {
				const firstChild$1 = Optional.from(fragment.firstChild).map(SugarElement.fromDom);
				const lastChild$1 = Optional.from(fragment.lastChild).map(SugarElement.fromDom);
				rng.deleteContents();
				rng.insertNode(fragment);
				const prevText = firstChild$1.bind(prevSibling).filter(isText$b).bind(removeEmpty);
				const nextText = lastChild$1.bind(nextSibling).filter(isText$b).bind(removeEmpty);
				mergeAndNormalizeText(prevText, firstChild$1, rng, true);
				mergeAndNormalizeText(nextText, lastChild$1, rng, false);
				rng.collapse(false);
			};
			const setupArgs$2 = (args, content) => ({
				format: "html",
				...args,
				set: true,
				selection: true,
				content
			});
			const cleanContent = (editor, args) => {
				if (args.format !== "raw") {
					const rng = editor.selection.getRng();
					const contextBlock = editor.dom.getParent(rng.commonAncestorContainer, editor.dom.isBlock);
					const contextArgs = contextBlock ? { context: contextBlock.nodeName.toLowerCase() } : {};
					const node = editor.parser.parse(args.content, {
						forced_root_block: false,
						...contextArgs,
						...args
					});
					return HtmlSerializer({ validate: false }, editor.schema).serialize(node);
				} else return args.content;
			};
			const setContent$1 = (editor, content, args = {}) => {
				preProcessSetContent(editor, setupArgs$2(args, content)).each((updatedArgs) => {
					const cleanedContent = cleanContent(editor, updatedArgs);
					const rng = editor.selection.getRng();
					rngSetContent(rng, rng.createContextualFragment(cleanedContent));
					editor.selection.setRng(rng);
					scrollRangeIntoView(editor, rng);
					postProcessSetContent(editor, cleanedContent, updatedArgs);
				});
			};
			const deleteFromCallbackMap = (callbackMap, selector, callback) => {
				if (has$2(callbackMap, selector)) {
					const newCallbacks = filter$5(callbackMap[selector], (cb) => cb !== callback);
					if (newCallbacks.length === 0) delete callbackMap[selector];
					else callbackMap[selector] = newCallbacks;
				}
			};
			var SelectorChanged = (dom$1, editor) => {
				let selectorChangedData;
				let currentSelectors;
				const findMatchingNode = (selector, nodes) => find$2(nodes, (node) => dom$1.is(node, selector));
				const getParents$4 = (elem) => dom$1.getParents(elem, void 0, dom$1.getRoot());
				const setup$10 = () => {
					selectorChangedData = {};
					currentSelectors = {};
					editor.on("NodeChange", (e) => {
						const node = e.element;
						const parents$2 = getParents$4(node);
						const matchedSelectors = {};
						each$d(selectorChangedData, (callbacks, selector) => {
							findMatchingNode(selector, parents$2).each((node$1) => {
								if (!currentSelectors[selector]) {
									each$e(callbacks, (callback) => {
										callback(true, {
											node: node$1,
											selector,
											parents: parents$2
										});
									});
									currentSelectors[selector] = callbacks;
								}
								matchedSelectors[selector] = callbacks;
							});
						});
						each$d(currentSelectors, (callbacks, selector) => {
							if (!matchedSelectors[selector]) {
								delete currentSelectors[selector];
								each$e(callbacks, (callback) => {
									callback(false, {
										node,
										selector,
										parents: parents$2
									});
								});
							}
						});
					});
				};
				return { selectorChangedWithUnbind: (selector, callback) => {
					if (!selectorChangedData) setup$10();
					if (!selectorChangedData[selector]) selectorChangedData[selector] = [];
					selectorChangedData[selector].push(callback);
					findMatchingNode(selector, getParents$4(editor.selection.getStart())).each(() => {
						currentSelectors[selector] = selectorChangedData[selector];
					});
					return { unbind: () => {
						deleteFromCallbackMap(selectorChangedData, selector, callback);
						deleteFromCallbackMap(currentSelectors, selector, callback);
					} };
				} };
			};
			const isAttachedToDom = (node) => {
				return !!(node && node.ownerDocument) && contains(SugarElement.fromDom(node.ownerDocument), SugarElement.fromDom(node));
			};
			const isValidRange = (rng) => {
				if (!rng) return false;
				else return isAttachedToDom(rng.startContainer) && isAttachedToDom(rng.endContainer);
			};
			const EditorSelection = (dom$1, win, serializer, editor) => {
				let selectedRange;
				let explicitRange;
				const { selectorChangedWithUnbind } = SelectorChanged(dom$1, editor);
				const setCursorLocation = (node, offset) => {
					const rng = dom$1.createRng();
					if (isNonNullable(node) && isNonNullable(offset)) {
						rng.setStart(node, offset);
						rng.setEnd(node, offset);
						setRng(rng);
						collapse$1(false);
					} else {
						moveEndPoint(dom$1, rng, editor.getBody(), true);
						setRng(rng);
					}
				};
				const getContent$3 = (args) => getContent$1(editor, args);
				const setContent$3 = (content, args) => setContent$1(editor, content, args);
				const getStart$1$1 = (real) => getStart(editor.getBody(), getRng$1(), real);
				const getEnd$2 = (real) => getEnd$1(editor.getBody(), getRng$1(), real);
				const getBookmark$3 = (type$2, normalized) => bookmarkManager.getBookmark(type$2, normalized);
				const moveToBookmark$1 = (bookmark) => bookmarkManager.moveToBookmark(bookmark);
				const select$1 = (node, content) => {
					select(dom$1, node, content).each(setRng);
					return node;
				};
				const isCollapsed = () => {
					const rng = getRng$1(), sel = getSel();
					if (!rng || rng.item) return false;
					if (rng.compareEndPoints) return rng.compareEndPoints("StartToEnd", rng) === 0;
					return !sel || rng.collapsed;
				};
				const isEditable$4 = () => {
					const rng = getRng$1();
					const fakeSelectedElements = editor.getBody().querySelectorAll("[data-mce-selected=\"1\"]");
					if (fakeSelectedElements.length > 0) return forall(fakeSelectedElements, (el) => dom$1.isEditable(el.parentElement));
					else if (rng.startContainer === rng.endContainer) return dom$1.isEditable(rng.startContainer);
					else return dom$1.isEditable(rng.startContainer) && dom$1.isEditable(rng.endContainer);
				};
				const collapse$1 = (toStart) => {
					const rng = getRng$1();
					rng.collapse(!!toStart);
					setRng(rng);
				};
				const getSel = () => win.getSelection ? win.getSelection() : win.document.selection;
				const getRng$1 = () => {
					let rng;
					const tryCompareBoundaryPoints = (how, sourceRange, destinationRange) => {
						try {
							return sourceRange.compareBoundaryPoints(how, destinationRange);
						} catch (ex) {
							return -1;
						}
					};
					const doc = win.document;
					if (isNonNullable(editor.bookmark) && !hasFocus(editor)) {
						const bookmark = getRng(editor);
						if (bookmark.isSome()) return bookmark.map((r$1) => processRanges(editor, [r$1])[0]).getOr(doc.createRange());
					}
					try {
						const selection = getSel();
						if (selection && !isRestrictedNode(selection.anchorNode)) {
							if (selection.rangeCount > 0) rng = selection.getRangeAt(0);
							else rng = doc.createRange();
							rng = processRanges(editor, [rng])[0];
						}
					} catch (ex) {}
					if (!rng) rng = doc.createRange();
					if (isDocument$1(rng.startContainer) && rng.collapsed) {
						const elm = dom$1.getRoot();
						rng.setStart(elm, 0);
						rng.setEnd(elm, 0);
					}
					if (selectedRange && explicitRange) if (tryCompareBoundaryPoints(rng.START_TO_START, rng, selectedRange) === 0 && tryCompareBoundaryPoints(rng.END_TO_END, rng, selectedRange) === 0) rng = explicitRange;
					else {
						selectedRange = null;
						explicitRange = null;
					}
					return rng;
				};
				const setRng = (rng, forward) => {
					if (!isValidRange(rng)) return;
					const sel = getSel();
					rng = editor.dispatch("SetSelectionRange", {
						range: rng,
						forward
					}).range;
					if (sel) {
						explicitRange = rng;
						try {
							sel.removeAllRanges();
							sel.addRange(rng);
						} catch (ex) {}
						if (forward === false && sel.extend) {
							sel.collapse(rng.endContainer, rng.endOffset);
							sel.extend(rng.startContainer, rng.startOffset);
						}
						selectedRange = sel.rangeCount > 0 ? sel.getRangeAt(0) : null;
					}
					if (!rng.collapsed && rng.startContainer === rng.endContainer && (sel === null || sel === void 0 ? void 0 : sel.setBaseAndExtent)) {
						if (rng.endOffset - rng.startOffset < 2) {
							if (rng.startContainer.hasChildNodes()) {
								const node = rng.startContainer.childNodes[rng.startOffset];
								if (node && node.nodeName === "IMG") {
									sel.setBaseAndExtent(rng.startContainer, rng.startOffset, rng.endContainer, rng.endOffset);
									if (sel.anchorNode !== rng.startContainer || sel.focusNode !== rng.endContainer) sel.setBaseAndExtent(node, 0, node, 1);
								}
							}
						}
					}
					editor.dispatch("AfterSetSelectionRange", {
						range: rng,
						forward
					});
				};
				const setNode = (elm) => {
					setContent$3(dom$1.getOuterHTML(elm));
					return elm;
				};
				const getNode$1$1 = () => getNode(editor.getBody(), getRng$1());
				const getSelectedBlocks$1 = (startElm, endElm) => getSelectedBlocks(dom$1, getRng$1(), startElm, endElm);
				const isForward = () => {
					const sel = getSel();
					const anchorNode = sel === null || sel === void 0 ? void 0 : sel.anchorNode;
					const focusNode = sel === null || sel === void 0 ? void 0 : sel.focusNode;
					if (!sel || !anchorNode || !focusNode || isRestrictedNode(anchorNode) || isRestrictedNode(focusNode)) return true;
					const anchorRange = dom$1.createRng();
					const focusRange = dom$1.createRng();
					try {
						anchorRange.setStart(anchorNode, sel.anchorOffset);
						anchorRange.collapse(true);
						focusRange.setStart(focusNode, sel.focusOffset);
						focusRange.collapse(true);
					} catch (e) {
						return true;
					}
					return anchorRange.compareBoundaryPoints(anchorRange.START_TO_START, focusRange) <= 0;
				};
				const normalize$5 = () => {
					const rng = getRng$1();
					if (!hasMultipleRanges(getSel()) && hasAnyRanges(editor)) {
						const normRng = normalize$2(dom$1, rng);
						normRng.each((normRng$1) => {
							setRng(normRng$1, isForward());
						});
						return normRng.getOr(rng);
					}
					return rng;
				};
				const selectorChanged = (selector, callback) => {
					selectorChangedWithUnbind(selector, callback);
					return exports$1;
				};
				const getScrollContainer = () => {
					let scrollContainer;
					let node = dom$1.getRoot();
					while (node && node.nodeName !== "BODY") {
						if (node.scrollHeight > node.clientHeight) {
							scrollContainer = node;
							break;
						}
						node = node.parentNode;
					}
					return scrollContainer;
				};
				const scrollIntoView = (elm, alignToTop) => {
					if (isNonNullable(elm)) scrollElementIntoView(editor, elm, alignToTop);
					else scrollRangeIntoView(editor, getRng$1(), alignToTop);
				};
				const placeCaretAt$1 = (clientX, clientY) => setRng(fromPoint(clientX, clientY, editor.getDoc()));
				const getBoundingClientRect$2 = () => {
					const rng = getRng$1();
					return rng.collapsed ? CaretPosition.fromRangeStart(rng).getClientRects()[0] : rng.getBoundingClientRect();
				};
				const destroy$1 = () => {
					win = selectedRange = explicitRange = null;
					controlSelection.destroy();
				};
				const expand = (options = { type: "word" }) => setRng(RangeUtils(dom$1).expand(getRng$1(), options));
				const exports$1 = {
					dom: dom$1,
					win,
					serializer,
					editor,
					expand,
					collapse: collapse$1,
					setCursorLocation,
					getContent: getContent$3,
					setContent: setContent$3,
					getBookmark: getBookmark$3,
					moveToBookmark: moveToBookmark$1,
					select: select$1,
					isCollapsed,
					isEditable: isEditable$4,
					isForward,
					setNode,
					getNode: getNode$1$1,
					getSel,
					setRng,
					getRng: getRng$1,
					getStart: getStart$1$1,
					getEnd: getEnd$2,
					getSelectedBlocks: getSelectedBlocks$1,
					normalize: normalize$5,
					selectorChanged,
					selectorChangedWithUnbind,
					getScrollContainer,
					scrollIntoView,
					placeCaretAt: placeCaretAt$1,
					getBoundingClientRect: getBoundingClientRect$2,
					destroy: destroy$1
				};
				const bookmarkManager = BookmarkManager(exports$1);
				const controlSelection = ControlSelection(exports$1, editor);
				exports$1.bookmarkManager = bookmarkManager;
				exports$1.controlSelection = controlSelection;
				return exports$1;
			};
			const register$3 = (htmlParser, settings, dom$1) => {
				htmlParser.addAttributeFilter("data-mce-tabindex", (nodes, name$1) => {
					let i = nodes.length;
					while (i--) {
						const node = nodes[i];
						node.attr("tabindex", node.attr("data-mce-tabindex"));
						node.attr(name$1, null);
					}
				});
				htmlParser.addAttributeFilter("src,href,style", (nodes, name$1) => {
					const internalName = "data-mce-" + name$1;
					const urlConverter = settings.url_converter;
					const urlConverterScope = settings.url_converter_scope;
					let i = nodes.length;
					while (i--) {
						const node = nodes[i];
						let value$3 = node.attr(internalName);
						if (value$3 !== void 0) {
							node.attr(name$1, value$3.length > 0 ? value$3 : null);
							node.attr(internalName, null);
						} else {
							value$3 = node.attr(name$1);
							if (name$1 === "style") value$3 = dom$1.serializeStyle(dom$1.parseStyle(value$3), node.name);
							else if (urlConverter) value$3 = urlConverter.call(urlConverterScope, value$3, name$1, node.name);
							node.attr(name$1, value$3.length > 0 ? value$3 : null);
						}
					}
				});
				htmlParser.addAttributeFilter("class", (nodes) => {
					let i = nodes.length;
					while (i--) {
						const node = nodes[i];
						let value$3 = node.attr("class");
						if (value$3) {
							value$3 = value$3.replace(/(?:^|\s)mce-item-\w+(?!\S)/g, "");
							node.attr("class", value$3.length > 0 ? value$3 : null);
						}
					}
				});
				htmlParser.addAttributeFilter("data-mce-type", (nodes, name$1, args) => {
					let i = nodes.length;
					while (i--) {
						const node = nodes[i];
						if (node.attr("data-mce-type") === "bookmark" && !args.cleanup) if (Optional.from(node.firstChild).exists((firstChild$1) => {
							var _a;
							return !isZwsp$1((_a = firstChild$1.value) !== null && _a !== void 0 ? _a : "");
						})) node.unwrap();
						else node.remove();
					}
				});
				htmlParser.addNodeFilter("noscript", (nodes) => {
					var _a;
					let i = nodes.length;
					while (i--) {
						const node = nodes[i].firstChild;
						if (node) node.value = Entities.decode((_a = node.value) !== null && _a !== void 0 ? _a : "");
					}
				});
				htmlParser.addNodeFilter("script,style", (nodes, name$1) => {
					var _a;
					const trim$4 = (value$3) => {
						return value$3.replace(/(<!--\[CDATA\[|\]\]-->)/g, "\n").replace(/^[\r\n]*|[\r\n]*$/g, "").replace(/^\s*((<!--)?(\s*\/\/)?\s*<!\[CDATA\[|(<!--\s*)?\/\*\s*<!\[CDATA\[\s*\*\/|(\/\/)?\s*<!--|\/\*\s*<!--\s*\*\/)\s*[\r\n]*/gi, "").replace(/\s*(\/\*\s*\]\]>\s*\*\/(-->)?|\s*\/\/\s*\]\]>(-->)?|\/\/\s*(-->)?|\]\]>|\/\*\s*-->\s*\*\/|\s*-->\s*)\s*$/g, "");
					};
					let i = nodes.length;
					while (i--) {
						const node = nodes[i];
						const firstChild$1 = node.firstChild;
						const value$3 = (_a = firstChild$1 === null || firstChild$1 === void 0 ? void 0 : firstChild$1.value) !== null && _a !== void 0 ? _a : "";
						if (name$1 === "script") {
							const type$2 = node.attr("type");
							if (type$2) node.attr("type", type$2 === "mce-no/type" ? null : type$2.replace(/^mce\-/, ""));
							if (settings.element_format === "xhtml" && firstChild$1 && value$3.length > 0) firstChild$1.value = "// <![CDATA[\n" + trim$4(value$3) + "\n// ]]>";
						} else if (settings.element_format === "xhtml" && firstChild$1 && value$3.length > 0) firstChild$1.value = "<!--\n" + trim$4(value$3) + "\n-->";
					}
				});
				htmlParser.addNodeFilter("#comment", (nodes) => {
					let i = nodes.length;
					while (i--) {
						const node = nodes[i];
						const value$3 = node.value;
						if (settings.preserve_cdata && (value$3 === null || value$3 === void 0 ? void 0 : value$3.indexOf("[CDATA[")) === 0) {
							node.name = "#cdata";
							node.type = 4;
							node.value = dom$1.decode(value$3.replace(/^\[CDATA\[|\]\]$/g, ""));
						} else if ((value$3 === null || value$3 === void 0 ? void 0 : value$3.indexOf("mce:protected ")) === 0) {
							node.name = "#text";
							node.type = 3;
							node.raw = true;
							node.value = unescape(value$3).substr(14);
						}
					}
				});
				htmlParser.addNodeFilter("xml:namespace,input", (nodes, name$1) => {
					let i = nodes.length;
					while (i--) {
						const node = nodes[i];
						if (node.type === 7) node.remove();
						else if (node.type === 1) {
							if (name$1 === "input" && !node.attr("type")) node.attr("type", "text");
						}
					}
				});
				htmlParser.addAttributeFilter("data-mce-type", (nodes) => {
					each$e(nodes, (node) => {
						if (node.attr("data-mce-type") === "format-caret") if (node.isEmpty(htmlParser.schema.getNonEmptyElements())) node.remove();
						else node.unwrap();
					});
				});
				htmlParser.addAttributeFilter("data-mce-src,data-mce-href,data-mce-style,data-mce-selected,data-mce-expando,data-mce-block,data-mce-type,data-mce-resize,data-mce-placeholder", (nodes, name$1) => {
					let i = nodes.length;
					while (i--) nodes[i].attr(name$1, null);
				});
				if (settings.remove_trailing_brs) addNodeFilter(settings, htmlParser, htmlParser.schema);
			};
			const trimTrailingBr = (rootNode) => {
				const isBr$7 = (node) => {
					return (node === null || node === void 0 ? void 0 : node.name) === "br";
				};
				const brNode1 = rootNode.lastChild;
				if (isBr$7(brNode1)) {
					const brNode2 = brNode1.prev;
					if (isBr$7(brNode2)) {
						brNode1.remove();
						brNode2.remove();
					}
				}
			};
			const preProcess$1 = (editor, node, args) => {
				let oldDoc;
				const dom$1 = editor.dom;
				let clonedNode = node.cloneNode(true);
				const impl = document.implementation;
				if (impl.createHTMLDocument) {
					const doc = impl.createHTMLDocument("");
					Tools.each(clonedNode.nodeName === "BODY" ? clonedNode.childNodes : [clonedNode], (node$1) => {
						doc.body.appendChild(doc.importNode(node$1, true));
					});
					if (clonedNode.nodeName !== "BODY") clonedNode = doc.body.firstChild;
					else clonedNode = doc.body;
					oldDoc = dom$1.doc;
					dom$1.doc = doc;
				}
				firePreProcess(editor, {
					...args,
					node: clonedNode
				});
				if (oldDoc) dom$1.doc = oldDoc;
				return clonedNode;
			};
			const shouldFireEvent = (editor, args) => {
				return isNonNullable(editor) && editor.hasEventListeners("PreProcess") && !args.no_events;
			};
			const process$1 = (editor, node, args) => {
				return shouldFireEvent(editor, args) ? preProcess$1(editor, node, args) : node;
			};
			const addTempAttr = (htmlParser, tempAttrs, name$1) => {
				if (Tools.inArray(tempAttrs, name$1) === -1) {
					htmlParser.addAttributeFilter(name$1, (nodes, name$2) => {
						let i = nodes.length;
						while (i--) nodes[i].attr(name$2, null);
					});
					tempAttrs.push(name$1);
				}
			};
			const postProcess = (editor, args, content) => {
				if (!args.no_events && editor) return firePostProcess(editor, {
					...args,
					content
				}).content;
				else return content;
			};
			const getHtmlFromNode = (dom$1, node, args) => {
				const html$2 = trim$1(args.getInner ? node.innerHTML : dom$1.getOuterHTML(node));
				return args.selection || isWsPreserveElement(SugarElement.fromDom(node)) ? html$2 : Tools.trim(html$2);
			};
			const parseHtml = (htmlParser, html$2, args) => {
				const parserArgs = args.selection ? {
					forced_root_block: false,
					...args
				} : args;
				const rootNode = htmlParser.parse(html$2, parserArgs);
				trimTrailingBr(rootNode);
				return rootNode;
			};
			const serializeNode = (settings, schema, node) => {
				return HtmlSerializer(settings, schema).serialize(node);
			};
			const toHtml = (editor, settings, schema, rootNode, args) => {
				return postProcess(editor, args, serializeNode(settings, schema, rootNode));
			};
			const DomSerializerImpl = (settings, editor) => {
				const tempAttrs = ["data-mce-selected"];
				const defaultedSettings = {
					entity_encoding: "named",
					remove_trailing_brs: true,
					pad_empty_with_br: false,
					...settings
				};
				const dom$1 = editor && editor.dom ? editor.dom : DOMUtils.DOM;
				const schema = editor && editor.schema ? editor.schema : Schema(defaultedSettings);
				const htmlParser = DomParser(defaultedSettings, schema);
				register$3(htmlParser, defaultedSettings, dom$1);
				const serialize = (node, parserArgs = {}) => {
					const args = {
						format: "html",
						...parserArgs
					};
					const rootNode = parseHtml(htmlParser, getHtmlFromNode(dom$1, process$1(editor, node, args), args), args);
					return args.format === "tree" ? rootNode : toHtml(editor, defaultedSettings, schema, rootNode, args);
				};
				return {
					schema,
					addNodeFilter: htmlParser.addNodeFilter,
					addAttributeFilter: htmlParser.addAttributeFilter,
					serialize,
					addRules: schema.addValidElements,
					setRules: schema.setValidElements,
					addTempAttr: curry(addTempAttr, htmlParser, tempAttrs),
					getTempAttrs: constant(tempAttrs),
					getNodeFilters: htmlParser.getNodeFilters,
					getAttributeFilters: htmlParser.getAttributeFilters,
					removeNodeFilter: htmlParser.removeNodeFilter,
					removeAttributeFilter: htmlParser.removeAttributeFilter
				};
			};
			const DomSerializer = (settings, editor) => {
				const domSerializer = DomSerializerImpl(settings, editor);
				return {
					schema: domSerializer.schema,
					addNodeFilter: domSerializer.addNodeFilter,
					addAttributeFilter: domSerializer.addAttributeFilter,
					serialize: domSerializer.serialize,
					addRules: domSerializer.addRules,
					setRules: domSerializer.setRules,
					addTempAttr: domSerializer.addTempAttr,
					getTempAttrs: domSerializer.getTempAttrs,
					getNodeFilters: domSerializer.getNodeFilters,
					getAttributeFilters: domSerializer.getAttributeFilters,
					removeNodeFilter: domSerializer.removeNodeFilter,
					removeAttributeFilter: domSerializer.removeAttributeFilter
				};
			};
			const defaultFormat$1 = "html";
			const setupArgs$1 = (args, format) => ({
				...args,
				format,
				get: true,
				getInner: true
			});
			const getContent = (editor, args = {}) => {
				return preProcessGetContent(editor, setupArgs$1(args, args.format ? args.format : defaultFormat$1)).fold(identity, (updatedArgs) => {
					return postProcessGetContent(editor, getContent$2(editor, updatedArgs), updatedArgs);
				});
			};
			const defaultFormat = "html";
			const setupArgs = (args, content) => ({
				format: defaultFormat,
				...args,
				set: true,
				content
			});
			const setContent = (editor, content, args = {}) => {
				return preProcessSetContent(editor, setupArgs(args, content)).map((updatedArgs) => {
					const result = setContent$2(editor, updatedArgs.content, updatedArgs);
					postProcessSetContent(editor, result.html, updatedArgs);
					return result.content;
				}).getOr(content);
			};
			const removedOptions = "autoresize_on_init,content_editable_state,padd_empty_with_br,block_elements,boolean_attributes,editor_deselector,editor_selector,elements,file_browser_callback_types,filepicker_validator_handler,force_hex_style_colors,force_p_newlines,gecko_spellcheck,images_dataimg_filter,media_scripts,mode,move_caret_before_on_enter_elements,non_empty_elements,self_closing_elements,short_ended_elements,special,spellchecker_select_languages,spellchecker_whitelist,tab_focus,tabfocus_elements,table_responsive_width,text_block_elements,text_inline_elements,toolbar_drawer,types,validate,whitespace_elements,paste_enable_default_filters,paste_filter_drop,paste_word_valid_elements,paste_retain_style_properties,paste_convert_word_fake_lists".split(",");
			const deprecatedOptions = "template_cdate_classes,template_mdate_classes,template_selected_content_classes,template_preview_replace_values,template_replace_values,templates,template_cdate_format,template_mdate_format".split(",");
			const removedPlugins = "bbcode,colorpicker,contextmenu,fullpage,legacyoutput,spellchecker,textcolor".split(",");
			const deprecatedPlugins = [{
				name: "template",
				replacedWith: "Advanced Template"
			}, { name: "rtc" }];
			const getMatchingOptions = (options, searchingFor) => {
				return sort(filter$5(searchingFor, (setting) => has$2(options, setting)));
			};
			const getRemovedOptions = (options) => {
				const settingNames = getMatchingOptions(options, removedOptions);
				const forcedRootBlock = options.forced_root_block;
				if (forcedRootBlock === false || forcedRootBlock === "") settingNames.push("forced_root_block (false only)");
				return sort(settingNames);
			};
			const getDeprecatedOptions = (options) => getMatchingOptions(options, deprecatedOptions);
			const getMatchingPlugins = (options, searchingFor) => {
				const plugins = Tools.makeMap(options.plugins, " ");
				const hasPlugin = (plugin) => has$2(plugins, plugin);
				return sort(filter$5(searchingFor, hasPlugin));
			};
			const getRemovedPlugins = (options) => getMatchingPlugins(options, removedPlugins);
			const getDeprecatedPlugins = (options) => getMatchingPlugins(options, deprecatedPlugins.map((entry) => entry.name));
			const logRemovedWarnings = (rawOptions, normalizedOptions) => {
				const removedOptions$1 = getRemovedOptions(rawOptions);
				const removedPlugins$1 = getRemovedPlugins(normalizedOptions);
				const hasRemovedPlugins = removedPlugins$1.length > 0;
				const hasRemovedOptions = removedOptions$1.length > 0;
				const isLegacyMobileTheme = normalizedOptions.theme === "mobile";
				if (hasRemovedPlugins || hasRemovedOptions || isLegacyMobileTheme) {
					const listJoiner = "\n- ";
					const themesMessage = isLegacyMobileTheme ? `\n\nThemes:${listJoiner}mobile` : "";
					const pluginsMessage = hasRemovedPlugins ? `\n\nPlugins:${listJoiner}${removedPlugins$1.join(listJoiner)}` : "";
					const optionsMessage = hasRemovedOptions ? `\n\nOptions:${listJoiner}${removedOptions$1.join(listJoiner)}` : "";
					console.warn("The following deprecated features are currently enabled and have been removed in TinyMCE 6.0. These features will no longer work and should be removed from the TinyMCE configuration. See https://www.tiny.cloud/docs/tinymce/6/migration-from-5x/ for more information." + themesMessage + pluginsMessage + optionsMessage);
				}
			};
			const getPluginDescription = (name$1) => find$2(deprecatedPlugins, (entry) => entry.name === name$1).fold(() => name$1, (entry) => {
				if (entry.replacedWith) return `${name$1}, replaced by ${entry.replacedWith}`;
				else return name$1;
			});
			const logDeprecatedWarnings = (rawOptions, normalizedOptions) => {
				const deprecatedOptions$1 = getDeprecatedOptions(rawOptions);
				const deprecatedPlugins$1 = getDeprecatedPlugins(normalizedOptions);
				const hasDeprecatedPlugins = deprecatedPlugins$1.length > 0;
				const hasDeprecatedOptions = deprecatedOptions$1.length > 0;
				if (hasDeprecatedPlugins || hasDeprecatedOptions) {
					const listJoiner = "\n- ";
					const pluginsMessage = hasDeprecatedPlugins ? `\n\nPlugins:${listJoiner}${deprecatedPlugins$1.map(getPluginDescription).join(listJoiner)}` : "";
					const optionsMessage = hasDeprecatedOptions ? `\n\nOptions:${listJoiner}${deprecatedOptions$1.join(listJoiner)}` : "";
					console.warn("The following deprecated features are currently enabled but will be removed soon." + pluginsMessage + optionsMessage);
				}
			};
			const logWarnings = (rawOptions, normalizedOptions) => {
				logRemovedWarnings(rawOptions, normalizedOptions);
				logDeprecatedWarnings(rawOptions, normalizedOptions);
			};
			const DOM$8 = DOMUtils.DOM;
			const restoreOriginalStyles = (editor) => {
				DOM$8.setStyle(editor.id, "display", editor.orgDisplay);
			};
			const safeDestroy = (x) => Optional.from(x).each((x$1) => x$1.destroy());
			const clearDomReferences = (editor) => {
				const ed = editor;
				ed.contentAreaContainer = ed.formElement = ed.container = ed.editorContainer = null;
				ed.bodyElement = ed.contentDocument = ed.contentWindow = null;
				ed.iframeElement = ed.targetElm = null;
				const selection = editor.selection;
				if (selection) {
					const dom$1 = selection.dom;
					ed.selection = selection.win = selection.dom = dom$1.doc = null;
				}
			};
			const restoreForm = (editor) => {
				const form = editor.formElement;
				if (form) {
					if (form._mceOldSubmit) {
						form.submit = form._mceOldSubmit;
						delete form._mceOldSubmit;
					}
					DOM$8.unbind(form, "submit reset", editor.formEventDelegate);
				}
			};
			const remove$1 = (editor) => {
				if (!editor.removed) {
					const { _selectionOverrides, editorUpload } = editor;
					const body = editor.getBody();
					const element = editor.getElement();
					if (body) editor.save({ is_removing: true });
					editor.removed = true;
					editor.unbindAllNativeEvents();
					if (editor.hasHiddenInput && isNonNullable(element === null || element === void 0 ? void 0 : element.nextSibling)) DOM$8.remove(element.nextSibling);
					fireRemove(editor);
					editor.editorManager.remove(editor);
					if (!editor.inline && body) restoreOriginalStyles(editor);
					fireDetach(editor);
					DOM$8.remove(editor.getContainer());
					safeDestroy(_selectionOverrides);
					safeDestroy(editorUpload);
					editor.destroy();
				}
			};
			const destroy = (editor, automatic) => {
				const { selection, dom: dom$1 } = editor;
				if (editor.destroyed) return;
				if (!automatic && !editor.removed) {
					editor.remove();
					return;
				}
				if (!automatic) {
					editor.editorManager.off("beforeunload", editor._beforeUnload);
					if (editor.theme && editor.theme.destroy) editor.theme.destroy();
					safeDestroy(selection);
					safeDestroy(dom$1);
				}
				restoreForm(editor);
				clearDomReferences(editor);
				editor.destroyed = true;
			};
			const CreateIconManager = () => {
				const lookup$2 = {};
				const add$5 = (id, iconPack) => {
					lookup$2[id] = iconPack;
				};
				const get$10 = (id) => {
					if (lookup$2[id]) return lookup$2[id];
					else return { icons: {} };
				};
				const has$3 = (id) => has$2(lookup$2, id);
				return {
					add: add$5,
					get: get$10,
					has: has$3
				};
			};
			const IconManager = CreateIconManager();
			const ModelManager = AddOnManager.ModelManager;
			const getProp = (propName, elm) => {
				return elm.dom[propName];
			};
			const getComputedSizeProp = (propName, elm) => parseInt(get$7(elm, propName), 10);
			const getClientWidth = curry(getProp, "clientWidth");
			const getClientHeight = curry(getProp, "clientHeight");
			const getMarginTop = curry(getComputedSizeProp, "margin-top");
			const getMarginLeft = curry(getComputedSizeProp, "margin-left");
			const getBoundingClientRect = (elm) => elm.dom.getBoundingClientRect();
			const isInsideElementContentArea = (bodyElm, clientX, clientY) => {
				const clientWidth = getClientWidth(bodyElm);
				const clientHeight = getClientHeight(bodyElm);
				return clientX >= 0 && clientY >= 0 && clientX <= clientWidth && clientY <= clientHeight;
			};
			const transpose = (inline, elm, clientX, clientY) => {
				const clientRect = getBoundingClientRect(elm);
				const deltaX = inline ? clientRect.left + elm.dom.clientLeft + getMarginLeft(elm) : 0;
				const deltaY = inline ? clientRect.top + elm.dom.clientTop + getMarginTop(elm) : 0;
				return {
					x: clientX - deltaX,
					y: clientY - deltaY
				};
			};
			const isXYInContentArea = (editor, clientX, clientY) => {
				const bodyElm = SugarElement.fromDom(editor.getBody());
				const targetElm = editor.inline ? bodyElm : documentElement(bodyElm);
				const transposedPoint = transpose(editor.inline, targetElm, clientX, clientY);
				return isInsideElementContentArea(targetElm, transposedPoint.x, transposedPoint.y);
			};
			const fromDomSafe = (node) => Optional.from(node).map(SugarElement.fromDom);
			const isEditorAttachedToDom = (editor) => {
				return fromDomSafe(editor.inline ? editor.getBody() : editor.getContentAreaContainer()).map(inBody).getOr(false);
			};
			var NotificationManagerImpl = () => {
				const unimplemented = () => {
					throw new Error("Theme did not provide a NotificationManager implementation.");
				};
				return {
					open: unimplemented,
					close: unimplemented,
					getArgs: unimplemented
				};
			};
			const NotificationManager = (editor) => {
				const notifications = [];
				const getImplementation = () => {
					const theme = editor.theme;
					return theme && theme.getNotificationManagerImpl ? theme.getNotificationManagerImpl() : NotificationManagerImpl();
				};
				const getTopNotification = () => {
					return Optional.from(notifications[0]);
				};
				const isEqual$1 = (a, b) => {
					return a.type === b.type && a.text === b.text && !a.progressBar && !a.timeout && !b.progressBar && !b.timeout;
				};
				const reposition$1 = () => {
					each$e(notifications, (notification) => {
						notification.reposition();
					});
				};
				const addNotification = (notification) => {
					notifications.push(notification);
				};
				const closeNotification = (notification) => {
					findIndex$2(notifications, (otherNotification) => {
						return otherNotification === notification;
					}).each((index) => {
						notifications.splice(index, 1);
					});
				};
				const open = (spec, fireEvent$1 = true) => {
					if (editor.removed || !isEditorAttachedToDom(editor)) return {};
					if (fireEvent$1) editor.dispatch("BeforeOpenNotification", { notification: spec });
					return find$2(notifications, (notification) => {
						return isEqual$1(getImplementation().getArgs(notification), spec);
					}).getOrThunk(() => {
						editor.editorManager.setActive(editor);
						const notification = getImplementation().open(spec, () => {
							closeNotification(notification);
							reposition$1();
							getTopNotification().fold(() => editor.focus(), (top) => focus$1(SugarElement.fromDom(top.getEl())));
						});
						addNotification(notification);
						reposition$1();
						editor.dispatch("OpenNotification", { notification: { ...notification } });
						return notification;
					});
				};
				const close = () => {
					getTopNotification().each((notification) => {
						getImplementation().close(notification);
						closeNotification(notification);
						reposition$1();
					});
				};
				const getNotifications = constant(notifications);
				const registerEvents$2 = (editor$1) => {
					editor$1.on("SkinLoaded", () => {
						const serviceMessage = getServiceMessage(editor$1);
						if (serviceMessage) open({
							text: serviceMessage,
							type: "warning",
							timeout: 0
						}, false);
						reposition$1();
					});
					editor$1.on("show ResizeEditor ResizeWindow NodeChange", () => {
						requestAnimationFrame(reposition$1);
					});
					editor$1.on("remove", () => {
						each$e(notifications.slice(), (notification) => {
							getImplementation().close(notification);
						});
					});
				};
				registerEvents$2(editor);
				return {
					open,
					close,
					getNotifications
				};
			};
			const PluginManager = AddOnManager.PluginManager;
			const ThemeManager = AddOnManager.ThemeManager;
			var WindowManagerImpl = () => {
				const unimplemented = () => {
					throw new Error("Theme did not provide a WindowManager implementation.");
				};
				return {
					open: unimplemented,
					openUrl: unimplemented,
					alert: unimplemented,
					confirm: unimplemented,
					close: unimplemented
				};
			};
			const WindowManager = (editor) => {
				let dialogs = [];
				const getImplementation = () => {
					const theme = editor.theme;
					return theme && theme.getWindowManagerImpl ? theme.getWindowManagerImpl() : WindowManagerImpl();
				};
				const funcBind = (scope, f) => {
					return (...args) => {
						return f ? f.apply(scope, args) : void 0;
					};
				};
				const fireOpenEvent = (dialog) => {
					editor.dispatch("OpenWindow", { dialog });
				};
				const fireCloseEvent = (dialog) => {
					editor.dispatch("CloseWindow", { dialog });
				};
				const addDialog = (dialog) => {
					dialogs.push(dialog);
					fireOpenEvent(dialog);
				};
				const closeDialog = (dialog) => {
					fireCloseEvent(dialog);
					dialogs = filter$5(dialogs, (otherDialog) => {
						return otherDialog !== dialog;
					});
					if (dialogs.length === 0) editor.focus();
				};
				const getTopDialog = () => {
					return Optional.from(dialogs[dialogs.length - 1]);
				};
				const storeSelectionAndOpenDialog = (openDialog) => {
					editor.editorManager.setActive(editor);
					store(editor);
					editor.ui.show();
					const dialog = openDialog();
					addDialog(dialog);
					return dialog;
				};
				const open = (args, params) => {
					return storeSelectionAndOpenDialog(() => getImplementation().open(args, params, closeDialog));
				};
				const openUrl = (args) => {
					return storeSelectionAndOpenDialog(() => getImplementation().openUrl(args, closeDialog));
				};
				const alert = (message, callback, scope) => {
					const windowManagerImpl = getImplementation();
					windowManagerImpl.alert(message, funcBind(scope ? scope : windowManagerImpl, callback));
				};
				const confirm = (message, callback, scope) => {
					const windowManagerImpl = getImplementation();
					windowManagerImpl.confirm(message, funcBind(scope ? scope : windowManagerImpl, callback));
				};
				const close = () => {
					getTopDialog().each((dialog) => {
						getImplementation().close(dialog);
						closeDialog(dialog);
					});
				};
				editor.on("remove", () => {
					each$e(dialogs, (dialog) => {
						getImplementation().close(dialog);
					});
				});
				return {
					open,
					openUrl,
					alert,
					confirm,
					close
				};
			};
			const displayNotification = (editor, message) => {
				editor.notificationManager.open({
					type: "error",
					text: message
				});
			};
			const displayError = (editor, message) => {
				if (editor._skinLoaded) displayNotification(editor, message);
				else editor.on("SkinLoaded", () => {
					displayNotification(editor, message);
				});
			};
			const uploadError = (editor, message) => {
				displayError(editor, I18n.translate(["Failed to upload image: {0}", message]));
			};
			const logError = (editor, errorType, msg) => {
				fireError(editor, errorType, { message: msg });
				console.error(msg);
			};
			const createLoadError = (type$2, url, name$1) => name$1 ? `Failed to load ${type$2}: ${name$1} from url ${url}` : `Failed to load ${type$2} url: ${url}`;
			const pluginLoadError = (editor, url, name$1) => {
				logError(editor, "PluginLoadError", createLoadError("plugin", url, name$1));
			};
			const iconsLoadError = (editor, url, name$1) => {
				logError(editor, "IconsLoadError", createLoadError("icons", url, name$1));
			};
			const languageLoadError = (editor, url, name$1) => {
				logError(editor, "LanguageLoadError", createLoadError("language", url, name$1));
			};
			const themeLoadError = (editor, url, name$1) => {
				logError(editor, "ThemeLoadError", createLoadError("theme", url, name$1));
			};
			const modelLoadError = (editor, url, name$1) => {
				logError(editor, "ModelLoadError", createLoadError("model", url, name$1));
			};
			const pluginInitError = (editor, name$1, err) => {
				const message = I18n.translate(["Failed to initialize plugin: {0}", name$1]);
				fireError(editor, "PluginLoadError", { message });
				initError(message, err);
				displayError(editor, message);
			};
			const initError = (message, ...x) => {
				const console$1 = window.console;
				if (console$1) if (console$1.error) console$1.error(message, ...x);
				else console$1.log(message, ...x);
			};
			const isContentCssSkinName = (url) => /^[a-z0-9\-]+$/i.test(url);
			const getContentCssUrls = (editor) => {
				return transformToUrls(editor, getContentCss(editor));
			};
			const getFontCssUrls = (editor) => {
				return transformToUrls(editor, getFontCss(editor));
			};
			const transformToUrls = (editor, cssLinks) => {
				const skinUrl = editor.editorManager.baseURL + "/skins/content";
				const contentCssFile = `content${editor.editorManager.suffix}.css`;
				return map$3(cssLinks, (url) => {
					if (isContentCssSkinName(url) && !editor.inline) return `${skinUrl}/${url}/${contentCssFile}`;
					else return editor.documentBaseURI.toAbsolute(url);
				});
			};
			const appendContentCssFromSettings = (editor) => {
				editor.contentCSS = editor.contentCSS.concat(getContentCssUrls(editor), getFontCssUrls(editor));
			};
			const getAllImages = (elm) => {
				return elm ? from(elm.getElementsByTagName("img")) : [];
			};
			const ImageScanner = (uploadStatus, blobCache) => {
				const cachedPromises = {};
				const findAll$1 = (elm, predicate = always) => {
					const promises = map$3(filter$5(getAllImages(elm), (img) => {
						const src = img.src;
						if (img.hasAttribute("data-mce-bogus")) return false;
						if (img.hasAttribute("data-mce-placeholder")) return false;
						if (!src || src === Env.transparentSrc) return false;
						if (startsWith(src, "blob:")) return !uploadStatus.isUploaded(src) && predicate(img);
						if (startsWith(src, "data:")) return predicate(img);
						return false;
					}), (img) => {
						const imageSrc = img.src;
						if (has$2(cachedPromises, imageSrc)) return cachedPromises[imageSrc].then((imageInfo) => {
							if (isString(imageInfo)) return imageInfo;
							else return {
								image: img,
								blobInfo: imageInfo.blobInfo
							};
						});
						else {
							const newPromise = imageToBlobInfo(blobCache, imageSrc).then((blobInfo) => {
								delete cachedPromises[imageSrc];
								return {
									image: img,
									blobInfo
								};
							}).catch((error$1) => {
								delete cachedPromises[imageSrc];
								return error$1;
							});
							cachedPromises[imageSrc] = newPromise;
							return newPromise;
						}
					});
					return Promise.all(promises);
				};
				return { findAll: findAll$1 };
			};
			const UploadStatus = () => {
				const PENDING = 1, UPLOADED = 2;
				let blobUriStatuses = {};
				const createStatus = (status, resultUri) => {
					return {
						status,
						resultUri
					};
				};
				const hasBlobUri = (blobUri) => {
					return blobUri in blobUriStatuses;
				};
				const getResultUri = (blobUri) => {
					const result = blobUriStatuses[blobUri];
					return result ? result.resultUri : null;
				};
				const isPending = (blobUri) => {
					return hasBlobUri(blobUri) ? blobUriStatuses[blobUri].status === PENDING : false;
				};
				const isUploaded = (blobUri) => {
					return hasBlobUri(blobUri) ? blobUriStatuses[blobUri].status === UPLOADED : false;
				};
				const markPending = (blobUri) => {
					blobUriStatuses[blobUri] = createStatus(PENDING, null);
				};
				const markUploaded = (blobUri, resultUri) => {
					blobUriStatuses[blobUri] = createStatus(UPLOADED, resultUri);
				};
				const removeFailed = (blobUri) => {
					delete blobUriStatuses[blobUri];
				};
				const destroy$1 = () => {
					blobUriStatuses = {};
				};
				return {
					hasBlobUri,
					getResultUri,
					isPending,
					isUploaded,
					markPending,
					markUploaded,
					removeFailed,
					destroy: destroy$1
				};
			};
			let count = 0;
			const seed = () => {
				const rnd = () => {
					return Math.round(Math.random() * 4294967295).toString(36);
				};
				return "s" + (/* @__PURE__ */ new Date()).getTime().toString(36) + rnd() + rnd() + rnd();
			};
			const uuid = (prefix) => {
				return prefix + count++ + seed();
			};
			const BlobCache = () => {
				let cache = [];
				const mimeToExt = (mime) => {
					return {
						"image/jpeg": "jpg",
						"image/jpg": "jpg",
						"image/gif": "gif",
						"image/png": "png",
						"image/apng": "apng",
						"image/avif": "avif",
						"image/svg+xml": "svg",
						"image/webp": "webp",
						"image/bmp": "bmp",
						"image/tiff": "tiff"
					}[mime.toLowerCase()] || "dat";
				};
				const create$10 = (o, blob, base64, name$1, filename) => {
					if (isString(o)) return toBlobInfo({
						id: o,
						name: name$1,
						filename,
						blob,
						base64
					});
					else if (isObject(o)) return toBlobInfo(o);
					else throw new Error("Unknown input type");
				};
				const toBlobInfo = (o) => {
					if (!o.blob || !o.base64) throw new Error("blob and base64 representations of the image are required for BlobInfo to be created");
					const id = o.id || uuid("blobid");
					const name$1 = o.name || id;
					const blob = o.blob;
					return {
						id: constant(id),
						name: constant(name$1),
						filename: constant(o.filename || name$1 + "." + mimeToExt(blob.type)),
						blob: constant(blob),
						base64: constant(o.base64),
						blobUri: constant(o.blobUri || URL.createObjectURL(blob)),
						uri: constant(o.uri)
					};
				};
				const add$5 = (blobInfo) => {
					if (!get$10(blobInfo.id())) cache.push(blobInfo);
				};
				const findFirst = (predicate) => find$2(cache, predicate).getOrUndefined();
				const get$10 = (id) => findFirst((cachedBlobInfo) => cachedBlobInfo.id() === id);
				const getByUri = (blobUri) => findFirst((blobInfo) => blobInfo.blobUri() === blobUri);
				const getByData = (base64, type$2) => findFirst((blobInfo) => blobInfo.base64() === base64 && blobInfo.blob().type === type$2);
				const removeByUri = (blobUri) => {
					cache = filter$5(cache, (blobInfo) => {
						if (blobInfo.blobUri() === blobUri) {
							URL.revokeObjectURL(blobInfo.blobUri());
							return false;
						}
						return true;
					});
				};
				const destroy$1 = () => {
					each$e(cache, (cachedBlobInfo) => {
						URL.revokeObjectURL(cachedBlobInfo.blobUri());
					});
					cache = [];
				};
				return {
					create: create$10,
					add: add$5,
					get: get$10,
					getByUri,
					getByData,
					findFirst,
					removeByUri,
					destroy: destroy$1
				};
			};
			const Uploader = (uploadStatus, settings) => {
				const pendingPromises = {};
				const pathJoin = (path1, path2) => {
					if (path1) return path1.replace(/\/$/, "") + "/" + path2.replace(/^\//, "");
					return path2;
				};
				const defaultHandler = (blobInfo, progress) => new Promise((success, failure) => {
					const xhr = new XMLHttpRequest();
					xhr.open("POST", settings.url);
					xhr.withCredentials = settings.credentials;
					xhr.upload.onprogress = (e) => {
						progress(e.loaded / e.total * 100);
					};
					xhr.onerror = () => {
						failure("Image upload failed due to a XHR Transport error. Code: " + xhr.status);
					};
					xhr.onload = () => {
						if (xhr.status < 200 || xhr.status >= 300) {
							failure("HTTP Error: " + xhr.status);
							return;
						}
						const json = JSON.parse(xhr.responseText);
						if (!json || !isString(json.location)) {
							failure("Invalid JSON: " + xhr.responseText);
							return;
						}
						success(pathJoin(settings.basePath, json.location));
					};
					const formData = new FormData();
					formData.append("file", blobInfo.blob(), blobInfo.filename());
					xhr.send(formData);
				});
				const uploadHandler = isFunction(settings.handler) ? settings.handler : defaultHandler;
				const noUpload = () => new Promise((resolve$4) => {
					resolve$4([]);
				});
				const handlerSuccess = (blobInfo, url) => ({
					url,
					blobInfo,
					status: true
				});
				const handlerFailure = (blobInfo, error$1) => ({
					url: "",
					blobInfo,
					status: false,
					error: error$1
				});
				const resolvePending = (blobUri, result) => {
					Tools.each(pendingPromises[blobUri], (resolve$4) => {
						resolve$4(result);
					});
					delete pendingPromises[blobUri];
				};
				const uploadBlobInfo = (blobInfo, handler, openNotification$1) => {
					uploadStatus.markPending(blobInfo.blobUri());
					return new Promise((resolve$4) => {
						let notification;
						let progress;
						try {
							const closeNotification = () => {
								if (notification) {
									notification.close();
									progress = noop;
								}
							};
							const success = (url) => {
								closeNotification();
								uploadStatus.markUploaded(blobInfo.blobUri(), url);
								resolvePending(blobInfo.blobUri(), handlerSuccess(blobInfo, url));
								resolve$4(handlerSuccess(blobInfo, url));
							};
							const failure = (error$1) => {
								closeNotification();
								uploadStatus.removeFailed(blobInfo.blobUri());
								resolvePending(blobInfo.blobUri(), handlerFailure(blobInfo, error$1));
								resolve$4(handlerFailure(blobInfo, error$1));
							};
							progress = (percent) => {
								if (percent < 0 || percent > 100) return;
								Optional.from(notification).orThunk(() => Optional.from(openNotification$1).map(apply$1)).each((n) => {
									notification = n;
									n.progressBar.value(percent);
								});
							};
							handler(blobInfo, progress).then(success, (err) => {
								failure(isString(err) ? { message: err } : err);
							});
						} catch (ex) {
							resolve$4(handlerFailure(blobInfo, ex));
						}
					});
				};
				const isDefaultHandler = (handler) => handler === defaultHandler;
				const pendingUploadBlobInfo = (blobInfo) => {
					const blobUri = blobInfo.blobUri();
					return new Promise((resolve$4) => {
						pendingPromises[blobUri] = pendingPromises[blobUri] || [];
						pendingPromises[blobUri].push(resolve$4);
					});
				};
				const uploadBlobs = (blobInfos, openNotification$1) => {
					blobInfos = Tools.grep(blobInfos, (blobInfo) => !uploadStatus.isUploaded(blobInfo.blobUri()));
					return Promise.all(Tools.map(blobInfos, (blobInfo) => uploadStatus.isPending(blobInfo.blobUri()) ? pendingUploadBlobInfo(blobInfo) : uploadBlobInfo(blobInfo, uploadHandler, openNotification$1)));
				};
				const upload = (blobInfos, openNotification$1) => !settings.url && isDefaultHandler(uploadHandler) ? noUpload() : uploadBlobs(blobInfos, openNotification$1);
				return { upload };
			};
			const openNotification = (editor) => () => editor.notificationManager.open({
				text: editor.translate("Image uploading..."),
				type: "info",
				timeout: -1,
				progressBar: true
			});
			const createUploader = (editor, uploadStatus) => Uploader(uploadStatus, {
				url: getImageUploadUrl(editor),
				basePath: getImageUploadBasePath(editor),
				credentials: getImagesUploadCredentials(editor),
				handler: getImagesUploadHandler(editor)
			});
			const ImageUploader = (editor) => {
				const uploader = createUploader(editor, UploadStatus());
				return { upload: (blobInfos, showNotification = true) => uploader.upload(blobInfos, showNotification ? openNotification(editor) : void 0) };
			};
			const isEmptyForPadding = (editor, element) => editor.dom.isEmpty(element.dom) && isNonNullable(editor.schema.getTextBlockElements()[name(element)]);
			const addPaddingToEmpty = (editor) => (element) => {
				if (isEmptyForPadding(editor, element)) append$1(element, SugarElement.fromHtml("<br data-mce-bogus=\"1\" />"));
			};
			const EditorUpload = (editor) => {
				const blobCache = BlobCache();
				let uploader, imageScanner;
				const uploadStatus = UploadStatus();
				const urlFilters = [];
				const aliveGuard = (callback) => {
					return (result) => {
						if (editor.selection) return callback(result);
						return [];
					};
				};
				const cacheInvalidator = (url) => url + (url.indexOf("?") === -1 ? "?" : "&") + (/* @__PURE__ */ new Date()).getTime();
				const replaceString = (content, search$1, replace) => {
					let index = 0;
					do {
						index = content.indexOf(search$1, index);
						if (index !== -1) {
							content = content.substring(0, index) + replace + content.substr(index + search$1.length);
							index += replace.length - search$1.length + 1;
						}
					} while (index !== -1);
					return content;
				};
				const replaceImageUrl = (content, targetUrl, replacementUrl) => {
					const replacementString = `src="${replacementUrl}"${replacementUrl === Env.transparentSrc ? " data-mce-placeholder=\"1\"" : ""}`;
					content = replaceString(content, `src="${targetUrl}"`, replacementString);
					content = replaceString(content, "data-mce-src=\"" + targetUrl + "\"", "data-mce-src=\"" + replacementUrl + "\"");
					return content;
				};
				const replaceUrlInUndoStack = (targetUrl, replacementUrl) => {
					each$e(editor.undoManager.data, (level) => {
						if (level.type === "fragmented") level.fragments = map$3(level.fragments, (fragment) => replaceImageUrl(fragment, targetUrl, replacementUrl));
						else level.content = replaceImageUrl(level.content, targetUrl, replacementUrl);
					});
				};
				const replaceImageUriInView = (image, resultUri) => {
					const src = editor.convertURL(resultUri, "src");
					replaceUrlInUndoStack(image.src, resultUri);
					setAll$1(SugarElement.fromDom(image), {
						"src": shouldReuseFileName(editor) ? cacheInvalidator(resultUri) : resultUri,
						"data-mce-src": src
					});
				};
				const uploadImages = () => {
					if (!uploader) uploader = createUploader(editor, uploadStatus);
					return scanForImages().then(aliveGuard((imageInfos) => {
						const blobInfos = map$3(imageInfos, (imageInfo) => imageInfo.blobInfo);
						return uploader.upload(blobInfos, openNotification(editor)).then(aliveGuard((result) => {
							const imagesToRemove = [];
							let shouldDispatchChange = false;
							const filteredResult = map$3(result, (uploadInfo, index) => {
								const { blobInfo, image } = imageInfos[index];
								let removed = false;
								if (uploadInfo.status && shouldReplaceBlobUris(editor)) {
									if (uploadInfo.url && !contains$1(image.src, uploadInfo.url)) shouldDispatchChange = true;
									blobCache.removeByUri(image.src);
									if (isRtc(editor));
									else replaceImageUriInView(image, uploadInfo.url);
								} else if (uploadInfo.error) {
									if (uploadInfo.error.remove) {
										replaceUrlInUndoStack(image.src, Env.transparentSrc);
										imagesToRemove.push(image);
										removed = true;
									}
									uploadError(editor, uploadInfo.error.message);
								}
								return {
									element: image,
									status: uploadInfo.status,
									uploadUri: uploadInfo.url,
									blobInfo,
									removed
								};
							});
							if (imagesToRemove.length > 0 && !isRtc(editor)) editor.undoManager.transact(() => {
								each$e(fromDom$1(imagesToRemove), (sugarElement) => {
									const parentOpt = parent(sugarElement);
									remove$5(sugarElement);
									parentOpt.each(addPaddingToEmpty(editor));
									blobCache.removeByUri(sugarElement.dom.src);
								});
							});
							else if (shouldDispatchChange) editor.undoManager.dispatchChange();
							return filteredResult;
						}));
					}));
				};
				const uploadImagesAuto = () => isAutomaticUploadsEnabled(editor) ? uploadImages() : Promise.resolve([]);
				const isValidDataUriImage = (imgElm) => forall(urlFilters, (filter$6) => filter$6(imgElm));
				const addFilter = (filter$6) => {
					urlFilters.push(filter$6);
				};
				const scanForImages = () => {
					if (!imageScanner) imageScanner = ImageScanner(uploadStatus, blobCache);
					return imageScanner.findAll(editor.getBody(), isValidDataUriImage).then(aliveGuard((result) => {
						const filteredResult = filter$5(result, (resultItem) => {
							if (isString(resultItem)) {
								displayError(editor, resultItem);
								return false;
							} else if (resultItem.uriType === "blob") return false;
							else return true;
						});
						if (isRtc(editor));
						else each$e(filteredResult, (resultItem) => {
							replaceUrlInUndoStack(resultItem.image.src, resultItem.blobInfo.blobUri());
							resultItem.image.src = resultItem.blobInfo.blobUri();
							resultItem.image.removeAttribute("data-mce-src");
						});
						return filteredResult;
					}));
				};
				const destroy$1 = () => {
					blobCache.destroy();
					uploadStatus.destroy();
					imageScanner = uploader = null;
				};
				const replaceBlobUris = (content) => {
					return content.replace(/src="(blob:[^"]+)"/g, (match$3, blobUri) => {
						const resultUri = uploadStatus.getResultUri(blobUri);
						if (resultUri) return "src=\"" + resultUri + "\"";
						let blobInfo = blobCache.getByUri(blobUri);
						if (!blobInfo) blobInfo = foldl(editor.editorManager.get(), (result, editor$1) => {
							return result || editor$1.editorUpload && editor$1.editorUpload.blobCache.getByUri(blobUri);
						}, void 0);
						if (blobInfo) return "src=\"data:" + blobInfo.blob().type + ";base64," + blobInfo.base64() + "\"";
						return match$3;
					});
				};
				editor.on("SetContent", () => {
					if (isAutomaticUploadsEnabled(editor)) uploadImagesAuto();
					else scanForImages();
				});
				editor.on("RawSaveContent", (e) => {
					e.content = replaceBlobUris(e.content);
				});
				editor.on("GetContent", (e) => {
					if (e.source_view || e.format === "raw" || e.format === "tree") return;
					e.content = replaceBlobUris(e.content);
				});
				editor.on("PostRender", () => {
					editor.parser.addNodeFilter("img", (images) => {
						each$e(images, (img) => {
							const src = img.attr("src");
							if (!src || blobCache.getByUri(src)) return;
							const resultUri = uploadStatus.getResultUri(src);
							if (resultUri) img.attr("src", resultUri);
						});
					});
				});
				return {
					blobCache,
					addFilter,
					uploadImages,
					uploadImagesAuto,
					scanForImages,
					destroy: destroy$1
				};
			};
			const get$1 = (editor) => {
				const dom$1 = editor.dom;
				const schemaType = editor.schema.type;
				const formats = {
					valigntop: [{
						selector: "td,th",
						styles: { verticalAlign: "top" }
					}],
					valignmiddle: [{
						selector: "td,th",
						styles: { verticalAlign: "middle" }
					}],
					valignbottom: [{
						selector: "td,th",
						styles: { verticalAlign: "bottom" }
					}],
					alignleft: [
						{
							selector: "figure.image",
							collapsed: false,
							classes: "align-left",
							ceFalseOverride: true,
							preview: "font-family font-size"
						},
						{
							selector: "figure,p,h1,h2,h3,h4,h5,h6,td,th,tr,div,ul,ol,li,pre",
							styles: { textAlign: "left" },
							inherit: false,
							preview: false
						},
						{
							selector: "img,audio,video",
							collapsed: false,
							styles: { float: "left" },
							preview: "font-family font-size"
						},
						{
							selector: "table",
							collapsed: false,
							styles: {
								marginLeft: "0px",
								marginRight: "auto"
							},
							onformat: (table$1) => {
								dom$1.setStyle(table$1, "float", null);
							},
							preview: "font-family font-size"
						},
						{
							selector: ".mce-preview-object,[data-ephox-embed-iri]",
							ceFalseOverride: true,
							styles: { float: "left" }
						}
					],
					aligncenter: [
						{
							selector: "figure,p,h1,h2,h3,h4,h5,h6,td,th,tr,div,ul,ol,li,pre",
							styles: { textAlign: "center" },
							inherit: false,
							preview: "font-family font-size"
						},
						{
							selector: "figure.image",
							collapsed: false,
							classes: "align-center",
							ceFalseOverride: true,
							preview: "font-family font-size"
						},
						{
							selector: "img,audio,video",
							collapsed: false,
							styles: {
								display: "block",
								marginLeft: "auto",
								marginRight: "auto"
							},
							preview: false
						},
						{
							selector: "table",
							collapsed: false,
							styles: {
								marginLeft: "auto",
								marginRight: "auto"
							},
							preview: "font-family font-size"
						},
						{
							selector: ".mce-preview-object",
							ceFalseOverride: true,
							styles: {
								display: "table",
								marginLeft: "auto",
								marginRight: "auto"
							},
							preview: false
						},
						{
							selector: "[data-ephox-embed-iri]",
							ceFalseOverride: true,
							styles: {
								marginLeft: "auto",
								marginRight: "auto"
							},
							preview: false
						}
					],
					alignright: [
						{
							selector: "figure.image",
							collapsed: false,
							classes: "align-right",
							ceFalseOverride: true,
							preview: "font-family font-size"
						},
						{
							selector: "figure,p,h1,h2,h3,h4,h5,h6,td,th,tr,div,ul,ol,li,pre",
							styles: { textAlign: "right" },
							inherit: false,
							preview: "font-family font-size"
						},
						{
							selector: "img,audio,video",
							collapsed: false,
							styles: { float: "right" },
							preview: "font-family font-size"
						},
						{
							selector: "table",
							collapsed: false,
							styles: {
								marginRight: "0px",
								marginLeft: "auto"
							},
							onformat: (table$1) => {
								dom$1.setStyle(table$1, "float", null);
							},
							preview: "font-family font-size"
						},
						{
							selector: ".mce-preview-object,[data-ephox-embed-iri]",
							ceFalseOverride: true,
							styles: { float: "right" },
							preview: false
						}
					],
					alignjustify: [{
						selector: "figure,p,h1,h2,h3,h4,h5,h6,td,th,tr,div,ul,ol,li,pre",
						styles: { textAlign: "justify" },
						inherit: false,
						preview: "font-family font-size"
					}],
					bold: [
						{
							inline: "strong",
							remove: "all",
							preserve_attributes: ["class", "style"]
						},
						{
							inline: "span",
							styles: { fontWeight: "bold" }
						},
						{
							inline: "b",
							remove: "all",
							preserve_attributes: ["class", "style"]
						}
					],
					italic: [
						{
							inline: "em",
							remove: "all",
							preserve_attributes: ["class", "style"]
						},
						{
							inline: "span",
							styles: { fontStyle: "italic" }
						},
						{
							inline: "i",
							remove: "all",
							preserve_attributes: ["class", "style"]
						}
					],
					underline: [{
						inline: "span",
						styles: { textDecoration: "underline" },
						exact: true
					}, {
						inline: "u",
						remove: "all",
						preserve_attributes: ["class", "style"]
					}],
					strikethrough: (() => {
						const span = {
							inline: "span",
							styles: { textDecoration: "line-through" },
							exact: true
						};
						const strike = {
							inline: "strike",
							remove: "all",
							preserve_attributes: ["class", "style"]
						};
						const s = {
							inline: "s",
							remove: "all",
							preserve_attributes: ["class", "style"]
						};
						return schemaType !== "html4" ? [
							s,
							span,
							strike
						] : [
							span,
							s,
							strike
						];
					})(),
					forecolor: {
						inline: "span",
						styles: { color: "%value" },
						links: true,
						remove_similar: true,
						clear_child_styles: true
					},
					hilitecolor: {
						inline: "span",
						styles: { backgroundColor: "%value" },
						links: true,
						remove_similar: true,
						clear_child_styles: true
					},
					fontname: {
						inline: "span",
						toggle: false,
						styles: { fontFamily: "%value" },
						clear_child_styles: true
					},
					fontsize: {
						inline: "span",
						toggle: false,
						styles: { fontSize: "%value" },
						clear_child_styles: true
					},
					lineheight: {
						selector: "h1,h2,h3,h4,h5,h6,p,li,td,th,div",
						styles: { lineHeight: "%value" }
					},
					fontsize_class: {
						inline: "span",
						attributes: { class: "%value" }
					},
					blockquote: {
						block: "blockquote",
						wrapper: true,
						remove: "all"
					},
					subscript: { inline: "sub" },
					superscript: { inline: "sup" },
					code: { inline: "code" },
					link: {
						inline: "a",
						selector: "a",
						remove: "all",
						split: true,
						deep: true,
						onmatch: (node, _fmt, _itemName) => {
							return isElement$6(node) && node.hasAttribute("href");
						},
						onformat: (elm, _fmt, vars) => {
							Tools.each(vars, (value$3, key) => {
								dom$1.setAttrib(elm, key, value$3);
							});
						}
					},
					lang: {
						inline: "span",
						clear_child_styles: true,
						remove_similar: true,
						attributes: {
							"lang": "%value",
							"data-mce-lang": (vars) => {
								var _a;
								return (_a = vars === null || vars === void 0 ? void 0 : vars.customValue) !== null && _a !== void 0 ? _a : null;
							}
						}
					},
					removeformat: [
						{
							selector: "b,strong,em,i,font,u,strike,s,sub,sup,dfn,code,samp,kbd,var,cite,mark,q,del,ins,small",
							remove: "all",
							split: true,
							expand: false,
							block_expand: true,
							deep: true
						},
						{
							selector: "span",
							attributes: ["style", "class"],
							remove: "empty",
							split: true,
							expand: false,
							deep: true
						},
						{
							selector: "*",
							attributes: ["style", "class"],
							split: false,
							expand: false,
							deep: true
						}
					]
				};
				Tools.each("p h1 h2 h3 h4 h5 h6 div address pre dt dd samp".split(/\s/), (name$1) => {
					formats[name$1] = {
						block: name$1,
						remove: "all"
					};
				});
				return formats;
			};
			const genericBase = {
				remove_similar: true,
				inherit: false
			};
			const cellBase = {
				selector: "td,th",
				...genericBase
			};
			const get = constant({
				tablecellbackgroundcolor: {
					styles: { backgroundColor: "%value" },
					...cellBase
				},
				tablecellverticalalign: {
					styles: { "vertical-align": "%value" },
					...cellBase
				},
				tablecellbordercolor: {
					styles: { borderColor: "%value" },
					...cellBase
				},
				tablecellclass: {
					classes: ["%value"],
					...cellBase
				},
				tableclass: {
					selector: "table",
					classes: ["%value"],
					...genericBase
				},
				tablecellborderstyle: {
					styles: { borderStyle: "%value" },
					...cellBase
				},
				tablecellborderwidth: {
					styles: { borderWidth: "%value" },
					...cellBase
				}
			});
			const FormatRegistry = (editor) => {
				const formats = {};
				const get$2$1 = (name$1) => isNonNullable(name$1) ? formats[name$1] : formats;
				const has$3 = (name$1) => has$2(formats, name$1);
				const register$8 = (name$1, format) => {
					if (name$1) if (!isString(name$1)) each$d(name$1, (format$1, name$2) => {
						register$8(name$2, format$1);
					});
					else {
						if (!isArray$1(format)) format = [format];
						each$e(format, (format$1) => {
							if (isUndefined(format$1.deep)) format$1.deep = !isSelectorFormat(format$1);
							if (isUndefined(format$1.split)) format$1.split = !isSelectorFormat(format$1) || isInlineFormat(format$1);
							if (isUndefined(format$1.remove) && isSelectorFormat(format$1) && !isInlineFormat(format$1)) format$1.remove = "none";
							if (isSelectorFormat(format$1) && isInlineFormat(format$1)) {
								format$1.mixed = true;
								format$1.block_expand = true;
							}
							if (isString(format$1.classes)) format$1.classes = format$1.classes.split(/\s+/);
						});
						formats[name$1] = format;
					}
				};
				const unregister = (name$1) => {
					if (name$1 && formats[name$1]) delete formats[name$1];
					return formats;
				};
				register$8(get$1(editor));
				register$8(get());
				register$8(getFormats(editor));
				return {
					get: get$2$1,
					has: has$3,
					register: register$8,
					unregister
				};
			};
			const each$3 = Tools.each;
			const dom = DOMUtils.DOM;
			const isPreviewItem = (item) => isNonNullable(item) && isObject(item);
			const parsedSelectorToHtml = (ancestry, editor) => {
				const schema = editor && editor.schema || Schema({});
				const decorate = (elm, item) => {
					if (item.classes.length > 0) dom.addClass(elm, item.classes.join(" "));
					dom.setAttribs(elm, item.attrs);
				};
				const createElement = (sItem) => {
					const item = isString(sItem) ? {
						name: sItem,
						classes: [],
						attrs: {}
					} : sItem;
					const elm = dom.create(item.name);
					decorate(elm, item);
					return elm;
				};
				const getRequiredParent = (elm, candidate) => {
					const elmRule = schema.getElementRule(elm.nodeName.toLowerCase());
					const parentsRequired = elmRule === null || elmRule === void 0 ? void 0 : elmRule.parentsRequired;
					if (parentsRequired && parentsRequired.length) return candidate && contains$2(parentsRequired, candidate) ? candidate : parentsRequired[0];
					else return false;
				};
				const wrapInHtml = (elm, ancestors, siblings$1) => {
					let parentCandidate;
					const ancestor$5 = ancestors[0];
					const ancestorName = isPreviewItem(ancestor$5) ? ancestor$5.name : void 0;
					const parentRequired = getRequiredParent(elm, ancestorName);
					if (parentRequired) if (ancestorName === parentRequired) {
						parentCandidate = ancestor$5;
						ancestors = ancestors.slice(1);
					} else parentCandidate = parentRequired;
					else if (ancestor$5) {
						parentCandidate = ancestor$5;
						ancestors = ancestors.slice(1);
					} else if (!siblings$1) return elm;
					const parent$1 = parentCandidate ? createElement(parentCandidate) : dom.create("div");
					parent$1.appendChild(elm);
					if (siblings$1) Tools.each(siblings$1, (sibling$2) => {
						const siblingElm = createElement(sibling$2);
						parent$1.insertBefore(siblingElm, elm);
					});
					const parentSiblings = isPreviewItem(parentCandidate) ? parentCandidate.siblings : void 0;
					return wrapInHtml(parent$1, ancestors, parentSiblings);
				};
				const fragment = dom.create("div");
				if (ancestry.length > 0) {
					const item = ancestry[0];
					const elm = createElement(item);
					const siblings$1 = isPreviewItem(item) ? item.siblings : void 0;
					fragment.appendChild(wrapInHtml(elm, ancestry.slice(1), siblings$1));
				}
				return fragment;
			};
			const parseSelectorItem = (item) => {
				item = Tools.trim(item);
				let tagName = "div";
				const obj = {
					name: tagName,
					classes: [],
					attrs: {},
					selector: item
				};
				if (item !== "*") tagName = item.replace(/(?:([#\.]|::?)([\w\-]+)|(\[)([^\]]+)\]?)/g, ($0, $1, $2, $3, $4) => {
					switch ($1) {
						case "#":
							obj.attrs.id = $2;
							break;
						case ".":
							obj.classes.push($2);
							break;
						case ":":
							if (Tools.inArray("checked disabled enabled read-only required".split(" "), $2) !== -1) obj.attrs[$2] = $2;
							break;
					}
					if ($3 === "[") {
						const m = $4.match(/([\w\-]+)(?:\=\"([^\"]+))?/);
						if (m) obj.attrs[m[1]] = m[2];
					}
					return "";
				});
				obj.name = tagName || "div";
				return obj;
			};
			const parseSelector = (selector) => {
				if (!isString(selector)) return [];
				selector = selector.split(/\s*,\s*/)[0];
				selector = selector.replace(/\s*(~\+|~|\+|>)\s*/g, "$1");
				return Tools.map(selector.split(/(?:>|\s+(?![^\[\]]+\]))/), (item) => {
					const siblings$1 = Tools.map(item.split(/(?:~\+|~|\+)/), parseSelectorItem);
					const obj = siblings$1.pop();
					if (siblings$1.length) obj.siblings = siblings$1;
					return obj;
				}).reverse();
			};
			const getCssText = (editor, format) => {
				let previewCss = "";
				let previewStyles = getPreviewStyles(editor);
				if (previewStyles === "") return "";
				const removeVars = (val) => {
					return isString(val) ? val.replace(/%(\w+)/g, "") : "";
				};
				const getComputedStyle = (name$2, elm) => {
					return dom.getStyle(elm !== null && elm !== void 0 ? elm : editor.getBody(), name$2, true);
				};
				if (isString(format)) {
					const formats = editor.formatter.get(format);
					if (!formats) return "";
					format = formats[0];
				}
				if ("preview" in format) {
					const preview = format.preview;
					if (preview === false) return "";
					else previewStyles = preview || previewStyles;
				}
				let name$1 = format.block || format.inline || "span";
				let previewFrag;
				const items = parseSelector(format.selector);
				if (items.length > 0) {
					if (!items[0].name) items[0].name = name$1;
					name$1 = format.selector;
					previewFrag = parsedSelectorToHtml(items, editor);
				} else previewFrag = parsedSelectorToHtml([name$1], editor);
				const previewElm = dom.select(name$1, previewFrag)[0] || previewFrag.firstChild;
				each$3(format.styles, (value$3, name$2) => {
					const newValue = removeVars(value$3);
					if (newValue) dom.setStyle(previewElm, name$2, newValue);
				});
				each$3(format.attributes, (value$3, name$2) => {
					const newValue = removeVars(value$3);
					if (newValue) dom.setAttrib(previewElm, name$2, newValue);
				});
				each$3(format.classes, (value$3) => {
					const newValue = removeVars(value$3);
					if (!dom.hasClass(previewElm, newValue)) dom.addClass(previewElm, newValue);
				});
				editor.dispatch("PreviewFormats");
				dom.setStyles(previewFrag, {
					position: "absolute",
					left: -65535
				});
				editor.getBody().appendChild(previewFrag);
				const rawParentFontSize = getComputedStyle("fontSize");
				const parentFontSize = /px$/.test(rawParentFontSize) ? parseInt(rawParentFontSize, 10) : 0;
				each$3(previewStyles.split(" "), (name$2) => {
					let value$3 = getComputedStyle(name$2, previewElm);
					if (name$2 === "background-color" && /transparent|rgba\s*\([^)]+,\s*0\)/.test(value$3)) {
						value$3 = getComputedStyle(name$2);
						if (rgbaToHexString(value$3).toLowerCase() === "#ffffff") return;
					}
					if (name$2 === "color") {
						if (rgbaToHexString(value$3).toLowerCase() === "#000000") return;
					}
					if (name$2 === "font-size") {
						if (/em|%$/.test(value$3)) {
							if (parentFontSize === 0) return;
							value$3 = parseFloat(value$3) / (/%$/.test(value$3) ? 100 : 1) * parentFontSize + "px";
						}
					}
					if (name$2 === "border" && value$3) previewCss += "padding:0 2px;";
					previewCss += name$2 + ":" + value$3 + ";";
				});
				editor.dispatch("AfterPreviewFormats");
				dom.remove(previewFrag);
				return previewCss;
			};
			const setup$r = (editor) => {
				editor.addShortcut("meta+b", "", "Bold");
				editor.addShortcut("meta+i", "", "Italic");
				editor.addShortcut("meta+u", "", "Underline");
				for (let i = 1; i <= 6; i++) editor.addShortcut("access+" + i, "", [
					"FormatBlock",
					false,
					"h" + i
				]);
				editor.addShortcut("access+7", "", [
					"FormatBlock",
					false,
					"p"
				]);
				editor.addShortcut("access+8", "", [
					"FormatBlock",
					false,
					"div"
				]);
				editor.addShortcut("access+9", "", [
					"FormatBlock",
					false,
					"address"
				]);
			};
			const Formatter = (editor) => {
				const formats = FormatRegistry(editor);
				const formatChangeState = Cell({});
				setup$r(editor);
				setup$u(editor);
				if (!isRtc(editor)) setup$t(formatChangeState, editor);
				return {
					get: formats.get,
					has: formats.has,
					register: formats.register,
					unregister: formats.unregister,
					apply: (name$1, vars, node) => {
						applyFormat(editor, name$1, vars, node);
					},
					remove: (name$1, vars, node, similar) => {
						removeFormat(editor, name$1, vars, node, similar);
					},
					toggle: (name$1, vars, node) => {
						toggleFormat(editor, name$1, vars, node);
					},
					match: (name$1, vars, node, similar) => matchFormat(editor, name$1, vars, node, similar),
					closest: (names) => closestFormat(editor, names),
					matchAll: (names, vars) => matchAllFormats(editor, names, vars),
					matchNode: (node, name$1, vars, similar) => matchNodeFormat(editor, node, name$1, vars, similar),
					canApply: (name$1) => canApplyFormat(editor, name$1),
					formatChanged: (formats$1, callback, similar, vars) => formatChanged(editor, formatChangeState, formats$1, callback, similar, vars),
					getCssText: curry(getCssText, editor)
				};
			};
			const shouldIgnoreCommand = (cmd) => {
				switch (cmd.toLowerCase()) {
					case "undo":
					case "redo":
					case "mcefocus": return true;
					default: return false;
				}
			};
			const registerEvents = (editor, undoManager, locks) => {
				const isFirstTypedCharacter = Cell(false);
				const addNonTypingUndoLevel = (e) => {
					setTyping(undoManager, false, locks);
					undoManager.add({}, e);
				};
				editor.on("init", () => {
					undoManager.add();
				});
				editor.on("BeforeExecCommand", (e) => {
					const cmd = e.command;
					if (!shouldIgnoreCommand(cmd)) {
						endTyping(undoManager, locks);
						undoManager.beforeChange();
					}
				});
				editor.on("ExecCommand", (e) => {
					const cmd = e.command;
					if (!shouldIgnoreCommand(cmd)) addNonTypingUndoLevel(e);
				});
				editor.on("ObjectResizeStart cut", () => {
					undoManager.beforeChange();
				});
				editor.on("SaveContent ObjectResized blur", addNonTypingUndoLevel);
				editor.on("dragend", addNonTypingUndoLevel);
				editor.on("keyup", (e) => {
					const keyCode = e.keyCode;
					if (e.isDefaultPrevented()) return;
					const isMeta = Env.os.isMacOS() && e.key === "Meta";
					if (keyCode >= 33 && keyCode <= 36 || keyCode >= 37 && keyCode <= 40 || keyCode === 45 || e.ctrlKey || isMeta) {
						addNonTypingUndoLevel();
						editor.nodeChanged();
					}
					if (keyCode === 46 || keyCode === 8) editor.nodeChanged();
					if (isFirstTypedCharacter.get() && undoManager.typing && !isEq$1(createFromEditor(editor), undoManager.data[0])) {
						if (!editor.isDirty()) editor.setDirty(true);
						editor.dispatch("TypingUndo");
						isFirstTypedCharacter.set(false);
						editor.nodeChanged();
					}
				});
				editor.on("keydown", (e) => {
					const keyCode = e.keyCode;
					if (e.isDefaultPrevented()) return;
					if (keyCode >= 33 && keyCode <= 36 || keyCode >= 37 && keyCode <= 40 || keyCode === 45) {
						if (undoManager.typing) addNonTypingUndoLevel(e);
						return;
					}
					const modKey = e.ctrlKey && !e.altKey || e.metaKey;
					if ((keyCode < 16 || keyCode > 20) && keyCode !== 224 && keyCode !== 91 && !undoManager.typing && !modKey) {
						undoManager.beforeChange();
						setTyping(undoManager, true, locks);
						undoManager.add({}, e);
						isFirstTypedCharacter.set(true);
						return;
					}
					if (Env.os.isMacOS() ? e.metaKey : e.ctrlKey && !e.altKey) undoManager.beforeChange();
				});
				editor.on("mousedown", (e) => {
					if (undoManager.typing) addNonTypingUndoLevel(e);
				});
				const isInsertReplacementText = (event) => event.inputType === "insertReplacementText";
				const isInsertTextDataNull = (event) => event.inputType === "insertText" && event.data === null;
				const isInsertFromPasteOrDrop = (event) => event.inputType === "insertFromPaste" || event.inputType === "insertFromDrop";
				editor.on("input", (e) => {
					if (e.inputType && (isInsertReplacementText(e) || isInsertTextDataNull(e) || isInsertFromPasteOrDrop(e))) addNonTypingUndoLevel(e);
				});
				editor.on("AddUndo Undo Redo ClearUndos", (e) => {
					if (!e.isDefaultPrevented()) editor.nodeChanged();
				});
			};
			const addKeyboardShortcuts = (editor) => {
				editor.addShortcut("meta+z", "", "Undo");
				editor.addShortcut("meta+y,meta+shift+z", "", "Redo");
			};
			const UndoManager = (editor) => {
				const beforeBookmark = value$2();
				const locks = Cell(0);
				const index = Cell(0);
				const undoManager = {
					data: [],
					typing: false,
					beforeChange: () => {
						beforeChange(editor, locks, beforeBookmark);
					},
					add: (level, event) => {
						return addUndoLevel(editor, undoManager, index, locks, beforeBookmark, level, event);
					},
					dispatchChange: () => {
						editor.setDirty(true);
						const level = createFromEditor(editor);
						level.bookmark = getUndoBookmark(editor.selection);
						editor.dispatch("change", {
							level,
							lastLevel: get$b(undoManager.data, index.get()).getOrUndefined()
						});
					},
					undo: () => {
						return undo(editor, undoManager, locks, index);
					},
					redo: () => {
						return redo(editor, index, undoManager.data);
					},
					clear: () => {
						clear(editor, undoManager, index);
					},
					reset: () => {
						reset(editor, undoManager);
					},
					hasUndo: () => {
						return hasUndo(editor, undoManager, index);
					},
					hasRedo: () => {
						return hasRedo(editor, undoManager, index);
					},
					transact: (callback) => {
						return transact(editor, undoManager, locks, callback);
					},
					ignore: (callback) => {
						ignore(editor, locks, callback);
					},
					extra: (callback1, callback2) => {
						extra(editor, undoManager, index, callback1, callback2);
					}
				};
				if (!isRtc(editor)) registerEvents(editor, undoManager, locks);
				addKeyboardShortcuts(editor);
				return undoManager;
			};
			const nonTypingKeycodes = [
				9,
				27,
				VK.HOME,
				VK.END,
				19,
				20,
				44,
				144,
				145,
				33,
				34,
				45,
				16,
				17,
				18,
				91,
				92,
				93,
				VK.DOWN,
				VK.UP,
				VK.LEFT,
				VK.RIGHT
			].concat(Env.browser.isFirefox() ? [224] : []);
			const placeholderAttr = "data-mce-placeholder";
			const isKeyboardEvent = (e) => e.type === "keydown" || e.type === "keyup";
			const isDeleteEvent = (e) => {
				const keyCode = e.keyCode;
				return keyCode === VK.BACKSPACE || keyCode === VK.DELETE;
			};
			const isNonTypingKeyboardEvent = (e) => {
				if (isKeyboardEvent(e)) {
					const keyCode = e.keyCode;
					return !isDeleteEvent(e) && (VK.metaKeyPressed(e) || e.altKey || keyCode >= 112 && keyCode <= 123 || contains$2(nonTypingKeycodes, keyCode));
				} else return false;
			};
			const isTypingKeyboardEvent = (e) => isKeyboardEvent(e) && !(isDeleteEvent(e) || e.type === "keyup" && e.keyCode === 229);
			const isVisuallyEmpty = (dom$1, rootElm, forcedRootBlock) => {
				if (isEmpty$2(SugarElement.fromDom(rootElm), false)) {
					const firstElement$1 = rootElm.firstElementChild;
					if (!firstElement$1) return true;
					else if (dom$1.getStyle(rootElm.firstElementChild, "padding-left") || dom$1.getStyle(rootElm.firstElementChild, "padding-right")) return false;
					else return forcedRootBlock === firstElement$1.nodeName.toLowerCase();
				} else return false;
			};
			const setup$q = (editor) => {
				var _a;
				const dom$1 = editor.dom;
				const rootBlock = getForcedRootBlock(editor);
				const placeholder = (_a = getPlaceholder(editor)) !== null && _a !== void 0 ? _a : "";
				const updatePlaceholder = (e, initial) => {
					if (isNonTypingKeyboardEvent(e)) return;
					const body = editor.getBody();
					const showPlaceholder = isTypingKeyboardEvent(e) ? false : isVisuallyEmpty(dom$1, body, rootBlock);
					if (dom$1.getAttrib(body, placeholderAttr) !== "" !== showPlaceholder || initial) {
						dom$1.setAttrib(body, placeholderAttr, showPlaceholder ? placeholder : null);
						dom$1.setAttrib(body, "aria-placeholder", showPlaceholder ? placeholder : null);
						firePlaceholderToggle(editor, showPlaceholder);
						editor.on(showPlaceholder ? "keydown" : "keyup", updatePlaceholder);
						editor.off(showPlaceholder ? "keyup" : "keydown", updatePlaceholder);
					}
				};
				if (isNotEmpty(placeholder)) editor.on("init", (e) => {
					updatePlaceholder(e, true);
					editor.on("change SetContent ExecCommand", updatePlaceholder);
					editor.on("paste", (e$1) => Delay.setEditorTimeout(editor, () => updatePlaceholder(e$1)));
				});
			};
			const blockPosition = (block, position) => ({
				block,
				position
			});
			const blockBoundary = (from$1, to$1) => ({
				from: from$1,
				to: to$1
			});
			const getBlockPosition = (rootNode, pos) => {
				return getParentBlock$2(SugarElement.fromDom(rootNode), SugarElement.fromDom(pos.container())).map((block) => blockPosition(block, pos));
			};
			const isDifferentBlocks = (blockBoundary$1) => !eq(blockBoundary$1.from.block, blockBoundary$1.to.block);
			const getClosestHost = (root, scope) => {
				const isRoot$2 = (node) => eq(node, root);
				const isHost = (node) => isTableCell$2(node) || isContentEditableTrue$3(node.dom);
				return closest$4(scope, isHost, isRoot$2).filter(isElement$7).getOr(root);
			};
			const hasSameHost = (rootNode, blockBoundary$1) => {
				const root = SugarElement.fromDom(rootNode);
				return eq(getClosestHost(root, blockBoundary$1.from.block), getClosestHost(root, blockBoundary$1.to.block));
			};
			const isEditable$1 = (blockBoundary$1) => isContentEditableFalse$b(blockBoundary$1.from.block.dom) === false && isContentEditableFalse$b(blockBoundary$1.to.block.dom) === false;
			const hasValidBlocks = (blockBoundary$1) => {
				const isValidBlock = (block) => isTextBlock$2(block) || hasBlockAttr(block.dom);
				return isValidBlock(blockBoundary$1.from.block) && isValidBlock(blockBoundary$1.to.block);
			};
			const skipLastBr = (rootNode, forward, blockPosition$1) => {
				if (isBr$6(blockPosition$1.position.getNode()) && !isEmpty$2(blockPosition$1.block)) return positionIn(false, blockPosition$1.block.dom).bind((lastPositionInBlock) => {
					if (lastPositionInBlock.isEqual(blockPosition$1.position)) return fromPosition(forward, rootNode, lastPositionInBlock).bind((to$1) => getBlockPosition(rootNode, to$1));
					else return Optional.some(blockPosition$1);
				}).getOr(blockPosition$1);
				else return blockPosition$1;
			};
			const readFromRange = (rootNode, forward, rng) => {
				const fromBlockPos = getBlockPosition(rootNode, CaretPosition.fromRangeStart(rng));
				return lift2(fromBlockPos, fromBlockPos.bind((blockPos) => fromPosition(forward, rootNode, blockPos.position).bind((to$1) => getBlockPosition(rootNode, to$1).map((blockPos$1) => skipLastBr(rootNode, forward, blockPos$1)))), blockBoundary).filter((blockBoundary$1) => isDifferentBlocks(blockBoundary$1) && hasSameHost(rootNode, blockBoundary$1) && isEditable$1(blockBoundary$1) && hasValidBlocks(blockBoundary$1));
			};
			const read$1 = (rootNode, forward, rng) => rng.collapsed ? readFromRange(rootNode, forward, rng) : Optional.none();
			const getChildrenUntilBlockBoundary = (block) => {
				const children$2 = children$1(block);
				return findIndex$2(children$2, isBlock$2).fold(constant(children$2), (index) => children$2.slice(0, index));
			};
			const extractChildren = (block) => {
				const children$2 = getChildrenUntilBlockBoundary(block);
				each$e(children$2, remove$5);
				return children$2;
			};
			const removeEmptyRoot = (rootNode, block) => {
				return find$2(parentsAndSelf(block, rootNode).reverse(), (element) => isEmpty$2(element)).each(remove$5);
			};
			const isEmptyBefore = (el) => filter$5(prevSiblings(el), (el$1) => !isEmpty$2(el$1)).length === 0;
			const nestedBlockMerge = (rootNode, fromBlock, toBlock, insertionPoint) => {
				if (isEmpty$2(toBlock)) {
					fillWithPaddingBr(toBlock);
					return firstPositionIn(toBlock.dom);
				}
				if (isEmptyBefore(insertionPoint) && isEmpty$2(fromBlock)) before$3(insertionPoint, SugarElement.fromTag("br"));
				const position = prevPosition(toBlock.dom, CaretPosition.before(insertionPoint.dom));
				each$e(extractChildren(fromBlock), (child$2) => {
					before$3(insertionPoint, child$2);
				});
				removeEmptyRoot(rootNode, fromBlock);
				return position;
			};
			const sidelongBlockMerge = (rootNode, fromBlock, toBlock) => {
				if (isEmpty$2(toBlock)) {
					if (isEmpty$2(fromBlock)) {
						const getInlineToBlockDescendants = (el) => {
							const helper = (node, elements) => firstChild(node).fold(() => elements, (child$2) => isInline$1(child$2) ? helper(child$2, elements.concat(shallow$1(child$2))) : elements);
							return helper(el, []);
						};
						const newFromBlockDescendants = foldr(getInlineToBlockDescendants(toBlock), (element, descendant$2) => {
							wrap$2(element, descendant$2);
							return descendant$2;
						}, createPaddingBr());
						empty(fromBlock);
						append$1(fromBlock, newFromBlockDescendants);
					}
					remove$5(toBlock);
					return firstPositionIn(fromBlock.dom);
				}
				const position = lastPositionIn(toBlock.dom);
				each$e(extractChildren(fromBlock), (child$2) => {
					append$1(toBlock, child$2);
				});
				removeEmptyRoot(rootNode, fromBlock);
				return position;
			};
			const findInsertionPoint = (toBlock, block) => {
				const parentsAndSelf$1 = parentsAndSelf(block, toBlock);
				return Optional.from(parentsAndSelf$1[parentsAndSelf$1.length - 1]);
			};
			const getInsertionPoint = (fromBlock, toBlock) => contains(toBlock, fromBlock) ? findInsertionPoint(toBlock, fromBlock) : Optional.none();
			const trimBr = (first$2, block) => {
				positionIn(first$2, block.dom).bind((position) => Optional.from(position.getNode())).map(SugarElement.fromDom).filter(isBr$5).each(remove$5);
			};
			const mergeBlockInto = (rootNode, fromBlock, toBlock) => {
				trimBr(true, fromBlock);
				trimBr(false, toBlock);
				return getInsertionPoint(fromBlock, toBlock).fold(curry(sidelongBlockMerge, rootNode, fromBlock, toBlock), curry(nestedBlockMerge, rootNode, fromBlock, toBlock));
			};
			const mergeBlocks = (rootNode, forward, block1, block2) => forward ? mergeBlockInto(rootNode, block2, block1) : mergeBlockInto(rootNode, block1, block2);
			const backspaceDelete$9 = (editor, forward) => {
				const rootNode = SugarElement.fromDom(editor.getBody());
				return read$1(rootNode.dom, forward, editor.selection.getRng()).map((blockBoundary$1) => () => {
					mergeBlocks(rootNode, forward, blockBoundary$1.from.block, blockBoundary$1.to.block).each((pos) => {
						editor.selection.setRng(pos.toRange());
					});
				});
			};
			const deleteRangeMergeBlocks = (rootNode, selection) => {
				const rng = selection.getRng();
				return lift2(getParentBlock$2(rootNode, SugarElement.fromDom(rng.startContainer)), getParentBlock$2(rootNode, SugarElement.fromDom(rng.endContainer)), (block1, block2) => {
					if (!eq(block1, block2)) return Optional.some(() => {
						rng.deleteContents();
						mergeBlocks(rootNode, true, block1, block2).each((pos) => {
							selection.setRng(pos.toRange());
						});
					});
					else return Optional.none();
				}).getOr(Optional.none());
			};
			const isRawNodeInTable = (root, rawNode) => {
				return ancestor$4(SugarElement.fromDom(rawNode), isTableCell$2, curry(eq, root)).isSome();
			};
			const isSelectionInTable = (root, rng) => isRawNodeInTable(root, rng.startContainer) || isRawNodeInTable(root, rng.endContainer);
			const isEverythingSelected = (root, rng) => {
				const noPrevious = prevPosition(root.dom, CaretPosition.fromRangeStart(rng)).isNone();
				const noNext = nextPosition(root.dom, CaretPosition.fromRangeEnd(rng)).isNone();
				return !isSelectionInTable(root, rng) && noPrevious && noNext;
			};
			const emptyEditor = (editor) => {
				return Optional.some(() => {
					editor.setContent("");
					editor.selection.setCursorLocation();
				});
			};
			const deleteRange$2 = (editor) => {
				const rootNode = SugarElement.fromDom(editor.getBody());
				return isEverythingSelected(rootNode, editor.selection.getRng()) ? emptyEditor(editor) : deleteRangeMergeBlocks(rootNode, editor.selection);
			};
			const backspaceDelete$8 = (editor, _forward) => editor.selection.isCollapsed() ? Optional.none() : deleteRange$2(editor);
			const showCaret = (direction, editor, node, before$1, scrollIntoView) => Optional.from(editor._selectionOverrides.showCaret(direction, node, before$1, scrollIntoView));
			const getNodeRange = (node) => {
				const rng = node.ownerDocument.createRange();
				rng.selectNode(node);
				return rng;
			};
			const selectNode = (editor, node) => {
				if (editor.dispatch("BeforeObjectSelected", { target: node }).isDefaultPrevented()) return Optional.none();
				return Optional.some(getNodeRange(node));
			};
			const renderCaretAtRange = (editor, range, scrollIntoView) => {
				const normalizedRange = normalizeRange(1, editor.getBody(), range);
				const caretPosition = CaretPosition.fromRangeStart(normalizedRange);
				const caretPositionNode = caretPosition.getNode();
				if (isInlineFakeCaretTarget(caretPositionNode)) return showCaret(1, editor, caretPositionNode, !caretPosition.isAtEnd(), false);
				const caretPositionBeforeNode = caretPosition.getNode(true);
				if (isInlineFakeCaretTarget(caretPositionBeforeNode)) return showCaret(1, editor, caretPositionBeforeNode, false, false);
				const ceRoot = getContentEditableRoot$1(editor.dom.getRoot(), caretPosition.getNode());
				if (isInlineFakeCaretTarget(ceRoot)) return showCaret(1, editor, ceRoot, false, scrollIntoView);
				return Optional.none();
			};
			const renderRangeCaret = (editor, range, scrollIntoView) => range.collapsed ? renderCaretAtRange(editor, range, scrollIntoView).getOr(range) : range;
			const isBeforeBoundary = (pos) => isBeforeContentEditableFalse(pos) || isBeforeMedia(pos);
			const isAfterBoundary = (pos) => isAfterContentEditableFalse(pos) || isAfterMedia(pos);
			const trimEmptyTextNode = (dom$1, node) => {
				if (isText$a(node) && node.data.length === 0) dom$1.remove(node);
			};
			const deleteContentAndShowCaret = (editor, range, node, direction, forward, peekCaretPosition) => {
				showCaret(direction, editor, peekCaretPosition.getNode(!forward), forward, true).each((caretRange) => {
					if (range.collapsed) {
						const deleteRange$4 = range.cloneRange();
						if (forward) deleteRange$4.setEnd(caretRange.startContainer, caretRange.startOffset);
						else deleteRange$4.setStart(caretRange.endContainer, caretRange.endOffset);
						deleteRange$4.deleteContents();
					} else range.deleteContents();
					editor.selection.setRng(caretRange);
				});
				trimEmptyTextNode(editor.dom, node);
			};
			const deleteBoundaryText = (editor, forward) => {
				const range = editor.selection.getRng();
				if (!isText$a(range.commonAncestorContainer)) return Optional.none();
				const direction = forward ? HDirection.Forwards : HDirection.Backwards;
				const caretWalker = CaretWalker(editor.getBody());
				const getNextPosFn = curry(getVisualCaretPosition, forward ? caretWalker.next : caretWalker.prev);
				const isBeforeFn = forward ? isBeforeBoundary : isAfterBoundary;
				const caretPosition = getNormalizedRangeEndPoint(direction, editor.getBody(), range);
				const nextCaretPosition = getNextPosFn(caretPosition);
				const normalizedNextCaretPosition = nextCaretPosition ? normalizePosition(forward, nextCaretPosition) : nextCaretPosition;
				if (!normalizedNextCaretPosition || !isMoveInsideSameBlock(caretPosition, normalizedNextCaretPosition)) return Optional.none();
				else if (isBeforeFn(normalizedNextCaretPosition)) return Optional.some(() => deleteContentAndShowCaret(editor, range, caretPosition.getNode(), direction, forward, normalizedNextCaretPosition));
				const peekCaretPosition = getNextPosFn(normalizedNextCaretPosition);
				if (peekCaretPosition && isBeforeFn(peekCaretPosition)) {
					if (isMoveInsideSameBlock(normalizedNextCaretPosition, peekCaretPosition)) return Optional.some(() => deleteContentAndShowCaret(editor, range, caretPosition.getNode(), direction, forward, peekCaretPosition));
				}
				return Optional.none();
			};
			const backspaceDelete$7 = (editor, forward) => deleteBoundaryText(editor, forward);
			const getEdgeCefPosition = (editor, atStart) => {
				const root = editor.getBody();
				return atStart ? firstPositionIn(root).filter(isBeforeContentEditableFalse) : lastPositionIn(root).filter(isAfterContentEditableFalse);
			};
			const isCefAtEdgeSelected = (editor) => {
				const rng = editor.selection.getRng();
				return !rng.collapsed && (getEdgeCefPosition(editor, true).exists((pos) => pos.isEqual(CaretPosition.fromRangeStart(rng))) || getEdgeCefPosition(editor, false).exists((pos) => pos.isEqual(CaretPosition.fromRangeEnd(rng))));
			};
			const isCompoundElement = (node) => isNonNullable(node) && (isTableCell$2(SugarElement.fromDom(node)) || isListItem$1(SugarElement.fromDom(node)));
			const DeleteAction = Adt.generate([
				{ remove: ["element"] },
				{ moveToElement: ["element"] },
				{ moveToPosition: ["position"] }
			]);
			const isAtContentEditableBlockCaret = (forward, from$1) => {
				const elm = from$1.getNode(!forward);
				const caretLocation = forward ? "after" : "before";
				return isElement$6(elm) && elm.getAttribute("data-mce-caret") === caretLocation;
			};
			const isDeleteFromCefDifferentBlocks = (root, forward, from$1, to$1) => {
				const inSameBlock = (elm) => isInline$1(SugarElement.fromDom(elm)) && !isInSameBlock(from$1, to$1, root);
				return getRelativeCefElm(!forward, from$1).fold(() => getRelativeCefElm(forward, to$1).fold(never, inSameBlock), inSameBlock);
			};
			const deleteEmptyBlockOrMoveToCef = (root, forward, from$1, to$1) => {
				const toCefElm = to$1.getNode(!forward);
				return getParentBlock$2(SugarElement.fromDom(root), SugarElement.fromDom(from$1.getNode())).map((blockElm) => isEmpty$2(blockElm) ? DeleteAction.remove(blockElm.dom) : DeleteAction.moveToElement(toCefElm)).orThunk(() => Optional.some(DeleteAction.moveToElement(toCefElm)));
			};
			const findCefPosition = (root, forward, from$1) => fromPosition(forward, root, from$1).bind((to$1) => {
				if (isCompoundElement(to$1.getNode())) return Optional.none();
				else if (isDeleteFromCefDifferentBlocks(root, forward, from$1, to$1)) return Optional.none();
				else if (forward && isContentEditableFalse$b(to$1.getNode())) return deleteEmptyBlockOrMoveToCef(root, forward, from$1, to$1);
				else if (!forward && isContentEditableFalse$b(to$1.getNode(true))) return deleteEmptyBlockOrMoveToCef(root, forward, from$1, to$1);
				else if (forward && isAfterContentEditableFalse(from$1)) return Optional.some(DeleteAction.moveToPosition(to$1));
				else if (!forward && isBeforeContentEditableFalse(from$1)) return Optional.some(DeleteAction.moveToPosition(to$1));
				else return Optional.none();
			});
			const getContentEditableBlockAction = (forward, elm) => {
				if (isNullable(elm)) return Optional.none();
				else if (forward && isContentEditableFalse$b(elm.nextSibling)) return Optional.some(DeleteAction.moveToElement(elm.nextSibling));
				else if (!forward && isContentEditableFalse$b(elm.previousSibling)) return Optional.some(DeleteAction.moveToElement(elm.previousSibling));
				else return Optional.none();
			};
			const skipMoveToActionFromInlineCefToContent = (root, from$1, deleteAction$1) => deleteAction$1.fold((elm) => Optional.some(DeleteAction.remove(elm)), (elm) => Optional.some(DeleteAction.moveToElement(elm)), (to$1) => {
				if (isInSameBlock(from$1, to$1, root)) return Optional.none();
				else return Optional.some(DeleteAction.moveToPosition(to$1));
			});
			const getContentEditableAction = (root, forward, from$1) => {
				if (isAtContentEditableBlockCaret(forward, from$1)) return getContentEditableBlockAction(forward, from$1.getNode(!forward)).orThunk(() => findCefPosition(root, forward, from$1));
				else return findCefPosition(root, forward, from$1).bind((deleteAction$1) => skipMoveToActionFromInlineCefToContent(root, from$1, deleteAction$1));
			};
			const read = (root, forward, rng) => {
				const normalizedRange = normalizeRange(forward ? 1 : -1, root, rng);
				const from$1 = CaretPosition.fromRangeStart(normalizedRange);
				const rootElement = SugarElement.fromDom(root);
				if (!forward && isAfterContentEditableFalse(from$1)) return Optional.some(DeleteAction.remove(from$1.getNode(true)));
				else if (forward && isBeforeContentEditableFalse(from$1)) return Optional.some(DeleteAction.remove(from$1.getNode()));
				else if (!forward && isBeforeContentEditableFalse(from$1) && isAfterBr(rootElement, from$1)) return findPreviousBr(rootElement, from$1).map((br) => DeleteAction.remove(br.getNode()));
				else if (forward && isAfterContentEditableFalse(from$1) && isBeforeBr$1(rootElement, from$1)) return findNextBr(rootElement, from$1).map((br) => DeleteAction.remove(br.getNode()));
				else return getContentEditableAction(root, forward, from$1);
			};
			const deleteElement$1 = (editor, forward) => (element) => {
				editor._selectionOverrides.hideFakeCaret();
				deleteElement$2(editor, forward, SugarElement.fromDom(element));
				return true;
			};
			const moveToElement = (editor, forward) => (element) => {
				const pos = forward ? CaretPosition.before(element) : CaretPosition.after(element);
				editor.selection.setRng(pos.toRange());
				return true;
			};
			const moveToPosition = (editor) => (pos) => {
				editor.selection.setRng(pos.toRange());
				return true;
			};
			const getAncestorCe = (editor, node) => Optional.from(getContentEditableRoot$1(editor.getBody(), node));
			const backspaceDeleteCaret = (editor, forward) => {
				return getAncestorCe(editor, editor.selection.getNode()).filter(isContentEditableFalse$b).fold(() => read(editor.getBody(), forward, editor.selection.getRng()).map((deleteAction$1) => () => deleteAction$1.fold(deleteElement$1(editor, forward), moveToElement(editor, forward), moveToPosition(editor))), () => Optional.some(noop));
			};
			const deleteOffscreenSelection = (rootElement) => {
				each$e(descendants(rootElement, ".mce-offscreen-selection"), remove$5);
			};
			const backspaceDeleteRange = (editor, forward) => {
				const selectedNode = editor.selection.getNode();
				if (isContentEditableFalse$b(selectedNode) && !isTableCell$3(selectedNode)) return getAncestorCe(editor, selectedNode.parentNode).filter(isContentEditableFalse$b).fold(() => Optional.some(() => {
					deleteOffscreenSelection(SugarElement.fromDom(editor.getBody()));
					deleteElement$2(editor, forward, SugarElement.fromDom(editor.selection.getNode()));
					paddEmptyBody(editor);
				}), () => Optional.some(noop));
				if (isCefAtEdgeSelected(editor)) return Optional.some(() => {
					deleteRangeContents(editor, editor.selection.getRng(), SugarElement.fromDom(editor.getBody()));
				});
				return Optional.none();
			};
			const paddEmptyElement = (editor) => {
				const dom$1 = editor.dom, selection = editor.selection;
				const ceRoot = getContentEditableRoot$1(editor.getBody(), selection.getNode());
				if (isContentEditableTrue$3(ceRoot) && dom$1.isBlock(ceRoot) && dom$1.isEmpty(ceRoot)) {
					const br = dom$1.create("br", { "data-mce-bogus": "1" });
					dom$1.setHTML(ceRoot, "");
					ceRoot.appendChild(br);
					selection.setRng(CaretPosition.before(br).toRange());
				}
				return true;
			};
			const backspaceDelete$6 = (editor, forward) => {
				if (editor.selection.isCollapsed()) return backspaceDeleteCaret(editor, forward);
				else return backspaceDeleteRange(editor, forward);
			};
			const deleteCaret$2 = (editor, forward) => {
				const fromPos = CaretPosition.fromRangeStart(editor.selection.getRng());
				return fromPosition(forward, editor.getBody(), fromPos).filter((pos) => forward ? isBeforeImageBlock(pos) : isAfterImageBlock(pos)).bind((pos) => getChildNodeAtRelativeOffset(forward ? 0 : -1, pos)).map((elm) => () => editor.selection.select(elm));
			};
			const backspaceDelete$5 = (editor, forward) => editor.selection.isCollapsed() ? deleteCaret$2(editor, forward) : Optional.none();
			const isText$2 = isText$a;
			const startsWithCaretContainer = (node) => isText$2(node) && node.data[0] === ZWSP$1;
			const endsWithCaretContainer = (node) => isText$2(node) && node.data[node.data.length - 1] === ZWSP$1;
			const createZwsp = (node) => {
				var _a;
				return ((_a = node.ownerDocument) !== null && _a !== void 0 ? _a : document).createTextNode(ZWSP$1);
			};
			const insertBefore$1 = (node) => {
				var _a;
				if (isText$2(node.previousSibling)) if (endsWithCaretContainer(node.previousSibling)) return node.previousSibling;
				else {
					node.previousSibling.appendData(ZWSP$1);
					return node.previousSibling;
				}
				else if (isText$2(node)) if (startsWithCaretContainer(node)) return node;
				else {
					node.insertData(0, ZWSP$1);
					return node;
				}
				else {
					const newNode = createZwsp(node);
					(_a = node.parentNode) === null || _a === void 0 || _a.insertBefore(newNode, node);
					return newNode;
				}
			};
			const insertAfter$1 = (node) => {
				var _a, _b;
				if (isText$2(node.nextSibling)) if (startsWithCaretContainer(node.nextSibling)) return node.nextSibling;
				else {
					node.nextSibling.insertData(0, ZWSP$1);
					return node.nextSibling;
				}
				else if (isText$2(node)) if (endsWithCaretContainer(node)) return node;
				else {
					node.appendData(ZWSP$1);
					return node;
				}
				else {
					const newNode = createZwsp(node);
					if (node.nextSibling) (_a = node.parentNode) === null || _a === void 0 || _a.insertBefore(newNode, node.nextSibling);
					else (_b = node.parentNode) === null || _b === void 0 || _b.appendChild(newNode);
					return newNode;
				}
			};
			const insertInline = (before$1, node) => before$1 ? insertBefore$1(node) : insertAfter$1(node);
			const insertInlineBefore = curry(insertInline, true);
			const insertInlineAfter = curry(insertInline, false);
			const insertInlinePos = (pos, before$1) => {
				if (isText$a(pos.container())) return insertInline(before$1, pos.container());
				else return insertInline(before$1, pos.getNode());
			};
			const isPosCaretContainer = (pos, caret) => {
				const caretNode = caret.get();
				return caretNode && pos.container() === caretNode && isCaretContainerInline(caretNode);
			};
			const renderCaret = (caret, location) => location.fold((element) => {
				remove$3(caret.get());
				const text$1 = insertInlineBefore(element);
				caret.set(text$1);
				return Optional.some(CaretPosition(text$1, text$1.length - 1));
			}, (element) => firstPositionIn(element).map((pos) => {
				if (!isPosCaretContainer(pos, caret)) {
					remove$3(caret.get());
					const text$1 = insertInlinePos(pos, true);
					caret.set(text$1);
					return CaretPosition(text$1, 1);
				} else return CaretPosition(caret.get(), 1);
			}), (element) => lastPositionIn(element).map((pos) => {
				if (!isPosCaretContainer(pos, caret)) {
					remove$3(caret.get());
					const text$1 = insertInlinePos(pos, false);
					caret.set(text$1);
					return CaretPosition(text$1, text$1.length - 1);
				} else {
					const node = caret.get();
					return CaretPosition(node, node.length - 1);
				}
			}), (element) => {
				remove$3(caret.get());
				const text$1 = insertInlineAfter(element);
				caret.set(text$1);
				return Optional.some(CaretPosition(text$1, 1));
			});
			const evaluateUntil = (fns, args) => {
				for (let i = 0; i < fns.length; i++) {
					const result = fns[i].apply(null, args);
					if (result.isSome()) return result;
				}
				return Optional.none();
			};
			const Location = Adt.generate([
				{ before: ["element"] },
				{ start: ["element"] },
				{ end: ["element"] },
				{ after: ["element"] }
			]);
			const rescope$1 = (rootNode, node) => {
				const parentBlock = getParentBlock$3(node, rootNode);
				return parentBlock ? parentBlock : rootNode;
			};
			const before = (isInlineTarget$1, rootNode, pos) => {
				const nPos = normalizeForwards(pos);
				const scope = rescope$1(rootNode, nPos.container());
				return findRootInline(isInlineTarget$1, scope, nPos).fold(() => nextPosition(scope, nPos).bind(curry(findRootInline, isInlineTarget$1, scope)).map((inline) => Location.before(inline)), Optional.none);
			};
			const isNotInsideFormatCaretContainer = (rootNode, elm) => getParentCaretContainer(rootNode, elm) === null;
			const findInsideRootInline = (isInlineTarget$1, rootNode, pos) => findRootInline(isInlineTarget$1, rootNode, pos).filter(curry(isNotInsideFormatCaretContainer, rootNode));
			const start$1 = (isInlineTarget$1, rootNode, pos) => {
				const nPos = normalizeBackwards(pos);
				return findInsideRootInline(isInlineTarget$1, rootNode, nPos).bind((inline) => {
					return prevPosition(inline, nPos).isNone() ? Optional.some(Location.start(inline)) : Optional.none();
				});
			};
			const end = (isInlineTarget$1, rootNode, pos) => {
				const nPos = normalizeForwards(pos);
				return findInsideRootInline(isInlineTarget$1, rootNode, nPos).bind((inline) => {
					return nextPosition(inline, nPos).isNone() ? Optional.some(Location.end(inline)) : Optional.none();
				});
			};
			const after = (isInlineTarget$1, rootNode, pos) => {
				const nPos = normalizeBackwards(pos);
				const scope = rescope$1(rootNode, nPos.container());
				return findRootInline(isInlineTarget$1, scope, nPos).fold(() => prevPosition(scope, nPos).bind(curry(findRootInline, isInlineTarget$1, scope)).map((inline) => Location.after(inline)), Optional.none);
			};
			const isValidLocation = (location) => !isRtl(getElement(location));
			const readLocation = (isInlineTarget$1, rootNode, pos) => {
				return evaluateUntil([
					before,
					start$1,
					end,
					after
				], [
					isInlineTarget$1,
					rootNode,
					pos
				]).filter(isValidLocation);
			};
			const getElement = (location) => location.fold(identity, identity, identity, identity);
			const getName = (location) => location.fold(constant("before"), constant("start"), constant("end"), constant("after"));
			const outside = (location) => location.fold(Location.before, Location.before, Location.after, Location.after);
			const inside = (location) => location.fold(Location.start, Location.start, Location.end, Location.end);
			const isEq = (location1, location2) => getName(location1) === getName(location2) && getElement(location1) === getElement(location2);
			const betweenInlines = (forward, isInlineTarget$1, rootNode, from$1, to$1, location) => lift2(findRootInline(isInlineTarget$1, rootNode, from$1), findRootInline(isInlineTarget$1, rootNode, to$1), (fromInline, toInline) => {
				if (fromInline !== toInline && hasSameParentBlock(rootNode, fromInline, toInline)) return Location.after(forward ? fromInline : toInline);
				else return location;
			}).getOr(location);
			const skipNoMovement = (fromLocation, toLocation) => fromLocation.fold(always, (fromLocation$1) => !isEq(fromLocation$1, toLocation));
			const findLocationTraverse = (forward, isInlineTarget$1, rootNode, fromLocation, pos) => {
				const from$1 = normalizePosition(forward, pos);
				return fromPosition(forward, rootNode, from$1).map(curry(normalizePosition, forward)).fold(() => fromLocation.map(outside), (to$1) => readLocation(isInlineTarget$1, rootNode, to$1).map(curry(betweenInlines, forward, isInlineTarget$1, rootNode, from$1, to$1)).filter(curry(skipNoMovement, fromLocation))).filter(isValidLocation);
			};
			const findLocationSimple = (forward, location) => {
				if (forward) return location.fold(compose(Optional.some, Location.start), Optional.none, compose(Optional.some, Location.after), Optional.none);
				else return location.fold(Optional.none, compose(Optional.some, Location.before), Optional.none, compose(Optional.some, Location.end));
			};
			const findLocation$1 = (forward, isInlineTarget$1, rootNode, pos) => {
				const from$1 = normalizePosition(forward, pos);
				const fromLocation = readLocation(isInlineTarget$1, rootNode, from$1);
				return readLocation(isInlineTarget$1, rootNode, from$1).bind(curry(findLocationSimple, forward)).orThunk(() => findLocationTraverse(forward, isInlineTarget$1, rootNode, fromLocation, pos));
			};
			const hasSelectionModifyApi = (editor) => {
				return isFunction(editor.selection.getSel().modify);
			};
			const moveRel = (forward, selection, pos) => {
				const delta = forward ? 1 : -1;
				selection.setRng(CaretPosition(pos.container(), pos.offset() + delta).toRange());
				selection.getSel().modify("move", forward ? "forward" : "backward", "word");
				return true;
			};
			const moveByWord = (forward, editor) => {
				const rng = editor.selection.getRng();
				const pos = forward ? CaretPosition.fromRangeEnd(rng) : CaretPosition.fromRangeStart(rng);
				if (!hasSelectionModifyApi(editor)) return false;
				else if (forward && isBeforeInline(pos)) return moveRel(true, editor.selection, pos);
				else if (!forward && isAfterInline(pos)) return moveRel(false, editor.selection, pos);
				else return false;
			};
			var BreakType;
			(function(BreakType$1) {
				BreakType$1[BreakType$1["Br"] = 0] = "Br";
				BreakType$1[BreakType$1["Block"] = 1] = "Block";
				BreakType$1[BreakType$1["Wrap"] = 2] = "Wrap";
				BreakType$1[BreakType$1["Eol"] = 3] = "Eol";
			})(BreakType || (BreakType = {}));
			const flip = (direction, positions) => direction === HDirection.Backwards ? reverse(positions) : positions;
			const walk$1 = (direction, caretWalker, pos) => direction === HDirection.Forwards ? caretWalker.next(pos) : caretWalker.prev(pos);
			const getBreakType = (scope, direction, currentPos, nextPos) => {
				if (isBr$6(nextPos.getNode(direction === HDirection.Forwards))) return BreakType.Br;
				else if (isInSameBlock(currentPos, nextPos) === false) return BreakType.Block;
				else return BreakType.Wrap;
			};
			const getPositionsUntil = (predicate, direction, scope, start$2) => {
				const caretWalker = CaretWalker(scope);
				let currentPos = start$2;
				const positions = [];
				while (currentPos) {
					const nextPos = walk$1(direction, caretWalker, currentPos);
					if (!nextPos) break;
					if (isBr$6(nextPos.getNode(false))) if (direction === HDirection.Forwards) return {
						positions: flip(direction, positions).concat([nextPos]),
						breakType: BreakType.Br,
						breakAt: Optional.some(nextPos)
					};
					else return {
						positions: flip(direction, positions),
						breakType: BreakType.Br,
						breakAt: Optional.some(nextPos)
					};
					if (!nextPos.isVisible()) {
						currentPos = nextPos;
						continue;
					}
					if (predicate(currentPos, nextPos)) {
						const breakType = getBreakType(scope, direction, currentPos, nextPos);
						return {
							positions: flip(direction, positions),
							breakType,
							breakAt: Optional.some(nextPos)
						};
					}
					positions.push(nextPos);
					currentPos = nextPos;
				}
				return {
					positions: flip(direction, positions),
					breakType: BreakType.Eol,
					breakAt: Optional.none()
				};
			};
			const getAdjacentLinePositions = (direction, getPositionsUntilBreak, scope, start$2) => getPositionsUntilBreak(scope, start$2).breakAt.map((pos) => {
				const positions = getPositionsUntilBreak(scope, pos).positions;
				return direction === HDirection.Backwards ? positions.concat(pos) : [pos].concat(positions);
			}).getOr([]);
			const findClosestHorizontalPositionFromPoint = (positions, x) => foldl(positions, (acc, newPos) => acc.fold(() => Optional.some(newPos), (lastPos) => lift2(head(lastPos.getClientRects()), head(newPos.getClientRects()), (lastRect, newRect) => {
				const lastDist = Math.abs(x - lastRect.left);
				return Math.abs(x - newRect.left) <= lastDist ? newPos : lastPos;
			}).or(acc)), Optional.none());
			const findClosestHorizontalPosition = (positions, pos) => head(pos.getClientRects()).bind((targetRect) => findClosestHorizontalPositionFromPoint(positions, targetRect.left));
			const getPositionsUntilPreviousLine = curry(getPositionsUntil, CaretPosition.isAbove, -1);
			const getPositionsUntilNextLine = curry(getPositionsUntil, CaretPosition.isBelow, 1);
			const getPositionsAbove = curry(getAdjacentLinePositions, -1, getPositionsUntilPreviousLine);
			const getPositionsBelow = curry(getAdjacentLinePositions, 1, getPositionsUntilNextLine);
			const isAtFirstLine = (scope, pos) => getPositionsUntilPreviousLine(scope, pos).breakAt.isNone();
			const isAtLastLine = (scope, pos) => getPositionsUntilNextLine(scope, pos).breakAt.isNone();
			const getFirstLinePositions = (scope) => firstPositionIn(scope).map((pos) => [pos].concat(getPositionsUntilNextLine(scope, pos).positions)).getOr([]);
			const getLastLinePositions = (scope) => lastPositionIn(scope).map((pos) => getPositionsUntilPreviousLine(scope, pos).positions.concat(pos)).getOr([]);
			const getClosestPositionAbove = (scope, pos) => findClosestHorizontalPosition(getPositionsAbove(scope, pos), pos);
			const getClosestPositionBelow = (scope, pos) => findClosestHorizontalPosition(getPositionsBelow(scope, pos), pos);
			const isContentEditableFalse$4 = isContentEditableFalse$b;
			const distanceToRectLeft$1 = (clientRect, clientX) => Math.abs(clientRect.left - clientX);
			const distanceToRectRight$1 = (clientRect, clientX) => Math.abs(clientRect.right - clientX);
			const isNodeClientRect = (rect) => hasNonNullableKey(rect, "node");
			const findClosestClientRect = (clientRects, clientX) => reduce(clientRects, (oldClientRect, clientRect) => {
				const oldDistance = Math.min(distanceToRectLeft$1(oldClientRect, clientX), distanceToRectRight$1(oldClientRect, clientX));
				const newDistance = Math.min(distanceToRectLeft$1(clientRect, clientX), distanceToRectRight$1(clientRect, clientX));
				if (newDistance === oldDistance && isNodeClientRect(clientRect) && isContentEditableFalse$4(clientRect.node)) return clientRect;
				if (newDistance < oldDistance) return clientRect;
				return oldClientRect;
			});
			const getNodeClientRects = (node) => {
				const toArrayWithNode = (clientRects) => {
					return map$3(clientRects, (rect) => {
						const clientRect = clone$1(rect);
						clientRect.node = node;
						return clientRect;
					});
				};
				if (isElement$6(node)) return toArrayWithNode(node.getClientRects());
				else if (isText$a(node)) {
					const rng = node.ownerDocument.createRange();
					rng.setStart(node, 0);
					rng.setEnd(node, node.data.length);
					return toArrayWithNode(rng.getClientRects());
				} else return [];
			};
			const getClientRects = (nodes) => bind$3(nodes, getNodeClientRects);
			var VDirection;
			(function(VDirection$1) {
				VDirection$1[VDirection$1["Up"] = -1] = "Up";
				VDirection$1[VDirection$1["Down"] = 1] = "Down";
			})(VDirection || (VDirection = {}));
			const findUntil = (direction, root, predicateFn, node) => {
				let currentNode = node;
				while (currentNode = findNode(currentNode, direction, isEditableCaretCandidate$1, root)) if (predicateFn(currentNode)) return;
			};
			const walkUntil = (direction, isAboveFn, isBeflowFn, root, predicateFn, caretPosition) => {
				let line = 0;
				const result = [];
				const add$5 = (node$1) => {
					let clientRects = getClientRects([node$1]);
					if (direction === -1) clientRects = clientRects.reverse();
					for (let i = 0; i < clientRects.length; i++) {
						const clientRect = clientRects[i];
						if (isBeflowFn(clientRect, targetClientRect)) continue;
						if (result.length > 0 && isAboveFn(clientRect, last$2(result))) line++;
						clientRect.line = line;
						if (predicateFn(clientRect)) return true;
						result.push(clientRect);
					}
					return false;
				};
				const targetClientRect = last$2(caretPosition.getClientRects());
				if (!targetClientRect) return result;
				const node = caretPosition.getNode();
				if (node) {
					add$5(node);
					findUntil(direction, root, add$5, node);
				}
				return result;
			};
			const aboveLineNumber = (lineNumber, clientRect) => clientRect.line > lineNumber;
			const isLineNumber = (lineNumber, clientRect) => clientRect.line === lineNumber;
			const upUntil = curry(walkUntil, VDirection.Up, isAbove$1, isBelow$1);
			const downUntil = curry(walkUntil, VDirection.Down, isBelow$1, isAbove$1);
			const getLastClientRect = (caretPosition) => {
				return last$2(caretPosition.getClientRects());
			};
			const positionsUntil = (direction, root, predicateFn, node) => {
				const caretWalker = CaretWalker(root);
				let walkFn;
				let isBelowFn;
				let isAboveFn;
				let caretPosition;
				const result = [];
				let line = 0;
				if (direction === 1) {
					walkFn = caretWalker.next;
					isBelowFn = isBelow$1;
					isAboveFn = isAbove$1;
					caretPosition = CaretPosition.after(node);
				} else {
					walkFn = caretWalker.prev;
					isBelowFn = isAbove$1;
					isAboveFn = isBelow$1;
					caretPosition = CaretPosition.before(node);
				}
				const targetClientRect = getLastClientRect(caretPosition);
				do {
					if (!caretPosition.isVisible()) continue;
					const rect = getLastClientRect(caretPosition);
					if (isAboveFn(rect, targetClientRect)) continue;
					if (result.length > 0 && isBelowFn(rect, last$2(result))) line++;
					const clientRect = clone$1(rect);
					clientRect.position = caretPosition;
					clientRect.line = line;
					if (predicateFn(clientRect)) return result;
					result.push(clientRect);
				} while (caretPosition = walkFn(caretPosition));
				return result;
			};
			const isAboveLine = (lineNumber) => (clientRect) => aboveLineNumber(lineNumber, clientRect);
			const isLine = (lineNumber) => (clientRect) => isLineNumber(lineNumber, clientRect);
			const moveToRange = (editor, rng) => {
				editor.selection.setRng(rng);
				scrollRangeIntoView(editor, editor.selection.getRng());
			};
			const renderRangeCaretOpt = (editor, range, scrollIntoView) => Optional.some(renderRangeCaret(editor, range, scrollIntoView));
			const moveHorizontally = (editor, direction, range, isBefore, isAfter, isElement$8) => {
				const forwards = direction === HDirection.Forwards;
				const caretWalker = CaretWalker(editor.getBody());
				const getNextPosFn = curry(getVisualCaretPosition, forwards ? caretWalker.next : caretWalker.prev);
				const isBeforeFn = forwards ? isBefore : isAfter;
				if (!range.collapsed) {
					const node = getSelectedNode(range);
					if (isElement$8(node)) return showCaret(direction, editor, node, direction === HDirection.Backwards, false);
					else if (isCefAtEdgeSelected(editor)) {
						const newRange = range.cloneRange();
						newRange.collapse(direction === HDirection.Backwards);
						return Optional.from(newRange);
					}
				}
				const caretPosition = getNormalizedRangeEndPoint(direction, editor.getBody(), range);
				if (isBeforeFn(caretPosition)) return selectNode(editor, caretPosition.getNode(!forwards));
				let nextCaretPosition = getNextPosFn(caretPosition);
				const rangeIsInContainerBlock = isRangeInCaretContainerBlock(range);
				if (!nextCaretPosition) return rangeIsInContainerBlock ? Optional.some(range) : Optional.none();
				else nextCaretPosition = normalizePosition(forwards, nextCaretPosition);
				if (isBeforeFn(nextCaretPosition)) return showCaret(direction, editor, nextCaretPosition.getNode(!forwards), forwards, false);
				const peekCaretPosition = getNextPosFn(nextCaretPosition);
				if (peekCaretPosition && isBeforeFn(peekCaretPosition)) {
					if (isMoveInsideSameBlock(nextCaretPosition, peekCaretPosition)) return showCaret(direction, editor, peekCaretPosition.getNode(!forwards), forwards, false);
				}
				if (rangeIsInContainerBlock) return renderRangeCaretOpt(editor, nextCaretPosition.toRange(), false);
				return Optional.none();
			};
			const moveVertically = (editor, direction, range, isBefore, isAfter, isElement$8) => {
				const caretPosition = getNormalizedRangeEndPoint(direction, editor.getBody(), range);
				const caretClientRect = last$2(caretPosition.getClientRects());
				const forwards = direction === VDirection.Down;
				const root = editor.getBody();
				if (!caretClientRect) return Optional.none();
				if (isCefAtEdgeSelected(editor)) {
					const caretPosition$1 = forwards ? CaretPosition.fromRangeEnd(range) : CaretPosition.fromRangeStart(range);
					return (!forwards ? getClosestPositionAbove : getClosestPositionBelow)(root, caretPosition$1).orThunk(() => Optional.from(caretPosition$1)).map((pos) => pos.toRange());
				}
				const nextLinePositions = filter$5((forwards ? downUntil : upUntil)(root, isAboveLine(1), caretPosition), isLine(1));
				const clientX = caretClientRect.left;
				const nextLineRect = findClosestClientRect(nextLinePositions, clientX);
				if (nextLineRect && isElement$8(nextLineRect.node)) {
					const dist1 = Math.abs(clientX - nextLineRect.left);
					const dist2 = Math.abs(clientX - nextLineRect.right);
					return showCaret(direction, editor, nextLineRect.node, dist1 < dist2, false);
				}
				let currentNode;
				if (isBefore(caretPosition)) currentNode = caretPosition.getNode();
				else if (isAfter(caretPosition)) currentNode = caretPosition.getNode(true);
				else currentNode = getSelectedNode(range);
				if (currentNode) {
					const caretPositions = positionsUntil(direction, root, isAboveLine(1), currentNode);
					let closestNextLineRect = findClosestClientRect(filter$5(caretPositions, isLine(1)), clientX);
					if (closestNextLineRect) return renderRangeCaretOpt(editor, closestNextLineRect.position.toRange(), false);
					closestNextLineRect = last$2(filter$5(caretPositions, isLine(0)));
					if (closestNextLineRect) return renderRangeCaretOpt(editor, closestNextLineRect.position.toRange(), false);
				}
				if (nextLinePositions.length === 0) return getLineEndPoint(editor, forwards).filter(forwards ? isAfter : isBefore).map((pos) => renderRangeCaret(editor, pos.toRange(), false));
				return Optional.none();
			};
			const getLineEndPoint = (editor, forward) => {
				const rng = editor.selection.getRng();
				const from$1 = forward ? CaretPosition.fromRangeEnd(rng) : CaretPosition.fromRangeStart(rng);
				const host = getEditingHost(from$1.container(), editor.getBody());
				if (forward) return last$3(getPositionsUntilNextLine(host, from$1).positions);
				else return head(getPositionsUntilPreviousLine(host, from$1).positions);
			};
			const moveToLineEndPoint$3 = (editor, forward, isElementPosition) => getLineEndPoint(editor, forward).filter(isElementPosition).exists((pos) => {
				editor.selection.setRng(pos.toRange());
				return true;
			});
			const setCaretPosition = (editor, pos) => {
				const rng = editor.dom.createRng();
				rng.setStart(pos.container(), pos.offset());
				rng.setEnd(pos.container(), pos.offset());
				editor.selection.setRng(rng);
			};
			const setSelected = (state, elm) => {
				if (state) elm.setAttribute("data-mce-selected", "inline-boundary");
				else elm.removeAttribute("data-mce-selected");
			};
			const renderCaretLocation = (editor, caret, location) => renderCaret(caret, location).map((pos) => {
				setCaretPosition(editor, pos);
				return location;
			});
			const getPositionFromRange = (range, root, forward) => {
				const start$2 = CaretPosition.fromRangeStart(range);
				if (range.collapsed) return start$2;
				else {
					const end$1 = CaretPosition.fromRangeEnd(range);
					return forward ? prevPosition(root, end$1).getOr(end$1) : nextPosition(root, start$2).getOr(start$2);
				}
			};
			const findLocation = (editor, caret, forward) => {
				const rootNode = editor.getBody();
				const from$1 = getPositionFromRange(editor.selection.getRng(), rootNode, forward);
				return findLocation$1(forward, curry(isInlineTarget, editor), rootNode, from$1).bind((location) => renderCaretLocation(editor, caret, location));
			};
			const toggleInlines = (isInlineTarget$1, dom$1, elms) => {
				const selectedInlines = filter$5(map$3(descendants(SugarElement.fromDom(dom$1.getRoot()), "*[data-mce-selected=\"inline-boundary\"]"), (e) => e.dom), isInlineTarget$1);
				const targetInlines = filter$5(elms, isInlineTarget$1);
				each$e(difference(selectedInlines, targetInlines), curry(setSelected, false));
				each$e(difference(targetInlines, selectedInlines), curry(setSelected, true));
			};
			const safeRemoveCaretContainer = (editor, caret) => {
				const caretValue = caret.get();
				if (editor.selection.isCollapsed() && !editor.composing && caretValue) {
					const pos = CaretPosition.fromRangeStart(editor.selection.getRng());
					if (CaretPosition.isTextPosition(pos) && !isAtZwsp(pos)) {
						setCaretPosition(editor, removeAndReposition(caretValue, pos));
						caret.set(null);
					}
				}
			};
			const renderInsideInlineCaret = (isInlineTarget$1, editor, caret, elms) => {
				if (editor.selection.isCollapsed()) each$e(filter$5(elms, isInlineTarget$1), (_inline) => {
					const pos = CaretPosition.fromRangeStart(editor.selection.getRng());
					readLocation(isInlineTarget$1, editor.getBody(), pos).bind((location) => renderCaretLocation(editor, caret, location));
				});
			};
			const move$3 = (editor, caret, forward) => isInlineBoundariesEnabled(editor) ? findLocation(editor, caret, forward).isSome() : false;
			const moveWord = (forward, editor, _caret) => isInlineBoundariesEnabled(editor) ? moveByWord(forward, editor) : false;
			const setupSelectedState = (editor) => {
				const caret = Cell(null);
				const isInlineTarget$1 = curry(isInlineTarget, editor);
				editor.on("NodeChange", (e) => {
					if (isInlineBoundariesEnabled(editor)) {
						toggleInlines(isInlineTarget$1, editor.dom, e.parents);
						safeRemoveCaretContainer(editor, caret);
						renderInsideInlineCaret(isInlineTarget$1, editor, caret, e.parents);
					}
				});
				return caret;
			};
			const moveNextWord = curry(moveWord, true);
			const movePrevWord = curry(moveWord, false);
			const moveToLineEndPoint$2 = (editor, forward, caret) => {
				if (isInlineBoundariesEnabled(editor)) {
					const linePoint = getLineEndPoint(editor, forward).getOrThunk(() => {
						const rng = editor.selection.getRng();
						return forward ? CaretPosition.fromRangeEnd(rng) : CaretPosition.fromRangeStart(rng);
					});
					return readLocation(curry(isInlineTarget, editor), editor.getBody(), linePoint).exists((loc) => {
						return renderCaret(caret, outside(loc)).exists((pos) => {
							setCaretPosition(editor, pos);
							return true;
						});
					});
				} else return false;
			};
			const rangeFromPositions = (from$1, to$1) => {
				const range = document.createRange();
				range.setStart(from$1.container(), from$1.offset());
				range.setEnd(to$1.container(), to$1.offset());
				return range;
			};
			const hasOnlyTwoOrLessPositionsLeft = (elm) => lift2(firstPositionIn(elm), lastPositionIn(elm), (firstPos, lastPos) => {
				const normalizedFirstPos = normalizePosition(true, firstPos);
				const normalizedLastPos = normalizePosition(false, lastPos);
				return nextPosition(elm, normalizedFirstPos).forall((pos) => pos.isEqual(normalizedLastPos));
			}).getOr(true);
			const setCaretLocation = (editor, caret) => (location) => renderCaret(caret, location).map((pos) => () => setCaretPosition(editor, pos));
			const deleteFromTo = (editor, caret, from$1, to$1) => {
				const rootNode = editor.getBody();
				const isInlineTarget$1 = curry(isInlineTarget, editor);
				editor.undoManager.ignore(() => {
					editor.selection.setRng(rangeFromPositions(from$1, to$1));
					execNativeDeleteCommand(editor);
					readLocation(isInlineTarget$1, rootNode, CaretPosition.fromRangeStart(editor.selection.getRng())).map(inside).bind(setCaretLocation(editor, caret)).each(call);
				});
				editor.nodeChanged();
			};
			const rescope = (rootNode, node) => {
				const parentBlock = getParentBlock$3(node, rootNode);
				return parentBlock ? parentBlock : rootNode;
			};
			const backspaceDeleteCollapsed = (editor, caret, forward, from$1) => {
				const rootNode = rescope(editor.getBody(), from$1.container());
				const isInlineTarget$1 = curry(isInlineTarget, editor);
				const fromLocation = readLocation(isInlineTarget$1, rootNode, from$1);
				return fromLocation.bind((location) => {
					if (forward) return location.fold(constant(Optional.some(inside(location))), Optional.none, constant(Optional.some(outside(location))), Optional.none);
					else return location.fold(Optional.none, constant(Optional.some(outside(location))), Optional.none, constant(Optional.some(inside(location))));
				}).map(setCaretLocation(editor, caret)).getOrThunk(() => {
					const toPosition = navigate(forward, rootNode, from$1);
					const toLocation = toPosition.bind((pos) => readLocation(isInlineTarget$1, rootNode, pos));
					return lift2(fromLocation, toLocation, () => findRootInline(isInlineTarget$1, rootNode, from$1).bind((elm) => {
						if (hasOnlyTwoOrLessPositionsLeft(elm)) return Optional.some(() => {
							deleteElement$2(editor, forward, SugarElement.fromDom(elm));
						});
						else return Optional.none();
					})).getOrThunk(() => toLocation.bind(() => toPosition.map((to$1) => {
						return () => {
							if (forward) deleteFromTo(editor, caret, from$1, to$1);
							else deleteFromTo(editor, caret, to$1, from$1);
						};
					})));
				});
			};
			const backspaceDelete$4 = (editor, caret, forward) => {
				if (editor.selection.isCollapsed() && isInlineBoundariesEnabled(editor)) return backspaceDeleteCollapsed(editor, caret, forward, CaretPosition.fromRangeStart(editor.selection.getRng()));
				return Optional.none();
			};
			const hasMultipleChildren = (elm) => childNodesCount(elm) > 1;
			const getParentsUntil = (editor, pred) => {
				const rootElm = SugarElement.fromDom(editor.getBody());
				const parents$2 = parentsAndSelf(SugarElement.fromDom(editor.selection.getStart()), rootElm);
				return findIndex$2(parents$2, pred).fold(constant(parents$2), (index) => parents$2.slice(0, index));
			};
			const hasOnlyOneChild = (elm) => childNodesCount(elm) === 1;
			const getParentInlinesUntilMultichildInline = (editor) => getParentsUntil(editor, (elm) => isBlock$2(elm) || hasMultipleChildren(elm));
			const getParentInlines = (editor) => getParentsUntil(editor, isBlock$2);
			const getFormatNodes = (editor, parentInlines) => {
				const isFormatElement$1 = curry(isFormatElement, editor);
				return bind$3(parentInlines, (elm) => isFormatElement$1(elm) ? [elm.dom] : []);
			};
			const getFormatNodesAtStart = (editor) => {
				return getFormatNodes(editor, getParentInlines(editor));
			};
			const deleteLastPosition = (forward, editor, target, parentInlines) => {
				const formatNodes = getFormatNodes(editor, parentInlines);
				if (formatNodes.length === 0) deleteElement$2(editor, forward, target);
				else {
					const pos = replaceWithCaretFormat(target.dom, formatNodes);
					editor.selection.setRng(pos.toRange());
				}
			};
			const deleteCaret$1 = (editor, forward) => {
				const parentInlines = filter$5(getParentInlinesUntilMultichildInline(editor), hasOnlyOneChild);
				return last$3(parentInlines).bind((target) => {
					if (willDeleteLastPositionInElement(forward, CaretPosition.fromRangeStart(editor.selection.getRng()), target.dom) && !isEmptyCaretFormatElement(target)) return Optional.some(() => deleteLastPosition(forward, editor, target, parentInlines));
					else return Optional.none();
				});
			};
			const isBrInEmptyElement = (editor, elm) => {
				const parentElm = elm.parentElement;
				return isBr$6(elm) && !isNull(parentElm) && editor.dom.isEmpty(parentElm);
			};
			const isEmptyCaret = (elm) => isEmptyCaretFormatElement(SugarElement.fromDom(elm));
			const createCaretFormatAtStart = (editor, formatNodes) => {
				const startElm = editor.selection.getStart();
				const pos = isBrInEmptyElement(editor, startElm) || isEmptyCaret(startElm) ? replaceWithCaretFormat(startElm, formatNodes) : createCaretFormatAtStart$1(editor.selection.getRng(), formatNodes);
				editor.selection.setRng(pos.toRange());
			};
			const updateCaretFormat = (editor, updateFormats) => {
				const missingFormats = difference(updateFormats, getFormatNodesAtStart(editor));
				if (missingFormats.length > 0) createCaretFormatAtStart(editor, missingFormats);
			};
			const rangeStartsAtTextContainer = (rng) => isText$a(rng.startContainer);
			const rangeStartsAtStartOfTextContainer = (rng) => rng.startOffset === 0 && rangeStartsAtTextContainer(rng);
			const rangeStartParentIsFormatElement = (editor, rng) => {
				const startParent = rng.startContainer.parentElement;
				return !isNull(startParent) && isFormatElement(editor, SugarElement.fromDom(startParent));
			};
			const rangeStartAndEndHaveSameParent = (rng) => {
				const startParent = rng.startContainer.parentNode;
				const endParent = rng.endContainer.parentNode;
				return !isNull(startParent) && !isNull(endParent) && startParent.isEqualNode(endParent);
			};
			const rangeEndsAtEndOfEndContainer = (rng) => {
				const endContainer = rng.endContainer;
				return rng.endOffset === (isText$a(endContainer) ? endContainer.length : endContainer.childNodes.length);
			};
			const rangeEndsAtEndOfStartContainer = (rng) => rangeStartAndEndHaveSameParent(rng) && rangeEndsAtEndOfEndContainer(rng);
			const rangeEndsAfterEndOfStartContainer = (rng) => !rng.endContainer.isEqualNode(rng.commonAncestorContainer);
			const rangeEndsAtOrAfterEndOfStartContainer = (rng) => rangeEndsAtEndOfStartContainer(rng) || rangeEndsAfterEndOfStartContainer(rng);
			const requiresDeleteRangeOverride = (editor) => {
				const rng = editor.selection.getRng();
				return rangeStartsAtStartOfTextContainer(rng) && rangeStartParentIsFormatElement(editor, rng) && rangeEndsAtOrAfterEndOfStartContainer(rng);
			};
			const deleteRange$1 = (editor) => {
				if (requiresDeleteRangeOverride(editor)) {
					const formatNodes = getFormatNodesAtStart(editor);
					return Optional.some(() => {
						execNativeDeleteCommand(editor);
						updateCaretFormat(editor, formatNodes);
					});
				} else return Optional.none();
			};
			const backspaceDelete$3 = (editor, forward) => editor.selection.isCollapsed() ? deleteCaret$1(editor, forward) : deleteRange$1(editor);
			const hasAncestorInlineCaret = (elm) => ancestor$1(elm, (node) => isCaretNode(node.dom), isBlock$2);
			const hasAncestorInlineCaretAtStart = (editor) => hasAncestorInlineCaret(SugarElement.fromDom(editor.selection.getStart()));
			const requiresRefreshCaretOverride = (editor) => {
				const rng = editor.selection.getRng();
				return rng.collapsed && (rangeStartsAtTextContainer(rng) || editor.dom.isEmpty(rng.startContainer)) && !hasAncestorInlineCaretAtStart(editor);
			};
			const refreshCaret = (editor) => {
				if (requiresRefreshCaretOverride(editor)) createCaretFormatAtStart(editor, []);
				return true;
			};
			const deleteElement = (editor, forward, element) => {
				if (isNonNullable(element)) return Optional.some(() => {
					editor._selectionOverrides.hideFakeCaret();
					deleteElement$2(editor, forward, SugarElement.fromDom(element));
				});
				else return Optional.none();
			};
			const deleteCaret = (editor, forward) => {
				const isNearMedia = forward ? isBeforeMedia : isAfterMedia;
				const fromPos = getNormalizedRangeEndPoint(forward ? HDirection.Forwards : HDirection.Backwards, editor.getBody(), editor.selection.getRng());
				if (isNearMedia(fromPos)) return deleteElement(editor, forward, fromPos.getNode(!forward));
				else return Optional.from(normalizePosition(forward, fromPos)).filter((pos) => isNearMedia(pos) && isMoveInsideSameBlock(fromPos, pos)).bind((pos) => deleteElement(editor, forward, pos.getNode(!forward)));
			};
			const deleteRange = (editor, forward) => {
				const selectedNode = editor.selection.getNode();
				return isMedia$2(selectedNode) ? deleteElement(editor, forward, selectedNode) : Optional.none();
			};
			const backspaceDelete$2 = (editor, forward) => editor.selection.isCollapsed() ? deleteCaret(editor, forward) : deleteRange(editor, forward);
			const isEditable = (target) => closest$4(target, (elm) => isContentEditableTrue$3(elm.dom) || isContentEditableFalse$b(elm.dom)).exists((elm) => isContentEditableTrue$3(elm.dom));
			const parseIndentValue = (value$3) => toInt(value$3 !== null && value$3 !== void 0 ? value$3 : "").getOr(0);
			const getIndentStyleName = (useMargin, element) => {
				return (useMargin || isTable$1(element) ? "margin" : "padding") + (get$7(element, "direction") === "rtl" ? "-right" : "-left");
			};
			const indentElement = (dom$1, command, useMargin, value$3, unit, element) => {
				const indentStyleName = getIndentStyleName(useMargin, SugarElement.fromDom(element));
				const parsedValue = parseIndentValue(dom$1.getStyle(element, indentStyleName));
				if (command === "outdent") {
					const styleValue = Math.max(0, parsedValue - value$3);
					dom$1.setStyle(element, indentStyleName, styleValue ? styleValue + unit : "");
				} else {
					const styleValue = parsedValue + value$3 + unit;
					dom$1.setStyle(element, indentStyleName, styleValue);
				}
			};
			const validateBlocks = (editor, blocks$1) => forall(blocks$1, (block) => {
				const intentValue = getRaw(block, getIndentStyleName(shouldIndentUseMargin(editor), block)).map(parseIndentValue).getOr(0);
				return editor.dom.getContentEditable(block.dom) !== "false" && intentValue > 0;
			});
			const canOutdent = (editor) => {
				const blocks$1 = getBlocksToIndent(editor);
				return !editor.mode.isReadOnly() && (blocks$1.length > 1 || validateBlocks(editor, blocks$1));
			};
			const isListComponent = (el) => isList(el) || isListItem$1(el);
			const parentIsListComponent = (el) => parent(el).exists(isListComponent);
			const getBlocksToIndent = (editor) => filter$5(fromDom$1(editor.selection.getSelectedBlocks()), (el) => !isListComponent(el) && !parentIsListComponent(el) && isEditable(el));
			const handle = (editor, command) => {
				var _a, _b;
				const { dom: dom$1 } = editor;
				const indentation = getIndentation(editor);
				const indentUnit = (_b = (_a = /[a-z%]+$/i.exec(indentation)) === null || _a === void 0 ? void 0 : _a[0]) !== null && _b !== void 0 ? _b : "px";
				const indentValue = parseIndentValue(indentation);
				const useMargin = shouldIndentUseMargin(editor);
				each$e(getBlocksToIndent(editor), (block) => {
					indentElement(dom$1, command, useMargin, indentValue, indentUnit, block.dom);
				});
			};
			const indent = (editor) => handle(editor, "indent");
			const outdent = (editor) => handle(editor, "outdent");
			const backspaceDelete$1 = (editor) => {
				if (editor.selection.isCollapsed() && canOutdent(editor)) {
					const dom$1 = editor.dom;
					const rng = editor.selection.getRng();
					const pos = CaretPosition.fromRangeStart(rng);
					const block = dom$1.getParent(rng.startContainer, dom$1.isBlock);
					if (block !== null && isAtStartOfBlock(SugarElement.fromDom(block), pos)) return Optional.some(() => outdent(editor));
				}
				return Optional.none();
			};
			const findAction = (editor, caret, forward) => findMap([
				backspaceDelete$1,
				backspaceDelete$6,
				backspaceDelete$7,
				(editor$1, forward$1) => backspaceDelete$4(editor$1, caret, forward$1),
				backspaceDelete$9,
				backspaceDelete$a,
				backspaceDelete$5,
				backspaceDelete$2,
				backspaceDelete$8,
				backspaceDelete$3
			], (item) => item(editor, forward)).filter((_) => editor.selection.isEditable());
			const deleteCommand = (editor, caret) => {
				findAction(editor, caret, false).fold(() => {
					execNativeDeleteCommand(editor);
					paddEmptyBody(editor);
				}, call);
			};
			const forwardDeleteCommand = (editor, caret) => {
				findAction(editor, caret, true).fold(() => execNativeForwardDeleteCommand(editor), call);
			};
			const setup$p = (editor, caret) => {
				editor.addCommand("delete", () => {
					deleteCommand(editor, caret);
				});
				editor.addCommand("forwardDelete", () => {
					forwardDeleteCommand(editor, caret);
				});
			};
			const SIGNIFICANT_MOVE = 5;
			const LONGPRESS_DELAY = 400;
			const getTouch = (event) => {
				if (event.touches === void 0 || event.touches.length !== 1) return Optional.none();
				return Optional.some(event.touches[0]);
			};
			const isFarEnough = (touch, data$1) => {
				const distX = Math.abs(touch.clientX - data$1.x);
				const distY = Math.abs(touch.clientY - data$1.y);
				return distX > SIGNIFICANT_MOVE || distY > SIGNIFICANT_MOVE;
			};
			const setup$o = (editor) => {
				const startData = value$2();
				const longpressFired = Cell(false);
				const debounceLongpress = last$1((e) => {
					editor.dispatch("longpress", {
						...e,
						type: "longpress"
					});
					longpressFired.set(true);
				}, LONGPRESS_DELAY);
				editor.on("touchstart", (e) => {
					getTouch(e).each((touch) => {
						debounceLongpress.cancel();
						const data$1 = {
							x: touch.clientX,
							y: touch.clientY,
							target: e.target
						};
						debounceLongpress.throttle(e);
						longpressFired.set(false);
						startData.set(data$1);
					});
				}, true);
				editor.on("touchmove", (e) => {
					debounceLongpress.cancel();
					getTouch(e).each((touch) => {
						startData.on((data$1) => {
							if (isFarEnough(touch, data$1)) {
								startData.clear();
								longpressFired.set(false);
								editor.dispatch("longpresscancel");
							}
						});
					});
				}, true);
				editor.on("touchend touchcancel", (e) => {
					debounceLongpress.cancel();
					if (e.type === "touchcancel") return;
					startData.get().filter((data$1) => data$1.target.isEqualNode(e.target)).each(() => {
						if (longpressFired.get()) e.preventDefault();
						else editor.dispatch("tap", {
							...e,
							type: "tap"
						});
					});
				}, true);
			};
			const isBlockElement = (blockElements, node) => has$2(blockElements, node.nodeName);
			const isValidTarget = (schema, node) => {
				if (isText$a(node)) return true;
				else if (isElement$6(node)) return !isBlockElement(schema.getBlockElements(), node) && !isBookmarkNode$1(node) && !isTransparentBlock(schema, node);
				else return false;
			};
			const hasBlockParent = (blockElements, root, node) => {
				return exists(parents(SugarElement.fromDom(node), SugarElement.fromDom(root)), (elm) => {
					return isBlockElement(blockElements, elm.dom);
				});
			};
			const shouldRemoveTextNode = (blockElements, node) => {
				if (isText$a(node)) {
					if (node.data.length === 0) return true;
					else if (/^\s+$/.test(node.data) && (!node.nextSibling || isBlockElement(blockElements, node.nextSibling))) return true;
				}
				return false;
			};
			const createRootBlock = (editor) => editor.dom.create(getForcedRootBlock(editor), getForcedRootBlockAttrs(editor));
			const addRootBlocks = (editor) => {
				const dom$1 = editor.dom, selection = editor.selection;
				const schema = editor.schema;
				const blockElements = schema.getBlockElements();
				const startNode = selection.getStart();
				const rootNode = editor.getBody();
				let rootBlockNode;
				let tempNode;
				let wrapped = false;
				const forcedRootBlock = getForcedRootBlock(editor);
				if (!startNode || !isElement$6(startNode)) return;
				const rootNodeName = rootNode.nodeName.toLowerCase();
				if (!schema.isValidChild(rootNodeName, forcedRootBlock.toLowerCase()) || hasBlockParent(blockElements, rootNode, startNode)) return;
				const rng = selection.getRng();
				const { startContainer, startOffset, endContainer, endOffset } = rng;
				const restoreSelection = hasFocus(editor);
				let node = rootNode.firstChild;
				while (node) {
					if (isElement$6(node)) updateElement(schema, node);
					if (isValidTarget(schema, node)) {
						if (shouldRemoveTextNode(blockElements, node)) {
							tempNode = node;
							node = node.nextSibling;
							dom$1.remove(tempNode);
							continue;
						}
						if (!rootBlockNode) {
							rootBlockNode = createRootBlock(editor);
							rootNode.insertBefore(rootBlockNode, node);
							wrapped = true;
						}
						tempNode = node;
						node = node.nextSibling;
						rootBlockNode.appendChild(tempNode);
					} else {
						rootBlockNode = null;
						node = node.nextSibling;
					}
				}
				if (wrapped && restoreSelection) {
					rng.setStart(startContainer, startOffset);
					rng.setEnd(endContainer, endOffset);
					selection.setRng(rng);
					editor.nodeChanged();
				}
			};
			const insertEmptyLine = (editor, root, insertBlock$1) => {
				const block = SugarElement.fromDom(createRootBlock(editor));
				const br = createPaddingBr();
				append$1(block, br);
				insertBlock$1(root, block);
				const rng = document.createRange();
				rng.setStartBefore(br.dom);
				rng.setEndBefore(br.dom);
				return rng;
			};
			const setup$n = (editor) => {
				editor.on("NodeChange", curry(addRootBlocks, editor));
			};
			const hasClass = (checkClassName) => (node) => (" " + node.attr("class") + " ").indexOf(checkClassName) !== -1;
			const replaceMatchWithSpan = (editor, content, cls) => {
				return function(match$3) {
					const args = arguments, index = args[args.length - 2];
					const prevChar = index > 0 ? content.charAt(index - 1) : "";
					if (prevChar === "\"") return match$3;
					if (prevChar === ">") {
						const findStartTagIndex = content.lastIndexOf("<", index);
						if (findStartTagIndex !== -1) {
							if (content.substring(findStartTagIndex, index).indexOf("contenteditable=\"false\"") !== -1) return match$3;
						}
					}
					return "<span class=\"" + cls + "\" data-mce-content=\"" + editor.dom.encode(args[0]) + "\">" + editor.dom.encode(typeof args[1] === "string" ? args[1] : args[0]) + "</span>";
				};
			};
			const convertRegExpsToNonEditable = (editor, nonEditableRegExps, e) => {
				let i = nonEditableRegExps.length, content = e.content;
				if (e.format === "raw") return;
				while (i--) content = content.replace(nonEditableRegExps[i], replaceMatchWithSpan(editor, content, getNonEditableClass(editor)));
				e.content = content;
			};
			const setup$m = (editor) => {
				const contentEditableAttrName = "contenteditable";
				const editClass = " " + Tools.trim(getEditableClass(editor)) + " ";
				const nonEditClass = " " + Tools.trim(getNonEditableClass(editor)) + " ";
				const hasEditClass = hasClass(editClass);
				const hasNonEditClass = hasClass(nonEditClass);
				const nonEditableRegExps = getNonEditableRegExps(editor);
				if (nonEditableRegExps.length > 0) editor.on("BeforeSetContent", (e) => {
					convertRegExpsToNonEditable(editor, nonEditableRegExps, e);
				});
				editor.parser.addAttributeFilter("class", (nodes) => {
					let i = nodes.length;
					while (i--) {
						const node = nodes[i];
						if (hasEditClass(node)) node.attr(contentEditableAttrName, "true");
						else if (hasNonEditClass(node)) node.attr(contentEditableAttrName, "false");
					}
				});
				editor.serializer.addAttributeFilter(contentEditableAttrName, (nodes) => {
					let i = nodes.length;
					while (i--) {
						const node = nodes[i];
						if (!hasEditClass(node) && !hasNonEditClass(node)) continue;
						if (nonEditableRegExps.length > 0 && node.attr("data-mce-content")) {
							node.name = "#text";
							node.type = 3;
							node.raw = true;
							node.value = node.attr("data-mce-content");
						} else node.attr(contentEditableAttrName, null);
					}
				});
			};
			const findBlockCaretContainer = (editor) => descendant(SugarElement.fromDom(editor.getBody()), "*[data-mce-caret]").map((elm) => elm.dom).getOrNull();
			const showBlockCaretContainer = (editor, blockCaretContainer) => {
				if (blockCaretContainer.hasAttribute("data-mce-caret")) {
					showCaretContainerBlock(blockCaretContainer);
					editor.selection.setRng(editor.selection.getRng());
					editor.selection.scrollIntoView(blockCaretContainer);
				}
			};
			const handleBlockContainer = (editor, e) => {
				const blockCaretContainer = findBlockCaretContainer(editor);
				if (!blockCaretContainer) return;
				if (e.type === "compositionstart") {
					e.preventDefault();
					e.stopPropagation();
					showBlockCaretContainer(editor, blockCaretContainer);
					return;
				}
				if (hasContent(blockCaretContainer)) {
					showBlockCaretContainer(editor, blockCaretContainer);
					editor.undoManager.add();
				}
			};
			const setup$l = (editor) => {
				editor.on("keyup compositionstart", curry(handleBlockContainer, editor));
			};
			const isContentEditableFalse$3 = isContentEditableFalse$b;
			const moveToCeFalseHorizontally = (direction, editor, range) => moveHorizontally(editor, direction, range, isBeforeContentEditableFalse, isAfterContentEditableFalse, isContentEditableFalse$3);
			const moveToCeFalseVertically = (direction, editor, range) => {
				const isBefore = (caretPosition) => isBeforeContentEditableFalse(caretPosition) || isBeforeTable(caretPosition);
				const isAfter = (caretPosition) => isAfterContentEditableFalse(caretPosition) || isAfterTable(caretPosition);
				return moveVertically(editor, direction, range, isBefore, isAfter, isContentEditableFalse$3);
			};
			const createTextBlock = (editor) => {
				const textBlock = editor.dom.create(getForcedRootBlock(editor));
				textBlock.innerHTML = "<br data-mce-bogus=\"1\">";
				return textBlock;
			};
			const exitPreBlock = (editor, direction, range) => {
				const caretWalker = CaretWalker(editor.getBody());
				const getVisualCaretPosition$1 = curry(getVisualCaretPosition, direction === 1 ? caretWalker.next : caretWalker.prev);
				if (range.collapsed) {
					const pre = editor.dom.getParent(range.startContainer, "PRE");
					if (!pre) return;
					if (!getVisualCaretPosition$1(CaretPosition.fromRangeStart(range))) {
						const newBlock = SugarElement.fromDom(createTextBlock(editor));
						if (direction === 1) after$4(SugarElement.fromDom(pre), newBlock);
						else before$3(SugarElement.fromDom(pre), newBlock);
						editor.selection.select(newBlock.dom, true);
						editor.selection.collapse();
					}
				}
			};
			const getHorizontalRange = (editor, forward) => {
				const direction = forward ? HDirection.Forwards : HDirection.Backwards;
				const range = editor.selection.getRng();
				return moveToCeFalseHorizontally(direction, editor, range).orThunk(() => {
					exitPreBlock(editor, direction, range);
					return Optional.none();
				});
			};
			const getVerticalRange = (editor, down) => {
				const direction = down ? 1 : -1;
				const range = editor.selection.getRng();
				return moveToCeFalseVertically(direction, editor, range).orThunk(() => {
					exitPreBlock(editor, direction, range);
					return Optional.none();
				});
			};
			const flipDirection = (selection, forward) => {
				return isRtl(forward ? selection.getEnd(true) : selection.getStart(true)) ? !forward : forward;
			};
			const moveH$2 = (editor, forward) => getHorizontalRange(editor, flipDirection(editor.selection, forward)).exists((newRange) => {
				moveToRange(editor, newRange);
				return true;
			});
			const moveV$4 = (editor, down) => getVerticalRange(editor, down).exists((newRange) => {
				moveToRange(editor, newRange);
				return true;
			});
			const moveToLineEndPoint$1 = (editor, forward) => {
				return moveToLineEndPoint$3(editor, forward, forward ? isAfterContentEditableFalse : isBeforeContentEditableFalse);
			};
			const selectToEndPoint = (editor, forward) => getEdgeCefPosition(editor, !forward).map((pos) => {
				const rng = pos.toRange();
				const curRng = editor.selection.getRng();
				if (forward) rng.setStart(curRng.startContainer, curRng.startOffset);
				else rng.setEnd(curRng.endContainer, curRng.endOffset);
				return rng;
			}).exists((rng) => {
				moveToRange(editor, rng);
				return true;
			});
			const isTarget = (node) => contains$2(["figcaption"], name(node));
			const getClosestTargetBlock = (pos, root) => {
				const isRoot$2 = curry(eq, root);
				return closest$4(SugarElement.fromDom(pos.container()), isBlock$2, isRoot$2).filter(isTarget);
			};
			const isAtFirstOrLastLine = (root, forward, pos) => forward ? isAtLastLine(root.dom, pos) : isAtFirstLine(root.dom, pos);
			const moveCaretToNewEmptyLine = (editor, forward) => {
				const root = SugarElement.fromDom(editor.getBody());
				const pos = CaretPosition.fromRangeStart(editor.selection.getRng());
				return getClosestTargetBlock(pos, root).exists(() => {
					if (isAtFirstOrLastLine(root, forward, pos)) {
						const rng = insertEmptyLine(editor, root, forward ? append$1 : prepend);
						editor.selection.setRng(rng);
						return true;
					} else return false;
				});
			};
			const moveV$3 = (editor, forward) => {
				if (editor.selection.isCollapsed()) return moveCaretToNewEmptyLine(editor, forward);
				else return false;
			};
			const moveUp = (editor, details, summary) => {
				const rng = editor.selection.getRng();
				const pos = CaretPosition.fromRangeStart(rng);
				if (editor.getBody().firstChild === details && isAtFirstLine(summary, pos)) {
					editor.execCommand("InsertNewBlockBefore");
					return true;
				} else return false;
			};
			const moveDown = (editor, details) => {
				const rng = editor.selection.getRng();
				const pos = CaretPosition.fromRangeStart(rng);
				if (editor.getBody().lastChild === details && isAtLastLine(details, pos)) {
					editor.execCommand("InsertNewBlockAfter");
					return true;
				} else return false;
			};
			const move$2 = (editor, forward) => {
				if (forward) return Optional.from(editor.dom.getParent(editor.selection.getNode(), "details")).map((details) => moveDown(editor, details)).getOr(false);
				else return Optional.from(editor.dom.getParent(editor.selection.getNode(), "summary")).bind((summary) => Optional.from(editor.dom.getParent(summary, "details")).map((details) => moveUp(editor, details, summary))).getOr(false);
			};
			const moveV$2 = (editor, forward) => move$2(editor, forward);
			const baseKeyPattern = {
				shiftKey: false,
				altKey: false,
				ctrlKey: false,
				metaKey: false,
				keyCode: 0
			};
			const defaultPatterns = (patterns) => map$3(patterns, (pattern) => ({
				...baseKeyPattern,
				...pattern
			}));
			const defaultDelayedPatterns = (patterns) => map$3(patterns, (pattern) => ({
				...baseKeyPattern,
				...pattern
			}));
			const matchesEvent = (pattern, evt) => evt.keyCode === pattern.keyCode && evt.shiftKey === pattern.shiftKey && evt.altKey === pattern.altKey && evt.ctrlKey === pattern.ctrlKey && evt.metaKey === pattern.metaKey;
			const match$1 = (patterns, evt) => bind$3(defaultPatterns(patterns), (pattern) => matchesEvent(pattern, evt) ? [pattern] : []);
			const matchDelayed = (patterns, evt) => bind$3(defaultDelayedPatterns(patterns), (pattern) => matchesEvent(pattern, evt) ? [pattern] : []);
			const action = (f, ...x) => () => f.apply(null, x);
			const execute = (patterns, evt) => find$2(match$1(patterns, evt), (pattern) => pattern.action());
			const executeWithDelayedAction = (patterns, evt) => findMap(matchDelayed(patterns, evt), (pattern) => pattern.action());
			const moveH$1 = (editor, forward) => {
				return moveHorizontally(editor, forward ? HDirection.Forwards : HDirection.Backwards, editor.selection.getRng(), isBeforeMedia, isAfterMedia, isMedia$2).exists((newRange) => {
					moveToRange(editor, newRange);
					return true;
				});
			};
			const moveV$1 = (editor, down) => {
				return moveVertically(editor, down ? 1 : -1, editor.selection.getRng(), isBeforeMedia, isAfterMedia, isMedia$2).exists((newRange) => {
					moveToRange(editor, newRange);
					return true;
				});
			};
			const moveToLineEndPoint = (editor, forward) => {
				return moveToLineEndPoint$3(editor, forward, forward ? isAfterMedia : isBeforeMedia);
			};
			const adt = Adt.generate([
				{ none: ["current"] },
				{ first: ["current"] },
				{ middle: ["current", "target"] },
				{ last: ["current"] }
			]);
			const none = (current) => adt.none(current);
			const CellLocation = {
				...adt,
				none
			};
			const firstLayer = (scope, selector) => {
				return filterFirstLayer(scope, selector, always);
			};
			const filterFirstLayer = (scope, selector, predicate) => {
				return bind$3(children$1(scope), (x) => {
					if (is$1(x, selector)) return predicate(x) ? [x] : [];
					else return filterFirstLayer(x, selector, predicate);
				});
			};
			const lookup$1 = (tags, element, isRoot$2 = never) => {
				if (isRoot$2(element)) return Optional.none();
				if (contains$2(tags, name(element))) return Optional.some(element);
				const isRootOrUpperTable = (elm) => is$1(elm, "table") || isRoot$2(elm);
				return ancestor$3(element, tags.join(","), isRootOrUpperTable);
			};
			const cell = (element, isRoot$2) => lookup$1(["td", "th"], element, isRoot$2);
			const cells = (ancestor$5) => firstLayer(ancestor$5, "th,td");
			const table = (element, isRoot$2) => closest$3(element, "table", isRoot$2);
			const walk = (all$1, current, index, direction, isEligible = always) => {
				const forwards = direction === 1;
				if (!forwards && index <= 0) return CellLocation.first(all$1[0]);
				else if (forwards && index >= all$1.length - 1) return CellLocation.last(all$1[all$1.length - 1]);
				else {
					const newIndex = index + direction;
					const elem = all$1[newIndex];
					return isEligible(elem) ? CellLocation.middle(current, elem) : walk(all$1, current, newIndex, direction, isEligible);
				}
			};
			const detect = (current, isRoot$2) => {
				return table(current, isRoot$2).bind((table$1) => {
					const all$1 = cells(table$1);
					return findIndex$2(all$1, (x) => eq(current, x)).map((index) => ({
						index,
						all: all$1
					}));
				});
			};
			const next = (current, isEligible, isRoot$2) => {
				return detect(current, isRoot$2).fold(() => {
					return CellLocation.none(current);
				}, (info) => {
					return walk(info.all, current, info.index, 1, isEligible);
				});
			};
			const prev = (current, isEligible, isRoot$2) => {
				return detect(current, isRoot$2).fold(() => {
					return CellLocation.none();
				}, (info) => {
					return walk(info.all, current, info.index, -1, isEligible);
				});
			};
			const deflate = (rect, delta) => ({
				left: rect.left - delta,
				top: rect.top - delta,
				right: rect.right + delta * 2,
				bottom: rect.bottom + delta * 2,
				width: rect.width + delta,
				height: rect.height + delta
			});
			const getCorners = (getYAxisValue, tds) => bind$3(tds, (td) => {
				const rect = deflate(clone$1(td.getBoundingClientRect()), -1);
				return [{
					x: rect.left,
					y: getYAxisValue(rect),
					cell: td
				}, {
					x: rect.right,
					y: getYAxisValue(rect),
					cell: td
				}];
			});
			const findClosestCorner = (corners, x, y) => foldl(corners, (acc, newCorner) => acc.fold(() => Optional.some(newCorner), (oldCorner) => {
				const oldDist = Math.sqrt(Math.abs(oldCorner.x - x) + Math.abs(oldCorner.y - y));
				const newDist = Math.sqrt(Math.abs(newCorner.x - x) + Math.abs(newCorner.y - y));
				return Optional.some(newDist < oldDist ? newCorner : oldCorner);
			}), Optional.none());
			const getClosestCell = (getYAxisValue, isTargetCorner, table$1, x, y) => {
				return findClosestCorner(filter$5(getCorners(getYAxisValue, descendants(SugarElement.fromDom(table$1), "td,th,caption").map((e) => e.dom)), (corner) => isTargetCorner(corner, y)), x, y).map((corner) => corner.cell);
			};
			const getBottomValue = (rect) => rect.bottom;
			const getTopValue = (rect) => rect.top;
			const isAbove = (corner, y) => corner.y < y;
			const isBelow = (corner, y) => corner.y > y;
			const getClosestCellAbove = curry(getClosestCell, getBottomValue, isAbove);
			const getClosestCellBelow = curry(getClosestCell, getTopValue, isBelow);
			const findClosestPositionInAboveCell = (table$1, pos) => head(pos.getClientRects()).bind((rect) => getClosestCellAbove(table$1, rect.left, rect.top)).bind((cell$1) => findClosestHorizontalPosition(getLastLinePositions(cell$1), pos));
			const findClosestPositionInBelowCell = (table$1, pos) => last$3(pos.getClientRects()).bind((rect) => getClosestCellBelow(table$1, rect.left, rect.top)).bind((cell$1) => findClosestHorizontalPosition(getFirstLinePositions(cell$1), pos));
			const hasNextBreak = (getPositionsUntil$1, scope, lineInfo) => lineInfo.breakAt.exists((breakPos) => getPositionsUntil$1(scope, breakPos).breakAt.isSome());
			const startsWithWrapBreak = (lineInfo) => lineInfo.breakType === BreakType.Wrap && lineInfo.positions.length === 0;
			const startsWithBrBreak = (lineInfo) => lineInfo.breakType === BreakType.Br && lineInfo.positions.length === 1;
			const isAtTableCellLine = (getPositionsUntil$1, scope, pos) => {
				const lineInfo = getPositionsUntil$1(scope, pos);
				if (startsWithWrapBreak(lineInfo) || !isBr$6(pos.getNode()) && startsWithBrBreak(lineInfo)) return !hasNextBreak(getPositionsUntil$1, scope, lineInfo);
				else return lineInfo.breakAt.isNone();
			};
			const isAtFirstTableCellLine = curry(isAtTableCellLine, getPositionsUntilPreviousLine);
			const isAtLastTableCellLine = curry(isAtTableCellLine, getPositionsUntilNextLine);
			const isCaretAtStartOrEndOfTable = (forward, rng, table$1) => {
				const caretPos = CaretPosition.fromRangeStart(rng);
				return positionIn(!forward, table$1).exists((pos) => pos.isEqual(caretPos));
			};
			const navigateHorizontally = (editor, forward, table$1, _td) => {
				const rng = editor.selection.getRng();
				const direction = forward ? 1 : -1;
				if (isFakeCaretTableBrowser() && isCaretAtStartOrEndOfTable(forward, rng, table$1)) {
					showCaret(direction, editor, table$1, !forward, false).each((newRng) => {
						moveToRange(editor, newRng);
					});
					return true;
				}
				return false;
			};
			const getClosestAbovePosition = (root, table$1, start$2) => findClosestPositionInAboveCell(table$1, start$2).orThunk(() => head(start$2.getClientRects()).bind((rect) => findClosestHorizontalPositionFromPoint(getPositionsAbove(root, CaretPosition.before(table$1)), rect.left))).getOr(CaretPosition.before(table$1));
			const getClosestBelowPosition = (root, table$1, start$2) => findClosestPositionInBelowCell(table$1, start$2).orThunk(() => head(start$2.getClientRects()).bind((rect) => findClosestHorizontalPositionFromPoint(getPositionsBelow(root, CaretPosition.after(table$1)), rect.left))).getOr(CaretPosition.after(table$1));
			const getTable = (previous, pos) => {
				const node = pos.getNode(previous);
				return isTable$2(node) ? Optional.some(node) : Optional.none();
			};
			const renderBlock = (down, editor, table$1) => {
				editor.undoManager.transact(() => {
					const insertFn = down ? after$4 : before$3;
					moveToRange(editor, insertEmptyLine(editor, SugarElement.fromDom(table$1), insertFn));
				});
			};
			const moveCaret = (editor, down, pos) => {
				const table$1 = down ? getTable(true, pos) : getTable(false, pos);
				const last$4 = down === false;
				table$1.fold(() => moveToRange(editor, pos.toRange()), (table$2) => positionIn(last$4, editor.getBody()).filter((lastPos) => lastPos.isEqual(pos)).fold(() => moveToRange(editor, pos.toRange()), (_) => renderBlock(down, editor, table$2)));
			};
			const navigateVertically = (editor, down, table$1, td) => {
				const rng = editor.selection.getRng();
				const pos = CaretPosition.fromRangeStart(rng);
				const root = editor.getBody();
				if (!down && isAtFirstTableCellLine(td, pos)) {
					moveCaret(editor, down, getClosestAbovePosition(root, table$1, pos));
					return true;
				} else if (down && isAtLastTableCellLine(td, pos)) {
					moveCaret(editor, down, getClosestBelowPosition(root, table$1, pos));
					return true;
				} else return false;
			};
			const move$1 = (editor, forward, mover) => Optional.from(editor.dom.getParent(editor.selection.getNode(), "td,th")).bind((td) => Optional.from(editor.dom.getParent(td, "table")).map((table$1) => mover(editor, forward, table$1, td))).getOr(false);
			const moveH = (editor, forward) => move$1(editor, forward, navigateHorizontally);
			const moveV = (editor, forward) => move$1(editor, forward, navigateVertically);
			const getCellFirstCursorPosition = (cell$1) => {
				return toNative(SimSelection.exact(cell$1, 0, cell$1, 0));
			};
			const tabGo = (editor, isRoot$2, cell$1) => {
				return cell$1.fold(Optional.none, Optional.none, (_current, next$1) => {
					return first(next$1).map((cell$2) => {
						return getCellFirstCursorPosition(cell$2);
					});
				}, (current) => {
					editor.execCommand("mceTableInsertRowAfter");
					return tabForward(editor, isRoot$2, current);
				});
			};
			const tabForward = (editor, isRoot$2, cell$1) => tabGo(editor, isRoot$2, next(cell$1, isEditable$3));
			const tabBackward = (editor, isRoot$2, cell$1) => tabGo(editor, isRoot$2, prev(cell$1, isEditable$3));
			const handleTab = (editor, forward) => {
				const rootElements = [
					"table",
					"li",
					"dl"
				];
				const body = SugarElement.fromDom(editor.getBody());
				const isRoot$2 = (element) => {
					const name$1 = name(element);
					return eq(element, body) || contains$2(rootElements, name$1);
				};
				const rng = editor.selection.getRng();
				return cell(SugarElement.fromDom(!forward ? rng.startContainer : rng.endContainer), isRoot$2).map((cell$1) => {
					table(cell$1, isRoot$2).each((table$1) => {
						editor.model.table.clearSelectedCells(table$1.dom);
					});
					editor.selection.collapse(!forward);
					(!forward ? tabBackward : tabForward)(editor, isRoot$2, cell$1).each((range) => {
						editor.selection.setRng(range);
					});
					return true;
				}).getOr(false);
			};
			const executeKeydownOverride$4 = (editor, caret, evt) => {
				const isMac = Env.os.isMacOS() || Env.os.isiOS();
				execute([
					{
						keyCode: VK.RIGHT,
						action: action(moveH$2, editor, true)
					},
					{
						keyCode: VK.LEFT,
						action: action(moveH$2, editor, false)
					},
					{
						keyCode: VK.UP,
						action: action(moveV$4, editor, false)
					},
					{
						keyCode: VK.DOWN,
						action: action(moveV$4, editor, true)
					},
					...isMac ? [{
						keyCode: VK.UP,
						action: action(selectToEndPoint, editor, false),
						metaKey: true,
						shiftKey: true
					}, {
						keyCode: VK.DOWN,
						action: action(selectToEndPoint, editor, true),
						metaKey: true,
						shiftKey: true
					}] : [],
					{
						keyCode: VK.RIGHT,
						action: action(moveH, editor, true)
					},
					{
						keyCode: VK.LEFT,
						action: action(moveH, editor, false)
					},
					{
						keyCode: VK.UP,
						action: action(moveV, editor, false)
					},
					{
						keyCode: VK.DOWN,
						action: action(moveV, editor, true)
					},
					{
						keyCode: VK.UP,
						action: action(moveV, editor, false)
					},
					{
						keyCode: VK.UP,
						action: action(moveV$2, editor, false)
					},
					{
						keyCode: VK.DOWN,
						action: action(moveV$2, editor, true)
					},
					{
						keyCode: VK.RIGHT,
						action: action(moveH$1, editor, true)
					},
					{
						keyCode: VK.LEFT,
						action: action(moveH$1, editor, false)
					},
					{
						keyCode: VK.UP,
						action: action(moveV$1, editor, false)
					},
					{
						keyCode: VK.DOWN,
						action: action(moveV$1, editor, true)
					},
					{
						keyCode: VK.RIGHT,
						action: action(move$3, editor, caret, true)
					},
					{
						keyCode: VK.LEFT,
						action: action(move$3, editor, caret, false)
					},
					{
						keyCode: VK.RIGHT,
						ctrlKey: !isMac,
						altKey: isMac,
						action: action(moveNextWord, editor, caret)
					},
					{
						keyCode: VK.LEFT,
						ctrlKey: !isMac,
						altKey: isMac,
						action: action(movePrevWord, editor, caret)
					},
					{
						keyCode: VK.UP,
						action: action(moveV$3, editor, false)
					},
					{
						keyCode: VK.DOWN,
						action: action(moveV$3, editor, true)
					}
				], evt).each((_) => {
					evt.preventDefault();
				});
			};
			const setup$k = (editor, caret) => {
				editor.on("keydown", (evt) => {
					if (!evt.isDefaultPrevented()) executeKeydownOverride$4(editor, caret, evt);
				});
			};
			const point = (container, offset) => ({
				container,
				offset
			});
			const DOM$7 = DOMUtils.DOM;
			const alwaysNext = (startNode) => (node) => startNode === node ? -1 : 0;
			const isBoundary = (dom$1) => (node) => dom$1.isBlock(node) || contains$2([
				"BR",
				"IMG",
				"HR",
				"INPUT"
			], node.nodeName) || dom$1.getContentEditable(node) === "false";
			const textBefore = (node, offset, rootNode) => {
				if (isText$a(node) && offset >= 0) return Optional.some(point(node, offset));
				else {
					const textSeeker = TextSeeker(DOM$7);
					return Optional.from(textSeeker.backwards(node, offset, alwaysNext(node), rootNode)).map((prev$1) => point(prev$1.container, prev$1.container.data.length));
				}
			};
			const textAfter = (node, offset, rootNode) => {
				if (isText$a(node) && offset >= node.length) return Optional.some(point(node, offset));
				else {
					const textSeeker = TextSeeker(DOM$7);
					return Optional.from(textSeeker.forwards(node, offset, alwaysNext(node), rootNode)).map((prev$1) => point(prev$1.container, 0));
				}
			};
			const scanLeft = (node, offset, rootNode) => {
				if (!isText$a(node)) return Optional.none();
				const text$1 = node.data;
				if (offset >= 0 && offset <= text$1.length) return Optional.some(point(node, offset));
				else {
					const textSeeker = TextSeeker(DOM$7);
					return Optional.from(textSeeker.backwards(node, offset, alwaysNext(node), rootNode)).bind((prev$1) => {
						const prevText = prev$1.container.data;
						return scanLeft(prev$1.container, offset + prevText.length, rootNode);
					});
				}
			};
			const scanRight = (node, offset, rootNode) => {
				if (!isText$a(node)) return Optional.none();
				const text$1 = node.data;
				if (offset <= text$1.length) return Optional.some(point(node, offset));
				else {
					const textSeeker = TextSeeker(DOM$7);
					return Optional.from(textSeeker.forwards(node, offset, alwaysNext(node), rootNode)).bind((next$1) => scanRight(next$1.container, offset - text$1.length, rootNode));
				}
			};
			const repeatLeft = (dom$1, node, offset, process$2, rootNode) => {
				const search$1 = TextSeeker(dom$1, isBoundary(dom$1));
				return Optional.from(search$1.backwards(node, offset, process$2, rootNode));
			};
			const isValidTextRange = (rng) => rng.collapsed && isText$a(rng.startContainer);
			const getText = (rng) => trim$1(rng.toString().replace(/\u00A0/g, " "));
			const isWhitespace = (chr) => chr !== "" && " \xA0\f\n\r	\v".indexOf(chr) !== -1;
			const stripTrigger = (text$1, trigger) => text$1.substring(trigger.length);
			const findTrigger = (text$1, index, trigger) => {
				let i;
				const firstChar = trigger.charAt(0);
				for (i = index - 1; i >= 0; i--) {
					const char = text$1.charAt(i);
					if (isWhitespace(char)) return Optional.none();
					if (firstChar === char && contains$1(text$1, trigger, i, index)) break;
				}
				return Optional.some(i);
			};
			const findStart = (dom$1, initRange, trigger, minChars = 0) => {
				if (!isValidTextRange(initRange)) return Optional.none();
				const buffer = {
					text: "",
					offset: 0
				};
				const findTriggerIndex = (element, offset, text$1) => {
					buffer.text = text$1 + buffer.text;
					buffer.offset += offset;
					return findTrigger(buffer.text, buffer.offset, trigger).getOr(offset);
				};
				const root = dom$1.getParent(initRange.startContainer, dom$1.isBlock) || dom$1.getRoot();
				return repeatLeft(dom$1, initRange.startContainer, initRange.startOffset, findTriggerIndex, root).bind((spot) => {
					const range = initRange.cloneRange();
					range.setStart(spot.container, spot.offset);
					range.setEnd(initRange.endContainer, initRange.endOffset);
					if (range.collapsed) return Optional.none();
					const text$1 = getText(range);
					if (text$1.lastIndexOf(trigger) !== 0 || stripTrigger(text$1, trigger).length < minChars) return Optional.none();
					else return Optional.some({
						text: stripTrigger(text$1, trigger),
						range,
						trigger
					});
				});
			};
			const getContext = (dom$1, initRange, trigger, minChars = 0) => detect$1(SugarElement.fromDom(initRange.startContainer)).fold(() => findStart(dom$1, initRange, trigger, minChars), (elm) => {
				const range = dom$1.createRng();
				range.selectNode(elm.dom);
				const text$1 = getText(range);
				return Optional.some({
					range,
					text: stripTrigger(text$1, trigger),
					trigger
				});
			});
			const isText$1 = (node) => node.nodeType === TEXT;
			const isElement = (node) => node.nodeType === ELEMENT;
			const toLast = (node) => {
				if (isText$1(node)) return point(node, node.data.length);
				else {
					const children$2 = node.childNodes;
					return children$2.length > 0 ? toLast(children$2[children$2.length - 1]) : point(node, children$2.length);
				}
			};
			const toLeaf = (node, offset) => {
				const children$2 = node.childNodes;
				if (children$2.length > 0 && offset < children$2.length) return toLeaf(children$2[offset], 0);
				else if (children$2.length > 0 && isElement(node) && children$2.length === offset) return toLast(children$2[children$2.length - 1]);
				else return point(node, offset);
			};
			const isPreviousCharContent = (dom$1, leaf) => {
				var _a;
				const root = (_a = dom$1.getParent(leaf.container, dom$1.isBlock)) !== null && _a !== void 0 ? _a : dom$1.getRoot();
				return repeatLeft(dom$1, leaf.container, leaf.offset, (_element, offset) => offset === 0 ? -1 : offset, root).filter((spot) => {
					return !isWhitespace(spot.container.data.charAt(spot.offset - 1));
				}).isSome();
			};
			const isStartOfWord = (dom$1) => (rng) => {
				return !isPreviousCharContent(dom$1, toLeaf(rng.startContainer, rng.startOffset));
			};
			const getTriggerContext = (dom$1, initRange, database) => findMap(database.triggers, (trigger) => getContext(dom$1, initRange, trigger));
			const lookup = (editor, getDatabase) => {
				const database = getDatabase();
				const rng = editor.selection.getRng();
				return getTriggerContext(editor.dom, rng, database).bind((context$1) => lookupWithContext(editor, getDatabase, context$1));
			};
			const lookupWithContext = (editor, getDatabase, context$1, fetchOptions = {}) => {
				var _a;
				const database = getDatabase();
				const startText = (_a = editor.selection.getRng().startContainer.nodeValue) !== null && _a !== void 0 ? _a : "";
				const autocompleters = filter$5(database.lookupByTrigger(context$1.trigger), (autocompleter) => context$1.text.length >= autocompleter.minChars && autocompleter.matches.getOrThunk(() => isStartOfWord(editor.dom))(context$1.range, startText, context$1.text));
				if (autocompleters.length === 0) return Optional.none();
				const lookupData = Promise.all(map$3(autocompleters, (ac) => {
					return ac.fetch(context$1.text, ac.maxResults, fetchOptions).then((results) => ({
						matchText: context$1.text,
						items: results,
						columns: ac.columns,
						onAction: ac.onAction,
						highlightOn: ac.highlightOn
					}));
				}));
				return Optional.some({
					lookupData,
					context: context$1
				});
			};
			var SimpleResultType;
			(function(SimpleResultType$1) {
				SimpleResultType$1[SimpleResultType$1["Error"] = 0] = "Error";
				SimpleResultType$1[SimpleResultType$1["Value"] = 1] = "Value";
			})(SimpleResultType || (SimpleResultType = {}));
			const fold$1 = (res, onError, onValue) => res.stype === SimpleResultType.Error ? onError(res.serror) : onValue(res.svalue);
			const partition = (results) => {
				const values$1 = [];
				const errors = [];
				each$e(results, (obj) => {
					fold$1(obj, (err) => errors.push(err), (val) => values$1.push(val));
				});
				return {
					values: values$1,
					errors
				};
			};
			const mapError = (res, f) => {
				if (res.stype === SimpleResultType.Error) return {
					stype: SimpleResultType.Error,
					serror: f(res.serror)
				};
				else return res;
			};
			const map = (res, f) => {
				if (res.stype === SimpleResultType.Value) return {
					stype: SimpleResultType.Value,
					svalue: f(res.svalue)
				};
				else return res;
			};
			const bind$1 = (res, f) => {
				if (res.stype === SimpleResultType.Value) return f(res.svalue);
				else return res;
			};
			const bindError = (res, f) => {
				if (res.stype === SimpleResultType.Error) return f(res.serror);
				else return res;
			};
			const svalue = (v) => ({
				stype: SimpleResultType.Value,
				svalue: v
			});
			const serror = (e) => ({
				stype: SimpleResultType.Error,
				serror: e
			});
			const toResult = (res) => fold$1(res, Result.error, Result.value);
			const fromResult = (res) => res.fold(serror, svalue);
			const SimpleResult = {
				fromResult,
				toResult,
				svalue,
				partition,
				serror,
				bind: bind$1,
				bindError,
				map,
				mapError,
				fold: fold$1
			};
			const formatObj = (input) => {
				return isObject(input) && keys(input).length > 100 ? " removed due to size" : JSON.stringify(input, null, 2);
			};
			const formatErrors = (errors) => {
				return map$3(errors.length > 10 ? errors.slice(0, 10).concat([{
					path: [],
					getErrorInfo: constant("... (only showing first ten failures)")
				}]) : errors, (e) => {
					return "Failed path: (" + e.path.join(" > ") + ")\n" + e.getErrorInfo();
				});
			};
			const nu = (path$1, getErrorInfo) => {
				return SimpleResult.serror([{
					path: path$1,
					getErrorInfo
				}]);
			};
			const missingRequired = (path$1, key, obj) => nu(path$1, () => "Could not find valid *required* value for \"" + key + "\" in " + formatObj(obj));
			const missingKey = (path$1, key) => nu(path$1, () => "Choice schema did not contain choice key: \"" + key + "\"");
			const missingBranch = (path$1, branches, branch) => nu(path$1, () => "The chosen schema: \"" + branch + "\" did not exist in branches: " + formatObj(branches));
			const custom = (path$1, err) => nu(path$1, constant(err));
			const chooseFrom = (path$1, input, branches, ch) => {
				return get$a(branches, ch).fold(() => missingBranch(path$1, branches, ch), (vp) => vp.extract(path$1.concat(["branch: " + ch]), input));
			};
			const choose$1 = (key, branches) => {
				const extract = (path$1, input) => {
					return get$a(input, key).fold(() => missingKey(path$1, key), (chosen) => chooseFrom(path$1, input, branches, chosen));
				};
				const toString = () => "chooseOn(" + key + "). Possible values: " + keys(branches);
				return {
					extract,
					toString
				};
			};
			const shallow = (old, nu$4) => {
				return nu$4;
			};
			const deep = (old, nu$4) => {
				return isPlainObject(old) && isPlainObject(nu$4) ? deepMerge(old, nu$4) : nu$4;
			};
			const baseMerge = (merger) => {
				return (...objects) => {
					if (objects.length === 0) throw new Error(`Can't merge zero objects`);
					const ret = {};
					for (let j = 0; j < objects.length; j++) {
						const curObject = objects[j];
						for (const key in curObject) if (has$2(curObject, key)) ret[key] = merger(ret[key], curObject[key]);
					}
					return ret;
				};
			};
			const deepMerge = baseMerge(deep);
			const merge = baseMerge(shallow);
			const required = () => ({
				tag: "required",
				process: {}
			});
			const defaultedThunk = (fallbackThunk) => ({
				tag: "defaultedThunk",
				process: fallbackThunk
			});
			const defaulted$1 = (fallback$1) => defaultedThunk(constant(fallback$1));
			const asOption = () => ({
				tag: "option",
				process: {}
			});
			const mergeValues = (values$1, base) => values$1.length > 0 ? SimpleResult.svalue(deepMerge(base, merge.apply(void 0, values$1))) : SimpleResult.svalue(base);
			const mergeErrors = (errors) => compose(SimpleResult.serror, flatten)(errors);
			const consolidateObj = (objects, base) => {
				const partition$3 = SimpleResult.partition(objects);
				return partition$3.errors.length > 0 ? mergeErrors(partition$3.errors) : mergeValues(partition$3.values, base);
			};
			const consolidateArr = (objects) => {
				const partitions = SimpleResult.partition(objects);
				return partitions.errors.length > 0 ? mergeErrors(partitions.errors) : SimpleResult.svalue(partitions.values);
			};
			const ResultCombine = {
				consolidateObj,
				consolidateArr
			};
			const field$1 = (key, newKey, presence, prop) => ({
				tag: "field",
				key,
				newKey,
				presence,
				prop
			});
			const customField$1 = (newKey, instantiator) => ({
				tag: "custom",
				newKey,
				instantiator
			});
			const fold = (value$3, ifField, ifCustom) => {
				switch (value$3.tag) {
					case "field": return ifField(value$3.key, value$3.newKey, value$3.presence, value$3.prop);
					case "custom": return ifCustom(value$3.newKey, value$3.instantiator);
				}
			};
			const value = (validator) => {
				const extract = (path$1, val) => {
					return SimpleResult.bindError(validator(val), (err) => custom(path$1, err));
				};
				return {
					extract,
					toString: constant("val")
				};
			};
			const anyValue$1 = value(SimpleResult.svalue);
			const requiredAccess = (path$1, obj, key, bundle) => get$a(obj, key).fold(() => missingRequired(path$1, key, obj), bundle);
			const fallbackAccess = (obj, key, fallback$1, bundle) => {
				return bundle(get$a(obj, key).getOrThunk(() => fallback$1(obj)));
			};
			const optionAccess = (obj, key, bundle) => bundle(get$a(obj, key));
			const optionDefaultedAccess = (obj, key, fallback$1, bundle) => {
				return bundle(get$a(obj, key).map((val) => val === true ? fallback$1(obj) : val));
			};
			const extractField = (field$2, path$1, obj, key, prop) => {
				const bundle = (av) => prop.extract(path$1.concat([key]), av);
				const bundleAsOption = (optValue) => optValue.fold(() => SimpleResult.svalue(Optional.none()), (ov) => {
					const result = prop.extract(path$1.concat([key]), ov);
					return SimpleResult.map(result, Optional.some);
				});
				switch (field$2.tag) {
					case "required": return requiredAccess(path$1, obj, key, bundle);
					case "defaultedThunk": return fallbackAccess(obj, key, field$2.process, bundle);
					case "option": return optionAccess(obj, key, bundleAsOption);
					case "defaultedOptionThunk": return optionDefaultedAccess(obj, key, field$2.process, bundleAsOption);
					case "mergeWithThunk": return fallbackAccess(obj, key, constant({}), (v) => {
						return bundle(deepMerge(field$2.process(obj), v));
					});
				}
			};
			const extractFields = (path$1, obj, fields) => {
				const success = {};
				const errors = [];
				for (const field$2 of fields) fold(field$2, (key, newKey, presence, prop) => {
					const result = extractField(presence, path$1, obj, key, prop);
					SimpleResult.fold(result, (err) => {
						errors.push(...err);
					}, (res) => {
						success[newKey] = res;
					});
				}, (newKey, instantiator) => {
					success[newKey] = instantiator(obj);
				});
				return errors.length > 0 ? SimpleResult.serror(errors) : SimpleResult.svalue(success);
			};
			const objOf = (values$1) => {
				const extract = (path$1, o) => extractFields(path$1, o, values$1);
				const toString = () => {
					return "obj{\n" + map$3(values$1, (value$3) => fold(value$3, (key, _okey, _presence, prop) => key + " -> " + prop.toString(), (newKey, _instantiator) => "state(" + newKey + ")")).join("\n") + "}";
				};
				return {
					extract,
					toString
				};
			};
			const arrOf = (prop) => {
				const extract = (path$1, array) => {
					const results = map$3(array, (a, i) => prop.extract(path$1.concat(["[" + i + "]"]), a));
					return ResultCombine.consolidateArr(results);
				};
				const toString = () => "array(" + prop.toString() + ")";
				return {
					extract,
					toString
				};
			};
			const valueOf = (validator) => value((v) => validator(v).fold(SimpleResult.serror, SimpleResult.svalue));
			const extractValue = (label, prop, obj) => {
				const res = prop.extract([label], obj);
				return SimpleResult.mapError(res, (errs) => ({
					input: obj,
					errors: errs
				}));
			};
			const asRaw = (label, prop, obj) => SimpleResult.toResult(extractValue(label, prop, obj));
			const formatError = (errInfo) => {
				return "Errors: \n" + formatErrors(errInfo.errors).join("\n") + "\n\nInput object: " + formatObj(errInfo.input);
			};
			const choose = (key, branches) => choose$1(key, map$2(branches, objOf));
			const anyValue = constant(anyValue$1);
			const typedValue = (validator, expectedType) => value((a) => {
				const actualType = typeof a;
				return validator(a) ? SimpleResult.svalue(a) : SimpleResult.serror(`Expected type: ${expectedType} but got: ${actualType}`);
			});
			const number = typedValue(isNumber, "number");
			const string = typedValue(isString, "string");
			const boolean = typedValue(isBoolean, "boolean");
			const functionProcessor = typedValue(isFunction, "function");
			const field = field$1;
			const customField = customField$1;
			const validateEnum = (values$1) => valueOf((value$3) => contains$2(values$1, value$3) ? Result.value(value$3) : Result.error(`Unsupported value: "${value$3}", choose one of "${values$1.join(", ")}".`));
			const requiredOf = (key, schema) => field(key, key, required(), schema);
			const requiredString = (key) => requiredOf(key, string);
			const requiredFunction = (key) => requiredOf(key, functionProcessor);
			const requiredArrayOf = (key, schema) => field(key, key, required(), arrOf(schema));
			const optionOf = (key, schema) => field(key, key, asOption(), schema);
			const optionString = (key) => optionOf(key, string);
			const optionFunction = (key) => optionOf(key, functionProcessor);
			const defaulted = (key, fallback$1) => field(key, key, defaulted$1(fallback$1), anyValue());
			const defaultedOf = (key, fallback$1, schema) => field(key, key, defaulted$1(fallback$1), schema);
			const defaultedNumber = (key, fallback$1) => defaultedOf(key, fallback$1, number);
			const defaultedString = (key, fallback$1) => defaultedOf(key, fallback$1, string);
			const defaultedStringEnum = (key, fallback$1, values$1) => defaultedOf(key, fallback$1, validateEnum(values$1));
			const defaultedBoolean = (key, fallback$1) => defaultedOf(key, fallback$1, boolean);
			const defaultedFunction = (key, fallback$1) => defaultedOf(key, fallback$1, functionProcessor);
			const defaultedArrayOf = (key, fallback$1, schema) => defaultedOf(key, fallback$1, arrOf(schema));
			const type = requiredString("type");
			const fetch$1 = requiredFunction("fetch");
			const onAction = requiredFunction("onAction");
			const onSetup = defaultedFunction("onSetup", () => noop);
			const optionalText = optionString("text");
			const optionalIcon = optionString("icon");
			const optionalTooltip = optionString("tooltip");
			const optionalLabel = optionString("label");
			const active = defaultedBoolean("active", false);
			const enabled = defaultedBoolean("enabled", true);
			const primary = defaultedBoolean("primary", false);
			const defaultedColumns = (num) => defaulted("columns", num);
			const defaultedType = (type$2) => defaultedString("type", type$2);
			const autocompleterSchema = objOf([
				type,
				requiredString("trigger"),
				defaultedNumber("minChars", 1),
				defaultedColumns(1),
				defaultedNumber("maxResults", 10),
				optionFunction("matches"),
				fetch$1,
				onAction,
				defaultedArrayOf("highlightOn", [], string)
			]);
			const createAutocompleter = (spec) => asRaw("Autocompleter", autocompleterSchema, {
				trigger: spec.ch,
				...spec
			});
			const baseToolbarButtonFields = [
				enabled,
				optionalTooltip,
				optionalIcon,
				optionalText,
				onSetup
			];
			const baseToolbarToggleButtonFields = [active].concat(baseToolbarButtonFields);
			const contextBarFields = [
				defaultedFunction("predicate", never),
				defaultedStringEnum("scope", "node", ["node", "editor"]),
				defaultedStringEnum("position", "selection", [
					"node",
					"selection",
					"line"
				])
			];
			const contextButtonFields = baseToolbarButtonFields.concat([
				defaultedType("contextformbutton"),
				primary,
				onAction,
				customField("original", identity)
			]);
			const contextToggleButtonFields = baseToolbarToggleButtonFields.concat([
				defaultedType("contextformbutton"),
				primary,
				onAction,
				customField("original", identity)
			]);
			const launchButtonFields = baseToolbarButtonFields.concat([defaultedType("contextformbutton")]);
			const launchToggleButtonFields = baseToolbarToggleButtonFields.concat([defaultedType("contextformtogglebutton")]);
			const toggleOrNormal = choose("type", {
				contextformbutton: contextButtonFields,
				contextformtogglebutton: contextToggleButtonFields
			});
			objOf([
				defaultedType("contextform"),
				defaultedFunction("initValue", constant("")),
				optionalLabel,
				requiredArrayOf("commands", toggleOrNormal),
				optionOf("launch", choose("type", {
					contextformbutton: launchButtonFields,
					contextformtogglebutton: launchToggleButtonFields
				}))
			].concat(contextBarFields));
			const register$2 = (editor) => {
				const popups = editor.ui.registry.getAll().popups;
				const dataset = map$2(popups, (popup) => createAutocompleter(popup).fold((err) => {
					throw new Error(formatError(err));
				}, identity));
				const triggers = stringArray(mapToArray(dataset, (v) => v.trigger));
				const datasetValues = values(dataset);
				const lookupByTrigger = (trigger) => filter$5(datasetValues, (dv) => dv.trigger === trigger);
				return {
					dataset,
					triggers,
					lookupByTrigger
				};
			};
			const setupEditorInput = (editor, api$2) => {
				const update = last$1(api$2.load, 50);
				editor.on("keypress compositionend", (e) => {
					if (e.which === 27) return;
					update.throttle();
				});
				editor.on("keydown", (e) => {
					const keyCode = e.which;
					if (keyCode === 8) update.throttle();
					else if (keyCode === 27) api$2.cancelIfNecessary();
				});
				editor.on("remove", update.cancel);
			};
			const setup$j = (editor) => {
				const activeAutocompleter = value$2();
				const uiActive = Cell(false);
				const isActive = activeAutocompleter.isSet;
				const cancelIfNecessary = () => {
					if (isActive()) {
						removeAutocompleterDecoration(editor);
						fireAutocompleterEnd(editor);
						uiActive.set(false);
						activeAutocompleter.clear();
					}
				};
				const commenceIfNecessary = (context$1) => {
					if (!isActive()) {
						addAutocompleterDecoration(editor, context$1.range);
						activeAutocompleter.set({
							trigger: context$1.trigger,
							matchLength: context$1.text.length
						});
					}
				};
				const getAutocompleters = cached(() => register$2(editor));
				const doLookup = (fetchOptions) => activeAutocompleter.get().map((ac) => getContext(editor.dom, editor.selection.getRng(), ac.trigger).bind((newContext) => lookupWithContext(editor, getAutocompleters, newContext, fetchOptions))).getOrThunk(() => lookup(editor, getAutocompleters));
				const load = (fetchOptions) => {
					doLookup(fetchOptions).fold(cancelIfNecessary, (lookupInfo) => {
						commenceIfNecessary(lookupInfo.context);
						lookupInfo.lookupData.then((lookupData) => {
							activeAutocompleter.get().map((ac) => {
								const context$1 = lookupInfo.context;
								if (ac.trigger === context$1.trigger) if (context$1.text.length - ac.matchLength >= 10) cancelIfNecessary();
								else {
									activeAutocompleter.set({
										...ac,
										matchLength: context$1.text.length
									});
									if (uiActive.get()) fireAutocompleterUpdate(editor, { lookupData });
									else {
										uiActive.set(true);
										fireAutocompleterStart(editor, { lookupData });
									}
								}
							});
						});
					});
				};
				editor.addCommand("mceAutocompleterReload", (_ui, value$3) => {
					load(isObject(value$3) ? value$3.fetchOptions : {});
				});
				editor.addCommand("mceAutocompleterClose", cancelIfNecessary);
				setupEditorInput(editor, {
					cancelIfNecessary,
					load
				});
			};
			const isSafari = detect$2().browser.isSafari();
			const emptyNodeContents = (node) => fillWithPaddingBr(SugarElement.fromDom(node));
			const isEntireNodeSelected = (rng, node) => {
				var _a;
				return rng.startOffset === 0 && rng.endOffset === ((_a = node.textContent) === null || _a === void 0 ? void 0 : _a.length);
			};
			const getParentDetailsElementAtPos = (dom$1, pos) => Optional.from(dom$1.getParent(pos.container(), "details"));
			const isInDetailsElement = (dom$1, pos) => getParentDetailsElementAtPos(dom$1, pos).isSome();
			const getDetailsElements = (dom$1, rng) => {
				const startDetails = Optional.from(dom$1.getParent(rng.startContainer, "details"));
				const endDetails = Optional.from(dom$1.getParent(rng.endContainer, "details"));
				if (startDetails.isSome() || endDetails.isSome()) {
					const startSummary = startDetails.bind((details) => Optional.from(dom$1.select("summary", details)[0]));
					return Optional.some({
						startSummary,
						startDetails,
						endDetails
					});
				} else return Optional.none();
			};
			const isCaretInTheBeginningOf = (caretPos, element) => firstPositionIn(element).exists((pos) => pos.isEqual(caretPos));
			const isCaretInTheEndOf = (caretPos, element) => {
				return lastPositionIn(element).exists((pos) => {
					if (isBr$6(pos.getNode())) return prevPosition(element, pos).exists((pos2) => pos2.isEqual(caretPos)) || pos.isEqual(caretPos);
					else return pos.isEqual(caretPos);
				});
			};
			const isCaretAtStartOfSummary = (caretPos, detailsElements) => detailsElements.startSummary.exists((summary) => isCaretInTheBeginningOf(caretPos, summary));
			const isCaretAtEndOfSummary = (caretPos, detailsElements) => detailsElements.startSummary.exists((summary) => isCaretInTheEndOf(caretPos, summary));
			const isCaretInFirstPositionInBody = (caretPos, detailsElements) => detailsElements.startDetails.exists((details) => prevPosition(details, caretPos).forall((pos) => detailsElements.startSummary.exists((summary) => !summary.contains(caretPos.container()) && summary.contains(pos.container()))));
			const isCaretInLastPositionInBody = (root, caretPos, detailsElements) => detailsElements.startDetails.exists((details) => nextPosition(root, caretPos).forall((pos) => !details.contains(pos.container())));
			const setCaretToPosition = (editor, position) => {
				const node = position.getNode();
				if (!isUndefined(node)) editor.selection.setCursorLocation(node, position.offset());
			};
			const moveCaretToDetailsPos = (editor, pos, forward) => {
				const details = editor.dom.getParent(pos.container(), "details");
				if (details && !details.open) {
					const summary = editor.dom.select("summary", details)[0];
					if (summary) (forward ? firstPositionIn(summary) : lastPositionIn(summary)).each((pos$1) => setCaretToPosition(editor, pos$1));
				} else setCaretToPosition(editor, pos);
			};
			const isPartialDelete = (rng, detailsElements) => {
				const containsStart = (element) => element.contains(rng.startContainer);
				const containsEnd = (element) => element.contains(rng.endContainer);
				const startInSummary = detailsElements.startSummary.exists(containsStart);
				const endInSummary = detailsElements.startSummary.exists(containsEnd);
				const isPartiallySelectedDetailsElements = detailsElements.startDetails.forall((startDetails) => detailsElements.endDetails.forall((endDetails) => startDetails !== endDetails));
				return (startInSummary || endInSummary) && !(startInSummary && endInSummary) || isPartiallySelectedDetailsElements;
			};
			const shouldPreventDeleteIntoDetails = (editor, forward, granularity) => {
				const { dom: dom$1, selection } = editor;
				const root = editor.getBody();
				if (granularity === "character") {
					const caretPos = CaretPosition.fromRangeStart(selection.getRng());
					const parentBlock = dom$1.getParent(caretPos.container(), dom$1.isBlock);
					const parentDetailsAtCaret = getParentDetailsElementAtPos(dom$1, caretPos);
					const inEmptyParentBlock = parentBlock && dom$1.isEmpty(parentBlock);
					const isFirstBlock = isNull(parentBlock === null || parentBlock === void 0 ? void 0 : parentBlock.previousSibling);
					const isLastBlock = isNull(parentBlock === null || parentBlock === void 0 ? void 0 : parentBlock.nextSibling);
					if (inEmptyParentBlock) {
						if (forward ? isLastBlock : isFirstBlock) {
							if (navigate(!forward, root, caretPos).exists((pos) => {
								return isInDetailsElement(dom$1, pos) && !equals(parentDetailsAtCaret, getParentDetailsElementAtPos(dom$1, pos));
							})) return true;
						}
					}
					return navigate(forward, root, caretPos).fold(never, (pos) => {
						const parentDetailsAtNewPos = getParentDetailsElementAtPos(dom$1, pos);
						if (isInDetailsElement(dom$1, pos) && !equals(parentDetailsAtCaret, parentDetailsAtNewPos)) {
							if (!forward) moveCaretToDetailsPos(editor, pos, false);
							if (parentBlock && inEmptyParentBlock) {
								if (forward && isFirstBlock) return true;
								else if (!forward && isLastBlock) return true;
								moveCaretToDetailsPos(editor, pos, forward);
								editor.dom.remove(parentBlock);
							}
							return true;
						} else return false;
					});
				} else return false;
			};
			const shouldPreventDeleteSummaryAction = (editor, detailElements, forward, granularity) => {
				const rng = editor.selection.getRng();
				const caretPos = CaretPosition.fromRangeStart(rng);
				const root = editor.getBody();
				if (granularity === "selection") return isPartialDelete(rng, detailElements);
				else if (forward) return isCaretAtEndOfSummary(caretPos, detailElements) || isCaretInLastPositionInBody(root, caretPos, detailElements);
				else return isCaretAtStartOfSummary(caretPos, detailElements) || isCaretInFirstPositionInBody(caretPos, detailElements);
			};
			const shouldPreventDeleteAction = (editor, forward, granularity) => getDetailsElements(editor.dom, editor.selection.getRng()).fold(() => shouldPreventDeleteIntoDetails(editor, forward, granularity), (detailsElements) => shouldPreventDeleteSummaryAction(editor, detailsElements, forward, granularity) || shouldPreventDeleteIntoDetails(editor, forward, granularity));
			const handleDeleteActionSafari = (editor, forward, granularity) => {
				const selection = editor.selection;
				const node = selection.getNode();
				const rng = selection.getRng();
				const caretPos = CaretPosition.fromRangeStart(rng);
				if (isSummary(node)) {
					if (granularity === "selection" && isEntireNodeSelected(rng, node) || willDeleteLastPositionInElement(forward, caretPos, node)) emptyNodeContents(node);
					else editor.undoManager.transact(() => {
						const sel = selection.getSel();
						let { anchorNode, anchorOffset, focusNode, focusOffset } = sel !== null && sel !== void 0 ? sel : {};
						const applySelection = () => {
							if (isNonNullable(anchorNode) && isNonNullable(anchorOffset) && isNonNullable(focusNode) && isNonNullable(focusOffset)) sel === null || sel === void 0 || sel.setBaseAndExtent(anchorNode, anchorOffset, focusNode, focusOffset);
						};
						const updateSelection = () => {
							anchorNode = sel === null || sel === void 0 ? void 0 : sel.anchorNode;
							anchorOffset = sel === null || sel === void 0 ? void 0 : sel.anchorOffset;
							focusNode = sel === null || sel === void 0 ? void 0 : sel.focusNode;
							focusOffset = sel === null || sel === void 0 ? void 0 : sel.focusOffset;
						};
						const appendAllChildNodes = (from$1, to$1) => {
							each$e(from$1.childNodes, (child$2) => {
								if (isNode(child$2)) to$1.appendChild(child$2);
							});
						};
						const container = editor.dom.create("span", { "data-mce-bogus": "1" });
						appendAllChildNodes(node, container);
						node.appendChild(container);
						applySelection();
						if (granularity === "word" || granularity === "line") sel === null || sel === void 0 || sel.modify("extend", forward ? "right" : "left", granularity);
						if (!selection.isCollapsed() && isEntireNodeSelected(selection.getRng(), container)) emptyNodeContents(node);
						else {
							editor.execCommand(forward ? "ForwardDelete" : "Delete");
							updateSelection();
							appendAllChildNodes(container, node);
							applySelection();
						}
						editor.dom.remove(container);
					});
					return true;
				} else return false;
			};
			const backspaceDelete = (editor, forward, granularity) => shouldPreventDeleteAction(editor, forward, granularity) || isSafari && handleDeleteActionSafari(editor, forward, granularity) ? Optional.some(noop) : Optional.none();
			const createAndFireInputEvent = (eventType) => (editor, inputType, specifics = {}) => {
				const target = editor.getBody();
				const overrides = {
					bubbles: true,
					composed: true,
					data: null,
					isComposing: false,
					detail: 0,
					view: null,
					target,
					currentTarget: target,
					eventPhase: Event.AT_TARGET,
					originalTarget: target,
					explicitOriginalTarget: target,
					isTrusted: false,
					srcElement: target,
					cancelable: false,
					preventDefault: noop,
					inputType
				};
				const input = clone$3(new InputEvent(eventType));
				return editor.dispatch(eventType, {
					...input,
					...overrides,
					...specifics
				});
			};
			const fireInputEvent = createAndFireInputEvent("input");
			const fireBeforeInputEvent = createAndFireInputEvent("beforeinput");
			const platform$2 = detect$2();
			const os = platform$2.os;
			const isMacOSOriOS = os.isMacOS() || os.isiOS();
			const isFirefox = platform$2.browser.isFirefox();
			const executeKeydownOverride$3 = (editor, caret, evt) => {
				const inputType = evt.keyCode === VK.BACKSPACE ? "deleteContentBackward" : "deleteContentForward";
				const isCollapsed = editor.selection.isCollapsed();
				const unmodifiedGranularity = isCollapsed ? "character" : "selection";
				const getModifiedGranularity = (isWord) => {
					if (isCollapsed) return isWord ? "word" : "line";
					else return "selection";
				};
				executeWithDelayedAction([
					{
						keyCode: VK.BACKSPACE,
						action: action(backspaceDelete$1, editor)
					},
					{
						keyCode: VK.BACKSPACE,
						action: action(backspaceDelete$6, editor, false)
					},
					{
						keyCode: VK.DELETE,
						action: action(backspaceDelete$6, editor, true)
					},
					{
						keyCode: VK.BACKSPACE,
						action: action(backspaceDelete$7, editor, false)
					},
					{
						keyCode: VK.DELETE,
						action: action(backspaceDelete$7, editor, true)
					},
					{
						keyCode: VK.BACKSPACE,
						action: action(backspaceDelete$4, editor, caret, false)
					},
					{
						keyCode: VK.DELETE,
						action: action(backspaceDelete$4, editor, caret, true)
					},
					{
						keyCode: VK.BACKSPACE,
						action: action(backspaceDelete$a, editor, false)
					},
					{
						keyCode: VK.DELETE,
						action: action(backspaceDelete$a, editor, true)
					},
					{
						keyCode: VK.BACKSPACE,
						action: action(backspaceDelete, editor, false, unmodifiedGranularity)
					},
					{
						keyCode: VK.DELETE,
						action: action(backspaceDelete, editor, true, unmodifiedGranularity)
					},
					...isMacOSOriOS ? [
						{
							keyCode: VK.BACKSPACE,
							altKey: true,
							action: action(backspaceDelete, editor, false, getModifiedGranularity(true))
						},
						{
							keyCode: VK.DELETE,
							altKey: true,
							action: action(backspaceDelete, editor, true, getModifiedGranularity(true))
						},
						{
							keyCode: VK.BACKSPACE,
							metaKey: true,
							action: action(backspaceDelete, editor, false, getModifiedGranularity(false))
						}
					] : [{
						keyCode: VK.BACKSPACE,
						ctrlKey: true,
						action: action(backspaceDelete, editor, false, getModifiedGranularity(true))
					}, {
						keyCode: VK.DELETE,
						ctrlKey: true,
						action: action(backspaceDelete, editor, true, getModifiedGranularity(true))
					}],
					{
						keyCode: VK.BACKSPACE,
						action: action(backspaceDelete$5, editor, false)
					},
					{
						keyCode: VK.DELETE,
						action: action(backspaceDelete$5, editor, true)
					},
					{
						keyCode: VK.BACKSPACE,
						action: action(backspaceDelete$2, editor, false)
					},
					{
						keyCode: VK.DELETE,
						action: action(backspaceDelete$2, editor, true)
					},
					{
						keyCode: VK.BACKSPACE,
						action: action(backspaceDelete$8, editor, false)
					},
					{
						keyCode: VK.DELETE,
						action: action(backspaceDelete$8, editor, true)
					},
					{
						keyCode: VK.BACKSPACE,
						action: action(backspaceDelete$9, editor, false)
					},
					{
						keyCode: VK.DELETE,
						action: action(backspaceDelete$9, editor, true)
					},
					{
						keyCode: VK.BACKSPACE,
						action: action(backspaceDelete$3, editor, false)
					},
					{
						keyCode: VK.DELETE,
						action: action(backspaceDelete$3, editor, true)
					}
				], evt).filter((_) => editor.selection.isEditable()).each((applyAction) => {
					evt.preventDefault();
					if (!fireBeforeInputEvent(editor, inputType).isDefaultPrevented()) {
						applyAction();
						fireInputEvent(editor, inputType);
					}
				});
			};
			const executeKeyupOverride = (editor, evt, isBackspaceKeydown) => execute([
				{
					keyCode: VK.BACKSPACE,
					action: action(paddEmptyElement, editor)
				},
				{
					keyCode: VK.DELETE,
					action: action(paddEmptyElement, editor)
				},
				...isMacOSOriOS ? [
					{
						keyCode: VK.BACKSPACE,
						altKey: true,
						action: action(refreshCaret, editor)
					},
					{
						keyCode: VK.DELETE,
						altKey: true,
						action: action(refreshCaret, editor)
					},
					...isBackspaceKeydown ? [{
						keyCode: isFirefox ? 224 : 91,
						action: action(refreshCaret, editor)
					}] : []
				] : [{
					keyCode: VK.BACKSPACE,
					ctrlKey: true,
					action: action(refreshCaret, editor)
				}, {
					keyCode: VK.DELETE,
					ctrlKey: true,
					action: action(refreshCaret, editor)
				}]
			], evt);
			const setup$i = (editor, caret) => {
				let isBackspaceKeydown = false;
				editor.on("keydown", (evt) => {
					isBackspaceKeydown = evt.keyCode === VK.BACKSPACE;
					if (!evt.isDefaultPrevented()) executeKeydownOverride$3(editor, caret, evt);
				});
				editor.on("keyup", (evt) => {
					if (!evt.isDefaultPrevented()) executeKeyupOverride(editor, evt, isBackspaceKeydown);
					isBackspaceKeydown = false;
				});
			};
			const firstNonWhiteSpaceNodeSibling = (node) => {
				while (node) {
					if (isElement$6(node) || isText$a(node) && node.data && /[\r\n\s]/.test(node.data)) return node;
					node = node.nextSibling;
				}
				return null;
			};
			const moveToCaretPosition = (editor, root) => {
				const dom$1 = editor.dom;
				const moveCaretBeforeOnEnterElementsMap = editor.schema.getMoveCaretBeforeOnEnterElements();
				if (!root) return;
				if (/^(LI|DT|DD)$/.test(root.nodeName)) {
					const firstChild$1 = firstNonWhiteSpaceNodeSibling(root.firstChild);
					if (firstChild$1 && /^(UL|OL|DL)$/.test(firstChild$1.nodeName)) root.insertBefore(dom$1.doc.createTextNode(nbsp), root.firstChild);
				}
				const rng = dom$1.createRng();
				root.normalize();
				if (root.hasChildNodes()) {
					const walker = new DomTreeWalker(root, root);
					let lastNode = root;
					let node;
					while (node = walker.current()) {
						if (isText$a(node)) {
							rng.setStart(node, 0);
							rng.setEnd(node, 0);
							break;
						}
						if (moveCaretBeforeOnEnterElementsMap[node.nodeName.toLowerCase()]) {
							rng.setStartBefore(node);
							rng.setEndBefore(node);
							break;
						}
						lastNode = node;
						node = walker.next();
					}
					if (!node) {
						rng.setStart(lastNode, 0);
						rng.setEnd(lastNode, 0);
					}
				} else if (isBr$6(root)) if (root.nextSibling && dom$1.isBlock(root.nextSibling)) {
					rng.setStartBefore(root);
					rng.setEndBefore(root);
				} else {
					rng.setStartAfter(root);
					rng.setEndAfter(root);
				}
				else {
					rng.setStart(root, 0);
					rng.setEnd(root, 0);
				}
				editor.selection.setRng(rng);
				scrollRangeIntoView(editor, rng);
			};
			const getEditableRoot = (dom$1, node) => {
				const root = dom$1.getRoot();
				let editableRoot;
				let parent$1 = node;
				while (parent$1 !== root && parent$1 && dom$1.getContentEditable(parent$1) !== "false") {
					if (dom$1.getContentEditable(parent$1) === "true") {
						editableRoot = parent$1;
						break;
					}
					parent$1 = parent$1.parentNode;
				}
				return parent$1 !== root ? editableRoot : root;
			};
			const getParentBlock$1 = (editor) => {
				return Optional.from(editor.dom.getParent(editor.selection.getStart(true), editor.dom.isBlock));
			};
			const getParentBlockName = (editor) => {
				return getParentBlock$1(editor).fold(constant(""), (parentBlock) => {
					return parentBlock.nodeName.toUpperCase();
				});
			};
			const isListItemParentBlock = (editor) => {
				return getParentBlock$1(editor).filter((elm) => {
					return isListItem$1(SugarElement.fromDom(elm));
				}).isSome();
			};
			const emptyBlock = (elm) => {
				elm.innerHTML = "<br data-mce-bogus=\"1\">";
			};
			const applyAttributes = (editor, node, forcedRootBlockAttrs) => {
				const dom$1 = editor.dom;
				Optional.from(forcedRootBlockAttrs.style).map(dom$1.parseStyle).each((attrStyles) => {
					const newStyles = {
						...getAllRaw(SugarElement.fromDom(node)),
						...attrStyles
					};
					dom$1.setStyles(node, newStyles);
				});
				lift2(Optional.from(forcedRootBlockAttrs.class).map((attrClasses) => attrClasses.split(/\s+/)), Optional.from(node.className).map((currentClasses) => filter$5(currentClasses.split(/\s+/), (clazz) => clazz !== "")), (attrClasses, currentClasses) => {
					const filteredClasses = filter$5(currentClasses, (clazz) => !contains$2(attrClasses, clazz));
					const newClasses = [...attrClasses, ...filteredClasses];
					dom$1.setAttrib(node, "class", newClasses.join(" "));
				});
				const appliedAttrs = ["style", "class"];
				const remainingAttrs = filter$4(forcedRootBlockAttrs, (_, attrs) => !contains$2(appliedAttrs, attrs));
				dom$1.setAttribs(node, remainingAttrs);
			};
			const setForcedBlockAttrs = (editor, node) => {
				if (getForcedRootBlock(editor).toLowerCase() === node.tagName.toLowerCase()) applyAttributes(editor, node, getForcedRootBlockAttrs(editor));
			};
			const createNewBlock = (editor, container, parentBlock, editableRoot, keepStyles = true, name$1) => {
				const dom$1 = editor.dom;
				const schema = editor.schema;
				const newBlockName = getForcedRootBlock(editor);
				const parentBlockName = parentBlock ? parentBlock.nodeName.toUpperCase() : "";
				let node = container;
				const textInlineElements = schema.getTextInlineElements();
				let block;
				if (name$1 || parentBlockName === "TABLE" || parentBlockName === "HR") block = dom$1.create(name$1 || newBlockName);
				else block = parentBlock.cloneNode(false);
				let caretNode = block;
				if (!keepStyles) {
					dom$1.setAttrib(block, "style", null);
					dom$1.setAttrib(block, "class", null);
				} else do
					if (textInlineElements[node.nodeName]) {
						if (isCaretNode(node) || isBookmarkNode$1(node)) continue;
						const clonedNode = node.cloneNode(false);
						dom$1.setAttrib(clonedNode, "id", "");
						if (block.hasChildNodes()) {
							clonedNode.appendChild(block.firstChild);
							block.appendChild(clonedNode);
						} else {
							caretNode = clonedNode;
							block.appendChild(clonedNode);
						}
					}
				while ((node = node.parentNode) && node !== editableRoot);
				setForcedBlockAttrs(editor, block);
				emptyBlock(caretNode);
				return block;
			};
			const getDetailsRoot = (editor, element) => editor.dom.getParent(element, isDetails);
			const isAtDetailsEdge = (root, element, isTextBlock$3) => {
				let node = element;
				while (node && node !== root && isNull(node.nextSibling)) {
					const parent$1 = node.parentElement;
					if (!parent$1 || !isTextBlock$3(parent$1)) return isDetails(parent$1);
					node = parent$1;
				}
				return false;
			};
			const isLastEmptyBlockInDetails = (editor, shiftKey, element) => !shiftKey && element.nodeName.toLowerCase() === getForcedRootBlock(editor) && editor.dom.isEmpty(element) && isAtDetailsEdge(editor.getBody(), element, (el) => has$2(editor.schema.getTextBlockElements(), el.nodeName.toLowerCase()));
			const insertNewLine = (editor, createNewBlock$1, parentBlock) => {
				var _a, _b, _c;
				const newBlock = createNewBlock$1(getForcedRootBlock(editor));
				const root = getDetailsRoot(editor, parentBlock);
				if (!root) return;
				editor.dom.insertAfter(newBlock, root);
				moveToCaretPosition(editor, newBlock);
				if (((_c = (_b = (_a = parentBlock.parentElement) === null || _a === void 0 ? void 0 : _a.childNodes) === null || _b === void 0 ? void 0 : _b.length) !== null && _c !== void 0 ? _c : 0) > 1) editor.dom.remove(parentBlock);
			};
			const hasFirstChild = (elm, name$1) => {
				return elm.firstChild && elm.firstChild.nodeName === name$1;
			};
			const isFirstChild = (elm) => {
				var _a;
				return ((_a = elm.parentNode) === null || _a === void 0 ? void 0 : _a.firstChild) === elm;
			};
			const hasParent = (elm, parentName) => {
				const parentNode = elm === null || elm === void 0 ? void 0 : elm.parentNode;
				return isNonNullable(parentNode) && parentNode.nodeName === parentName;
			};
			const isListBlock = (elm) => {
				return isNonNullable(elm) && /^(OL|UL|LI)$/.test(elm.nodeName);
			};
			const isListItem = (elm) => {
				return isNonNullable(elm) && /^(LI|DT|DD)$/.test(elm.nodeName);
			};
			const isNestedList = (elm) => {
				return isListBlock(elm) && isListBlock(elm.parentNode);
			};
			const getContainerBlock = (containerBlock) => {
				const containerBlockParent = containerBlock.parentNode;
				return isListItem(containerBlockParent) ? containerBlockParent : containerBlock;
			};
			const isFirstOrLastLi = (containerBlock, parentBlock, first$2) => {
				let node = containerBlock[first$2 ? "firstChild" : "lastChild"];
				while (node) {
					if (isElement$6(node)) break;
					node = node[first$2 ? "nextSibling" : "previousSibling"];
				}
				return node === parentBlock;
			};
			const insert$4 = (editor, createNewBlock$1, containerBlock, parentBlock, newBlockName) => {
				const dom$1 = editor.dom;
				const rng = editor.selection.getRng();
				const containerParent = containerBlock.parentNode;
				if (containerBlock === editor.getBody() || !containerParent) return;
				if (isNestedList(containerBlock)) newBlockName = "LI";
				let newBlock = createNewBlock$1(newBlockName);
				if (isFirstOrLastLi(containerBlock, parentBlock, true) && isFirstOrLastLi(containerBlock, parentBlock, false)) if (hasParent(containerBlock, "LI")) {
					const containerBlockParent = getContainerBlock(containerBlock);
					dom$1.insertAfter(newBlock, containerBlockParent);
					if (isFirstChild(containerBlock)) dom$1.remove(containerBlockParent);
					else dom$1.remove(containerBlock);
				} else dom$1.replace(newBlock, containerBlock);
				else if (isFirstOrLastLi(containerBlock, parentBlock, true)) {
					if (hasParent(containerBlock, "LI")) {
						dom$1.insertAfter(newBlock, getContainerBlock(containerBlock));
						newBlock.appendChild(dom$1.doc.createTextNode(" "));
						newBlock.appendChild(containerBlock);
					} else containerParent.insertBefore(newBlock, containerBlock);
					dom$1.remove(parentBlock);
				} else if (isFirstOrLastLi(containerBlock, parentBlock, false)) {
					dom$1.insertAfter(newBlock, getContainerBlock(containerBlock));
					dom$1.remove(parentBlock);
				} else {
					containerBlock = getContainerBlock(containerBlock);
					const tmpRng = rng.cloneRange();
					tmpRng.setStartAfter(parentBlock);
					tmpRng.setEndAfter(containerBlock);
					const fragment = tmpRng.extractContents();
					if (newBlockName === "LI" && hasFirstChild(fragment, "LI")) {
						newBlock = fragment.firstChild;
						dom$1.insertAfter(fragment, containerBlock);
					} else {
						dom$1.insertAfter(fragment, containerBlock);
						dom$1.insertAfter(newBlock, containerBlock);
					}
					dom$1.remove(parentBlock);
				}
				moveToCaretPosition(editor, newBlock);
			};
			const trimZwsp = (fragment) => {
				each$e(descendants$1(SugarElement.fromDom(fragment), isText$b), (text$1) => {
					const rawNode = text$1.dom;
					rawNode.nodeValue = trim$1(rawNode.data);
				});
			};
			const isWithinNonEditableList = (editor, node) => {
				const parentList = editor.dom.getParent(node, "ol,ul,dl");
				return parentList !== null && editor.dom.getContentEditableParent(parentList) === "false";
			};
			const isEmptyAnchor = (dom$1, elm) => {
				return elm && elm.nodeName === "A" && dom$1.isEmpty(elm);
			};
			const containerAndSiblingName = (container, nodeName) => {
				return container.nodeName === nodeName || container.previousSibling && container.previousSibling.nodeName === nodeName;
			};
			const canSplitBlock = (dom$1, node) => {
				return isNonNullable(node) && dom$1.isBlock(node) && !/^(TD|TH|CAPTION|FORM)$/.test(node.nodeName) && !/^(fixed|absolute)/i.test(node.style.position) && dom$1.isEditable(node.parentNode) && dom$1.getContentEditable(node) !== "false";
			};
			const trimInlineElementsOnLeftSideOfBlock = (dom$1, nonEmptyElementsMap, block) => {
				var _a;
				const firstChilds = [];
				if (!block) return;
				let currentNode = block;
				while (currentNode = currentNode.firstChild) {
					if (dom$1.isBlock(currentNode)) return;
					if (isElement$6(currentNode) && !nonEmptyElementsMap[currentNode.nodeName.toLowerCase()]) firstChilds.push(currentNode);
				}
				let i = firstChilds.length;
				while (i--) {
					currentNode = firstChilds[i];
					if (!currentNode.hasChildNodes() || currentNode.firstChild === currentNode.lastChild && ((_a = currentNode.firstChild) === null || _a === void 0 ? void 0 : _a.nodeValue) === "") dom$1.remove(currentNode);
					else if (isEmptyAnchor(dom$1, currentNode)) dom$1.remove(currentNode);
				}
			};
			const normalizeZwspOffset = (start$2, container, offset) => {
				if (!isText$a(container)) return offset;
				else if (start$2) return offset === 1 && container.data.charAt(offset - 1) === ZWSP$1 ? 0 : offset;
				else return offset === container.data.length - 1 && container.data.charAt(offset) === ZWSP$1 ? container.data.length : offset;
			};
			const includeZwspInRange = (rng) => {
				const newRng = rng.cloneRange();
				newRng.setStart(rng.startContainer, normalizeZwspOffset(true, rng.startContainer, rng.startOffset));
				newRng.setEnd(rng.endContainer, normalizeZwspOffset(false, rng.endContainer, rng.endOffset));
				return newRng;
			};
			const trimLeadingLineBreaks = (node) => {
				let currentNode = node;
				do {
					if (isText$a(currentNode)) currentNode.data = currentNode.data.replace(/^[\r\n]+/, "");
					currentNode = currentNode.firstChild;
				} while (currentNode);
			};
			const wrapSelfAndSiblingsInDefaultBlock = (editor, newBlockName, rng, container, offset) => {
				var _a, _b;
				const dom$1 = editor.dom;
				const editableRoot = (_a = getEditableRoot(dom$1, container)) !== null && _a !== void 0 ? _a : dom$1.getRoot();
				let parentBlock = dom$1.getParent(container, dom$1.isBlock);
				if (!parentBlock || !canSplitBlock(dom$1, parentBlock)) {
					parentBlock = parentBlock || editableRoot;
					if (!parentBlock.hasChildNodes()) {
						const newBlock = dom$1.create(newBlockName);
						setForcedBlockAttrs(editor, newBlock);
						parentBlock.appendChild(newBlock);
						rng.setStart(newBlock, 0);
						rng.setEnd(newBlock, 0);
						return newBlock;
					}
					let node = container;
					while (node && node.parentNode !== parentBlock) node = node.parentNode;
					let startNode;
					while (node && !dom$1.isBlock(node)) {
						startNode = node;
						node = node.previousSibling;
					}
					const startNodeName = (_b = startNode === null || startNode === void 0 ? void 0 : startNode.parentElement) === null || _b === void 0 ? void 0 : _b.nodeName;
					if (startNode && startNodeName && editor.schema.isValidChild(startNodeName, newBlockName.toLowerCase())) {
						const startNodeParent = startNode.parentNode;
						const newBlock = dom$1.create(newBlockName);
						setForcedBlockAttrs(editor, newBlock);
						startNodeParent.insertBefore(newBlock, startNode);
						node = startNode;
						while (node && !dom$1.isBlock(node)) {
							const next$1 = node.nextSibling;
							newBlock.appendChild(node);
							node = next$1;
						}
						rng.setStart(container, offset);
						rng.setEnd(container, offset);
					}
				}
				return container;
			};
			const addBrToBlockIfNeeded = (dom$1, block) => {
				block.normalize();
				const lastChild$1 = block.lastChild;
				if (!lastChild$1 || isElement$6(lastChild$1) && /^(left|right)$/gi.test(dom$1.getStyle(lastChild$1, "float", true))) dom$1.add(block, "br");
			};
			const shouldEndContainer = (editor, container) => {
				const optionValue = shouldEndContainerOnEmptyBlock(editor);
				if (isNullable(container)) return false;
				else if (isString(optionValue)) return contains$2(Tools.explode(optionValue), container.nodeName.toLowerCase());
				else return optionValue;
			};
			const insert$3 = (editor, evt) => {
				let container;
				let offset;
				let parentBlockName;
				let containerBlock;
				let isAfterLastNodeInContainer = false;
				const dom$1 = editor.dom;
				const nonEmptyElementsMap = editor.schema.getNonEmptyElements();
				const rng = editor.selection.getRng();
				const newBlockName = getForcedRootBlock(editor);
				const start$2 = SugarElement.fromDom(rng.startContainer);
				const child$2 = child$1(start$2, rng.startOffset);
				const isCef = child$2.exists((element) => isHTMLElement(element) && !isEditable$3(element));
				const collapsedAndCef = rng.collapsed && isCef;
				const createNewBlock$1 = (name$1) => {
					return createNewBlock(editor, container, parentBlock, editableRoot, shouldKeepStyles(editor), name$1);
				};
				const isCaretAtStartOrEndOfBlock = (start$3) => {
					const normalizedOffset = normalizeZwspOffset(start$3, container, offset);
					if (isText$a(container) && (start$3 ? normalizedOffset > 0 : normalizedOffset < container.data.length)) return false;
					if (container.parentNode === parentBlock && isAfterLastNodeInContainer && !start$3) return true;
					if (start$3 && isElement$6(container) && container === parentBlock.firstChild) return true;
					if (containerAndSiblingName(container, "TABLE") || containerAndSiblingName(container, "HR")) return isAfterLastNodeInContainer && !start$3 || !isAfterLastNodeInContainer && start$3;
					const walker = new DomTreeWalker(container, parentBlock);
					if (isText$a(container)) {
						if (start$3 && normalizedOffset === 0) walker.prev();
						else if (!start$3 && normalizedOffset === container.data.length) walker.next();
					}
					let node;
					while (node = walker.current()) {
						if (isElement$6(node)) {
							if (!node.getAttribute("data-mce-bogus")) {
								const name$1 = node.nodeName.toLowerCase();
								if (nonEmptyElementsMap[name$1] && name$1 !== "br") return false;
							}
						} else if (isText$a(node) && !isWhitespaceText(node.data)) return false;
						if (start$3) walker.prev();
						else walker.next();
					}
					return true;
				};
				const insertNewBlockAfter = () => {
					let block;
					if (/^(H[1-6]|PRE|FIGURE)$/.test(parentBlockName) && containerBlockName !== "HGROUP") block = createNewBlock$1(newBlockName);
					else block = createNewBlock$1();
					if (shouldEndContainer(editor, containerBlock) && canSplitBlock(dom$1, containerBlock) && dom$1.isEmpty(parentBlock, void 0, { includeZwsp: true })) block = dom$1.split(containerBlock, parentBlock);
					else dom$1.insertAfter(block, parentBlock);
					moveToCaretPosition(editor, block);
					return block;
				};
				normalize$2(dom$1, rng).each((normRng) => {
					rng.setStart(normRng.startContainer, normRng.startOffset);
					rng.setEnd(normRng.endContainer, normRng.endOffset);
				});
				container = rng.startContainer;
				offset = rng.startOffset;
				const shiftKey = !!(evt && evt.shiftKey);
				const ctrlKey = !!(evt && evt.ctrlKey);
				if (isElement$6(container) && container.hasChildNodes() && !collapsedAndCef) {
					isAfterLastNodeInContainer = offset > container.childNodes.length - 1;
					container = container.childNodes[Math.min(offset, container.childNodes.length - 1)] || container;
					if (isAfterLastNodeInContainer && isText$a(container)) offset = container.data.length;
					else offset = 0;
				}
				const editableRoot = getEditableRoot(dom$1, container);
				if (!editableRoot || isWithinNonEditableList(editor, container)) return;
				if (!shiftKey) container = wrapSelfAndSiblingsInDefaultBlock(editor, newBlockName, rng, container, offset);
				let parentBlock = dom$1.getParent(container, dom$1.isBlock) || dom$1.getRoot();
				containerBlock = isNonNullable(parentBlock === null || parentBlock === void 0 ? void 0 : parentBlock.parentNode) ? dom$1.getParent(parentBlock.parentNode, dom$1.isBlock) : null;
				parentBlockName = parentBlock ? parentBlock.nodeName.toUpperCase() : "";
				const containerBlockName = containerBlock ? containerBlock.nodeName.toUpperCase() : "";
				if (containerBlockName === "LI" && !ctrlKey) {
					const liBlock = containerBlock;
					parentBlock = liBlock;
					containerBlock = liBlock.parentNode;
					parentBlockName = containerBlockName;
				}
				if (isElement$6(containerBlock) && isLastEmptyBlockInDetails(editor, shiftKey, parentBlock)) return insertNewLine(editor, createNewBlock$1, parentBlock);
				if (/^(LI|DT|DD)$/.test(parentBlockName) && isElement$6(containerBlock)) {
					if (dom$1.isEmpty(parentBlock)) {
						insert$4(editor, createNewBlock$1, containerBlock, parentBlock, newBlockName);
						return;
					}
				}
				if (!collapsedAndCef && (parentBlock === editor.getBody() || !canSplitBlock(dom$1, parentBlock))) return;
				const parentBlockParent = parentBlock.parentNode;
				let newBlock;
				if (collapsedAndCef) {
					newBlock = createNewBlock$1(newBlockName);
					child$2.fold(() => {
						append$1(start$2, SugarElement.fromDom(newBlock));
					}, (child$3) => {
						before$3(child$3, SugarElement.fromDom(newBlock));
					});
					editor.selection.setCursorLocation(newBlock, 0);
				} else if (isCaretContainerBlock$1(parentBlock)) {
					newBlock = showCaretContainerBlock(parentBlock);
					if (dom$1.isEmpty(parentBlock)) emptyBlock(parentBlock);
					setForcedBlockAttrs(editor, newBlock);
					moveToCaretPosition(editor, newBlock);
				} else if (isCaretAtStartOrEndOfBlock(false)) newBlock = insertNewBlockAfter();
				else if (isCaretAtStartOrEndOfBlock(true) && parentBlockParent) {
					newBlock = parentBlockParent.insertBefore(createNewBlock$1(), parentBlock);
					const isNearChildren = hasChildNodes(SugarElement.fromDom(rng.startContainer)) && rng.collapsed;
					moveToCaretPosition(editor, containerAndSiblingName(parentBlock, "HR") || isNearChildren ? newBlock : parentBlock);
				} else {
					const tmpRng = includeZwspInRange(rng).cloneRange();
					tmpRng.setEndAfter(parentBlock);
					const fragment = tmpRng.extractContents();
					trimZwsp(fragment);
					trimLeadingLineBreaks(fragment);
					newBlock = fragment.firstChild;
					dom$1.insertAfter(fragment, parentBlock);
					trimInlineElementsOnLeftSideOfBlock(dom$1, nonEmptyElementsMap, newBlock);
					addBrToBlockIfNeeded(dom$1, parentBlock);
					if (dom$1.isEmpty(parentBlock)) emptyBlock(parentBlock);
					newBlock.normalize();
					if (dom$1.isEmpty(newBlock)) {
						dom$1.remove(newBlock);
						insertNewBlockAfter();
					} else {
						setForcedBlockAttrs(editor, newBlock);
						moveToCaretPosition(editor, newBlock);
					}
				}
				dom$1.setAttrib(newBlock, "id", "");
				editor.dispatch("NewBlock", { newBlock });
			};
			const blockbreak = {
				insert: insert$3,
				fakeEventName: "insertParagraph"
			};
			const hasRightSideContent = (schema, container, parentBlock) => {
				const walker = new DomTreeWalker(container, parentBlock);
				let node;
				const nonEmptyElementsMap = schema.getNonEmptyElements();
				while (node = walker.next()) if (nonEmptyElementsMap[node.nodeName.toLowerCase()] || isText$a(node) && node.length > 0) return true;
				return false;
			};
			const moveSelectionToBr = (editor, brElm, extraBr) => {
				const rng = editor.dom.createRng();
				if (!extraBr) {
					rng.setStartAfter(brElm);
					rng.setEndAfter(brElm);
				} else {
					rng.setStartBefore(brElm);
					rng.setEndBefore(brElm);
				}
				editor.selection.setRng(rng);
				scrollRangeIntoView(editor, rng);
			};
			const insertBrAtCaret = (editor, evt) => {
				const selection = editor.selection;
				const dom$1 = editor.dom;
				const rng = selection.getRng();
				let brElm;
				let extraBr = false;
				normalize$2(dom$1, rng).each((normRng) => {
					rng.setStart(normRng.startContainer, normRng.startOffset);
					rng.setEnd(normRng.endContainer, normRng.endOffset);
				});
				let offset = rng.startOffset;
				let container = rng.startContainer;
				if (isElement$6(container) && container.hasChildNodes()) {
					const isAfterLastNodeInContainer = offset > container.childNodes.length - 1;
					container = container.childNodes[Math.min(offset, container.childNodes.length - 1)] || container;
					if (isAfterLastNodeInContainer && isText$a(container)) offset = container.data.length;
					else offset = 0;
				}
				let parentBlock = dom$1.getParent(container, dom$1.isBlock);
				const containerBlock = parentBlock && parentBlock.parentNode ? dom$1.getParent(parentBlock.parentNode, dom$1.isBlock) : null;
				const containerBlockName = containerBlock ? containerBlock.nodeName.toUpperCase() : "";
				const isControlKey = !!(evt && evt.ctrlKey);
				if (containerBlockName === "LI" && !isControlKey) parentBlock = containerBlock;
				if (isText$a(container) && offset >= container.data.length) {
					if (!hasRightSideContent(editor.schema, container, parentBlock || dom$1.getRoot())) {
						brElm = dom$1.create("br");
						rng.insertNode(brElm);
						rng.setStartAfter(brElm);
						rng.setEndAfter(brElm);
						extraBr = true;
					}
				}
				brElm = dom$1.create("br");
				rangeInsertNode(dom$1, rng, brElm);
				moveSelectionToBr(editor, brElm, extraBr);
				editor.undoManager.add();
			};
			const insertBrBefore = (editor, inline) => {
				const br = SugarElement.fromTag("br");
				before$3(SugarElement.fromDom(inline), br);
				editor.undoManager.add();
			};
			const insertBrAfter = (editor, inline) => {
				if (!hasBrAfter(editor.getBody(), inline)) after$4(SugarElement.fromDom(inline), SugarElement.fromTag("br"));
				const br = SugarElement.fromTag("br");
				after$4(SugarElement.fromDom(inline), br);
				moveSelectionToBr(editor, br.dom, false);
				editor.undoManager.add();
			};
			const isBeforeBr = (pos) => {
				return isBr$6(pos.getNode());
			};
			const hasBrAfter = (rootNode, startNode) => {
				if (isBeforeBr(CaretPosition.after(startNode))) return true;
				else return nextPosition(rootNode, CaretPosition.after(startNode)).map((pos) => {
					return isBr$6(pos.getNode());
				}).getOr(false);
			};
			const isAnchorLink = (elm) => {
				return elm && elm.nodeName === "A" && "href" in elm;
			};
			const isInsideAnchor = (location) => {
				return location.fold(never, isAnchorLink, isAnchorLink, never);
			};
			const readInlineAnchorLocation = (editor) => {
				const isInlineTarget$1 = curry(isInlineTarget, editor);
				const position = CaretPosition.fromRangeStart(editor.selection.getRng());
				return readLocation(isInlineTarget$1, editor.getBody(), position).filter(isInsideAnchor);
			};
			const insertBrOutsideAnchor = (editor, location) => {
				location.fold(noop, curry(insertBrBefore, editor), curry(insertBrAfter, editor), noop);
			};
			const insert$2 = (editor, evt) => {
				const anchorLocation = readInlineAnchorLocation(editor);
				if (anchorLocation.isSome()) anchorLocation.each(curry(insertBrOutsideAnchor, editor));
				else insertBrAtCaret(editor, evt);
			};
			const linebreak = {
				insert: insert$2,
				fakeEventName: "insertLineBreak"
			};
			const matchesSelector = (editor, selector) => {
				return getParentBlock$1(editor).filter((parentBlock) => {
					return selector.length > 0 && is$1(SugarElement.fromDom(parentBlock), selector);
				}).isSome();
			};
			const shouldInsertBr = (editor) => {
				return matchesSelector(editor, getBrNewLineSelector(editor));
			};
			const shouldBlockNewLine$1 = (editor) => {
				return matchesSelector(editor, getNoNewLineSelector(editor));
			};
			const newLineAction = Adt.generate([
				{ br: [] },
				{ block: [] },
				{ none: [] }
			]);
			const shouldBlockNewLine = (editor, _shiftKey) => {
				return shouldBlockNewLine$1(editor);
			};
			const inListBlock = (requiredState) => {
				return (editor, _shiftKey) => {
					return isListItemParentBlock(editor) === requiredState;
				};
			};
			const inBlock = (blockName, requiredState) => (editor, _shiftKey) => {
				return getParentBlockName(editor) === blockName.toUpperCase() === requiredState;
			};
			const inCefBlock = (editor) => {
				return isNullable(getEditableRoot(editor.dom, editor.selection.getStart()));
			};
			const inPreBlock = (requiredState) => inBlock("pre", requiredState);
			const inSummaryBlock = () => inBlock("summary", true);
			const shouldPutBrInPre = (requiredState) => {
				return (editor, _shiftKey) => {
					return shouldPutBrInPre$1(editor) === requiredState;
				};
			};
			const inBrContext = (editor, _shiftKey) => {
				return shouldInsertBr(editor);
			};
			const hasShiftKey = (_editor, shiftKey) => {
				return shiftKey;
			};
			const canInsertIntoEditableRoot = (editor) => {
				const forcedRootBlock = getForcedRootBlock(editor);
				const rootEditable = getEditableRoot(editor.dom, editor.selection.getStart());
				return isNonNullable(rootEditable) && editor.schema.isValidChild(rootEditable.nodeName, forcedRootBlock);
			};
			const isInRootWithEmptyOrCEF = (editor) => {
				const rng = editor.selection.getRng();
				const isCefOpt = child$1(SugarElement.fromDom(rng.startContainer), rng.startOffset).map((element) => isHTMLElement(element) && !isEditable$3(element));
				return rng.collapsed && isCefOpt.getOr(true);
			};
			const match = (predicates, action$1) => {
				return (editor, shiftKey) => {
					return foldl(predicates, (res, p) => {
						return res && p(editor, shiftKey);
					}, true) ? Optional.some(action$1) : Optional.none();
				};
			};
			const getAction = (editor, evt) => {
				return evaluateUntil([
					match([shouldBlockNewLine], newLineAction.none()),
					match([inPreBlock(true), inCefBlock], newLineAction.none()),
					match([inSummaryBlock()], newLineAction.br()),
					match([
						inPreBlock(true),
						shouldPutBrInPre(false),
						hasShiftKey
					], newLineAction.br()),
					match([inPreBlock(true), shouldPutBrInPre(false)], newLineAction.block()),
					match([
						inPreBlock(true),
						shouldPutBrInPre(true),
						hasShiftKey
					], newLineAction.block()),
					match([inPreBlock(true), shouldPutBrInPre(true)], newLineAction.br()),
					match([inListBlock(true), hasShiftKey], newLineAction.br()),
					match([inListBlock(true)], newLineAction.block()),
					match([inBrContext], newLineAction.br()),
					match([hasShiftKey], newLineAction.br()),
					match([canInsertIntoEditableRoot], newLineAction.block()),
					match([isInRootWithEmptyOrCEF], newLineAction.block())
				], [editor, !!(evt && evt.shiftKey)]).getOr(newLineAction.none());
			};
			const insertBreak = (breakType, editor, evt) => {
				if (!editor.selection.isCollapsed()) execEditorDeleteCommand(editor);
				if (isNonNullable(evt)) {
					if (fireBeforeInputEvent(editor, breakType.fakeEventName).isDefaultPrevented()) return;
				}
				breakType.insert(editor, evt);
				if (isNonNullable(evt)) fireInputEvent(editor, breakType.fakeEventName);
			};
			const insert$1 = (editor, evt) => {
				const br = () => insertBreak(linebreak, editor, evt);
				const block = () => insertBreak(blockbreak, editor, evt);
				const logicalAction = getAction(editor, evt);
				switch (getNewlineBehavior(editor)) {
					case "linebreak":
						logicalAction.fold(br, br, noop);
						break;
					case "block":
						logicalAction.fold(block, block, noop);
						break;
					case "invert":
						logicalAction.fold(block, br, noop);
						break;
					default:
						logicalAction.fold(br, block, noop);
						break;
				}
			};
			const platform$1 = detect$2();
			const isIOSSafari = platform$1.os.isiOS() && platform$1.browser.isSafari();
			const handleEnterKeyEvent = (editor, event) => {
				if (event.isDefaultPrevented()) return;
				event.preventDefault();
				endTypingLevelIgnoreLocks(editor.undoManager);
				editor.undoManager.transact(() => {
					insert$1(editor, event);
				});
			};
			const isCaretAfterKoreanCharacter = (rng) => {
				if (!rng.collapsed) return false;
				const startContainer = rng.startContainer;
				if (isText$a(startContainer)) {
					const koreanCharRegex = /^[\uAC00-\uD7AF\u1100-\u11FF\u3130-\u318F\uA960-\uA97F\uD7B0-\uD7FF]$/;
					const char = startContainer.data.charAt(rng.startOffset - 1);
					return koreanCharRegex.test(char);
				} else return false;
			};
			const setup$h = (editor) => {
				let iOSSafariKeydownBookmark = Optional.none();
				const iOSSafariKeydownOverride = (editor$1) => {
					iOSSafariKeydownBookmark = Optional.some(editor$1.selection.getBookmark());
					editor$1.undoManager.add();
				};
				const iOSSafariKeyupOverride = (editor$1, event) => {
					editor$1.undoManager.undo();
					iOSSafariKeydownBookmark.fold(noop, (b) => editor$1.selection.moveToBookmark(b));
					handleEnterKeyEvent(editor$1, event);
					iOSSafariKeydownBookmark = Optional.none();
				};
				editor.on("keydown", (event) => {
					if (event.keyCode === VK.ENTER) if (isIOSSafari && isCaretAfterKoreanCharacter(editor.selection.getRng())) iOSSafariKeydownOverride(editor);
					else handleEnterKeyEvent(editor, event);
				});
				editor.on("keyup", (event) => {
					if (event.keyCode === VK.ENTER) iOSSafariKeydownBookmark.each(() => iOSSafariKeyupOverride(editor, event));
				});
			};
			const executeKeydownOverride$2 = (editor, caret, evt) => {
				const isMac = Env.os.isMacOS() || Env.os.isiOS();
				execute([
					{
						keyCode: VK.END,
						action: action(moveToLineEndPoint$1, editor, true)
					},
					{
						keyCode: VK.HOME,
						action: action(moveToLineEndPoint$1, editor, false)
					},
					...!isMac ? [{
						keyCode: VK.HOME,
						action: action(selectToEndPoint, editor, false),
						ctrlKey: true,
						shiftKey: true
					}, {
						keyCode: VK.END,
						action: action(selectToEndPoint, editor, true),
						ctrlKey: true,
						shiftKey: true
					}] : [],
					{
						keyCode: VK.END,
						action: action(moveToLineEndPoint, editor, true)
					},
					{
						keyCode: VK.HOME,
						action: action(moveToLineEndPoint, editor, false)
					},
					{
						keyCode: VK.END,
						action: action(moveToLineEndPoint$2, editor, true, caret)
					},
					{
						keyCode: VK.HOME,
						action: action(moveToLineEndPoint$2, editor, false, caret)
					}
				], evt).each((_) => {
					evt.preventDefault();
				});
			};
			const setup$g = (editor, caret) => {
				editor.on("keydown", (evt) => {
					if (!evt.isDefaultPrevented()) executeKeydownOverride$2(editor, caret, evt);
				});
			};
			const setup$f = (editor) => {
				editor.on("input", (e) => {
					if (!e.isComposing) normalizeNbspsInEditor(editor);
				});
			};
			const platform = detect$2();
			const executeKeyupAction = (editor, caret, evt) => {
				execute([{
					keyCode: VK.PAGE_UP,
					action: action(moveToLineEndPoint$2, editor, false, caret)
				}, {
					keyCode: VK.PAGE_DOWN,
					action: action(moveToLineEndPoint$2, editor, true, caret)
				}], evt);
			};
			const stopImmediatePropagation = (e) => e.stopImmediatePropagation();
			const isPageUpDown = (evt) => evt.keyCode === VK.PAGE_UP || evt.keyCode === VK.PAGE_DOWN;
			const setNodeChangeBlocker = (blocked, editor, block) => {
				if (block && !blocked.get()) editor.on("NodeChange", stopImmediatePropagation, true);
				else if (!block && blocked.get()) editor.off("NodeChange", stopImmediatePropagation);
				blocked.set(block);
			};
			const setup$e = (editor, caret) => {
				if (platform.os.isMacOS()) return;
				const blocked = Cell(false);
				editor.on("keydown", (evt) => {
					if (isPageUpDown(evt)) setNodeChangeBlocker(blocked, editor, true);
				});
				editor.on("keyup", (evt) => {
					if (!evt.isDefaultPrevented()) executeKeyupAction(editor, caret, evt);
					if (isPageUpDown(evt) && blocked.get()) {
						setNodeChangeBlocker(blocked, editor, false);
						editor.nodeChanged();
					}
				});
			};
			const insertTextAtPosition = (text$1, pos) => {
				const container = pos.container();
				const offset = pos.offset();
				if (isText$a(container)) {
					container.insertData(offset, text$1);
					return Optional.some(CaretPosition(container, offset + text$1.length));
				} else return getElementFromPosition(pos).map((elm) => {
					const textNode = SugarElement.fromText(text$1);
					if (pos.isAtEnd()) after$4(elm, textNode);
					else before$3(elm, textNode);
					return CaretPosition(textNode.dom, text$1.length);
				});
			};
			const insertNbspAtPosition = curry(insertTextAtPosition, nbsp);
			const insertSpaceAtPosition = curry(insertTextAtPosition, " ");
			const insertSpaceOrNbspAtPosition = (root, pos) => needsToHaveNbsp(root, pos) ? insertNbspAtPosition(pos) : insertSpaceAtPosition(pos);
			const locationToCaretPosition = (root) => (location) => location.fold((element) => prevPosition(root.dom, CaretPosition.before(element)), (element) => firstPositionIn(element), (element) => lastPositionIn(element), (element) => nextPosition(root.dom, CaretPosition.after(element)));
			const insertInlineBoundarySpaceOrNbsp = (root, pos) => (checkPos) => needsToHaveNbsp(root, checkPos) ? insertNbspAtPosition(pos) : insertSpaceAtPosition(pos);
			const setSelection = (editor) => (pos) => {
				editor.selection.setRng(pos.toRange());
				editor.nodeChanged();
			};
			const isInsideSummary = (domUtils, node) => domUtils.isEditable(domUtils.getParent(node, "summary"));
			const insertSpaceOrNbspAtSelection = (editor) => {
				const pos = CaretPosition.fromRangeStart(editor.selection.getRng());
				const root = SugarElement.fromDom(editor.getBody());
				if (editor.selection.isCollapsed()) {
					const isInlineTarget$1 = curry(isInlineTarget, editor);
					const caretPosition = CaretPosition.fromRangeStart(editor.selection.getRng());
					return readLocation(isInlineTarget$1, editor.getBody(), caretPosition).bind(locationToCaretPosition(root)).map((checkPos) => () => insertInlineBoundarySpaceOrNbsp(root, pos)(checkPos).each(setSelection(editor)));
				} else return Optional.none();
			};
			const insertSpaceInSummaryAtSelectionOnFirefox = (editor) => {
				const insertSpaceThunk = () => {
					const root = SugarElement.fromDom(editor.getBody());
					if (!editor.selection.isCollapsed()) editor.getDoc().execCommand("Delete");
					insertSpaceOrNbspAtPosition(root, CaretPosition.fromRangeStart(editor.selection.getRng())).each(setSelection(editor));
				};
				return someIf(Env.browser.isFirefox() && editor.selection.isEditable() && isInsideSummary(editor.dom, editor.selection.getRng().startContainer), insertSpaceThunk);
			};
			const executeKeydownOverride$1 = (editor, evt) => {
				executeWithDelayedAction([{
					keyCode: VK.SPACEBAR,
					action: action(insertSpaceOrNbspAtSelection, editor)
				}, {
					keyCode: VK.SPACEBAR,
					action: action(insertSpaceInSummaryAtSelectionOnFirefox, editor)
				}], evt).each((applyAction) => {
					evt.preventDefault();
					if (!fireBeforeInputEvent(editor, "insertText", { data: " " }).isDefaultPrevented()) {
						applyAction();
						fireInputEvent(editor, "insertText", { data: " " });
					}
				});
			};
			const setup$d = (editor) => {
				editor.on("keydown", (evt) => {
					if (!evt.isDefaultPrevented()) executeKeydownOverride$1(editor, evt);
				});
			};
			const tableTabNavigation = (editor) => {
				if (hasTableTabNavigation(editor)) return [{
					keyCode: VK.TAB,
					action: action(handleTab, editor, true)
				}, {
					keyCode: VK.TAB,
					shiftKey: true,
					action: action(handleTab, editor, false)
				}];
				else return [];
			};
			const executeKeydownOverride = (editor, evt) => {
				execute([...tableTabNavigation(editor)], evt).each((_) => {
					evt.preventDefault();
				});
			};
			const setup$c = (editor) => {
				editor.on("keydown", (evt) => {
					if (!evt.isDefaultPrevented()) executeKeydownOverride(editor, evt);
				});
			};
			const setup$b = (editor) => {
				editor.addShortcut("Meta+P", "", "mcePrint");
				setup$j(editor);
				if (isRtc(editor)) return Cell(null);
				else {
					const caret = setupSelectedState(editor);
					setup$l(editor);
					setup$k(editor, caret);
					setup$i(editor, caret);
					setup$h(editor);
					setup$d(editor);
					setup$f(editor);
					setup$c(editor);
					setup$g(editor, caret);
					setup$e(editor, caret);
					return caret;
				}
			};
			class NodeChange {
				constructor(editor) {
					this.lastPath = [];
					this.editor = editor;
					let lastRng;
					const self = this;
					if (!("onselectionchange" in editor.getDoc())) editor.on("NodeChange click mouseup keyup focus", (e) => {
						const nativeRng = editor.selection.getRng();
						const fakeRng = {
							startContainer: nativeRng.startContainer,
							startOffset: nativeRng.startOffset,
							endContainer: nativeRng.endContainer,
							endOffset: nativeRng.endOffset
						};
						if (e.type === "nodechange" || !isEq$4(fakeRng, lastRng)) editor.dispatch("SelectionChange");
						lastRng = fakeRng;
					});
					editor.on("contextmenu", () => {
						editor.dispatch("SelectionChange");
					});
					editor.on("SelectionChange", () => {
						const startElm = editor.selection.getStart(true);
						if (!startElm) return;
						if (hasAnyRanges(editor) && !self.isSameElementPath(startElm) && editor.dom.isChildOf(startElm, editor.getBody())) editor.nodeChanged({ selectionChange: true });
					});
					editor.on("mouseup", (e) => {
						if (!e.isDefaultPrevented() && hasAnyRanges(editor)) if (editor.selection.getNode().nodeName === "IMG") Delay.setEditorTimeout(editor, () => {
							editor.nodeChanged();
						});
						else editor.nodeChanged();
					});
				}
				nodeChanged(args = {}) {
					const selection = this.editor.selection;
					let node;
					if (this.editor.initialized && selection && !shouldDisableNodeChange(this.editor) && !this.editor.mode.isReadOnly()) {
						const root = this.editor.getBody();
						node = selection.getStart(true) || root;
						if (node.ownerDocument !== this.editor.getDoc() || !this.editor.dom.isChildOf(node, root)) node = root;
						const parents$2 = [];
						this.editor.dom.getParent(node, (node$1) => {
							if (node$1 === root) return true;
							else {
								parents$2.push(node$1);
								return false;
							}
						});
						this.editor.dispatch("NodeChange", {
							...args,
							element: node,
							parents: parents$2
						});
					}
				}
				isSameElementPath(startElm) {
					let i;
					const editor = this.editor;
					const currentPath = reverse(editor.dom.getParents(startElm, always, editor.getBody()));
					if (currentPath.length === this.lastPath.length) {
						for (i = currentPath.length; i >= 0; i--) if (currentPath[i] !== this.lastPath[i]) break;
						if (i === -1) {
							this.lastPath = currentPath;
							return true;
						}
					}
					this.lastPath = currentPath;
					return false;
				}
			}
			const imageId = generate$1("image");
			const getDragImage = (transfer) => {
				const dt = transfer;
				return Optional.from(dt[imageId]);
			};
			const setDragImage = (transfer, imageData) => {
				const dt = transfer;
				dt[imageId] = imageData;
			};
			const eventId = generate$1("event");
			const getEvent = (transfer) => {
				const dt = transfer;
				return Optional.from(dt[eventId]);
			};
			const mkSetEventFn = (type$2) => (transfer) => {
				const dt = transfer;
				dt[eventId] = type$2;
			};
			const setEvent = (transfer, type$2) => mkSetEventFn(type$2)(transfer);
			const setDragstartEvent = mkSetEventFn(0);
			const setDropEvent = mkSetEventFn(2);
			const setDragendEvent = mkSetEventFn(1);
			const checkEvent = (expectedType) => (transfer) => {
				const dt = transfer;
				return Optional.from(dt[eventId]).exists((type$2) => type$2 === expectedType);
			};
			const isInDragStartEvent = checkEvent(0);
			const createEmptyFileList = () => Object.freeze({
				length: 0,
				item: (_) => null
			});
			const modeId = generate$1("mode");
			const getMode = (transfer) => {
				const dt = transfer;
				return Optional.from(dt[modeId]);
			};
			const mkSetModeFn = (mode) => (transfer) => {
				const dt = transfer;
				dt[modeId] = mode;
			};
			const setMode$1 = (transfer, mode) => mkSetModeFn(mode)(transfer);
			const setReadWriteMode = mkSetModeFn(0);
			const setReadOnlyMode = mkSetModeFn(2);
			const setProtectedMode = mkSetModeFn(1);
			const checkMode = (expectedMode) => (transfer) => {
				const dt = transfer;
				return Optional.from(dt[modeId]).exists((mode) => mode === expectedMode);
			};
			const isInReadWriteMode = checkMode(0);
			const isInProtectedMode = checkMode(1);
			const normalizeItems = (dataTransfer, itemsImpl) => ({
				...itemsImpl,
				get length() {
					return itemsImpl.length;
				},
				add: (data$1, type$2) => {
					if (isInReadWriteMode(dataTransfer)) if (isString(data$1)) {
						if (!isUndefined(type$2)) return itemsImpl.add(data$1, type$2);
					} else return itemsImpl.add(data$1);
					return null;
				},
				remove: (idx) => {
					if (isInReadWriteMode(dataTransfer)) itemsImpl.remove(idx);
				},
				clear: () => {
					if (isInReadWriteMode(dataTransfer)) itemsImpl.clear();
				}
			});
			const validDropEffects = [
				"none",
				"copy",
				"link",
				"move"
			];
			const validEffectAlloweds = [
				"none",
				"copy",
				"copyLink",
				"copyMove",
				"link",
				"linkMove",
				"move",
				"all",
				"uninitialized"
			];
			const createDataTransfer = () => {
				const dataTransferImpl = new window.DataTransfer();
				let dropEffect = "move";
				let effectAllowed = "all";
				const dataTransfer = {
					get dropEffect() {
						return dropEffect;
					},
					set dropEffect(effect) {
						if (contains$2(validDropEffects, effect)) dropEffect = effect;
					},
					get effectAllowed() {
						return effectAllowed;
					},
					set effectAllowed(allowed) {
						if (isInDragStartEvent(dataTransfer) && contains$2(validEffectAlloweds, allowed)) effectAllowed = allowed;
					},
					get items() {
						return normalizeItems(dataTransfer, dataTransferImpl.items);
					},
					get files() {
						if (isInProtectedMode(dataTransfer)) return createEmptyFileList();
						else return dataTransferImpl.files;
					},
					get types() {
						return dataTransferImpl.types;
					},
					setDragImage: (image, x, y) => {
						if (isInReadWriteMode(dataTransfer)) {
							setDragImage(dataTransfer, {
								image,
								x,
								y
							});
							dataTransferImpl.setDragImage(image, x, y);
						}
					},
					getData: (format) => {
						if (isInProtectedMode(dataTransfer)) return "";
						else return dataTransferImpl.getData(format);
					},
					setData: (format, data$1) => {
						if (isInReadWriteMode(dataTransfer)) dataTransferImpl.setData(format, data$1);
					},
					clearData: (format) => {
						if (isInReadWriteMode(dataTransfer)) dataTransferImpl.clearData(format);
					}
				};
				setReadWriteMode(dataTransfer);
				return dataTransfer;
			};
			const cloneDataTransfer = (original) => {
				const clone$5 = createDataTransfer();
				const originalMode = getMode(original);
				setReadOnlyMode(original);
				setDragstartEvent(clone$5);
				clone$5.dropEffect = original.dropEffect;
				clone$5.effectAllowed = original.effectAllowed;
				getDragImage(original).each((imageData) => clone$5.setDragImage(imageData.image, imageData.x, imageData.y));
				each$e(original.types, (type$2) => {
					if (type$2 !== "Files") clone$5.setData(type$2, original.getData(type$2));
				});
				each$e(original.files, (file) => clone$5.items.add(file));
				getEvent(original).each((type$2) => {
					setEvent(clone$5, type$2);
				});
				originalMode.each((mode) => {
					setMode$1(original, mode);
					setMode$1(clone$5, mode);
				});
				return clone$5;
			};
			const getHtmlData = (dataTransfer) => {
				const html$2 = dataTransfer.getData("text/html");
				return html$2 === "" ? Optional.none() : Optional.some(html$2);
			};
			const setHtmlData = (dataTransfer, html$2) => dataTransfer.setData("text/html", html$2);
			const internalMimeType = "x-tinymce/html";
			const internalHtmlMime = constant(internalMimeType);
			const internalMark = "<!-- " + internalMimeType + " -->";
			const mark = (html$2) => internalMark + html$2;
			const unmark = (html$2) => html$2.replace(internalMark, "");
			const isMarked = (html$2) => html$2.indexOf(internalMark) !== -1;
			const isPlainText = (text$1) => {
				return !/<(?:\/?(?!(?:div|p|br|span)>)\w+|(?:(?!(?:span style="white-space:\s?pre;?">)|br\s?\/>))\w+\s[^>]+)>/i.test(text$1);
			};
			const openContainer = (rootTag, rootAttrs) => {
				let tag = "<" + rootTag;
				const attrs = mapToArray(rootAttrs, (value$3, key) => key + "=\"" + Entities.encodeAllRaw(value$3) + "\"");
				if (attrs.length) tag += " " + attrs.join(" ");
				return tag + ">";
			};
			const toBlockElements = (text$1, rootTag, rootAttrs) => {
				const blocks$1 = text$1.split(/\n\n/);
				const tagOpen = openContainer(rootTag, rootAttrs);
				const tagClose = "</" + rootTag + ">";
				const paragraphs = map$3(blocks$1, (p) => {
					return p.split(/\n/).join("<br />");
				});
				const stitch = (p) => {
					return tagOpen + p + tagClose;
				};
				return paragraphs.length === 1 ? paragraphs[0] : map$3(paragraphs, stitch).join("");
			};
			const pasteBinDefaultContent = "%MCEPASTEBIN%";
			const create$6 = (editor, lastRngCell) => {
				const { dom: dom$1, selection } = editor;
				const body = editor.getBody();
				lastRngCell.set(selection.getRng());
				const pasteBinElm = dom$1.add(editor.getBody(), "div", {
					"id": "mcepastebin",
					"class": "mce-pastebin",
					"contentEditable": true,
					"data-mce-bogus": "all",
					"style": "position: fixed; top: 50%; width: 10px; height: 10px; overflow: hidden; opacity: 0"
				}, pasteBinDefaultContent);
				if (Env.browser.isFirefox()) dom$1.setStyle(pasteBinElm, "left", dom$1.getStyle(body, "direction", true) === "rtl" ? 65535 : -65535);
				dom$1.bind(pasteBinElm, "beforedeactivate focusin focusout", (e) => {
					e.stopPropagation();
				});
				pasteBinElm.focus();
				selection.select(pasteBinElm, true);
			};
			const remove = (editor, lastRngCell) => {
				const dom$1 = editor.dom;
				if (getEl(editor)) {
					let pasteBinClone;
					const lastRng = lastRngCell.get();
					while (pasteBinClone = getEl(editor)) {
						dom$1.remove(pasteBinClone);
						dom$1.unbind(pasteBinClone);
					}
					if (lastRng) editor.selection.setRng(lastRng);
				}
				lastRngCell.set(null);
			};
			const getEl = (editor) => editor.dom.get("mcepastebin");
			const isPasteBin = (elm) => isNonNullable(elm) && elm.id === "mcepastebin";
			const getHtml = (editor) => {
				const dom$1 = editor.dom;
				const copyAndRemove = (toElm, fromElm) => {
					toElm.appendChild(fromElm);
					dom$1.remove(fromElm, true);
				};
				const [pasteBinElm, ...pasteBinClones] = filter$5(editor.getBody().childNodes, isPasteBin);
				each$e(pasteBinClones, (pasteBinClone) => {
					copyAndRemove(pasteBinElm, pasteBinClone);
				});
				const dirtyWrappers = dom$1.select("div[id=mcepastebin]", pasteBinElm);
				for (let i = dirtyWrappers.length - 1; i >= 0; i--) {
					const cleanWrapper = dom$1.create("div");
					pasteBinElm.insertBefore(cleanWrapper, dirtyWrappers[i]);
					copyAndRemove(cleanWrapper, dirtyWrappers[i]);
				}
				return pasteBinElm ? pasteBinElm.innerHTML : "";
			};
			const isDefaultPasteBinContent = (content) => content === pasteBinDefaultContent;
			const PasteBin = (editor) => {
				const lastRng = Cell(null);
				return {
					create: () => create$6(editor, lastRng),
					remove: () => remove(editor, lastRng),
					getEl: () => getEl(editor),
					getHtml: () => getHtml(editor),
					getLastRng: lastRng.get
				};
			};
			const filter$1 = (content, items) => {
				Tools.each(items, (v) => {
					if (is$4(v, RegExp)) content = content.replace(v, "");
					else content = content.replace(v[0], v[1]);
				});
				return content;
			};
			const innerText = (html$2) => {
				const schema = Schema();
				const domParser = DomParser({}, schema);
				let text$1 = "";
				const voidElements = schema.getVoidElements();
				const ignoreElements = Tools.makeMap("script noscript style textarea video audio iframe object", " ");
				const blockElements = schema.getBlockElements();
				const walk$5 = (node) => {
					const name$1 = node.name, currentNode = node;
					if (name$1 === "br") {
						text$1 += "\n";
						return;
					}
					if (name$1 === "wbr") return;
					if (voidElements[name$1]) text$1 += " ";
					if (ignoreElements[name$1]) {
						text$1 += " ";
						return;
					}
					if (node.type === 3) text$1 += node.value;
					if (!(node.name in schema.getVoidElements())) {
						let currentNode$1 = node.firstChild;
						if (currentNode$1) do
							walk$5(currentNode$1);
						while (currentNode$1 = currentNode$1.next);
					}
					if (blockElements[name$1] && currentNode.next) {
						text$1 += "\n";
						if (name$1 === "p") text$1 += "\n";
					}
				};
				html$2 = filter$1(html$2, [/<!\[[^\]]+\]>/g]);
				walk$5(domParser.parse(html$2));
				return text$1;
			};
			const trimHtml = (html$2) => {
				const trimSpaces = (all$1, s1, s2) => {
					if (!s1 && !s2) return " ";
					return nbsp;
				};
				html$2 = filter$1(html$2, [
					/^[\s\S]*<body[^>]*>\s*|\s*<\/body[^>]*>[\s\S]*$/gi,
					/<!--StartFragment-->|<!--EndFragment-->/g,
					[/( ?)<span class="Apple-converted-space">\u00a0<\/span>( ?)/g, trimSpaces],
					/<br class="Apple-interchange-newline">/g,
					/<br>$/i
				]);
				return html$2;
			};
			const createIdGenerator = (prefix) => {
				let count$2 = 0;
				return () => {
					return prefix + count$2++;
				};
			};
			const getImageMimeType = (ext) => {
				const lowerExt = ext.toLowerCase();
				const mimeOverrides = {
					jpg: "jpeg",
					jpe: "jpeg",
					jfi: "jpeg",
					jif: "jpeg",
					jfif: "jpeg",
					pjpeg: "jpeg",
					pjp: "jpeg",
					svg: "svg+xml"
				};
				return Tools.hasOwn(mimeOverrides, lowerExt) ? "image/" + mimeOverrides[lowerExt] : "image/" + lowerExt;
			};
			const preProcess = (editor, html$2) => {
				const parser = DomParser({ sanitize: shouldSanitizeXss(editor) }, editor.schema);
				parser.addNodeFilter("meta", (nodes) => {
					Tools.each(nodes, (node) => {
						node.remove();
					});
				});
				const fragment = parser.parse(html$2, {
					forced_root_block: false,
					isRootContent: true
				});
				return HtmlSerializer({ validate: true }, editor.schema).serialize(fragment);
			};
			const processResult = (content, cancelled) => ({
				content,
				cancelled
			});
			const postProcessFilter = (editor, html$2, internal) => {
				const postProcessArgs = firePastePostProcess(editor, editor.dom.create("div", { style: "display:none" }, html$2), internal);
				return processResult(postProcessArgs.node.innerHTML, postProcessArgs.isDefaultPrevented());
			};
			const filterContent = (editor, content, internal) => {
				const preProcessArgs = firePastePreProcess(editor, content, internal);
				const filteredContent = preProcess(editor, preProcessArgs.content);
				if (editor.hasEventListeners("PastePostProcess") && !preProcessArgs.isDefaultPrevented()) return postProcessFilter(editor, filteredContent, internal);
				else return processResult(filteredContent, preProcessArgs.isDefaultPrevented());
			};
			const process = (editor, html$2, internal) => {
				return filterContent(editor, html$2, internal);
			};
			const pasteHtml$1 = (editor, html$2) => {
				editor.insertContent(html$2, {
					merge: shouldPasteMergeFormats(editor),
					paste: true
				});
				return true;
			};
			const isAbsoluteUrl = (url) => /^https?:\/\/[\w\-\/+=.,!;:&%@^~(){}?#]+$/i.test(url);
			const isImageUrl = (editor, url) => {
				return isAbsoluteUrl(url) && exists(getAllowedImageFileTypes(editor), (type$2) => endsWith(url.toLowerCase(), `.${type$2.toLowerCase()}`));
			};
			const createImage = (editor, url, pasteHtmlFn) => {
				editor.undoManager.extra(() => {
					pasteHtmlFn(editor, url);
				}, () => {
					editor.insertContent("<img src=\"" + url + "\">");
				});
				return true;
			};
			const createLink = (editor, url, pasteHtmlFn) => {
				editor.undoManager.extra(() => {
					pasteHtmlFn(editor, url);
				}, () => {
					editor.execCommand("mceInsertLink", false, url);
				});
				return true;
			};
			const linkSelection = (editor, html$2, pasteHtmlFn) => !editor.selection.isCollapsed() && isAbsoluteUrl(html$2) ? createLink(editor, html$2, pasteHtmlFn) : false;
			const insertImage = (editor, html$2, pasteHtmlFn) => isImageUrl(editor, html$2) ? createImage(editor, html$2, pasteHtmlFn) : false;
			const smartInsertContent = (editor, html$2) => {
				Tools.each([
					linkSelection,
					insertImage,
					pasteHtml$1
				], (action$1) => {
					return !action$1(editor, html$2, pasteHtml$1);
				});
			};
			const insertContent = (editor, html$2, pasteAsText) => {
				if (pasteAsText || !isSmartPasteEnabled(editor)) pasteHtml$1(editor, html$2);
				else smartInsertContent(editor, html$2);
			};
			const uniqueId = createIdGenerator("mceclip");
			const createPasteDataTransfer = (html$2) => {
				const dataTransfer = createDataTransfer();
				setHtmlData(dataTransfer, html$2);
				setReadOnlyMode(dataTransfer);
				return dataTransfer;
			};
			const doPaste = (editor, content, internal, pasteAsText, shouldSimulateInputEvent) => {
				const res = process(editor, content, internal);
				if (!res.cancelled) {
					const content$1 = res.content;
					const doPasteAction = () => insertContent(editor, content$1, pasteAsText);
					if (shouldSimulateInputEvent) {
						if (!fireBeforeInputEvent(editor, "insertFromPaste", { dataTransfer: createPasteDataTransfer(content$1) }).isDefaultPrevented()) {
							doPasteAction();
							fireInputEvent(editor, "insertFromPaste");
						}
					} else doPasteAction();
				}
			};
			const pasteHtml = (editor, html$2, internalFlag, shouldSimulateInputEvent) => {
				const internal = internalFlag ? internalFlag : isMarked(html$2);
				doPaste(editor, unmark(html$2), internal, false, shouldSimulateInputEvent);
			};
			const pasteText = (editor, text$1, shouldSimulateInputEvent) => {
				doPaste(editor, toBlockElements(normalize$4(editor.dom.encode(text$1).replace(/\r\n/g, "\n"), getPasteTabSpaces(editor)), getForcedRootBlock(editor), getForcedRootBlockAttrs(editor)), false, true, shouldSimulateInputEvent);
			};
			const getDataTransferItems = (dataTransfer) => {
				const items = {};
				if (dataTransfer && dataTransfer.types) for (let i = 0; i < dataTransfer.types.length; i++) {
					const contentType = dataTransfer.types[i];
					try {
						items[contentType] = dataTransfer.getData(contentType);
					} catch (ex) {
						items[contentType] = "";
					}
				}
				return items;
			};
			const hasContentType = (clipboardContent, mimeType) => mimeType in clipboardContent && clipboardContent[mimeType].length > 0;
			const hasHtmlOrText = (content) => hasContentType(content, "text/html") || hasContentType(content, "text/plain");
			const extractFilename = (editor, str) => {
				const m = str.match(/([\s\S]+?)(?:\.[a-z0-9.]+)$/i);
				return isNonNullable(m) ? editor.dom.encode(m[1]) : void 0;
			};
			const createBlobInfo = (editor, blobCache, file, base64) => {
				const id = uniqueId();
				const useFileName = shouldReuseFileName(editor) && isNonNullable(file.name);
				const name$1 = useFileName ? extractFilename(editor, file.name) : id;
				const filename = useFileName ? file.name : void 0;
				const blobInfo = blobCache.create(id, file, base64, name$1, filename);
				blobCache.add(blobInfo);
				return blobInfo;
			};
			const pasteImage = (editor, imageItem) => {
				parseDataUri(imageItem.uri).each(({ data: data$1, type: type$2, base64Encoded }) => {
					const base64 = base64Encoded ? data$1 : btoa(data$1);
					const file = imageItem.file;
					const blobCache = editor.editorUpload.blobCache;
					const existingBlobInfo = blobCache.getByData(base64, type$2);
					pasteHtml(editor, `<img src="${(existingBlobInfo !== null && existingBlobInfo !== void 0 ? existingBlobInfo : createBlobInfo(editor, blobCache, file, base64)).blobUri()}">`, false, true);
				});
			};
			const isClipboardEvent = (event) => event.type === "paste";
			const readFilesAsDataUris = (items) => Promise.all(map$3(items, (file) => {
				return blobToDataUri(file).then((uri) => ({
					file,
					uri
				}));
			}));
			const isImage = (editor) => {
				const allowedExtensions = getAllowedImageFileTypes(editor);
				return (file) => startsWith(file.type, "image/") && exists(allowedExtensions, (extension) => {
					return getImageMimeType(extension) === file.type;
				});
			};
			const getImagesFromDataTransfer = (editor, dataTransfer) => {
				const items = dataTransfer.items ? bind$3(from(dataTransfer.items), (item) => {
					return item.kind === "file" ? [item.getAsFile()] : [];
				}) : [];
				const files = dataTransfer.files ? from(dataTransfer.files) : [];
				return filter$5(items.length > 0 ? items : files, isImage(editor));
			};
			const pasteImageData = (editor, e, rng) => {
				const dataTransfer = isClipboardEvent(e) ? e.clipboardData : e.dataTransfer;
				if (shouldPasteDataImages(editor) && dataTransfer) {
					const images = getImagesFromDataTransfer(editor, dataTransfer);
					if (images.length > 0) {
						e.preventDefault();
						readFilesAsDataUris(images).then((fileResults) => {
							if (rng) editor.selection.setRng(rng);
							each$e(fileResults, (result) => {
								pasteImage(editor, result);
							});
						});
						return true;
					}
				}
				return false;
			};
			const isBrokenAndroidClipboardEvent = (e) => {
				var _a, _b;
				return Env.os.isAndroid() && ((_b = (_a = e.clipboardData) === null || _a === void 0 ? void 0 : _a.items) === null || _b === void 0 ? void 0 : _b.length) === 0;
			};
			const isKeyboardPasteEvent = (e) => VK.metaKeyPressed(e) && e.keyCode === 86 || e.shiftKey && e.keyCode === 45;
			const insertClipboardContent = (editor, clipboardContent, html$2, plainTextMode, shouldSimulateInputEvent) => {
				let content = trimHtml(html$2);
				const isInternal = hasContentType(clipboardContent, internalHtmlMime()) || isMarked(html$2);
				const isPlainTextHtml = !isInternal && isPlainText(content);
				const isAbsoluteUrl$1 = isAbsoluteUrl(content);
				if (isDefaultPasteBinContent(content) || !content.length || isPlainTextHtml && !isAbsoluteUrl$1) plainTextMode = true;
				if (plainTextMode || isAbsoluteUrl$1) if (hasContentType(clipboardContent, "text/plain") && isPlainTextHtml) content = clipboardContent["text/plain"];
				else content = innerText(content);
				if (isDefaultPasteBinContent(content)) return;
				if (plainTextMode) pasteText(editor, content, shouldSimulateInputEvent);
				else pasteHtml(editor, content, isInternal, shouldSimulateInputEvent);
			};
			const registerEventHandlers = (editor, pasteBin, pasteFormat) => {
				let keyboardPastePlainTextState;
				const getLastRng = () => pasteBin.getLastRng() || editor.selection.getRng();
				editor.on("keydown", (e) => {
					if (isKeyboardPasteEvent(e) && !e.isDefaultPrevented()) keyboardPastePlainTextState = e.shiftKey && e.keyCode === 86;
				});
				editor.on("paste", (e) => {
					if (e.isDefaultPrevented() || isBrokenAndroidClipboardEvent(e)) return;
					const plainTextMode = pasteFormat.get() === "text" || keyboardPastePlainTextState;
					keyboardPastePlainTextState = false;
					const clipboardContent = getDataTransferItems(e.clipboardData);
					if (!hasHtmlOrText(clipboardContent) && pasteImageData(editor, e, getLastRng())) return;
					if (hasContentType(clipboardContent, "text/html")) {
						e.preventDefault();
						insertClipboardContent(editor, clipboardContent, clipboardContent["text/html"], plainTextMode, true);
					} else if (hasContentType(clipboardContent, "text/plain") && hasContentType(clipboardContent, "text/uri-list")) {
						e.preventDefault();
						insertClipboardContent(editor, clipboardContent, clipboardContent["text/plain"], plainTextMode, true);
					} else {
						pasteBin.create();
						Delay.setEditorTimeout(editor, () => {
							const html$2 = pasteBin.getHtml();
							pasteBin.remove();
							insertClipboardContent(editor, clipboardContent, html$2, plainTextMode, false);
						}, 0);
					}
				});
			};
			const registerDataImageFilter = (editor) => {
				const isWebKitFakeUrl = (src) => startsWith(src, "webkit-fake-url");
				const isDataUri = (src) => startsWith(src, "data:");
				const isPasteInsert = (args) => {
					var _a;
					return ((_a = args.data) === null || _a === void 0 ? void 0 : _a.paste) === true;
				};
				editor.parser.addNodeFilter("img", (nodes, name$1, args) => {
					if (!shouldPasteDataImages(editor) && isPasteInsert(args)) for (const node of nodes) {
						const src = node.attr("src");
						if (isString(src) && !node.attr("data-mce-object") && src !== Env.transparentSrc) {
							if (isWebKitFakeUrl(src)) node.remove();
							else if (!shouldAllowHtmlDataUrls(editor) && isDataUri(src)) node.remove();
						}
					}
				});
			};
			const registerEventsAndFilters = (editor, pasteBin, pasteFormat) => {
				registerEventHandlers(editor, pasteBin, pasteFormat);
				registerDataImageFilter(editor);
			};
			const togglePlainTextPaste = (editor, pasteFormat) => {
				if (pasteFormat.get() === "text") {
					pasteFormat.set("html");
					firePastePlainTextToggle(editor, false);
				} else {
					pasteFormat.set("text");
					firePastePlainTextToggle(editor, true);
				}
				editor.focus();
			};
			const register$1 = (editor, pasteFormat) => {
				editor.addCommand("mceTogglePlainTextPaste", () => {
					togglePlainTextPaste(editor, pasteFormat);
				});
				editor.addCommand("mceInsertClipboardContent", (ui, value$3) => {
					if (value$3.html) pasteHtml(editor, value$3.html, value$3.internal, false);
					if (value$3.text) pasteText(editor, value$3.text, false);
				});
			};
			const setHtml5Clipboard = (clipboardData, html$2, text$1) => {
				if (clipboardData) try {
					clipboardData.clearData();
					clipboardData.setData("text/html", html$2);
					clipboardData.setData("text/plain", text$1);
					clipboardData.setData(internalHtmlMime(), html$2);
					return true;
				} catch (e) {
					return false;
				}
				else return false;
			};
			const setClipboardData = (evt, data$1, fallback$1, done) => {
				if (setHtml5Clipboard(evt.clipboardData, data$1.html, data$1.text)) {
					evt.preventDefault();
					done();
				} else fallback$1(data$1.html, done);
			};
			const fallback = (editor) => (html$2, done) => {
				const { dom: dom$1, selection } = editor;
				const outer = dom$1.create("div", {
					"contenteditable": "false",
					"data-mce-bogus": "all"
				});
				const inner = dom$1.create("div", { contenteditable: "true" }, html$2);
				dom$1.setStyles(outer, {
					position: "fixed",
					top: "0",
					left: "-3000px",
					width: "1000px",
					overflow: "hidden"
				});
				outer.appendChild(inner);
				dom$1.add(editor.getBody(), outer);
				const range = selection.getRng();
				inner.focus();
				const offscreenRange = dom$1.createRng();
				offscreenRange.selectNodeContents(inner);
				selection.setRng(offscreenRange);
				Delay.setEditorTimeout(editor, () => {
					selection.setRng(range);
					dom$1.remove(outer);
					done();
				}, 0);
			};
			const getData = (editor) => ({
				html: mark(editor.selection.getContent({ contextual: true })),
				text: editor.selection.getContent({ format: "text" })
			});
			const isTableSelection = (editor) => !!editor.dom.getParent(editor.selection.getStart(), "td[data-mce-selected],th[data-mce-selected]", editor.getBody());
			const hasSelectedContent = (editor) => !editor.selection.isCollapsed() || isTableSelection(editor);
			const cut = (editor) => (evt) => {
				if (!evt.isDefaultPrevented() && hasSelectedContent(editor)) setClipboardData(evt, getData(editor), fallback(editor), () => {
					if (Env.browser.isChromium() || Env.browser.isFirefox()) {
						const rng = editor.selection.getRng();
						Delay.setEditorTimeout(editor, () => {
							editor.selection.setRng(rng);
							editor.execCommand("Delete");
						}, 0);
					} else editor.execCommand("Delete");
				});
			};
			const copy = (editor) => (evt) => {
				if (!evt.isDefaultPrevented() && hasSelectedContent(editor)) setClipboardData(evt, getData(editor), fallback(editor), noop);
			};
			const register = (editor) => {
				editor.on("cut", cut(editor));
				editor.on("copy", copy(editor));
			};
			const getCaretRangeFromEvent = (editor, e) => {
				var _a, _b;
				return RangeUtils.getCaretRangeFromPoint((_a = e.clientX) !== null && _a !== void 0 ? _a : 0, (_b = e.clientY) !== null && _b !== void 0 ? _b : 0, editor.getDoc());
			};
			const isPlainTextFileUrl = (content) => {
				const plainTextContent = content["text/plain"];
				return plainTextContent ? plainTextContent.indexOf("file://") === 0 : false;
			};
			const setFocusedRange = (editor, rng) => {
				editor.focus();
				if (rng) editor.selection.setRng(rng);
			};
			const hasImage = (dataTransfer) => exists(dataTransfer.files, (file) => /^image\//.test(file.type));
			const needsCustomInternalDrop = (dom$1, schema, target, dropContent) => {
				const parentTransparent = dom$1.getParent(target, (node) => isTransparentBlock(schema, node));
				if (!isNull(dom$1.getParent(target, "summary"))) return true;
				else if (parentTransparent && has$2(dropContent, "text/html")) {
					const fragment = new DOMParser().parseFromString(dropContent["text/html"], "text/html").body;
					return !isNull(fragment.querySelector(parentTransparent.nodeName.toLowerCase()));
				} else return false;
			};
			const setupSummaryDeleteByDragFix = (editor) => {
				editor.on("input", (e) => {
					const hasNoSummary = (el) => isNull(el.querySelector("summary"));
					if (e.inputType === "deleteByDrag") each$e(filter$5(editor.dom.select("details"), hasNoSummary), (details) => {
						if (isBr$6(details.firstChild)) details.firstChild.remove();
						const summary = editor.dom.create("summary");
						summary.appendChild(createPaddingBr().dom);
						details.prepend(summary);
					});
				});
			};
			const setup$a = (editor, draggingInternallyState) => {
				if (shouldPasteBlockDrop(editor)) editor.on("dragend dragover draggesture dragdrop drop drag", (e) => {
					e.preventDefault();
					e.stopPropagation();
				});
				if (!shouldPasteDataImages(editor)) editor.on("drop", (e) => {
					const dataTransfer = e.dataTransfer;
					if (dataTransfer && hasImage(dataTransfer)) e.preventDefault();
				});
				editor.on("drop", (e) => {
					if (e.isDefaultPrevented()) return;
					const rng = getCaretRangeFromEvent(editor, e);
					if (isNullable(rng)) return;
					const dropContent = getDataTransferItems(e.dataTransfer);
					const internal = hasContentType(dropContent, internalHtmlMime());
					if ((!hasHtmlOrText(dropContent) || isPlainTextFileUrl(dropContent)) && pasteImageData(editor, e, rng)) return;
					const internalContent = dropContent[internalHtmlMime()];
					const content = internalContent || dropContent["text/html"] || dropContent["text/plain"];
					const needsInternalDrop = needsCustomInternalDrop(editor.dom, editor.schema, rng.startContainer, dropContent);
					const isInternalDrop = draggingInternallyState.get();
					if (isInternalDrop && !needsInternalDrop) return;
					if (content) {
						e.preventDefault();
						Delay.setEditorTimeout(editor, () => {
							editor.undoManager.transact(() => {
								if (internalContent || isInternalDrop && needsInternalDrop) editor.execCommand("Delete");
								setFocusedRange(editor, rng);
								const trimmedContent = trimHtml(content);
								if (dropContent["text/html"]) pasteHtml(editor, trimmedContent, internal, true);
								else pasteText(editor, trimmedContent, true);
							});
						});
					}
				});
				editor.on("dragstart", (_e) => {
					draggingInternallyState.set(true);
				});
				editor.on("dragover dragend", (e) => {
					if (shouldPasteDataImages(editor) && !draggingInternallyState.get()) {
						e.preventDefault();
						setFocusedRange(editor, getCaretRangeFromEvent(editor, e));
					}
					if (e.type === "dragend") draggingInternallyState.set(false);
				});
				setupSummaryDeleteByDragFix(editor);
			};
			const setup$9 = (editor) => {
				const processEvent = (f) => (e) => {
					f(editor, e);
				};
				const preProcess$2 = getPastePreProcess(editor);
				if (isFunction(preProcess$2)) editor.on("PastePreProcess", processEvent(preProcess$2));
				const postProcess$2 = getPastePostProcess(editor);
				if (isFunction(postProcess$2)) editor.on("PastePostProcess", processEvent(postProcess$2));
			};
			const addPreProcessFilter = (editor, filterFunc) => {
				editor.on("PastePreProcess", (e) => {
					e.content = filterFunc(editor, e.content, e.internal);
				});
			};
			const rgbRegExp = /rgb\s*\(\s*([0-9]+)\s*,\s*([0-9]+)\s*,\s*([0-9]+)\s*\)/gi;
			const rgbToHex = (value$3) => Tools.trim(value$3).replace(rgbRegExp, rgbaToHexString).toLowerCase();
			const removeWebKitStyles = (editor, content, internal) => {
				const webKitStylesOption = getPasteWebkitStyles(editor);
				if (internal || webKitStylesOption === "all" || !shouldPasteRemoveWebKitStyles(editor)) return content;
				const webKitStyles = webKitStylesOption ? webKitStylesOption.split(/[, ]/) : [];
				if (webKitStyles && webKitStylesOption !== "none") {
					const dom$1 = editor.dom, node = editor.selection.getNode();
					content = content.replace(/(<[^>]+) style="([^"]*)"([^>]*>)/gi, (all$1, before$1, value$3, after$1) => {
						const inputStyles = dom$1.parseStyle(dom$1.decode(value$3));
						const outputStyles = {};
						for (let i = 0; i < webKitStyles.length; i++) {
							const inputValue = inputStyles[webKitStyles[i]];
							let compareInput = inputValue;
							let currentValue = dom$1.getStyle(node, webKitStyles[i], true);
							if (/color/.test(webKitStyles[i])) {
								compareInput = rgbToHex(compareInput);
								currentValue = rgbToHex(currentValue);
							}
							if (currentValue !== compareInput) outputStyles[webKitStyles[i]] = inputValue;
						}
						const outputStyle = dom$1.serializeStyle(outputStyles, "span");
						if (outputStyle) return before$1 + " style=\"" + outputStyle + "\"" + after$1;
						return before$1 + after$1;
					});
				} else content = content.replace(/(<[^>]+) style="([^"]*)"([^>]*>)/gi, "$1$3");
				content = content.replace(/(<[^>]+) data-mce-style="([^"]+)"([^>]*>)/gi, (all$1, before$1, value$3, after$1) => {
					return before$1 + " style=\"" + value$3 + "\"" + after$1;
				});
				return content;
			};
			const setup$8 = (editor) => {
				if (Env.browser.isChromium() || Env.browser.isSafari()) addPreProcessFilter(editor, removeWebKitStyles);
			};
			const setup$7 = (editor) => {
				const draggingInternallyState = Cell(false);
				const pasteFormat = Cell(isPasteAsTextEnabled(editor) ? "text" : "html");
				const pasteBin = PasteBin(editor);
				setup$8(editor);
				register$1(editor, pasteFormat);
				setup$9(editor);
				editor.on("PreInit", () => {
					register(editor);
					setup$a(editor, draggingInternallyState);
					registerEventsAndFilters(editor, pasteBin, pasteFormat);
				});
			};
			const preventSummaryToggle = (editor) => {
				editor.on("click", (e) => {
					if (editor.dom.getParent(e.target, "details")) e.preventDefault();
				});
			};
			const filterDetails = (editor) => {
				editor.parser.addNodeFilter("details", (elms) => {
					const initialStateOption = getDetailsInitialState(editor);
					each$e(elms, (details) => {
						if (initialStateOption === "expanded") details.attr("open", "open");
						else if (initialStateOption === "collapsed") details.attr("open", null);
					});
				});
				editor.serializer.addNodeFilter("details", (elms) => {
					const serializedStateOption = getDetailsSerializedState(editor);
					each$e(elms, (details) => {
						if (serializedStateOption === "expanded") details.attr("open", "open");
						else if (serializedStateOption === "collapsed") details.attr("open", null);
					});
				});
			};
			const setup$6 = (editor) => {
				preventSummaryToggle(editor);
				filterDetails(editor);
			};
			const isBr = isBr$6;
			const isText = isText$a;
			const isContentEditableFalse$2 = (elm) => isContentEditableFalse$b(elm.dom);
			const isContentEditableTrue = (elm) => isContentEditableTrue$3(elm.dom);
			const isRoot = (rootNode) => (elm) => eq(SugarElement.fromDom(rootNode), elm);
			const getClosestScope = (node, rootNode) => closest$4(SugarElement.fromDom(node), (elm) => isContentEditableTrue(elm) || isBlock$2(elm), isRoot(rootNode)).getOr(SugarElement.fromDom(rootNode)).dom;
			const getClosestCef = (node, rootNode) => closest$4(SugarElement.fromDom(node), isContentEditableFalse$2, isRoot(rootNode));
			const findEdgeCaretCandidate = (startNode, scope, forward) => {
				const walker = new DomTreeWalker(startNode, scope);
				const next$1 = forward ? walker.next.bind(walker) : walker.prev.bind(walker);
				let result = startNode;
				for (let current = forward ? startNode : next$1(); current && !isBr(current); current = next$1()) if (isCaretCandidate$3(current)) result = current;
				return result;
			};
			const findClosestBlockRange = (startRng, rootNode) => {
				const clickNode = CaretPosition.fromRangeStart(startRng).getNode();
				const scope = getClosestScope(clickNode, rootNode);
				const startNode = findEdgeCaretCandidate(clickNode, scope, false);
				const endNode = findEdgeCaretCandidate(clickNode, scope, true);
				const rng = document.createRange();
				getClosestCef(startNode, scope).fold(() => {
					if (isText(startNode)) rng.setStart(startNode, 0);
					else rng.setStartBefore(startNode);
				}, (cef) => rng.setStartBefore(cef.dom));
				getClosestCef(endNode, scope).fold(() => {
					if (isText(endNode)) rng.setEnd(endNode, endNode.data.length);
					else rng.setEndAfter(endNode);
				}, (cef) => rng.setEndAfter(cef.dom));
				return rng;
			};
			const onTripleClickSelect = (editor) => {
				const rng = findClosestBlockRange(editor.selection.getRng(), editor.getBody());
				editor.selection.setRng(normalize(rng));
			};
			const setup$5 = (editor) => {
				editor.on("mousedown", (e) => {
					if (e.detail >= 3) {
						e.preventDefault();
						onTripleClickSelect(editor);
					}
				});
			};
			var FakeCaretPosition;
			(function(FakeCaretPosition$1) {
				FakeCaretPosition$1["Before"] = "before";
				FakeCaretPosition$1["After"] = "after";
			})(FakeCaretPosition || (FakeCaretPosition = {}));
			const distanceToRectLeft = (clientRect, clientX) => Math.abs(clientRect.left - clientX);
			const distanceToRectRight = (clientRect, clientX) => Math.abs(clientRect.right - clientX);
			const isInsideY = (clientY, clientRect) => clientY >= clientRect.top && clientY <= clientRect.bottom;
			const collidesY = (r1, r2) => r1.top < r2.bottom && r1.bottom > r2.top;
			const isOverlapping = (r1, r2) => {
				const overlap = overlapY(r1, r2) / Math.min(r1.height, r2.height);
				return collidesY(r1, r2) && overlap > .5;
			};
			const splitRectsPerAxis = (rects, y) => {
				return boundingClientRectFromRects(filter$5(rects, (rect) => isInsideY(y, rect))).fold(() => [[], rects], (boundingRect) => {
					const { pass: horizontal, fail: vertical } = partition$2(rects, (rect) => isOverlapping(rect, boundingRect));
					return [horizontal, vertical];
				});
			};
			const clientInfo = (rect, clientX) => {
				return {
					node: rect.node,
					position: distanceToRectLeft(rect, clientX) < distanceToRectRight(rect, clientX) ? FakeCaretPosition.Before : FakeCaretPosition.After
				};
			};
			const horizontalDistance = (rect, x, _y) => x > rect.left && x < rect.right ? 0 : Math.min(Math.abs(rect.left - x), Math.abs(rect.right - x));
			const closestChildCaretCandidateNodeRect = (children$2, clientX, clientY) => {
				const caretCandidateRect = (rect) => {
					if (isCaretCandidate$3(rect.node)) return Optional.some(rect);
					else if (isElement$6(rect.node)) return closestChildCaretCandidateNodeRect(from(rect.node.childNodes), clientX, clientY);
					else return Optional.none();
				};
				const getClosestTextNode = (rects, distance) => {
					if (rects.length >= 2) {
						const r1 = caretCandidateRect(rects[0]).getOr(rects[0]);
						const r2 = caretCandidateRect(rects[1]).getOr(rects[1]);
						if (Math.abs(distance(r1, clientX, clientY) - distance(r2, clientX, clientY)) < 2) {
							if (isText$a(r1.node)) return Optional.some(r1);
							else if (isText$a(r2.node)) return Optional.some(r2);
						}
					}
					return Optional.none();
				};
				const findClosestCaretCandidateNodeRect = (rects, distance) => {
					const sortedRects = sort(rects, (r1, r2) => distance(r1, clientX, clientY) - distance(r2, clientX, clientY));
					return getClosestTextNode(sortedRects, distance).orThunk(() => findMap(sortedRects, caretCandidateRect));
				};
				const [horizontalRects, verticalRects] = splitRectsPerAxis(getClientRects(children$2), clientY);
				const { pass: above, fail: below } = partition$2(verticalRects, (rect) => rect.top < clientY);
				return findClosestCaretCandidateNodeRect(horizontalRects, horizontalDistance).orThunk(() => findClosestCaretCandidateNodeRect(below, distanceToRectEdgeFromXY)).orThunk(() => findClosestCaretCandidateNodeRect(above, distanceToRectEdgeFromXY));
			};
			const traverseUp = (rootElm, scope, clientX, clientY) => {
				const helper = (scope$1, prevScope) => {
					const isDragGhostContainer = (node) => isElement$6(node) && node.classList.contains("mce-drag-container");
					const childNodesWithoutGhost = filter$5(scope$1.dom.childNodes, not(isDragGhostContainer));
					return prevScope.fold(() => closestChildCaretCandidateNodeRect(childNodesWithoutGhost, clientX, clientY), (prevScope$1) => {
						return closestChildCaretCandidateNodeRect(filter$5(childNodesWithoutGhost, (node) => node !== prevScope$1.dom), clientX, clientY);
					}).orThunk(() => {
						return (eq(scope$1, rootElm) ? Optional.none() : parentElement(scope$1)).bind((newScope) => helper(newScope, Optional.some(scope$1)));
					});
				};
				return helper(scope, Optional.none());
			};
			const closestCaretCandidateNodeRect = (root, clientX, clientY) => {
				const rootElm = SugarElement.fromDom(root);
				const ownerDoc = documentOrOwner(rootElm);
				return traverseUp(rootElm, SugarElement.fromPoint(ownerDoc, clientX, clientY).filter((elm) => contains(rootElm, elm)).getOr(rootElm), clientX, clientY);
			};
			const closestFakeCaretCandidate = (root, clientX, clientY) => closestCaretCandidateNodeRect(root, clientX, clientY).filter((rect) => isFakeCaretTarget(rect.node)).map((rect) => clientInfo(rect, clientX));
			const getAbsolutePosition = (elm) => {
				var _a, _b;
				const clientRect = elm.getBoundingClientRect();
				const doc = elm.ownerDocument;
				const docElem = doc.documentElement;
				const win = doc.defaultView;
				return {
					top: clientRect.top + ((_a = win === null || win === void 0 ? void 0 : win.scrollY) !== null && _a !== void 0 ? _a : 0) - docElem.clientTop,
					left: clientRect.left + ((_b = win === null || win === void 0 ? void 0 : win.scrollX) !== null && _b !== void 0 ? _b : 0) - docElem.clientLeft
				};
			};
			const getBodyPosition = (editor) => editor.inline ? getAbsolutePosition(editor.getBody()) : {
				left: 0,
				top: 0
			};
			const getScrollPosition = (editor) => {
				const body = editor.getBody();
				return editor.inline ? {
					left: body.scrollLeft,
					top: body.scrollTop
				} : {
					left: 0,
					top: 0
				};
			};
			const getBodyScroll = (editor) => {
				const body = editor.getBody(), docElm = editor.getDoc().documentElement;
				const inlineScroll = {
					left: body.scrollLeft,
					top: body.scrollTop
				};
				const iframeScroll = {
					left: body.scrollLeft || docElm.scrollLeft,
					top: body.scrollTop || docElm.scrollTop
				};
				return editor.inline ? inlineScroll : iframeScroll;
			};
			const getMousePosition = (editor, event) => {
				if (event.target.ownerDocument !== editor.getDoc()) {
					const iframePosition = getAbsolutePosition(editor.getContentAreaContainer());
					const scrollPosition = getBodyScroll(editor);
					return {
						left: event.pageX - iframePosition.left + scrollPosition.left,
						top: event.pageY - iframePosition.top + scrollPosition.top
					};
				}
				return {
					left: event.pageX,
					top: event.pageY
				};
			};
			const calculatePosition = (bodyPosition, scrollPosition, mousePosition) => ({
				pageX: mousePosition.left - bodyPosition.left + scrollPosition.left,
				pageY: mousePosition.top - bodyPosition.top + scrollPosition.top
			});
			const calc = (editor, event) => calculatePosition(getBodyPosition(editor), getScrollPosition(editor), getMousePosition(editor, event));
			const getTargetProps = (target) => ({
				target,
				srcElement: target
			});
			const makeDndEventFromMouseEvent = (type$2, mouseEvent, target, dataTransfer) => ({
				...mouseEvent,
				dataTransfer,
				type: type$2,
				...getTargetProps(target)
			});
			const makeDndEvent = (type$2, target, dataTransfer) => {
				const fail = die("Function not supported on simulated event.");
				return {
					bubbles: true,
					cancelBubble: false,
					cancelable: true,
					composed: false,
					currentTarget: null,
					defaultPrevented: false,
					eventPhase: 0,
					isTrusted: true,
					returnValue: false,
					timeStamp: 0,
					type: type$2,
					composedPath: fail,
					initEvent: fail,
					preventDefault: noop,
					stopImmediatePropagation: noop,
					stopPropagation: noop,
					AT_TARGET: window.Event.AT_TARGET,
					BUBBLING_PHASE: window.Event.BUBBLING_PHASE,
					CAPTURING_PHASE: window.Event.CAPTURING_PHASE,
					NONE: window.Event.NONE,
					altKey: false,
					button: 0,
					buttons: 0,
					clientX: 0,
					clientY: 0,
					ctrlKey: false,
					metaKey: false,
					movementX: 0,
					movementY: 0,
					offsetX: 0,
					offsetY: 0,
					pageX: 0,
					pageY: 0,
					relatedTarget: null,
					screenX: 0,
					screenY: 0,
					shiftKey: false,
					x: 0,
					y: 0,
					detail: 0,
					view: null,
					which: 0,
					initUIEvent: fail,
					initMouseEvent: fail,
					getModifierState: fail,
					dataTransfer,
					...getTargetProps(target)
				};
			};
			const makeDataTransferCopyForDragEvent = (dataTransfer, eventType) => {
				const copy$1 = cloneDataTransfer(dataTransfer);
				if (eventType === "dragstart") {
					setDragstartEvent(copy$1);
					setReadWriteMode(copy$1);
				} else if (eventType === "drop") {
					setDropEvent(copy$1);
					setReadOnlyMode(copy$1);
				} else {
					setDragendEvent(copy$1);
					setProtectedMode(copy$1);
				}
				return copy$1;
			};
			const makeDragEvent = (type$2, target, dataTransfer, mouseEvent) => {
				const dataTransferForDispatch = makeDataTransferCopyForDragEvent(dataTransfer, type$2);
				return isUndefined(mouseEvent) ? makeDndEvent(type$2, target, dataTransferForDispatch) : makeDndEventFromMouseEvent(type$2, mouseEvent, target, dataTransferForDispatch);
			};
			const scrollPixelsPerInterval = 32;
			const scrollIntervalValue = 100;
			const mouseRangeToTriggerScrollInsideEditor = 8;
			const mouseRangeToTriggerScrollOutsideEditor = 16;
			const isContentEditableFalse$1 = isContentEditableFalse$b;
			const isContentEditable = or(isContentEditableFalse$1, isContentEditableTrue$3);
			const isDraggable = (dom$1, rootElm, elm) => isContentEditableFalse$1(elm) && elm !== rootElm && dom$1.isEditable(elm.parentElement);
			const isValidDropTarget = (editor, targetElement, dragElement) => {
				if (isNullable(targetElement)) return false;
				else if (targetElement === dragElement || editor.dom.isChildOf(targetElement, dragElement)) return false;
				else return editor.dom.isEditable(targetElement);
			};
			const createGhost = (editor, elm, width, height) => {
				const dom$1 = editor.dom;
				const clonedElm = elm.cloneNode(true);
				dom$1.setStyles(clonedElm, {
					width,
					height
				});
				dom$1.setAttrib(clonedElm, "data-mce-selected", null);
				const ghostElm = dom$1.create("div", {
					"class": "mce-drag-container",
					"data-mce-bogus": "all",
					"unselectable": "on",
					"contenteditable": "false"
				});
				dom$1.setStyles(ghostElm, {
					position: "absolute",
					opacity: .5,
					overflow: "hidden",
					border: 0,
					padding: 0,
					margin: 0,
					width,
					height
				});
				dom$1.setStyles(clonedElm, {
					margin: 0,
					boxSizing: "border-box"
				});
				ghostElm.appendChild(clonedElm);
				return ghostElm;
			};
			const appendGhostToBody = (ghostElm, bodyElm) => {
				if (ghostElm.parentNode !== bodyElm) bodyElm.appendChild(ghostElm);
			};
			const scrollEditor = (direction, amount) => (win) => () => {
				const current = direction === "left" ? win.scrollX : win.scrollY;
				win.scroll({
					[direction]: current + amount,
					behavior: "smooth"
				});
			};
			const scrollLeft = scrollEditor("left", -scrollPixelsPerInterval);
			const scrollRight = scrollEditor("left", scrollPixelsPerInterval);
			const scrollUp = scrollEditor("top", -scrollPixelsPerInterval);
			const scrollDown = scrollEditor("top", scrollPixelsPerInterval);
			const moveGhost = (ghostElm, position, width, height, maxX, maxY, mouseY, mouseX, contentAreaContainer, win, state, mouseEventOriginatedFromWithinTheEditor) => {
				let overflowX = 0, overflowY = 0;
				ghostElm.style.left = position.pageX + "px";
				ghostElm.style.top = position.pageY + "px";
				if (position.pageX + width > maxX) overflowX = position.pageX + width - maxX;
				if (position.pageY + height > maxY) overflowY = position.pageY + height - maxY;
				ghostElm.style.width = width - overflowX + "px";
				ghostElm.style.height = height - overflowY + "px";
				const clientHeight = contentAreaContainer.clientHeight;
				const clientWidth = contentAreaContainer.clientWidth;
				const outerMouseY = mouseY + contentAreaContainer.getBoundingClientRect().top;
				const outerMouseX = mouseX + contentAreaContainer.getBoundingClientRect().left;
				state.on((state$1) => {
					state$1.intervalId.clear();
					if (state$1.dragging && mouseEventOriginatedFromWithinTheEditor) {
						if (mouseY + mouseRangeToTriggerScrollInsideEditor >= clientHeight) state$1.intervalId.set(scrollDown(win));
						else if (mouseY - mouseRangeToTriggerScrollInsideEditor <= 0) state$1.intervalId.set(scrollUp(win));
						else if (mouseX + mouseRangeToTriggerScrollInsideEditor >= clientWidth) state$1.intervalId.set(scrollRight(win));
						else if (mouseX - mouseRangeToTriggerScrollInsideEditor <= 0) state$1.intervalId.set(scrollLeft(win));
						else if (outerMouseY + mouseRangeToTriggerScrollOutsideEditor >= window.innerHeight) state$1.intervalId.set(scrollDown(window));
						else if (outerMouseY - mouseRangeToTriggerScrollOutsideEditor <= 0) state$1.intervalId.set(scrollUp(window));
						else if (outerMouseX + mouseRangeToTriggerScrollOutsideEditor >= window.innerWidth) state$1.intervalId.set(scrollRight(window));
						else if (outerMouseX - mouseRangeToTriggerScrollOutsideEditor <= 0) state$1.intervalId.set(scrollLeft(window));
					}
				});
			};
			const removeElement = (elm) => {
				if (elm && elm.parentNode) elm.parentNode.removeChild(elm);
			};
			const removeElementWithPadding = (dom$1, elm) => {
				const parentBlock = dom$1.getParent(elm.parentNode, dom$1.isBlock);
				removeElement(elm);
				if (parentBlock && parentBlock !== dom$1.getRoot() && dom$1.isEmpty(parentBlock)) fillWithPaddingBr(SugarElement.fromDom(parentBlock));
			};
			const isLeftMouseButtonPressed = (e) => e.button === 0;
			const applyRelPos = (state, position) => ({
				pageX: position.pageX - state.relX,
				pageY: position.pageY + 5
			});
			const start = (state, editor) => (e) => {
				if (isLeftMouseButtonPressed(e)) {
					const ceElm = find$2(editor.dom.getParents(e.target), isContentEditable).getOr(null);
					if (isNonNullable(ceElm) && isDraggable(editor.dom, editor.getBody(), ceElm)) {
						const elmPos = editor.dom.getPos(ceElm);
						const bodyElm = editor.getBody();
						const docElm = editor.getDoc().documentElement;
						state.set({
							element: ceElm,
							dataTransfer: createDataTransfer(),
							dragging: false,
							screenX: e.screenX,
							screenY: e.screenY,
							maxX: (editor.inline ? bodyElm.scrollWidth : docElm.offsetWidth) - 2,
							maxY: (editor.inline ? bodyElm.scrollHeight : docElm.offsetHeight) - 2,
							relX: e.pageX - elmPos.x,
							relY: e.pageY - elmPos.y,
							width: ceElm.offsetWidth,
							height: ceElm.offsetHeight,
							ghost: createGhost(editor, ceElm, ceElm.offsetWidth, ceElm.offsetHeight),
							intervalId: repeatable(scrollIntervalValue)
						});
					}
				}
			};
			const placeCaretAt = (editor, clientX, clientY) => {
				editor._selectionOverrides.hideFakeCaret();
				closestFakeCaretCandidate(editor.getBody(), clientX, clientY).fold(() => editor.selection.placeCaretAt(clientX, clientY), (caretInfo) => {
					const range = editor._selectionOverrides.showCaret(1, caretInfo.node, caretInfo.position === FakeCaretPosition.Before, false);
					if (range) editor.selection.setRng(range);
					else editor.selection.placeCaretAt(clientX, clientY);
				});
			};
			const dispatchDragEvent = (editor, type$2, target, dataTransfer, mouseEvent) => {
				if (type$2 === "dragstart") setHtmlData(dataTransfer, editor.dom.getOuterHTML(target));
				const event = makeDragEvent(type$2, target, dataTransfer, mouseEvent);
				return editor.dispatch(type$2, event);
			};
			const move = (state, editor) => {
				const throttledPlaceCaretAt = first$1((clientX, clientY) => placeCaretAt(editor, clientX, clientY), 0);
				editor.on("remove", throttledPlaceCaretAt.cancel);
				const state_ = state;
				return (e) => state.on((state$1) => {
					const movement = Math.max(Math.abs(e.screenX - state$1.screenX), Math.abs(e.screenY - state$1.screenY));
					if (!state$1.dragging && movement > 10) {
						const args = dispatchDragEvent(editor, "dragstart", state$1.element, state$1.dataTransfer, e);
						if (isNonNullable(args.dataTransfer)) state$1.dataTransfer = args.dataTransfer;
						if (args.isDefaultPrevented()) return;
						state$1.dragging = true;
						editor.focus();
					}
					if (state$1.dragging) {
						const mouseEventOriginatedFromWithinTheEditor = e.currentTarget === editor.getDoc().documentElement;
						const targetPos = applyRelPos(state$1, calc(editor, e));
						appendGhostToBody(state$1.ghost, editor.getBody());
						moveGhost(state$1.ghost, targetPos, state$1.width, state$1.height, state$1.maxX, state$1.maxY, e.clientY, e.clientX, editor.getContentAreaContainer(), editor.getWin(), state_, mouseEventOriginatedFromWithinTheEditor);
						throttledPlaceCaretAt.throttle(e.clientX, e.clientY);
					}
				});
			};
			const getRawTarget = (selection) => {
				const sel = selection.getSel();
				if (isNonNullable(sel)) {
					const startContainer = sel.getRangeAt(0).startContainer;
					return isText$a(startContainer) ? startContainer.parentNode : startContainer;
				} else return null;
			};
			const drop = (state, editor) => (e) => {
				state.on((state$1) => {
					var _a;
					state$1.intervalId.clear();
					if (state$1.dragging) {
						if (isValidDropTarget(editor, getRawTarget(editor.selection), state$1.element)) {
							if (!dispatchDragEvent(editor, "drop", (_a = editor.getDoc().elementFromPoint(e.clientX, e.clientY)) !== null && _a !== void 0 ? _a : editor.getBody(), state$1.dataTransfer, e).isDefaultPrevented()) editor.undoManager.transact(() => {
								removeElementWithPadding(editor.dom, state$1.element);
								getHtmlData(state$1.dataTransfer).each((content) => editor.insertContent(content));
								editor._selectionOverrides.hideFakeCaret();
							});
						}
						dispatchDragEvent(editor, "dragend", editor.getBody(), state$1.dataTransfer, e);
					}
				});
				removeDragState(state);
			};
			const stopDragging = (state, editor, e) => {
				state.on((state$1) => {
					state$1.intervalId.clear();
					if (state$1.dragging) e.fold(() => dispatchDragEvent(editor, "dragend", state$1.element, state$1.dataTransfer), (mouseEvent) => dispatchDragEvent(editor, "dragend", state$1.element, state$1.dataTransfer, mouseEvent));
				});
				removeDragState(state);
			};
			const stop = (state, editor) => (e) => stopDragging(state, editor, Optional.some(e));
			const removeDragState = (state) => {
				state.on((state$1) => {
					state$1.intervalId.clear();
					removeElement(state$1.ghost);
				});
				state.clear();
			};
			const bindFakeDragEvents = (editor) => {
				const state = value$2();
				const pageDom = DOMUtils.DOM;
				const rootDocument = document;
				const dragStartHandler = start(state, editor);
				const dragHandler = move(state, editor);
				const dropHandler = drop(state, editor);
				const dragEndHandler = stop(state, editor);
				editor.on("mousedown", dragStartHandler);
				editor.on("mousemove", dragHandler);
				editor.on("mouseup", dropHandler);
				pageDom.bind(rootDocument, "mousemove", dragHandler);
				pageDom.bind(rootDocument, "mouseup", dragEndHandler);
				editor.on("remove", () => {
					pageDom.unbind(rootDocument, "mousemove", dragHandler);
					pageDom.unbind(rootDocument, "mouseup", dragEndHandler);
				});
				editor.on("keydown", (e) => {
					if (e.keyCode === VK.ESC) stopDragging(state, editor, Optional.none());
				});
			};
			const blockUnsupportedFileDrop = (editor) => {
				const preventFileDrop = (e) => {
					if (!e.isDefaultPrevented()) {
						const dataTransfer = e.dataTransfer;
						if (dataTransfer && (contains$2(dataTransfer.types, "Files") || dataTransfer.files.length > 0)) {
							e.preventDefault();
							if (e.type === "drop") displayError(editor, "Dropped file type is not supported");
						}
					}
				};
				const preventFileDropIfUIElement = (e) => {
					if (isUIElement(editor, e.target)) preventFileDrop(e);
				};
				const setup$10 = () => {
					const pageDom = DOMUtils.DOM;
					const dom$1 = editor.dom;
					const doc = document;
					const editorRoot = editor.inline ? editor.getBody() : editor.getDoc();
					const eventNames = ["drop", "dragover"];
					each$e(eventNames, (name$1) => {
						pageDom.bind(doc, name$1, preventFileDropIfUIElement);
						dom$1.bind(editorRoot, name$1, preventFileDrop);
					});
					editor.on("remove", () => {
						each$e(eventNames, (name$1) => {
							pageDom.unbind(doc, name$1, preventFileDropIfUIElement);
							dom$1.unbind(editorRoot, name$1, preventFileDrop);
						});
					});
				};
				editor.on("init", () => {
					Delay.setEditorTimeout(editor, setup$10, 0);
				});
			};
			const init$2 = (editor) => {
				bindFakeDragEvents(editor);
				if (shouldBlockUnsupportedDrop(editor)) blockUnsupportedFileDrop(editor);
			};
			const setup$4 = (editor) => {
				const renderFocusCaret = first$1(() => {
					if (!editor.removed && editor.getBody().contains(document.activeElement)) {
						const rng = editor.selection.getRng();
						if (rng.collapsed) {
							const caretRange = renderRangeCaret(editor, rng, false);
							editor.selection.setRng(caretRange);
						}
					}
				}, 0);
				editor.on("focus", () => {
					renderFocusCaret.throttle();
				});
				editor.on("blur", () => {
					renderFocusCaret.cancel();
				});
			};
			const setup$3 = (editor) => {
				editor.on("init", () => {
					editor.on("focusin", (e) => {
						const target = e.target;
						if (isMedia$2(target)) {
							const ceRoot = getContentEditableRoot$1(editor.getBody(), target);
							const node = isContentEditableFalse$b(ceRoot) ? ceRoot : target;
							if (editor.selection.getNode() !== node) selectNode(editor, node).each((rng) => editor.selection.setRng(rng));
						}
					});
				});
			};
			const isContentEditableFalse = isContentEditableFalse$b;
			const getContentEditableRoot = (editor, node) => getContentEditableRoot$1(editor.getBody(), node);
			const SelectionOverrides = (editor) => {
				const selection = editor.selection, dom$1 = editor.dom;
				const rootNode = editor.getBody();
				const fakeCaret = FakeCaret(editor, rootNode, dom$1.isBlock, () => hasFocus(editor));
				const realSelectionId = "sel-" + dom$1.uniqueId();
				const elementSelectionAttr$1 = "data-mce-selected";
				let selectedElement;
				const isFakeSelectionElement = (node) => isNonNullable(node) && dom$1.hasClass(node, "mce-offscreen-selection");
				const isFakeSelectionTargetElement = (node) => node !== rootNode && (isContentEditableFalse(node) || isMedia$2(node)) && dom$1.isChildOf(node, rootNode) && dom$1.isEditable(node.parentNode);
				const setRange = (range) => {
					if (range) selection.setRng(range);
				};
				const showCaret$1 = (direction, node, before$1, scrollIntoView = true) => {
					if (editor.dispatch("ShowCaret", {
						target: node,
						direction,
						before: before$1
					}).isDefaultPrevented()) return null;
					if (scrollIntoView) selection.scrollIntoView(node, direction === -1);
					return fakeCaret.show(before$1, node);
				};
				const showBlockCaretContainer$1 = (blockCaretContainer) => {
					if (blockCaretContainer.hasAttribute("data-mce-caret")) {
						showCaretContainerBlock(blockCaretContainer);
						selection.scrollIntoView(blockCaretContainer);
					}
				};
				const registerEvents$2 = () => {
					editor.on("click", (e) => {
						if (!dom$1.isEditable(e.target)) {
							e.preventDefault();
							editor.focus();
						}
					});
					editor.on("blur NewBlock", removeElementSelection);
					editor.on("ResizeWindow FullscreenStateChanged", fakeCaret.reposition);
					editor.on("tap", (e) => {
						const targetElm = e.target;
						const contentEditableRoot = getContentEditableRoot(editor, targetElm);
						if (isContentEditableFalse(contentEditableRoot)) {
							e.preventDefault();
							selectNode(editor, contentEditableRoot).each(setElementSelection);
						} else if (isFakeSelectionTargetElement(targetElm)) selectNode(editor, targetElm).each(setElementSelection);
					}, true);
					editor.on("mousedown", (e) => {
						const targetElm = e.target;
						if (targetElm !== rootNode && targetElm.nodeName !== "HTML" && !dom$1.isChildOf(targetElm, rootNode)) return;
						if (!isXYInContentArea(editor, e.clientX, e.clientY)) return;
						removeElementSelection();
						hideFakeCaret();
						const closestContentEditable = getContentEditableRoot(editor, targetElm);
						if (isContentEditableFalse(closestContentEditable)) {
							e.preventDefault();
							selectNode(editor, closestContentEditable).each(setElementSelection);
						} else closestFakeCaretCandidate(rootNode, e.clientX, e.clientY).each((caretInfo) => {
							e.preventDefault();
							setRange(showCaret$1(1, caretInfo.node, caretInfo.position === FakeCaretPosition.Before, false));
							if (isElement$6(closestContentEditable)) closestContentEditable.focus();
							else editor.getBody().focus();
						});
					});
					editor.on("keypress", (e) => {
						if (VK.modifierPressed(e)) return;
						if (isContentEditableFalse(selection.getNode())) e.preventDefault();
					});
					editor.on("GetSelectionRange", (e) => {
						let rng = e.range;
						if (selectedElement) {
							if (!selectedElement.parentNode) {
								selectedElement = null;
								return;
							}
							rng = rng.cloneRange();
							rng.selectNode(selectedElement);
							e.range = rng;
						}
					});
					editor.on("SetSelectionRange", (e) => {
						e.range = normalizeVoidElementSelection(e.range);
						const rng = setElementSelection(e.range, e.forward);
						if (rng) e.range = rng;
					});
					const isPasteBin$1 = (node) => isElement$6(node) && node.id === "mcepastebin";
					editor.on("AfterSetSelectionRange", (e) => {
						const rng = e.range;
						const parent$1 = rng.startContainer.parentElement;
						if (!isRangeInCaretContainer(rng) && !isPasteBin$1(parent$1)) hideFakeCaret();
						if (!isFakeSelectionElement(parent$1)) removeElementSelection();
					});
					init$2(editor);
					setup$4(editor);
					setup$3(editor);
				};
				const isWithinCaretContainer = (node) => isCaretContainer$2(node) || startsWithCaretContainer$1(node) || endsWithCaretContainer$1(node);
				const isRangeInCaretContainer = (rng) => isWithinCaretContainer(rng.startContainer) || isWithinCaretContainer(rng.endContainer);
				const normalizeVoidElementSelection = (rng) => {
					const voidElements = editor.schema.getVoidElements();
					const newRng = dom$1.createRng();
					const startContainer = rng.startContainer;
					const startOffset = rng.startOffset;
					const endContainer = rng.endContainer;
					const endOffset = rng.endOffset;
					if (has$2(voidElements, startContainer.nodeName.toLowerCase())) if (startOffset === 0) newRng.setStartBefore(startContainer);
					else newRng.setStartAfter(startContainer);
					else newRng.setStart(startContainer, startOffset);
					if (has$2(voidElements, endContainer.nodeName.toLowerCase())) if (endOffset === 0) newRng.setEndBefore(endContainer);
					else newRng.setEndAfter(endContainer);
					else newRng.setEnd(endContainer, endOffset);
					return newRng;
				};
				const setupOffscreenSelection = (node, targetClone) => {
					const body = SugarElement.fromDom(editor.getBody());
					const doc = editor.getDoc();
					const realSelectionContainer = descendant(body, "#" + realSelectionId).getOrThunk(() => {
						const newContainer = SugarElement.fromHtml("<div data-mce-bogus=\"all\" class=\"mce-offscreen-selection\"></div>", doc);
						set$3(newContainer, "id", realSelectionId);
						append$1(body, newContainer);
						return newContainer;
					});
					const newRange = dom$1.createRng();
					empty(realSelectionContainer);
					append(realSelectionContainer, [
						SugarElement.fromText(nbsp, doc),
						SugarElement.fromDom(targetClone),
						SugarElement.fromText(nbsp, doc)
					]);
					newRange.setStart(realSelectionContainer.dom.firstChild, 1);
					newRange.setEnd(realSelectionContainer.dom.lastChild, 0);
					setAll(realSelectionContainer, { top: dom$1.getPos(node, editor.getBody()).y + "px" });
					focus$1(realSelectionContainer);
					const sel = selection.getSel();
					if (sel) {
						sel.removeAllRanges();
						sel.addRange(newRange);
					}
					return newRange;
				};
				const selectElement = (elm) => {
					const targetClone = elm.cloneNode(true);
					const e = editor.dispatch("ObjectSelected", {
						target: elm,
						targetClone
					});
					if (e.isDefaultPrevented()) return null;
					const range = setupOffscreenSelection(elm, e.targetClone);
					const nodeElm = SugarElement.fromDom(elm);
					each$e(descendants(SugarElement.fromDom(editor.getBody()), `*[${elementSelectionAttr$1}]`), (elm$1) => {
						if (!eq(nodeElm, elm$1)) remove$a(elm$1, elementSelectionAttr$1);
					});
					if (!dom$1.getAttrib(elm, elementSelectionAttr$1)) elm.setAttribute(elementSelectionAttr$1, "1");
					selectedElement = elm;
					hideFakeCaret();
					return range;
				};
				const setElementSelection = (range, forward) => {
					if (!range) return null;
					if (range.collapsed) {
						if (!isRangeInCaretContainer(range)) {
							const dir = forward ? 1 : -1;
							const caretPosition = getNormalizedRangeEndPoint(dir, rootNode, range);
							const beforeNode = caretPosition.getNode(!forward);
							if (isNonNullable(beforeNode)) {
								if (isFakeCaretTarget(beforeNode)) return showCaret$1(dir, beforeNode, forward ? !caretPosition.isAtEnd() : false, false);
								if (isCaretContainerInline(beforeNode) && isContentEditableFalse$b(beforeNode.nextSibling)) {
									const rng = dom$1.createRng();
									rng.setStart(beforeNode, 0);
									rng.setEnd(beforeNode, 0);
									return rng;
								}
							}
							const afterNode = caretPosition.getNode(forward);
							if (isNonNullable(afterNode)) {
								if (isFakeCaretTarget(afterNode)) return showCaret$1(dir, afterNode, forward ? false : !caretPosition.isAtEnd(), false);
								if (isCaretContainerInline(afterNode) && isContentEditableFalse$b(afterNode.previousSibling)) {
									const rng = dom$1.createRng();
									rng.setStart(afterNode, 1);
									rng.setEnd(afterNode, 1);
									return rng;
								}
							}
						}
						return null;
					}
					let startContainer = range.startContainer;
					let startOffset = range.startOffset;
					const endOffset = range.endOffset;
					if (isText$a(startContainer) && startOffset === 0 && isContentEditableFalse(startContainer.parentNode)) {
						startContainer = startContainer.parentNode;
						startOffset = dom$1.nodeIndex(startContainer);
						startContainer = startContainer.parentNode;
					}
					if (!isElement$6(startContainer)) return null;
					if (endOffset === startOffset + 1 && startContainer === range.endContainer) {
						const node = startContainer.childNodes[startOffset];
						if (isFakeSelectionTargetElement(node)) return selectElement(node);
					}
					return null;
				};
				const removeElementSelection = () => {
					if (selectedElement) selectedElement.removeAttribute(elementSelectionAttr$1);
					descendant(SugarElement.fromDom(editor.getBody()), "#" + realSelectionId).each(remove$5);
					selectedElement = null;
				};
				const destroy$1 = () => {
					fakeCaret.destroy();
					selectedElement = null;
				};
				const hideFakeCaret = () => {
					fakeCaret.hide();
				};
				if (!isRtc(editor)) registerEvents$2();
				return {
					showCaret: showCaret$1,
					showBlockCaretContainer: showBlockCaretContainer$1,
					hideFakeCaret,
					destroy: destroy$1
				};
			};
			const getNormalizedTextOffset = (container, offset) => {
				let normalizedOffset = offset;
				for (let node = container.previousSibling; isText$a(node); node = node.previousSibling) normalizedOffset += node.data.length;
				return normalizedOffset;
			};
			const generatePath = (dom$1, root, node, offset, normalized) => {
				if (isText$a(node) && (offset < 0 || offset > node.data.length)) return [];
				const p = normalized && isText$a(node) ? [getNormalizedTextOffset(node, offset)] : [offset];
				let current = node;
				while (current !== root && current.parentNode) {
					p.push(dom$1.nodeIndex(current, normalized));
					current = current.parentNode;
				}
				return current === root ? p.reverse() : [];
			};
			const generatePathRange = (dom$1, root, startNode, startOffset, endNode, endOffset, normalized = false) => {
				return {
					start: generatePath(dom$1, root, startNode, startOffset, normalized),
					end: generatePath(dom$1, root, endNode, endOffset, normalized)
				};
			};
			const resolvePath = (root, path$1) => {
				const nodePath = path$1.slice();
				const offset = nodePath.pop();
				if (!isNumber(offset)) return Optional.none();
				else return foldl(nodePath, (optNode, index) => optNode.bind((node) => Optional.from(node.childNodes[index])), Optional.some(root)).bind((node) => {
					if (isText$a(node) && (offset < 0 || offset > node.data.length)) return Optional.none();
					else return Optional.some({
						node,
						offset
					});
				});
			};
			const resolvePathRange = (root, range) => resolvePath(root, range.start).bind(({ node: startNode, offset: startOffset }) => resolvePath(root, range.end).map(({ node: endNode, offset: endOffset }) => {
				const rng = document.createRange();
				rng.setStart(startNode, startOffset);
				rng.setEnd(endNode, endOffset);
				return rng;
			}));
			const generatePathRangeFromRange = (dom$1, root, range, normalized = false) => generatePathRange(dom$1, root, range.startContainer, range.startOffset, range.endContainer, range.endOffset, normalized);
			const cleanEmptyNodes = (dom$1, node, isRoot$2) => {
				if (node && dom$1.isEmpty(node) && !isRoot$2(node)) {
					const parent$1 = node.parentNode;
					dom$1.remove(node, isText$a(node.firstChild) && isWhitespaceText(node.firstChild.data));
					cleanEmptyNodes(dom$1, parent$1, isRoot$2);
				}
			};
			const deleteRng = (dom$1, rng, isRoot$2, clean = true) => {
				const startParent = rng.startContainer.parentNode;
				const endParent = rng.endContainer.parentNode;
				rng.deleteContents();
				if (clean && !isRoot$2(rng.startContainer)) {
					if (isText$a(rng.startContainer) && rng.startContainer.data.length === 0) dom$1.remove(rng.startContainer);
					if (isText$a(rng.endContainer) && rng.endContainer.data.length === 0) dom$1.remove(rng.endContainer);
					cleanEmptyNodes(dom$1, startParent, isRoot$2);
					if (startParent !== endParent) cleanEmptyNodes(dom$1, endParent, isRoot$2);
				}
			};
			const getParentBlock = (editor, rng) => Optional.from(editor.dom.getParent(rng.startContainer, editor.dom.isBlock));
			const resolveFromDynamicPatterns = (patternSet, block, beforeText) => {
				const dynamicPatterns = patternSet.dynamicPatternsLookup({
					text: beforeText,
					block
				});
				return {
					...patternSet,
					blockPatterns: getBlockPatterns(dynamicPatterns).concat(patternSet.blockPatterns),
					inlinePatterns: getInlinePatterns(dynamicPatterns).concat(patternSet.inlinePatterns)
				};
			};
			const getBeforeText = (dom$1, block, node, offset) => {
				const rng = dom$1.createRng();
				rng.setStart(block, 0);
				rng.setEnd(node, offset);
				return rng.toString();
			};
			const startsWithSingleSpace = (s) => /^\s[^\s]/.test(s);
			const stripPattern = (dom$1, block, pattern) => {
				textAfter(block, 0, block).each((spot) => {
					const node = spot.container;
					scanRight(node, pattern.start.length, block).each((end$1) => {
						const rng = dom$1.createRng();
						rng.setStart(node, 0);
						rng.setEnd(end$1.container, end$1.offset);
						deleteRng(dom$1, rng, (e) => e === block);
					});
					const text$1 = SugarElement.fromDom(node);
					const textContent = get$3(text$1);
					if (startsWithSingleSpace(textContent)) set(text$1, textContent.slice(1));
				});
			};
			const applyPattern$1 = (editor, match$3) => {
				const dom$1 = editor.dom;
				const pattern = match$3.pattern;
				const rng = resolvePathRange(dom$1.getRoot(), match$3.range).getOrDie("Unable to resolve path range");
				const isBlockFormatName = (name$1, formatter) => {
					const formatSet = formatter.get(name$1);
					return isArray$1(formatSet) && head(formatSet).exists((format) => has$2(format, "block"));
				};
				getParentBlock(editor, rng).each((block) => {
					if (pattern.type === "block-format") {
						if (isBlockFormatName(pattern.format, editor.formatter)) editor.undoManager.transact(() => {
							stripPattern(editor.dom, block, pattern);
							editor.formatter.apply(pattern.format);
						});
					} else if (pattern.type === "block-command") editor.undoManager.transact(() => {
						stripPattern(editor.dom, block, pattern);
						editor.execCommand(pattern.cmd, false, pattern.value);
					});
				});
				return true;
			};
			const sortPatterns$1 = (patterns) => sort(patterns, (a, b) => b.start.length - a.start.length);
			const findPattern$1 = (patterns, text$1) => {
				const sortedPatterns = sortPatterns$1(patterns);
				const nuText = text$1.replace(nbsp, " ");
				return find$2(sortedPatterns, (pattern) => text$1.indexOf(pattern.start) === 0 || nuText.indexOf(pattern.start) === 0);
			};
			const findPatterns$1 = (editor, block, patternSet, normalizedMatches) => {
				var _a;
				const dom$1 = editor.dom;
				const forcedRootBlock = getForcedRootBlock(editor);
				if (!dom$1.is(block, forcedRootBlock)) return [];
				const blockText = (_a = block.textContent) !== null && _a !== void 0 ? _a : "";
				return findPattern$1(patternSet.blockPatterns, blockText).map((pattern) => {
					if (Tools.trim(blockText).length === pattern.start.length) return [];
					return [{
						pattern,
						range: generatePathRange(dom$1, dom$1.getRoot(), block, 0, block, 0, normalizedMatches)
					}];
				}).getOr([]);
			};
			const applyMatches$1 = (editor, matches) => {
				if (matches.length === 0) return;
				const bookmark = editor.selection.getBookmark();
				each$e(matches, (match$3) => applyPattern$1(editor, match$3));
				editor.selection.moveToBookmark(bookmark);
			};
			const newMarker = (dom$1, id) => dom$1.create("span", {
				"data-mce-type": "bookmark",
				id
			});
			const rangeFromMarker = (dom$1, marker) => {
				const rng = dom$1.createRng();
				rng.setStartAfter(marker.start);
				rng.setEndBefore(marker.end);
				return rng;
			};
			const createMarker = (dom$1, markerPrefix, pathRange) => {
				const rng = resolvePathRange(dom$1.getRoot(), pathRange).getOrDie("Unable to resolve path range");
				const startNode = rng.startContainer;
				const endNode = rng.endContainer;
				const textEnd = rng.endOffset === 0 ? endNode : endNode.splitText(rng.endOffset);
				const textStart = rng.startOffset === 0 ? startNode : startNode.splitText(rng.startOffset);
				const startParentNode = textStart.parentNode;
				return {
					prefix: markerPrefix,
					end: textEnd.parentNode.insertBefore(newMarker(dom$1, markerPrefix + "-end"), textEnd),
					start: startParentNode.insertBefore(newMarker(dom$1, markerPrefix + "-start"), textStart)
				};
			};
			const removeMarker = (dom$1, marker, isRoot$2) => {
				cleanEmptyNodes(dom$1, dom$1.get(marker.prefix + "-end"), isRoot$2);
				cleanEmptyNodes(dom$1, dom$1.get(marker.prefix + "-start"), isRoot$2);
			};
			const isReplacementPattern = (pattern) => pattern.start.length === 0;
			const matchesPattern = (patternContent) => (element, offset) => {
				const searchText = element.data.substring(0, offset);
				const startEndIndex = searchText.lastIndexOf(patternContent.charAt(patternContent.length - 1));
				const startIndex = searchText.lastIndexOf(patternContent);
				if (startIndex !== -1) return startIndex + patternContent.length;
				else if (startEndIndex !== -1) return startEndIndex + 1;
				else return -1;
			};
			const findPatternStartFromSpot = (dom$1, pattern, block, spot) => {
				const startPattern = pattern.start;
				return repeatLeft(dom$1, spot.container, spot.offset, matchesPattern(startPattern), block).bind((spot$1) => {
					var _a, _b;
					const startPatternIndex = (_b = (_a = block.textContent) === null || _a === void 0 ? void 0 : _a.indexOf(startPattern)) !== null && _b !== void 0 ? _b : -1;
					if (startPatternIndex !== -1 && spot$1.offset >= startPatternIndex + startPattern.length) {
						const rng = dom$1.createRng();
						rng.setStart(spot$1.container, spot$1.offset - startPattern.length);
						rng.setEnd(spot$1.container, spot$1.offset);
						return Optional.some(rng);
					} else {
						const offset = spot$1.offset - startPattern.length;
						return scanLeft(spot$1.container, offset, block).map((nextSpot) => {
							const rng = dom$1.createRng();
							rng.setStart(nextSpot.container, nextSpot.offset);
							rng.setEnd(spot$1.container, spot$1.offset);
							return rng;
						}).filter((rng) => rng.toString() === startPattern).orThunk(() => findPatternStartFromSpot(dom$1, pattern, block, point(spot$1.container, 0)));
					}
				});
			};
			const findPatternStart = (dom$1, pattern, node, offset, block, requireGap = false) => {
				if (pattern.start.length === 0 && !requireGap) {
					const rng = dom$1.createRng();
					rng.setStart(node, offset);
					rng.setEnd(node, offset);
					return Optional.some(rng);
				}
				return textBefore(node, offset, block).bind((spot) => {
					return findPatternStartFromSpot(dom$1, pattern, block, spot).bind((startRange) => {
						var _a;
						if (requireGap) {
							if (startRange.endContainer === spot.container && startRange.endOffset === spot.offset) return Optional.none();
							else if (spot.offset === 0 && ((_a = startRange.endContainer.textContent) === null || _a === void 0 ? void 0 : _a.length) === startRange.endOffset) return Optional.none();
						}
						return Optional.some(startRange);
					});
				});
			};
			const findPattern = (editor, block, details, normalizedMatches) => {
				const dom$1 = editor.dom;
				const root = dom$1.getRoot();
				const pattern = details.pattern;
				const endNode = details.position.container;
				const endOffset = details.position.offset;
				return scanLeft(endNode, endOffset - details.pattern.end.length, block).bind((spot) => {
					const endPathRng = generatePathRange(dom$1, root, spot.container, spot.offset, endNode, endOffset, normalizedMatches);
					if (isReplacementPattern(pattern)) return Optional.some({
						matches: [{
							pattern,
							startRng: endPathRng,
							endRng: endPathRng
						}],
						position: spot
					});
					else {
						const resultsOpt = findPatternsRec(editor, details.remainingPatterns, spot.container, spot.offset, block, normalizedMatches);
						const results = resultsOpt.getOr({
							matches: [],
							position: spot
						});
						const pos = results.position;
						return findPatternStart(dom$1, pattern, pos.container, pos.offset, block, resultsOpt.isNone()).map((startRng) => {
							const startPathRng = generatePathRangeFromRange(dom$1, root, startRng, normalizedMatches);
							return {
								matches: results.matches.concat([{
									pattern,
									startRng: startPathRng,
									endRng: endPathRng
								}]),
								position: point(startRng.startContainer, startRng.startOffset)
							};
						});
					}
				});
			};
			const findPatternsRec = (editor, patterns, node, offset, block, normalizedMatches) => {
				const dom$1 = editor.dom;
				return textBefore(node, offset, dom$1.getRoot()).bind((endSpot) => {
					const text$1 = getBeforeText(dom$1, block, node, offset);
					for (let i = 0; i < patterns.length; i++) {
						const pattern = patterns[i];
						if (!endsWith(text$1, pattern.end)) continue;
						const patternsWithoutCurrent = patterns.slice();
						patternsWithoutCurrent.splice(i, 1);
						const result = findPattern(editor, block, {
							pattern,
							remainingPatterns: patternsWithoutCurrent,
							position: endSpot
						}, normalizedMatches);
						if (result.isNone() && offset > 0) return findPatternsRec(editor, patterns, node, offset - 1, block, normalizedMatches);
						if (result.isSome()) return result;
					}
					return Optional.none();
				});
			};
			const applyPattern = (editor, pattern, patternRange) => {
				editor.selection.setRng(patternRange);
				if (pattern.type === "inline-format") each$e(pattern.format, (format) => {
					editor.formatter.apply(format);
				});
				else editor.execCommand(pattern.cmd, false, pattern.value);
			};
			const applyReplacementPattern = (editor, pattern, marker, isRoot$2) => {
				const markerRange = rangeFromMarker(editor.dom, marker);
				deleteRng(editor.dom, markerRange, isRoot$2);
				applyPattern(editor, pattern, markerRange);
			};
			const applyPatternWithContent = (editor, pattern, startMarker, endMarker, isRoot$2) => {
				const dom$1 = editor.dom;
				const markerEndRange = rangeFromMarker(dom$1, endMarker);
				deleteRng(dom$1, rangeFromMarker(dom$1, startMarker), isRoot$2);
				deleteRng(dom$1, markerEndRange, isRoot$2);
				applyPattern(editor, pattern, rangeFromMarker(dom$1, {
					prefix: startMarker.prefix,
					start: startMarker.end,
					end: endMarker.start
				}));
			};
			const addMarkers = (dom$1, matches) => {
				const markerPrefix = generate$1("mce_textpattern");
				const matchesWithEnds = foldr(matches, (acc, match$3) => {
					const endMarker = createMarker(dom$1, markerPrefix + `_end${acc.length}`, match$3.endRng);
					return acc.concat([{
						...match$3,
						endMarker
					}]);
				}, []);
				return foldr(matchesWithEnds, (acc, match$3) => {
					const idx = matchesWithEnds.length - acc.length - 1;
					const startMarker = isReplacementPattern(match$3.pattern) ? match$3.endMarker : createMarker(dom$1, markerPrefix + `_start${idx}`, match$3.startRng);
					return acc.concat([{
						...match$3,
						startMarker
					}]);
				}, []);
			};
			const sortPatterns = (patterns) => sort(patterns, (a, b) => b.end.length - a.end.length);
			const getBestMatches = (matches, matchesWithSortedPatterns) => {
				const hasSameMatches = forall(matches, (match$3) => exists(matchesWithSortedPatterns, (sortedMatch) => match$3.pattern.start === sortedMatch.pattern.start && match$3.pattern.end === sortedMatch.pattern.end));
				if (matches.length === matchesWithSortedPatterns.length) if (hasSameMatches) return matches;
				else return matchesWithSortedPatterns;
				return matches.length > matchesWithSortedPatterns.length ? matches : matchesWithSortedPatterns;
			};
			const findPatterns = (editor, block, node, offset, patternSet, normalizedMatches) => {
				return getBestMatches(findPatternsRec(editor, patternSet.inlinePatterns, node, offset, block, normalizedMatches).fold(() => [], (result) => result.matches), findPatternsRec(editor, sortPatterns(patternSet.inlinePatterns), node, offset, block, normalizedMatches).fold(() => [], (result) => result.matches));
			};
			const applyMatches = (editor, matches) => {
				if (matches.length === 0) return;
				const dom$1 = editor.dom;
				const bookmark = editor.selection.getBookmark();
				each$e(addMarkers(dom$1, matches), (match$3) => {
					const block = dom$1.getParent(match$3.startMarker.start, dom$1.isBlock);
					const isRoot$2 = (node) => node === block;
					if (isReplacementPattern(match$3.pattern)) applyReplacementPattern(editor, match$3.pattern, match$3.endMarker, isRoot$2);
					else applyPatternWithContent(editor, match$3.pattern, match$3.startMarker, match$3.endMarker, isRoot$2);
					removeMarker(dom$1, match$3.endMarker, isRoot$2);
					removeMarker(dom$1, match$3.startMarker, isRoot$2);
				});
				editor.selection.moveToBookmark(bookmark);
			};
			const handleEnter = (editor, patternSet) => {
				const rng = editor.selection.getRng();
				return getParentBlock(editor, rng).map((block) => {
					var _a;
					const offset = Math.max(0, rng.startOffset);
					const dynamicPatternSet = resolveFromDynamicPatterns(patternSet, block, (_a = block.textContent) !== null && _a !== void 0 ? _a : "");
					const inlineMatches = findPatterns(editor, block, rng.startContainer, offset, dynamicPatternSet, true);
					const blockMatches = findPatterns$1(editor, block, dynamicPatternSet, true);
					if (blockMatches.length > 0 || inlineMatches.length > 0) {
						editor.undoManager.add();
						editor.undoManager.extra(() => {
							editor.execCommand("mceInsertNewLine");
						}, () => {
							editor.insertContent(zeroWidth);
							applyMatches(editor, inlineMatches);
							applyMatches$1(editor, blockMatches);
							const range = editor.selection.getRng();
							const spot = textBefore(range.startContainer, range.startOffset, editor.dom.getRoot());
							editor.execCommand("mceInsertNewLine");
							spot.each((s) => {
								const node = s.container;
								if (node.data.charAt(s.offset - 1) === zeroWidth) {
									node.deleteData(s.offset - 1, 1);
									cleanEmptyNodes(editor.dom, node.parentNode, (e) => e === editor.dom.getRoot());
								}
							});
						});
						return true;
					}
					return false;
				}).getOr(false);
			};
			const handleInlineKey = (editor, patternSet) => {
				const rng = editor.selection.getRng();
				getParentBlock(editor, rng).map((block) => {
					const offset = Math.max(0, rng.startOffset - 1);
					const dynamicPatternSet = resolveFromDynamicPatterns(patternSet, block, getBeforeText(editor.dom, block, rng.startContainer, offset));
					const inlineMatches = findPatterns(editor, block, rng.startContainer, offset, dynamicPatternSet, false);
					if (inlineMatches.length > 0) editor.undoManager.transact(() => {
						applyMatches(editor, inlineMatches);
					});
				});
			};
			const checkKeyEvent = (codes, event, predicate) => {
				for (let i = 0; i < codes.length; i++) if (predicate(codes[i], event)) return true;
				return false;
			};
			const checkKeyCode = (codes, event) => checkKeyEvent(codes, event, (code, event$1) => {
				return code === event$1.keyCode && !VK.modifierPressed(event$1);
			});
			const checkCharCode = (chars, event) => checkKeyEvent(chars, event, (chr, event$1) => {
				return chr.charCodeAt(0) === event$1.charCode;
			});
			const setup$2 = (editor) => {
				const charCodes = [
					",",
					".",
					";",
					":",
					"!",
					"?"
				];
				const keyCodes = [32];
				const getPatternSet = () => createPatternSet(getTextPatterns(editor), getTextPatternsLookup(editor));
				const hasDynamicPatterns = () => hasTextPatternsLookup(editor);
				editor.on("keydown", (e) => {
					if (e.keyCode === 13 && !VK.modifierPressed(e) && editor.selection.isCollapsed()) {
						const patternSet = getPatternSet();
						if ((patternSet.inlinePatterns.length > 0 || patternSet.blockPatterns.length > 0 || hasDynamicPatterns()) && handleEnter(editor, patternSet)) e.preventDefault();
					}
				}, true);
				const handleInlineTrigger = () => {
					if (editor.selection.isCollapsed()) {
						const patternSet = getPatternSet();
						if (patternSet.inlinePatterns.length > 0 || hasDynamicPatterns()) handleInlineKey(editor, patternSet);
					}
				};
				editor.on("keyup", (e) => {
					if (checkKeyCode(keyCodes, e)) handleInlineTrigger();
				});
				editor.on("keypress", (e) => {
					if (checkCharCode(charCodes, e)) Delay.setEditorTimeout(editor, handleInlineTrigger);
				});
			};
			const setup$1 = (editor) => {
				setup$2(editor);
			};
			const Quirks = (editor) => {
				const each$10 = Tools.each;
				const BACKSPACE = VK.BACKSPACE, DELETE$1 = VK.DELETE, dom$1 = editor.dom, selection = editor.selection, parser = editor.parser;
				const browser = Env.browser;
				const isGecko = browser.isFirefox();
				const isWebKit = browser.isChromium() || browser.isSafari();
				const isiOS = Env.deviceType.isiPhone() || Env.deviceType.isiPad();
				const isMac = Env.os.isMacOS() || Env.os.isiOS();
				const setEditorCommandState$1 = (cmd, state) => {
					try {
						editor.getDoc().execCommand(cmd, false, String(state));
					} catch (ex) {}
				};
				const isDefaultPrevented = (e) => {
					return e.isDefaultPrevented();
				};
				const emptyEditorWhenDeleting = () => {
					const serializeRng = (rng) => {
						const body = dom$1.create("body");
						const contents = rng.cloneContents();
						body.appendChild(contents);
						return selection.serializer.serialize(body, { format: "html" });
					};
					const allContentsSelected = (rng) => {
						const selection$1 = serializeRng(rng);
						const allRng = dom$1.createRng();
						allRng.selectNode(editor.getBody());
						return selection$1 === serializeRng(allRng);
					};
					const hasPreservedEmptyElements = (elm) => {
						const scope = SugarElement.fromDom(elm);
						const isEditableHost = (elm$1) => parentElement(elm$1).exists((elm$2) => !isEditable$3(elm$2));
						return exists(descendants(scope, "[contenteditable=\"true\"]"), isEditableHost);
					};
					editor.on("keydown", (e) => {
						const keyCode = e.keyCode;
						if (!isDefaultPrevented(e) && (keyCode === DELETE$1 || keyCode === BACKSPACE) && editor.selection.isEditable()) {
							const isCollapsed = editor.selection.isCollapsed();
							const body = editor.getBody();
							if (isCollapsed && (!dom$1.isEmpty(body) || hasPreservedEmptyElements(body))) return;
							if (!isCollapsed && !allContentsSelected(editor.selection.getRng())) return;
							e.preventDefault();
							editor.setContent("");
							if (body.firstChild && dom$1.isBlock(body.firstChild)) editor.selection.setCursorLocation(body.firstChild, 0);
							else editor.selection.setCursorLocation(body, 0);
							editor.nodeChanged();
						}
					});
				};
				const selectAll = () => {
					editor.shortcuts.add("meta+a", null, "SelectAll");
				};
				const documentElementEditingFocus = () => {
					if (!editor.inline) dom$1.bind(editor.getDoc(), "mousedown mouseup", (e) => {
						let rng;
						if (e.target === editor.getDoc().documentElement) {
							rng = selection.getRng();
							editor.getBody().focus();
							if (e.type === "mousedown") {
								if (isCaretContainer$2(rng.startContainer)) return;
								selection.placeCaretAt(e.clientX, e.clientY);
							} else selection.setRng(rng);
						}
					});
				};
				const removeHrOnBackspace = () => {
					editor.on("keydown", (e) => {
						if (!isDefaultPrevented(e) && e.keyCode === BACKSPACE) {
							if (!editor.getBody().getElementsByTagName("hr").length) return;
							if (selection.isCollapsed() && selection.getRng().startOffset === 0) {
								const node = selection.getNode();
								const previousSibling = node.previousSibling;
								if (node.nodeName === "HR") {
									dom$1.remove(node);
									e.preventDefault();
									return;
								}
								if (previousSibling && previousSibling.nodeName && previousSibling.nodeName.toLowerCase() === "hr") {
									dom$1.remove(previousSibling);
									e.preventDefault();
								}
							}
						}
					});
				};
				const focusBody$1 = () => {
					if (!Range.prototype.getClientRects) editor.on("mousedown", (e) => {
						if (!isDefaultPrevented(e) && e.target.nodeName === "HTML") {
							const body = editor.getBody();
							body.blur();
							Delay.setEditorTimeout(editor, () => {
								body.focus();
							});
						}
					});
				};
				const selectControlElements = () => {
					const visualAidsAnchorClass = getVisualAidsAnchorClass(editor);
					editor.on("click", (e) => {
						const target = e.target;
						if (/^(IMG|HR)$/.test(target.nodeName) && dom$1.isEditable(target.parentNode)) {
							e.preventDefault();
							editor.selection.select(target);
							editor.nodeChanged();
						}
						if (target.nodeName === "A" && dom$1.hasClass(target, visualAidsAnchorClass) && target.childNodes.length === 0 && dom$1.isEditable(target.parentNode)) {
							e.preventDefault();
							selection.select(target);
						}
					});
				};
				const removeStylesWhenDeletingAcrossBlockElements = () => {
					const getAttributeApplyFunction = () => {
						const template = dom$1.getAttribs(selection.getStart().cloneNode(false));
						return () => {
							const target = selection.getStart();
							if (target !== editor.getBody()) {
								dom$1.setAttrib(target, "style", null);
								each$10(template, (attr) => {
									target.setAttributeNode(attr.cloneNode(true));
								});
							}
						};
					};
					const isSelectionAcrossElements = () => {
						return !selection.isCollapsed() && dom$1.getParent(selection.getStart(), dom$1.isBlock) !== dom$1.getParent(selection.getEnd(), dom$1.isBlock);
					};
					editor.on("keypress", (e) => {
						let applyAttributes$1;
						if (!isDefaultPrevented(e) && (e.keyCode === 8 || e.keyCode === 46) && isSelectionAcrossElements()) {
							applyAttributes$1 = getAttributeApplyFunction();
							editor.getDoc().execCommand("delete", false);
							applyAttributes$1();
							e.preventDefault();
							return false;
						} else return true;
					});
					dom$1.bind(editor.getDoc(), "cut", (e) => {
						if (!isDefaultPrevented(e) && isSelectionAcrossElements()) {
							const applyAttributes$1 = getAttributeApplyFunction();
							Delay.setEditorTimeout(editor, () => {
								applyAttributes$1();
							});
						}
					});
				};
				const disableBackspaceIntoATable = () => {
					editor.on("keydown", (e) => {
						if (!isDefaultPrevented(e) && e.keyCode === BACKSPACE) {
							if (selection.isCollapsed() && selection.getRng().startOffset === 0) {
								const previousSibling = selection.getNode().previousSibling;
								if (previousSibling && previousSibling.nodeName && previousSibling.nodeName.toLowerCase() === "table") {
									e.preventDefault();
									return false;
								}
							}
						}
						return true;
					});
				};
				const removeBlockQuoteOnBackSpace = () => {
					editor.on("keydown", (e) => {
						if (isDefaultPrevented(e) || e.keyCode !== VK.BACKSPACE) return;
						let rng = selection.getRng();
						const container = rng.startContainer;
						const offset = rng.startOffset;
						const root = dom$1.getRoot();
						let parent$1 = container;
						if (!rng.collapsed || offset !== 0) return;
						while (parent$1.parentNode && parent$1.parentNode.firstChild === parent$1 && parent$1.parentNode !== root) parent$1 = parent$1.parentNode;
						if (parent$1.nodeName === "BLOCKQUOTE") {
							editor.formatter.toggle("blockquote", void 0, parent$1);
							rng = dom$1.createRng();
							rng.setStart(container, 0);
							rng.setEnd(container, 0);
							selection.setRng(rng);
						}
					});
				};
				const setGeckoEditingOptions = () => {
					const setOpts = () => {
						setEditorCommandState$1("StyleWithCSS", false);
						setEditorCommandState$1("enableInlineTableEditing", false);
						if (!getObjectResizing(editor)) setEditorCommandState$1("enableObjectResizing", false);
					};
					if (!isReadOnly$1(editor)) editor.on("BeforeExecCommand mousedown", setOpts);
				};
				const addBrAfterLastLinks = () => {
					const fixLinks = () => {
						each$10(dom$1.select("a:not([data-mce-block])"), (node) => {
							var _a;
							let parentNode = node.parentNode;
							const root = dom$1.getRoot();
							if ((parentNode === null || parentNode === void 0 ? void 0 : parentNode.lastChild) === node) {
								while (parentNode && !dom$1.isBlock(parentNode)) {
									if (((_a = parentNode.parentNode) === null || _a === void 0 ? void 0 : _a.lastChild) !== parentNode || parentNode === root) return;
									parentNode = parentNode.parentNode;
								}
								dom$1.add(parentNode, "br", { "data-mce-bogus": 1 });
							}
						});
					};
					editor.on("SetContent ExecCommand", (e) => {
						if (e.type === "setcontent" || e.command === "mceInsertLink") fixLinks();
					});
				};
				const setDefaultBlockType = () => {
					editor.on("init", () => {
						setEditorCommandState$1("DefaultParagraphSeparator", getForcedRootBlock(editor));
					});
				};
				const isAllContentSelected = (editor$1) => {
					const body = editor$1.getBody();
					const rng = editor$1.selection.getRng();
					return rng.startContainer === rng.endContainer && rng.startContainer === body && rng.startOffset === 0 && rng.endOffset === body.childNodes.length;
				};
				const normalizeSelection$1 = () => {
					editor.on("keyup focusin mouseup", (e) => {
						if (!VK.modifierPressed(e) && !isAllContentSelected(editor)) selection.normalize();
					}, true);
				};
				const showBrokenImageIcon = () => {
					editor.contentStyles.push("img:-moz-broken {-moz-force-broken-image-icon:1;min-width:24px;min-height:24px}");
				};
				const restoreFocusOnKeyDown = () => {
					if (!editor.inline) editor.on("keydown", () => {
						if (document.activeElement === document.body) editor.getWin().focus();
					});
				};
				const bodyHeight = () => {
					if (!editor.inline) {
						editor.contentStyles.push("body {min-height: 150px}");
						editor.on("click", (e) => {
							let rng;
							if (e.target.nodeName === "HTML") {
								rng = editor.selection.getRng();
								editor.getBody().focus();
								editor.selection.setRng(rng);
								editor.selection.normalize();
								editor.nodeChanged();
							}
						});
					}
				};
				const blockCmdArrowNavigation = () => {
					if (isMac) editor.on("keydown", (e) => {
						if (VK.metaKeyPressed(e) && !e.shiftKey && (e.keyCode === 37 || e.keyCode === 39)) {
							e.preventDefault();
							editor.selection.getSel().modify("move", e.keyCode === 37 ? "backward" : "forward", "lineboundary");
						}
					});
				};
				const tapLinksAndImages = () => {
					editor.on("click", (e) => {
						let elm = e.target;
						do
							if (elm.tagName === "A") {
								e.preventDefault();
								return;
							}
						while (elm = elm.parentNode);
					});
					editor.contentStyles.push(".mce-content-body {-webkit-touch-callout: none}");
				};
				const blockFormSubmitInsideEditor = () => {
					editor.on("init", () => {
						editor.dom.bind(editor.getBody(), "submit", (e) => {
							e.preventDefault();
						});
					});
				};
				const removeAppleInterchangeBrs = () => {
					parser.addNodeFilter("br", (nodes) => {
						let i = nodes.length;
						while (i--) if (nodes[i].attr("class") === "Apple-interchange-newline") nodes[i].remove();
					});
				};
				const refreshContentEditable = noop;
				const isHidden = () => {
					if (!isGecko || editor.removed) return false;
					const sel = editor.selection.getSel();
					return !sel || !sel.rangeCount || sel.rangeCount === 0;
				};
				const setupRtc = () => {
					if (isWebKit) {
						documentElementEditingFocus();
						selectControlElements();
						blockFormSubmitInsideEditor();
						selectAll();
						if (isiOS) {
							restoreFocusOnKeyDown();
							bodyHeight();
							tapLinksAndImages();
						}
					}
					if (isGecko) {
						focusBody$1();
						setGeckoEditingOptions();
						showBrokenImageIcon();
						blockCmdArrowNavigation();
					}
				};
				const dropDragEndEvent = () => {
					editor.on("drop", (event) => {
						var _a;
						const data$1 = (_a = event.dataTransfer) === null || _a === void 0 ? void 0 : _a.getData("text/html");
						if (isString(data$1) && /^<img[^>]*>$/.test(data$1)) editor.dispatch("dragend", new window.DragEvent("dragend", event));
					});
				};
				const setup$10 = () => {
					removeBlockQuoteOnBackSpace();
					emptyEditorWhenDeleting();
					if (!Env.windowsPhone) normalizeSelection$1();
					if (isWebKit) {
						documentElementEditingFocus();
						selectControlElements();
						setDefaultBlockType();
						blockFormSubmitInsideEditor();
						disableBackspaceIntoATable();
						removeAppleInterchangeBrs();
						if (isiOS) {
							restoreFocusOnKeyDown();
							bodyHeight();
							tapLinksAndImages();
						} else selectAll();
					}
					if (isGecko) {
						removeHrOnBackspace();
						focusBody$1();
						removeStylesWhenDeletingAcrossBlockElements();
						setGeckoEditingOptions();
						addBrAfterLastLinks();
						showBrokenImageIcon();
						blockCmdArrowNavigation();
						disableBackspaceIntoATable();
						dropDragEndEvent();
					}
				};
				if (isRtc(editor)) setupRtc();
				else setup$10();
				return {
					refreshContentEditable,
					isHidden
				};
			};
			const DOM$6 = DOMUtils.DOM;
			const appendStyle = (editor, text$1) => {
				const container = getStyleContainer(getRootNode(SugarElement.fromDom(editor.getBody())));
				const style = SugarElement.fromTag("style");
				set$3(style, "type", "text/css");
				append$1(style, SugarElement.fromText(text$1));
				append$1(container, style);
				editor.on("remove", () => {
					remove$5(style);
				});
			};
			const getRootName = (editor) => editor.inline ? editor.getElement().nodeName.toLowerCase() : void 0;
			const removeUndefined = (obj) => filter$4(obj, (v) => isUndefined(v) === false);
			const mkParserSettings = (editor) => {
				const getOption$1 = editor.options.get;
				const blobCache = editor.editorUpload.blobCache;
				return removeUndefined({
					allow_conditional_comments: getOption$1("allow_conditional_comments"),
					allow_html_data_urls: getOption$1("allow_html_data_urls"),
					allow_svg_data_urls: getOption$1("allow_svg_data_urls"),
					allow_html_in_named_anchor: getOption$1("allow_html_in_named_anchor"),
					allow_script_urls: getOption$1("allow_script_urls"),
					allow_unsafe_link_target: getOption$1("allow_unsafe_link_target"),
					convert_fonts_to_spans: getOption$1("convert_fonts_to_spans"),
					fix_list_elements: getOption$1("fix_list_elements"),
					font_size_legacy_values: getOption$1("font_size_legacy_values"),
					forced_root_block: getOption$1("forced_root_block"),
					forced_root_block_attrs: getOption$1("forced_root_block_attrs"),
					preserve_cdata: getOption$1("preserve_cdata"),
					inline_styles: getOption$1("inline_styles"),
					root_name: getRootName(editor),
					sanitize: getOption$1("xss_sanitization"),
					validate: true,
					blob_cache: blobCache,
					document: editor.getDoc()
				});
			};
			const mkSchemaSettings = (editor) => {
				const getOption$1 = editor.options.get;
				return removeUndefined({
					custom_elements: getOption$1("custom_elements"),
					extended_valid_elements: getOption$1("extended_valid_elements"),
					invalid_elements: getOption$1("invalid_elements"),
					invalid_styles: getOption$1("invalid_styles"),
					schema: getOption$1("schema"),
					valid_children: getOption$1("valid_children"),
					valid_classes: getOption$1("valid_classes"),
					valid_elements: getOption$1("valid_elements"),
					valid_styles: getOption$1("valid_styles"),
					verify_html: getOption$1("verify_html"),
					padd_empty_block_inline_children: getOption$1("format_empty_lines")
				});
			};
			const mkSerializerSettings = (editor) => {
				const getOption$1 = editor.options.get;
				return {
					...mkParserSettings(editor),
					...mkSchemaSettings(editor),
					...removeUndefined({
						remove_trailing_brs: getOption$1("remove_trailing_brs"),
						pad_empty_with_br: getOption$1("pad_empty_with_br"),
						url_converter: getOption$1("url_converter"),
						url_converter_scope: getOption$1("url_converter_scope"),
						element_format: getOption$1("element_format"),
						entities: getOption$1("entities"),
						entity_encoding: getOption$1("entity_encoding"),
						indent: getOption$1("indent"),
						indent_after: getOption$1("indent_after"),
						indent_before: getOption$1("indent_before")
					})
				};
			};
			const createParser = (editor) => {
				const parser = DomParser(mkParserSettings(editor), editor.schema);
				parser.addAttributeFilter("src,href,style,tabindex", (nodes, name$1) => {
					const dom$1 = editor.dom;
					const internalName = "data-mce-" + name$1;
					let i = nodes.length;
					while (i--) {
						const node = nodes[i];
						let value$3 = node.attr(name$1);
						if (value$3 && !node.attr(internalName)) {
							if (value$3.indexOf("data:") === 0 || value$3.indexOf("blob:") === 0) continue;
							if (name$1 === "style") {
								value$3 = dom$1.serializeStyle(dom$1.parseStyle(value$3), node.name);
								if (!value$3.length) value$3 = null;
								node.attr(internalName, value$3);
								node.attr(name$1, value$3);
							} else if (name$1 === "tabindex") {
								node.attr(internalName, value$3);
								node.attr(name$1, null);
							} else node.attr(internalName, editor.convertURL(value$3, name$1, node.name));
						}
					}
				});
				parser.addNodeFilter("script", (nodes) => {
					let i = nodes.length;
					while (i--) {
						const node = nodes[i];
						const type$2 = node.attr("type") || "no/type";
						if (type$2.indexOf("mce-") !== 0) node.attr("type", "mce-" + type$2);
					}
				});
				if (shouldPreserveCData(editor)) parser.addNodeFilter("#cdata", (nodes) => {
					var _a;
					let i = nodes.length;
					while (i--) {
						const node = nodes[i];
						node.type = 8;
						node.name = "#comment";
						node.value = "[CDATA[" + editor.dom.encode((_a = node.value) !== null && _a !== void 0 ? _a : "") + "]]";
					}
				});
				parser.addNodeFilter("p,h1,h2,h3,h4,h5,h6,div", (nodes) => {
					let i = nodes.length;
					const nonEmptyElements = editor.schema.getNonEmptyElements();
					while (i--) {
						const node = nodes[i];
						if (node.isEmpty(nonEmptyElements) && node.getAll("br").length === 0) node.append(new AstNode("br", 1));
					}
				});
				return parser;
			};
			const autoFocus = (editor) => {
				const autoFocus$1 = getAutoFocus(editor);
				if (autoFocus$1) Delay.setEditorTimeout(editor, () => {
					let focusEditor$1;
					if (autoFocus$1 === true) focusEditor$1 = editor;
					else focusEditor$1 = editor.editorManager.get(autoFocus$1);
					if (focusEditor$1 && !focusEditor$1.destroyed) {
						focusEditor$1.focus();
						focusEditor$1.selection.scrollIntoView();
					}
				}, 100);
			};
			const moveSelectionToFirstCaretPosition = (editor) => {
				const root = editor.dom.getRoot();
				if (!editor.inline && (!hasAnyRanges(editor) || editor.selection.getStart(true) === root)) firstPositionIn(root).each((pos) => {
					const node = pos.getNode();
					const caretPos = isTable$2(node) ? firstPositionIn(node).getOr(pos) : pos;
					editor.selection.setRng(caretPos.toRange());
				});
			};
			const initEditor = (editor) => {
				editor.bindPendingEventDelegates();
				editor.initialized = true;
				fireInit(editor);
				editor.focus(true);
				moveSelectionToFirstCaretPosition(editor);
				editor.nodeChanged({ initial: true });
				const initInstanceCallback = getInitInstanceCallback(editor);
				if (isFunction(initInstanceCallback)) initInstanceCallback.call(editor, editor);
				autoFocus(editor);
			};
			const getStyleSheetLoader$1 = (editor) => editor.inline ? editor.ui.styleSheetLoader : editor.dom.styleSheetLoader;
			const makeStylesheetLoadingPromises = (editor, css, framedFonts) => {
				const promises = [getStyleSheetLoader$1(editor).loadAll(css)];
				if (editor.inline) return promises;
				else return promises.concat([editor.ui.styleSheetLoader.loadAll(framedFonts)]);
			};
			const loadContentCss = (editor) => {
				const styleSheetLoader = getStyleSheetLoader$1(editor);
				const fontCss = getFontCss(editor);
				const css = editor.contentCSS;
				const removeCss = () => {
					styleSheetLoader.unloadAll(css);
					if (!editor.inline) editor.ui.styleSheetLoader.unloadAll(fontCss);
				};
				const loaded = () => {
					if (editor.removed) removeCss();
					else editor.on("remove", removeCss);
				};
				if (editor.contentStyles.length > 0) {
					let contentCssText = "";
					Tools.each(editor.contentStyles, (style) => {
						contentCssText += style + "\r\n";
					});
					editor.dom.addStyle(contentCssText);
				}
				const allStylesheets = Promise.all(makeStylesheetLoadingPromises(editor, css, fontCss)).then(loaded).catch(loaded);
				const contentStyle = getContentStyle(editor);
				if (contentStyle) appendStyle(editor, contentStyle);
				return allStylesheets;
			};
			const preInit = (editor) => {
				const doc = editor.getDoc(), body = editor.getBody();
				firePreInit(editor);
				if (!shouldBrowserSpellcheck(editor)) {
					doc.body.spellcheck = false;
					DOM$6.setAttrib(body, "spellcheck", "false");
				}
				editor.quirks = Quirks(editor);
				firePostRender(editor);
				const directionality = getDirectionality(editor);
				if (directionality !== void 0) body.dir = directionality;
				const protect = getProtect(editor);
				if (protect) editor.on("BeforeSetContent", (e) => {
					Tools.each(protect, (pattern) => {
						e.content = e.content.replace(pattern, (str) => {
							return "<!--mce:protected " + escape(str) + "-->";
						});
					});
				});
				editor.on("SetContent", () => {
					editor.addVisual(editor.getBody());
				});
				editor.on("compositionstart compositionend", (e) => {
					editor.composing = e.type === "compositionstart";
				});
			};
			const loadInitialContent = (editor) => {
				if (!isRtc(editor)) editor.load({
					initial: true,
					format: "html"
				});
				editor.startContent = editor.getContent({ format: "raw" });
			};
			const initEditorWithInitialContent = (editor) => {
				if (editor.removed !== true) {
					loadInitialContent(editor);
					initEditor(editor);
				}
			};
			const startProgress = (editor) => {
				let canceled = false;
				const progressTimeout = setTimeout(() => {
					if (!canceled) editor.setProgressState(true);
				}, 500);
				return () => {
					clearTimeout(progressTimeout);
					canceled = true;
					editor.setProgressState(false);
				};
			};
			const contentBodyLoaded = (editor) => {
				const targetElm = editor.getElement();
				let doc = editor.getDoc();
				if (editor.inline) {
					DOM$6.addClass(targetElm, "mce-content-body");
					editor.contentDocument = doc = document;
					editor.contentWindow = window;
					editor.bodyElement = targetElm;
					editor.contentAreaContainer = targetElm;
				}
				const body = editor.getBody();
				body.disabled = true;
				editor.readonly = isReadOnly$1(editor);
				editor._editableRoot = hasEditableRoot$1(editor);
				if (!editor.readonly && editor.hasEditableRoot()) {
					if (editor.inline && DOM$6.getStyle(body, "position", true) === "static") body.style.position = "relative";
					body.contentEditable = "true";
				}
				body.disabled = false;
				editor.editorUpload = EditorUpload(editor);
				editor.schema = Schema(mkSchemaSettings(editor));
				editor.dom = DOMUtils(doc, {
					keep_values: true,
					url_converter: editor.convertURL,
					url_converter_scope: editor,
					update_styles: true,
					root_element: editor.inline ? editor.getBody() : null,
					collect: editor.inline,
					schema: editor.schema,
					contentCssCors: shouldUseContentCssCors(editor),
					referrerPolicy: getReferrerPolicy(editor),
					onSetAttrib: (e) => {
						editor.dispatch("SetAttrib", e);
					}
				});
				editor.parser = createParser(editor);
				editor.serializer = DomSerializer(mkSerializerSettings(editor), editor);
				editor.selection = EditorSelection(editor.dom, editor.getWin(), editor.serializer, editor);
				editor.annotator = Annotator(editor);
				editor.formatter = Formatter(editor);
				editor.undoManager = UndoManager(editor);
				editor._nodeChangeDispatcher = new NodeChange(editor);
				editor._selectionOverrides = SelectionOverrides(editor);
				setup$o(editor);
				setup$6(editor);
				setup$m(editor);
				if (!isRtc(editor)) {
					setup$5(editor);
					setup$1(editor);
				}
				setup$p(editor, setup$b(editor));
				setup$n(editor);
				setup$q(editor);
				setup$7(editor);
				const setupRtcThunk = setup$s(editor);
				preInit(editor);
				setupRtcThunk.fold(() => {
					const cancelProgress = startProgress(editor);
					loadContentCss(editor).then(() => {
						initEditorWithInitialContent(editor);
						cancelProgress();
					});
				}, (setupRtc) => {
					editor.setProgressState(true);
					loadContentCss(editor).then(() => {
						setupRtc().then((_rtcMode) => {
							editor.setProgressState(false);
							initEditorWithInitialContent(editor);
							bindEvents(editor);
						}, (err) => {
							editor.notificationManager.open({
								type: "error",
								text: String(err)
							});
							initEditorWithInitialContent(editor);
							bindEvents(editor);
						});
					});
				});
			};
			const filter = always;
			const bind = (element, event, handler) => bind$2(element, event, filter, handler);
			const DOM$5 = DOMUtils.DOM;
			const createIframeElement = (id, title, customAttrs, tabindex) => {
				const iframe = SugarElement.fromTag("iframe");
				tabindex.each((t) => set$3(iframe, "tabindex", t));
				setAll$1(iframe, customAttrs);
				setAll$1(iframe, {
					id: id + "_ifr",
					frameBorder: "0",
					allowTransparency: "true",
					title
				});
				add$2(iframe, "tox-edit-area__iframe");
				return iframe;
			};
			const getIframeHtml = (editor) => {
				let iframeHTML = getDocType(editor) + "<html><head>";
				if (getDocumentBaseUrl(editor) !== editor.documentBaseUrl) iframeHTML += "<base href=\"" + editor.documentBaseURI.getURI() + "\" />";
				iframeHTML += "<meta http-equiv=\"Content-Type\" content=\"text/html; charset=UTF-8\" />";
				const bodyId = getBodyId(editor);
				const bodyClass = getBodyClass(editor);
				const translatedAriaText = editor.translate(getIframeAriaText(editor));
				if (getContentSecurityPolicy(editor)) iframeHTML += "<meta http-equiv=\"Content-Security-Policy\" content=\"" + getContentSecurityPolicy(editor) + "\" />";
				iframeHTML += `</head><body id="${bodyId}" class="mce-content-body ${bodyClass}" data-id="${editor.id}" aria-label="${translatedAriaText}"><br></body></html>`;
				return iframeHTML;
			};
			const createIframe = (editor, boxInfo) => {
				const iframeTitle = editor.translate("Rich Text Area");
				const tabindex = getOpt(SugarElement.fromDom(editor.getElement()), "tabindex").bind(toInt);
				const ifr = createIframeElement(editor.id, iframeTitle, getIframeAttrs(editor), tabindex).dom;
				ifr.onload = () => {
					ifr.onload = null;
					editor.dispatch("load");
				};
				editor.contentAreaContainer = boxInfo.iframeContainer;
				editor.iframeElement = ifr;
				editor.iframeHTML = getIframeHtml(editor);
				DOM$5.add(boxInfo.iframeContainer, ifr);
			};
			const setupIframeBody = (editor) => {
				const iframe = editor.iframeElement;
				const ready = () => {
					editor.contentDocument = iframe.contentDocument;
					contentBodyLoaded(editor);
				};
				if (shouldUseDocumentWrite(editor) || Env.browser.isFirefox()) {
					const doc = editor.getDoc();
					doc.open();
					doc.write(editor.iframeHTML);
					doc.close();
					ready();
				} else {
					const binder$1 = bind(SugarElement.fromDom(iframe), "load", () => {
						binder$1.unbind();
						ready();
					});
					iframe.srcdoc = editor.iframeHTML;
				}
			};
			const init$1 = (editor, boxInfo) => {
				createIframe(editor, boxInfo);
				if (boxInfo.editorContainer) {
					boxInfo.editorContainer.style.display = editor.orgDisplay;
					editor.hidden = DOM$5.isHidden(boxInfo.editorContainer);
				}
				editor.getElement().style.display = "none";
				DOM$5.setAttrib(editor.id, "aria-hidden", "true");
				editor.getElement().style.visibility = editor.orgVisibility;
				setupIframeBody(editor);
			};
			const DOM$4 = DOMUtils.DOM;
			const initPlugin = (editor, initializedPlugins, plugin) => {
				const Plugin = PluginManager.get(plugin);
				const pluginUrl = PluginManager.urls[plugin] || editor.documentBaseUrl.replace(/\/$/, "");
				plugin = Tools.trim(plugin);
				if (Plugin && Tools.inArray(initializedPlugins, plugin) === -1) {
					if (editor.plugins[plugin]) return;
					try {
						const pluginInstance = Plugin(editor, pluginUrl) || {};
						editor.plugins[plugin] = pluginInstance;
						if (isFunction(pluginInstance.init)) {
							pluginInstance.init(editor, pluginUrl);
							initializedPlugins.push(plugin);
						}
					} catch (e) {
						pluginInitError(editor, plugin, e);
					}
				}
			};
			const trimLegacyPrefix = (name$1) => {
				return name$1.replace(/^\-/, "");
			};
			const initPlugins = (editor) => {
				const initializedPlugins = [];
				each$e(getPlugins(editor), (name$1) => {
					initPlugin(editor, initializedPlugins, trimLegacyPrefix(name$1));
				});
			};
			const initIcons = (editor) => {
				const iconPackName = Tools.trim(getIconPackName(editor));
				const currentIcons = editor.ui.registry.getAll().icons;
				each$d({
					...IconManager.get("default").icons,
					...IconManager.get(iconPackName).icons
				}, (svgData, icon) => {
					if (!has$2(currentIcons, icon)) editor.ui.registry.addIcon(icon, svgData);
				});
			};
			const initTheme = (editor) => {
				const theme = getTheme(editor);
				if (isString(theme)) {
					editor.theme = ThemeManager.get(theme)(editor, ThemeManager.urls[theme]) || {};
					if (isFunction(editor.theme.init)) editor.theme.init(editor, ThemeManager.urls[theme] || editor.documentBaseUrl.replace(/\/$/, ""));
				} else editor.theme = {};
			};
			const initModel = (editor) => {
				const model = getModel(editor);
				editor.model = ModelManager.get(model)(editor, ModelManager.urls[model]);
			};
			const renderFromLoadedTheme = (editor) => {
				const render$1 = editor.theme.renderUI;
				return render$1 ? render$1() : renderThemeFalse(editor);
			};
			const renderFromThemeFunc = (editor) => {
				const elm = editor.getElement();
				const info = getTheme(editor)(editor, elm);
				if (info.editorContainer.nodeType) info.editorContainer.id = info.editorContainer.id || editor.id + "_parent";
				if (info.iframeContainer && info.iframeContainer.nodeType) info.iframeContainer.id = info.iframeContainer.id || editor.id + "_iframecontainer";
				info.height = info.iframeHeight ? info.iframeHeight : elm.offsetHeight;
				return info;
			};
			const createThemeFalseResult = (element, iframe) => {
				return {
					editorContainer: element,
					iframeContainer: iframe,
					api: {}
				};
			};
			const renderThemeFalseIframe = (targetElement) => {
				const iframeContainer = DOM$4.create("div");
				DOM$4.insertAfter(iframeContainer, targetElement);
				return createThemeFalseResult(iframeContainer, iframeContainer);
			};
			const renderThemeFalse = (editor) => {
				const targetElement = editor.getElement();
				return editor.inline ? createThemeFalseResult(null) : renderThemeFalseIframe(targetElement);
			};
			const renderThemeUi = (editor) => {
				editor.orgDisplay = editor.getElement().style.display;
				if (isString(getTheme(editor))) return renderFromLoadedTheme(editor);
				else if (isFunction(getTheme(editor))) return renderFromThemeFunc(editor);
				else return renderThemeFalse(editor);
			};
			const augmentEditorUiApi = (editor, api$2) => {
				const uiApiFacade = {
					show: Optional.from(api$2.show).getOr(noop),
					hide: Optional.from(api$2.hide).getOr(noop),
					isEnabled: Optional.from(api$2.isEnabled).getOr(always),
					setEnabled: (state) => {
						if (!editor.mode.isReadOnly()) Optional.from(api$2.setEnabled).each((f) => f(state));
					}
				};
				editor.ui = {
					...editor.ui,
					...uiApiFacade
				};
			};
			const init = async (editor) => {
				editor.dispatch("ScriptsLoaded");
				initIcons(editor);
				initTheme(editor);
				initModel(editor);
				initPlugins(editor);
				const renderInfo = await renderThemeUi(editor);
				augmentEditorUiApi(editor, Optional.from(renderInfo.api).getOr({}));
				editor.editorContainer = renderInfo.editorContainer;
				appendContentCssFromSettings(editor);
				if (editor.inline) contentBodyLoaded(editor);
				else init$1(editor, {
					editorContainer: renderInfo.editorContainer,
					iframeContainer: renderInfo.iframeContainer
				});
			};
			const DOM$3 = DOMUtils.DOM;
			const hasSkipLoadPrefix = (name$1) => name$1.charAt(0) === "-";
			const loadLanguage = (scriptLoader, editor) => {
				const languageCode = getLanguageCode(editor);
				const languageUrl = getLanguageUrl(editor);
				if (!I18n.hasCode(languageCode) && languageCode !== "en") {
					const url = isNotEmpty(languageUrl) ? languageUrl : `${editor.editorManager.baseURL}/langs/${languageCode}.js`;
					scriptLoader.add(url).catch(() => {
						languageLoadError(editor, url, languageCode);
					});
				}
			};
			const loadTheme = (editor, suffix) => {
				const theme = getTheme(editor);
				if (isString(theme) && !hasSkipLoadPrefix(theme) && !has$2(ThemeManager.urls, theme)) {
					const themeUrl = getThemeUrl(editor);
					const url = themeUrl ? editor.documentBaseURI.toAbsolute(themeUrl) : `themes/${theme}/theme${suffix}.js`;
					ThemeManager.load(theme, url).catch(() => {
						themeLoadError(editor, url, theme);
					});
				}
			};
			const loadModel = (editor, suffix) => {
				const model = getModel(editor);
				if (model !== "plugin" && !has$2(ModelManager.urls, model)) {
					const modelUrl = getModelUrl(editor);
					const url = isString(modelUrl) ? editor.documentBaseURI.toAbsolute(modelUrl) : `models/${model}/model${suffix}.js`;
					ModelManager.load(model, url).catch(() => {
						modelLoadError(editor, url, model);
					});
				}
			};
			const getIconsUrlMetaFromUrl = (editor) => Optional.from(getIconsUrl(editor)).filter(isNotEmpty).map((url) => ({
				url,
				name: Optional.none()
			}));
			const getIconsUrlMetaFromName = (editor, name$1, suffix) => Optional.from(name$1).filter((name$2) => isNotEmpty(name$2) && !IconManager.has(name$2)).map((name$2) => ({
				url: `${editor.editorManager.baseURL}/icons/${name$2}/icons${suffix}.js`,
				name: Optional.some(name$2)
			}));
			const loadIcons = (scriptLoader, editor, suffix) => {
				each$e(cat([getIconsUrlMetaFromName(editor, "default", suffix), getIconsUrlMetaFromUrl(editor).orThunk(() => getIconsUrlMetaFromName(editor, getIconPackName(editor), ""))]), (urlMeta) => {
					scriptLoader.add(urlMeta.url).catch(() => {
						iconsLoadError(editor, urlMeta.url, urlMeta.name.getOrUndefined());
					});
				});
			};
			const loadPlugins = (editor, suffix) => {
				const loadPlugin = (name$1, url) => {
					PluginManager.load(name$1, url).catch(() => {
						pluginLoadError(editor, url, name$1);
					});
				};
				each$d(getExternalPlugins$1(editor), (url, name$1) => {
					loadPlugin(name$1, url);
					editor.options.set("plugins", getPlugins(editor).concat(name$1));
				});
				each$e(getPlugins(editor), (plugin) => {
					plugin = Tools.trim(plugin);
					if (plugin && !PluginManager.urls[plugin] && !hasSkipLoadPrefix(plugin)) loadPlugin(plugin, `plugins/${plugin}/plugin${suffix}.js`);
				});
			};
			const isThemeLoaded = (editor) => {
				const theme = getTheme(editor);
				return !isString(theme) || isNonNullable(ThemeManager.get(theme));
			};
			const isModelLoaded = (editor) => {
				const model = getModel(editor);
				return isNonNullable(ModelManager.get(model));
			};
			const loadScripts = (editor, suffix) => {
				const scriptLoader = ScriptLoader.ScriptLoader;
				const initEditor$1 = () => {
					if (!editor.removed && isThemeLoaded(editor) && isModelLoaded(editor)) init(editor);
				};
				loadTheme(editor, suffix);
				loadModel(editor, suffix);
				loadLanguage(scriptLoader, editor);
				loadIcons(scriptLoader, editor, suffix);
				loadPlugins(editor, suffix);
				scriptLoader.loadQueue().then(initEditor$1, initEditor$1);
			};
			const getStyleSheetLoader = (element, editor) => instance.forElement(element, {
				contentCssCors: hasContentCssCors(editor),
				referrerPolicy: getReferrerPolicy(editor)
			});
			const render = (editor) => {
				const id = editor.id;
				I18n.setCode(getLanguageCode(editor));
				const readyHandler = () => {
					DOM$3.unbind(window, "ready", readyHandler);
					editor.render();
				};
				if (!EventUtils.Event.domLoaded) {
					DOM$3.bind(window, "ready", readyHandler);
					return;
				}
				if (!editor.getElement()) return;
				const element = SugarElement.fromDom(editor.getElement());
				const snapshot = clone$4(element);
				editor.on("remove", () => {
					eachr(element.dom.attributes, (attr) => remove$a(element, attr.name));
					setAll$1(element, snapshot);
				});
				editor.ui.styleSheetLoader = getStyleSheetLoader(element, editor);
				if (!isInline(editor)) {
					editor.orgVisibility = editor.getElement().style.visibility;
					editor.getElement().style.visibility = "hidden";
				} else editor.inline = true;
				const form = editor.getElement().form || DOM$3.getParent(id, "form");
				if (form) {
					editor.formElement = form;
					if (hasHiddenInput(editor) && !isTextareaOrInput(editor.getElement())) {
						DOM$3.insertAfter(DOM$3.create("input", {
							type: "hidden",
							name: id
						}), id);
						editor.hasHiddenInput = true;
					}
					editor.formEventDelegate = (e) => {
						editor.dispatch(e.type, e);
					};
					DOM$3.bind(form, "submit reset", editor.formEventDelegate);
					editor.on("reset", () => {
						editor.resetContent();
					});
					if (shouldPatchSubmit(editor) && !form.submit.nodeType && !form.submit.length && !form._mceOldSubmit) {
						form._mceOldSubmit = form.submit;
						form.submit = () => {
							editor.editorManager.triggerSave();
							editor.setDirty(false);
							return form._mceOldSubmit(form);
						};
					}
				}
				editor.windowManager = WindowManager(editor);
				editor.notificationManager = NotificationManager(editor);
				if (isEncodingXml(editor)) editor.on("GetContent", (e) => {
					if (e.save) e.content = DOM$3.encode(e.content);
				});
				if (shouldAddFormSubmitTrigger(editor)) editor.on("submit", () => {
					if (editor.initialized) editor.save();
				});
				if (shouldAddUnloadTrigger(editor)) {
					editor._beforeUnload = () => {
						if (editor.initialized && !editor.destroyed && !editor.isHidden()) editor.save({
							format: "raw",
							no_events: true,
							set_dirty: false
						});
					};
					editor.editorManager.on("BeforeUnload", editor._beforeUnload);
				}
				editor.editorManager.add(editor);
				loadScripts(editor, editor.suffix);
			};
			const setEditableRoot = (editor, state) => {
				if (editor._editableRoot !== state) {
					editor._editableRoot = state;
					if (!editor.readonly) {
						editor.getBody().contentEditable = String(editor.hasEditableRoot());
						editor.nodeChanged();
					}
					fireEditableRootStateChange(editor, state);
				}
			};
			const hasEditableRoot = (editor) => editor._editableRoot;
			const sectionResult = (sections, settings) => ({
				sections: constant(sections),
				options: constant(settings)
			});
			const deviceDetection = detect$2().deviceType;
			const isPhone = deviceDetection.isPhone();
			const isTablet = deviceDetection.isTablet();
			const normalizePlugins = (plugins) => {
				if (isNullable(plugins)) return [];
				else return filter$5(map$3(isArray$1(plugins) ? plugins : plugins.split(/[ ,]/), trim$3), isNotEmpty);
			};
			const extractSections = (keys$1, options) => {
				const result = bifilter(options, (value$3, key) => {
					return contains$2(keys$1, key);
				});
				return sectionResult(result.t, result.f);
			};
			const getSection = (sectionResult$1, name$1, defaults = {}) => {
				const sectionOptions = get$a(sectionResult$1.sections(), name$1).getOr({});
				return Tools.extend({}, defaults, sectionOptions);
			};
			const hasSection = (sectionResult$1, name$1) => {
				return has$2(sectionResult$1.sections(), name$1);
			};
			const getSectionConfig = (sectionResult$1, name$1) => {
				return hasSection(sectionResult$1, name$1) ? sectionResult$1.sections()[name$1] : {};
			};
			const getMobileOverrideOptions = (mobileOptions, isPhone$1) => {
				const defaultMobileOptions = {
					table_grid: false,
					object_resizing: false,
					resize: false,
					toolbar_mode: get$a(mobileOptions, "toolbar_mode").getOr("scrolling"),
					toolbar_sticky: false
				};
				const defaultPhoneOptions = { menubar: false };
				return {
					...defaultMobileOptions,
					...isPhone$1 ? defaultPhoneOptions : {}
				};
			};
			const getExternalPlugins = (overrideOptions, options) => {
				var _a;
				const userDefinedExternalPlugins = (_a = options.external_plugins) !== null && _a !== void 0 ? _a : {};
				if (overrideOptions && overrideOptions.external_plugins) return Tools.extend({}, overrideOptions.external_plugins, userDefinedExternalPlugins);
				else return userDefinedExternalPlugins;
			};
			const combinePlugins = (forcedPlugins, plugins) => [...normalizePlugins(forcedPlugins), ...normalizePlugins(plugins)];
			const getPlatformPlugins = (isMobileDevice, sectionResult$1, desktopPlugins, mobilePlugins) => {
				if (isMobileDevice && hasSection(sectionResult$1, "mobile")) return mobilePlugins;
				else return desktopPlugins;
			};
			const processPlugins = (isMobileDevice, sectionResult$1, defaultOverrideOptions, options) => {
				const forcedPlugins = normalizePlugins(defaultOverrideOptions.forced_plugins);
				const desktopPlugins = normalizePlugins(options.plugins);
				const mobileConfig = getSectionConfig(sectionResult$1, "mobile");
				const combinedPlugins = combinePlugins(forcedPlugins, getPlatformPlugins(isMobileDevice, sectionResult$1, desktopPlugins, mobileConfig.plugins ? normalizePlugins(mobileConfig.plugins) : desktopPlugins));
				return Tools.extend(options, {
					forced_plugins: forcedPlugins,
					plugins: combinedPlugins
				});
			};
			const isOnMobile = (isMobileDevice, sectionResult$1) => {
				return isMobileDevice && hasSection(sectionResult$1, "mobile");
			};
			const combineOptions = (isMobileDevice, isPhone$1, defaultOptions, defaultOverrideOptions, options) => {
				var _a;
				const sectionResult$1 = extractSections(["mobile"], deepMerge(isMobileDevice ? { mobile: getMobileOverrideOptions((_a = options.mobile) !== null && _a !== void 0 ? _a : {}, isPhone$1) } : {}, options));
				return processPlugins(isMobileDevice, sectionResult$1, defaultOverrideOptions, Tools.extend(defaultOptions, defaultOverrideOptions, sectionResult$1.options(), isOnMobile(isMobileDevice, sectionResult$1) ? getSection(sectionResult$1, "mobile") : {}, { external_plugins: getExternalPlugins(defaultOverrideOptions, sectionResult$1.options()) }));
			};
			const normalizeOptions = (defaultOverrideOptions, options) => combineOptions(isPhone || isTablet, isPhone, options, defaultOverrideOptions, options);
			const addVisual = (editor, elm) => addVisual$1(editor, elm);
			const registerExecCommands$3 = (editor) => {
				const toggleFormat$1 = (name$1, value$3) => {
					editor.formatter.toggle(name$1, value$3);
					editor.nodeChanged();
				};
				const toggleAlign = (align) => () => {
					each$e("left,center,right,justify".split(","), (name$1) => {
						if (align !== name$1) editor.formatter.remove("align" + name$1);
					});
					if (align !== "none") toggleFormat$1("align" + align);
				};
				editor.editorCommands.addCommands({
					JustifyLeft: toggleAlign("left"),
					JustifyCenter: toggleAlign("center"),
					JustifyRight: toggleAlign("right"),
					JustifyFull: toggleAlign("justify"),
					JustifyNone: toggleAlign("none")
				});
			};
			const registerQueryStateCommands$1 = (editor) => {
				const alignStates = (name$1) => () => {
					const selection = editor.selection;
					return exists(selection.isCollapsed() ? [editor.dom.getParent(selection.getNode(), editor.dom.isBlock)] : selection.getSelectedBlocks(), (node) => isNonNullable(editor.formatter.matchNode(node, name$1)));
				};
				editor.editorCommands.addCommands({
					JustifyLeft: alignStates("alignleft"),
					JustifyCenter: alignStates("aligncenter"),
					JustifyRight: alignStates("alignright"),
					JustifyFull: alignStates("alignjustify")
				}, "state");
			};
			const registerCommands$b = (editor) => {
				registerExecCommands$3(editor);
				registerQueryStateCommands$1(editor);
			};
			const registerCommands$a = (editor) => {
				editor.editorCommands.addCommands({ "Cut,Copy,Paste": (command) => {
					const doc = editor.getDoc();
					let failed;
					try {
						doc.execCommand(command);
					} catch (ex) {
						failed = true;
					}
					if (command === "paste" && !doc.queryCommandEnabled(command)) failed = true;
					if (failed || !doc.queryCommandSupported(command)) {
						let msg = editor.translate("Your browser doesn't support direct access to the clipboard. Please use the Ctrl+X/C/V keyboard shortcuts instead.");
						if (Env.os.isMacOS() || Env.os.isiOS()) msg = msg.replace(/Ctrl\+/g, "+");
						editor.notificationManager.open({
							text: msg,
							type: "error"
						});
					}
				} });
			};
			const trimOrPadLeftRight = (dom$1, rng, html$2) => {
				const root = SugarElement.fromDom(dom$1.getRoot());
				if (needsToBeNbspLeft(root, CaretPosition.fromRangeStart(rng))) html$2 = html$2.replace(/^ /, "&nbsp;");
				else html$2 = html$2.replace(/^&nbsp;/, " ");
				if (needsToBeNbspRight(root, CaretPosition.fromRangeEnd(rng))) html$2 = html$2.replace(/(&nbsp;| )(<br( \/)>)?$/, "&nbsp;");
				else html$2 = html$2.replace(/&nbsp;(<br( \/)?>)?$/, " ");
				return html$2;
			};
			const processValue$1 = (value$3) => {
				if (typeof value$3 !== "string") {
					const details = Tools.extend({
						paste: value$3.paste,
						data: { paste: value$3.paste }
					}, value$3);
					return {
						content: value$3.content,
						details
					};
				}
				return {
					content: value$3,
					details: {}
				};
			};
			const trimOrPad = (editor, value$3) => {
				const selection = editor.selection;
				const dom$1 = editor.dom;
				if (/^ | $/.test(value$3)) return trimOrPadLeftRight(dom$1, selection.getRng(), value$3);
				else return value$3;
			};
			const insertAtCaret = (editor, value$3) => {
				if (editor.selection.isEditable()) {
					const { content, details } = processValue$1(value$3);
					preProcessSetContent(editor, {
						...details,
						content: trimOrPad(editor, content),
						format: "html",
						set: false,
						selection: true
					}).each((args) => {
						postProcessSetContent(editor, insertContent$1(editor, args.content, details), args);
						editor.addVisual();
					});
				}
			};
			const registerCommands$9 = (editor) => {
				editor.editorCommands.addCommands({
					mceCleanup: () => {
						const bm = editor.selection.getBookmark();
						editor.setContent(editor.getContent());
						editor.selection.moveToBookmark(bm);
					},
					insertImage: (_command, _ui, value$3) => {
						insertAtCaret(editor, editor.dom.createHTML("img", { src: value$3 }));
					},
					insertHorizontalRule: () => {
						editor.execCommand("mceInsertContent", false, "<hr>");
					},
					insertText: (_command, _ui, value$3) => {
						insertAtCaret(editor, editor.dom.encode(value$3));
					},
					insertHTML: (_command, _ui, value$3) => {
						insertAtCaret(editor, value$3);
					},
					mceInsertContent: (_command, _ui, value$3) => {
						insertAtCaret(editor, value$3);
					},
					mceSetContent: (_command, _ui, value$3) => {
						editor.setContent(value$3);
					},
					mceReplaceContent: (_command, _ui, value$3) => {
						editor.execCommand("mceInsertContent", false, value$3.replace(/\{\$selection\}/g, editor.selection.getContent({ format: "text" })));
					},
					mceNewDocument: () => {
						editor.setContent(getNewDocumentContent(editor));
					}
				});
			};
			const legacyPropNames = {
				"font-size": "size",
				"font-family": "face"
			};
			const isFont = isTag("font");
			const getSpecifiedFontProp = (propName, rootElm, elm) => {
				const getProperty = (elm$1) => getRaw(elm$1, propName).orThunk(() => {
					if (isFont(elm$1)) return get$a(legacyPropNames, propName).bind((legacyPropName) => getOpt(elm$1, legacyPropName));
					else return Optional.none();
				});
				const isRoot$2 = (elm$1) => eq(SugarElement.fromDom(rootElm), elm$1);
				return closest$1(SugarElement.fromDom(elm), (elm$1) => getProperty(elm$1), isRoot$2);
			};
			const normalizeFontFamily = (fontFamily) => fontFamily.replace(/[\'\"\\]/g, "").replace(/,\s+/g, ",");
			const getComputedFontProp = (propName, elm) => Optional.from(DOMUtils.DOM.getStyle(elm, propName, true));
			const getFontProp = (propName) => (rootElm, elm) => Optional.from(elm).map(SugarElement.fromDom).filter(isElement$7).bind((element) => getSpecifiedFontProp(propName, rootElm, element.dom).or(getComputedFontProp(propName, element.dom))).getOr("");
			const getFontSize = getFontProp("font-size");
			const getFontFamily = compose(normalizeFontFamily, getFontProp("font-family"));
			const findFirstCaretElement = (editor) => firstPositionIn(editor.getBody()).bind((caret) => {
				const container = caret.container();
				return Optional.from(isText$a(container) ? container.parentNode : container);
			});
			const getCaretElement = (editor) => Optional.from(editor.selection.getRng()).bind((rng) => {
				const root = editor.getBody();
				return rng.startContainer === root && rng.startOffset === 0 ? Optional.none() : Optional.from(editor.selection.getStart(true));
			});
			const bindRange = (editor, binder$1) => getCaretElement(editor).orThunk(curry(findFirstCaretElement, editor)).map(SugarElement.fromDom).filter(isElement$7).bind(binder$1);
			const mapRange = (editor, mapper) => bindRange(editor, compose1(Optional.some, mapper));
			const fromFontSizeNumber = (editor, value$3) => {
				if (/^[0-9.]+$/.test(value$3)) {
					const fontSizeNumber = parseInt(value$3, 10);
					if (fontSizeNumber >= 1 && fontSizeNumber <= 7) {
						const fontSizes = getFontStyleValues(editor);
						const fontClasses = getFontSizeClasses(editor);
						if (fontClasses.length > 0) return fontClasses[fontSizeNumber - 1] || value$3;
						else return fontSizes[fontSizeNumber - 1] || value$3;
					} else return value$3;
				} else return value$3;
			};
			const normalizeFontNames = (font) => {
				return map$3(font.split(/\s*,\s*/), (font$1) => {
					if (font$1.indexOf(" ") !== -1 && !(startsWith(font$1, "\"") || startsWith(font$1, `'`))) return `'${font$1}'`;
					else return font$1;
				}).join(",");
			};
			const fontNameAction = (editor, value$3) => {
				const font = fromFontSizeNumber(editor, value$3);
				editor.formatter.toggle("fontname", { value: normalizeFontNames(font) });
				editor.nodeChanged();
			};
			const fontNameQuery = (editor) => mapRange(editor, (elm) => getFontFamily(editor.getBody(), elm.dom)).getOr("");
			const fontSizeAction = (editor, value$3) => {
				editor.formatter.toggle("fontsize", { value: fromFontSizeNumber(editor, value$3) });
				editor.nodeChanged();
			};
			const fontSizeQuery = (editor) => mapRange(editor, (elm) => getFontSize(editor.getBody(), elm.dom)).getOr("");
			const lineHeightQuery = (editor) => mapRange(editor, (elm) => {
				const specifiedStyle = closest$1(elm, (elm$1) => getRaw(elm$1, "line-height"), curry(eq, SugarElement.fromDom(editor.getBody())));
				const computedStyle = () => {
					const lineHeight = parseFloat(get$7(elm, "line-height"));
					const fontSize = parseFloat(get$7(elm, "font-size"));
					return String(lineHeight / fontSize);
				};
				return specifiedStyle.getOrThunk(computedStyle);
			}).getOr("");
			const lineHeightAction = (editor, lineHeight) => {
				editor.formatter.toggle("lineheight", { value: String(lineHeight) });
				editor.nodeChanged();
			};
			const registerExecCommands$2 = (editor) => {
				const toggleFormat$1 = (name$1, value$3) => {
					editor.formatter.toggle(name$1, value$3);
					editor.nodeChanged();
				};
				editor.editorCommands.addCommands({
					"Bold,Italic,Underline,Strikethrough,Superscript,Subscript": (command) => {
						toggleFormat$1(command);
					},
					"ForeColor,HiliteColor": (command, _ui, value$3) => {
						toggleFormat$1(command, { value: value$3 });
					},
					"BackColor": (_command, _ui, value$3) => {
						toggleFormat$1("hilitecolor", { value: value$3 });
					},
					"FontName": (_command, _ui, value$3) => {
						fontNameAction(editor, value$3);
					},
					"FontSize": (_command, _ui, value$3) => {
						fontSizeAction(editor, value$3);
					},
					"LineHeight": (_command, _ui, value$3) => {
						lineHeightAction(editor, value$3);
					},
					"Lang": (command, _ui, lang) => {
						var _a;
						toggleFormat$1(command, {
							value: lang.code,
							customValue: (_a = lang.customCode) !== null && _a !== void 0 ? _a : null
						});
					},
					"RemoveFormat": (command) => {
						editor.formatter.remove(command);
					},
					"mceBlockQuote": () => {
						toggleFormat$1("blockquote");
					},
					"FormatBlock": (_command, _ui, value$3) => {
						toggleFormat$1(isString(value$3) ? value$3 : "p");
					},
					"mceToggleFormat": (_command, _ui, value$3) => {
						toggleFormat$1(value$3);
					}
				});
			};
			const registerQueryValueCommands = (editor) => {
				const isFormatMatch = (name$1) => editor.formatter.match(name$1);
				editor.editorCommands.addCommands({
					"Bold,Italic,Underline,Strikethrough,Superscript,Subscript": (command) => isFormatMatch(command),
					"mceBlockQuote": () => isFormatMatch("blockquote")
				}, "state");
				editor.editorCommands.addQueryValueHandler("FontName", () => fontNameQuery(editor));
				editor.editorCommands.addQueryValueHandler("FontSize", () => fontSizeQuery(editor));
				editor.editorCommands.addQueryValueHandler("LineHeight", () => lineHeightQuery(editor));
			};
			const registerCommands$8 = (editor) => {
				registerExecCommands$2(editor);
				registerQueryValueCommands(editor);
			};
			const registerCommands$7 = (editor) => {
				editor.editorCommands.addCommands({
					mceAddUndoLevel: () => {
						editor.undoManager.add();
					},
					mceEndUndoLevel: () => {
						editor.undoManager.add();
					},
					Undo: () => {
						editor.undoManager.undo();
					},
					Redo: () => {
						editor.undoManager.redo();
					}
				});
			};
			const registerCommands$6 = (editor) => {
				editor.editorCommands.addCommands({
					Indent: () => {
						indent(editor);
					},
					Outdent: () => {
						outdent(editor);
					}
				});
				editor.editorCommands.addCommands({ Outdent: () => canOutdent(editor) }, "state");
			};
			const registerCommands$5 = (editor) => {
				const applyLinkToSelection = (_command, _ui, value$3) => {
					const linkDetails = isString(value$3) ? { href: value$3 } : value$3;
					const anchor = editor.dom.getParent(editor.selection.getNode(), "a");
					if (isObject(linkDetails) && isString(linkDetails.href)) {
						linkDetails.href = linkDetails.href.replace(/ /g, "%20");
						if (!anchor || !linkDetails.href) editor.formatter.remove("link");
						if (linkDetails.href) editor.formatter.apply("link", linkDetails, anchor);
					}
				};
				editor.editorCommands.addCommands({
					unlink: () => {
						if (editor.selection.isEditable()) {
							if (editor.selection.isCollapsed()) {
								const elm = editor.dom.getParent(editor.selection.getStart(), "a");
								if (elm) editor.dom.remove(elm, true);
								return;
							}
							editor.formatter.remove("link");
						}
					},
					mceInsertLink: applyLinkToSelection,
					createLink: applyLinkToSelection
				});
			};
			const registerExecCommands$1 = (editor) => {
				editor.editorCommands.addCommands({ "InsertUnorderedList,InsertOrderedList": (command) => {
					editor.getDoc().execCommand(command);
					const listElm = editor.dom.getParent(editor.selection.getNode(), "ol,ul");
					if (listElm) {
						const listParent = listElm.parentNode;
						if (listParent && /^(H[1-6]|P|ADDRESS|PRE)$/.test(listParent.nodeName)) {
							const bm = editor.selection.getBookmark();
							editor.dom.split(listParent, listElm);
							editor.selection.moveToBookmark(bm);
						}
					}
				} });
			};
			const registerQueryStateCommands = (editor) => {
				editor.editorCommands.addCommands({ "InsertUnorderedList,InsertOrderedList": (command) => {
					const list = editor.dom.getParent(editor.selection.getNode(), "ul,ol");
					return list && (command === "insertunorderedlist" && list.tagName === "UL" || command === "insertorderedlist" && list.tagName === "OL");
				} }, "state");
			};
			const registerCommands$4 = (editor) => {
				registerExecCommands$1(editor);
				registerQueryStateCommands(editor);
			};
			const getTopParentBlock = (editor, node, root, container) => {
				const dom$1 = editor.dom;
				const selector = (node$1) => dom$1.isBlock(node$1) && node$1.parentElement === root;
				const topParentBlock = selector(node) ? node : dom$1.getParent(container, selector, root);
				return Optional.from(topParentBlock).map(SugarElement.fromDom);
			};
			const insert = (editor, before$1) => {
				const dom$1 = editor.dom;
				const rng = editor.selection.getRng();
				const node = before$1 ? editor.selection.getStart() : editor.selection.getEnd();
				const container = before$1 ? rng.startContainer : rng.endContainer;
				const root = getEditableRoot(dom$1, container);
				if (!root || !root.isContentEditable) return;
				const insertFn = before$1 ? before$3 : after$4;
				const newBlockName = getForcedRootBlock(editor);
				getTopParentBlock(editor, node, root, container).each((parentBlock) => {
					const newBlock = createNewBlock(editor, container, parentBlock.dom, root, false, newBlockName);
					insertFn(parentBlock, SugarElement.fromDom(newBlock));
					editor.selection.setCursorLocation(newBlock, 0);
					editor.dispatch("NewBlock", { newBlock });
					fireInputEvent(editor, "insertParagraph");
				});
			};
			const insertBefore = (editor) => insert(editor, true);
			const insertAfter = (editor) => insert(editor, false);
			const registerCommands$3 = (editor) => {
				editor.editorCommands.addCommands({
					InsertNewBlockBefore: () => {
						insertBefore(editor);
					},
					InsertNewBlockAfter: () => {
						insertAfter(editor);
					}
				});
			};
			const registerCommands$2 = (editor) => {
				editor.editorCommands.addCommands({
					insertParagraph: () => {
						insertBreak(blockbreak, editor);
					},
					mceInsertNewLine: (_command, _ui, value$3) => {
						insert$1(editor, value$3);
					},
					InsertLineBreak: (_command, _ui, _value) => {
						insertBreak(linebreak, editor);
					}
				});
			};
			const registerCommands$1 = (editor) => {
				editor.editorCommands.addCommands({
					mceSelectNodeDepth: (_command, _ui, value$3) => {
						let counter = 0;
						editor.dom.getParent(editor.selection.getNode(), (node) => {
							if (isElement$6(node) && counter++ === value$3) {
								editor.selection.select(node);
								return false;
							} else return true;
						}, editor.getBody());
					},
					mceSelectNode: (_command, _ui, value$3) => {
						editor.selection.select(value$3);
					},
					selectAll: () => {
						const editingHost = editor.dom.getParent(editor.selection.getStart(), isContentEditableTrue$3);
						if (editingHost) {
							const rng = editor.dom.createRng();
							rng.selectNodeContents(editingHost);
							editor.selection.setRng(rng);
						}
					}
				});
			};
			const registerExecCommands = (editor) => {
				editor.editorCommands.addCommands({
					mceRemoveNode: (_command, _ui, value$3) => {
						const node = value$3 !== null && value$3 !== void 0 ? value$3 : editor.selection.getNode();
						if (node !== editor.getBody()) {
							const bm = editor.selection.getBookmark();
							editor.dom.remove(node, true);
							editor.selection.moveToBookmark(bm);
						}
					},
					mcePrint: () => {
						editor.getWin().print();
					},
					mceFocus: (_command, _ui, value$3) => {
						focus(editor, value$3 === true);
					},
					mceToggleVisualAid: () => {
						editor.hasVisual = !editor.hasVisual;
						editor.addVisual();
					}
				});
			};
			const registerCommands = (editor) => {
				registerCommands$b(editor);
				registerCommands$a(editor);
				registerCommands$7(editor);
				registerCommands$1(editor);
				registerCommands$9(editor);
				registerCommands$5(editor);
				registerCommands$6(editor);
				registerCommands$3(editor);
				registerCommands$2(editor);
				registerCommands$4(editor);
				registerCommands$8(editor);
				registerExecCommands(editor);
			};
			const selectionSafeCommands = ["toggleview"];
			const isSelectionSafeCommand = (command) => contains$2(selectionSafeCommands, command.toLowerCase());
			class EditorCommands {
				constructor(editor) {
					this.commands = {
						state: {},
						exec: {},
						value: {}
					};
					this.editor = editor;
				}
				execCommand(command, ui = false, value$3, args) {
					const editor = this.editor;
					const lowerCaseCommand = command.toLowerCase();
					const skipFocus = args === null || args === void 0 ? void 0 : args.skip_focus;
					if (editor.removed) return false;
					if (lowerCaseCommand !== "mcefocus") if (!/^(mceAddUndoLevel|mceEndUndoLevel)$/i.test(lowerCaseCommand) && !skipFocus) editor.focus();
					else restore(editor);
					if (editor.dispatch("BeforeExecCommand", {
						command,
						ui,
						value: value$3
					}).isDefaultPrevented()) return false;
					const func = this.commands.exec[lowerCaseCommand];
					if (isFunction(func)) {
						func(lowerCaseCommand, ui, value$3);
						editor.dispatch("ExecCommand", {
							command,
							ui,
							value: value$3
						});
						return true;
					}
					return false;
				}
				queryCommandState(command) {
					if (!isSelectionSafeCommand(command) && this.editor.quirks.isHidden() || this.editor.removed) return false;
					const lowerCaseCommand = command.toLowerCase();
					const func = this.commands.state[lowerCaseCommand];
					if (isFunction(func)) return func(lowerCaseCommand);
					return false;
				}
				queryCommandValue(command) {
					if (!isSelectionSafeCommand(command) && this.editor.quirks.isHidden() || this.editor.removed) return "";
					const lowerCaseCommand = command.toLowerCase();
					const func = this.commands.value[lowerCaseCommand];
					if (isFunction(func)) return func(lowerCaseCommand);
					return "";
				}
				addCommands(commandList, type$2 = "exec") {
					const commands = this.commands;
					each$d(commandList, (callback, command) => {
						each$e(command.toLowerCase().split(","), (command$1) => {
							commands[type$2][command$1] = callback;
						});
					});
				}
				addCommand(command, callback, scope) {
					const lowerCaseCommand = command.toLowerCase();
					this.commands.exec[lowerCaseCommand] = (_command, ui, value$3) => callback.call(scope !== null && scope !== void 0 ? scope : this.editor, ui, value$3);
				}
				queryCommandSupported(command) {
					const lowerCaseCommand = command.toLowerCase();
					if (this.commands.exec[lowerCaseCommand]) return true;
					else return false;
				}
				addQueryStateHandler(command, callback, scope) {
					this.commands.state[command.toLowerCase()] = () => callback.call(scope !== null && scope !== void 0 ? scope : this.editor);
				}
				addQueryValueHandler(command, callback, scope) {
					this.commands.value[command.toLowerCase()] = () => callback.call(scope !== null && scope !== void 0 ? scope : this.editor);
				}
			}
			const internalContentEditableAttr = "data-mce-contenteditable";
			const toggleClass = (elm, cls, state) => {
				if (has(elm, cls) && !state) remove$7(elm, cls);
				else if (state) add$2(elm, cls);
			};
			const setEditorCommandState = (editor, cmd, state) => {
				try {
					editor.getDoc().execCommand(cmd, false, String(state));
				} catch (ex) {}
			};
			const setContentEditable = (elm, state) => {
				elm.dom.contentEditable = state ? "true" : "false";
			};
			const switchOffContentEditableTrue = (elm) => {
				each$e(descendants(elm, "*[contenteditable=\"true\"]"), (elm$1) => {
					set$3(elm$1, internalContentEditableAttr, "true");
					setContentEditable(elm$1, false);
				});
			};
			const switchOnContentEditableTrue = (elm) => {
				each$e(descendants(elm, `*[${internalContentEditableAttr}="true"]`), (elm$1) => {
					remove$a(elm$1, internalContentEditableAttr);
					setContentEditable(elm$1, true);
				});
			};
			const removeFakeSelection = (editor) => {
				Optional.from(editor.selection.getNode()).each((elm) => {
					elm.removeAttribute("data-mce-selected");
				});
			};
			const restoreFakeSelection = (editor) => {
				editor.selection.setRng(editor.selection.getRng());
			};
			const toggleReadOnly = (editor, state) => {
				const body = SugarElement.fromDom(editor.getBody());
				toggleClass(body, "mce-content-readonly", state);
				if (state) {
					editor.selection.controlSelection.hideResizeRect();
					editor._selectionOverrides.hideFakeCaret();
					removeFakeSelection(editor);
					editor.readonly = true;
					setContentEditable(body, false);
					switchOffContentEditableTrue(body);
				} else {
					editor.readonly = false;
					if (editor.hasEditableRoot()) setContentEditable(body, true);
					switchOnContentEditableTrue(body);
					setEditorCommandState(editor, "StyleWithCSS", false);
					setEditorCommandState(editor, "enableInlineTableEditing", false);
					setEditorCommandState(editor, "enableObjectResizing", false);
					if (hasEditorOrUiFocus(editor)) editor.focus();
					restoreFakeSelection(editor);
					editor.nodeChanged();
				}
			};
			const isReadOnly = (editor) => editor.readonly;
			const registerFilters = (editor) => {
				editor.parser.addAttributeFilter("contenteditable", (nodes) => {
					if (isReadOnly(editor)) each$e(nodes, (node) => {
						node.attr(internalContentEditableAttr, node.attr("contenteditable"));
						node.attr("contenteditable", "false");
					});
				});
				editor.serializer.addAttributeFilter(internalContentEditableAttr, (nodes) => {
					if (isReadOnly(editor)) each$e(nodes, (node) => {
						node.attr("contenteditable", node.attr(internalContentEditableAttr));
					});
				});
				editor.serializer.addTempAttr(internalContentEditableAttr);
			};
			const registerReadOnlyContentFilters = (editor) => {
				if (editor.serializer) registerFilters(editor);
				else editor.on("PreInit", () => {
					registerFilters(editor);
				});
			};
			const isClickEvent = (e) => e.type === "click";
			const allowedEvents = ["copy"];
			const isReadOnlyAllowedEvent = (e) => contains$2(allowedEvents, e.type);
			const getAnchorHrefOpt = (editor, elm) => {
				const isRoot$2 = (elm$1) => eq(elm$1, SugarElement.fromDom(editor.getBody()));
				return closest$3(elm, "a", isRoot$2).bind((a) => getOpt(a, "href"));
			};
			const processReadonlyEvents = (editor, e) => {
				if (isClickEvent(e) && !VK.metaKeyPressed(e)) getAnchorHrefOpt(editor, SugarElement.fromDom(e.target)).each((href) => {
					e.preventDefault();
					if (/^#/.test(href)) {
						const targetEl = editor.dom.select(`${href},[name="${removeLeading(href, "#")}"]`);
						if (targetEl.length) editor.selection.scrollIntoView(targetEl[0], true);
					} else window.open(href, "_blank", "rel=noopener noreferrer,menubar=yes,toolbar=yes,location=yes,status=yes,resizable=yes,scrollbars=yes");
				});
				else if (isReadOnlyAllowedEvent(e)) editor.dispatch(e.type, e);
			};
			const registerReadOnlySelectionBlockers = (editor) => {
				editor.on("ShowCaret", (e) => {
					if (isReadOnly(editor)) e.preventDefault();
				});
				editor.on("ObjectSelected", (e) => {
					if (isReadOnly(editor)) e.preventDefault();
				});
			};
			const nativeEvents = Tools.makeMap("focus blur focusin focusout click dblclick mousedown mouseup mousemove mouseover beforepaste paste cut copy selectionchange mouseout mouseenter mouseleave wheel keydown keypress keyup input beforeinput contextmenu dragstart dragend dragover draggesture dragdrop drop drag submit compositionstart compositionend compositionupdate touchstart touchmove touchend touchcancel", " ");
			class EventDispatcher {
				static isNative(name$1) {
					return !!nativeEvents[name$1.toLowerCase()];
				}
				constructor(settings) {
					this.bindings = {};
					this.settings = settings || {};
					this.scope = this.settings.scope || this;
					this.toggleEvent = this.settings.toggleEvent || never;
				}
				fire(name$1, args) {
					return this.dispatch(name$1, args);
				}
				dispatch(name$1, args) {
					const lcName = name$1.toLowerCase();
					const event = normalize$3(lcName, args !== null && args !== void 0 ? args : {}, this.scope);
					if (this.settings.beforeFire) this.settings.beforeFire(event);
					const handlers = this.bindings[lcName];
					if (handlers) for (let i = 0, l = handlers.length; i < l; i++) {
						const callback = handlers[i];
						if (callback.removed) continue;
						if (callback.once) this.off(lcName, callback.func);
						if (event.isImmediatePropagationStopped()) return event;
						if (callback.func.call(this.scope, event) === false) {
							event.preventDefault();
							return event;
						}
					}
					return event;
				}
				on(name$1, callback, prepend$1, extra$2) {
					if (callback === false) callback = never;
					if (callback) {
						const wrappedCallback = {
							func: callback,
							removed: false
						};
						if (extra$2) Tools.extend(wrappedCallback, extra$2);
						const names = name$1.toLowerCase().split(" ");
						let i = names.length;
						while (i--) {
							const currentName = names[i];
							let handlers = this.bindings[currentName];
							if (!handlers) {
								handlers = [];
								this.toggleEvent(currentName, true);
							}
							if (prepend$1) handlers = [wrappedCallback, ...handlers];
							else handlers = [...handlers, wrappedCallback];
							this.bindings[currentName] = handlers;
						}
					}
					return this;
				}
				off(name$1, callback) {
					if (name$1) {
						const names = name$1.toLowerCase().split(" ");
						let i = names.length;
						while (i--) {
							const currentName = names[i];
							let handlers = this.bindings[currentName];
							if (!currentName) {
								each$d(this.bindings, (_value, bindingName) => {
									this.toggleEvent(bindingName, false);
									delete this.bindings[bindingName];
								});
								return this;
							}
							if (handlers) {
								if (!callback) handlers.length = 0;
								else {
									const filteredHandlers = partition$2(handlers, (handler) => handler.func === callback);
									handlers = filteredHandlers.fail;
									this.bindings[currentName] = handlers;
									each$e(filteredHandlers.pass, (handler) => {
										handler.removed = true;
									});
								}
								if (!handlers.length) {
									this.toggleEvent(name$1, false);
									delete this.bindings[currentName];
								}
							}
						}
					} else {
						each$d(this.bindings, (_value, name$2) => {
							this.toggleEvent(name$2, false);
						});
						this.bindings = {};
					}
					return this;
				}
				once(name$1, callback, prepend$1) {
					return this.on(name$1, callback, prepend$1, { once: true });
				}
				has(name$1) {
					name$1 = name$1.toLowerCase();
					const binding = this.bindings[name$1];
					return !(!binding || binding.length === 0);
				}
			}
			const getEventDispatcher = (obj) => {
				if (!obj._eventDispatcher) obj._eventDispatcher = new EventDispatcher({
					scope: obj,
					toggleEvent: (name$1, state) => {
						if (EventDispatcher.isNative(name$1) && obj.toggleNativeEvent) obj.toggleNativeEvent(name$1, state);
					}
				});
				return obj._eventDispatcher;
			};
			const Observable = {
				fire(name$1, args, bubble) {
					return this.dispatch(name$1, args, bubble);
				},
				dispatch(name$1, args, bubble) {
					const self = this;
					if (self.removed && name$1 !== "remove" && name$1 !== "detach") return normalize$3(name$1.toLowerCase(), args !== null && args !== void 0 ? args : {}, self);
					const dispatcherArgs = getEventDispatcher(self).dispatch(name$1, args);
					if (bubble !== false && self.parent) {
						let parent$1 = self.parent();
						while (parent$1 && !dispatcherArgs.isPropagationStopped()) {
							parent$1.dispatch(name$1, dispatcherArgs, false);
							parent$1 = parent$1.parent ? parent$1.parent() : void 0;
						}
					}
					return dispatcherArgs;
				},
				on(name$1, callback, prepend$1) {
					return getEventDispatcher(this).on(name$1, callback, prepend$1);
				},
				off(name$1, callback) {
					return getEventDispatcher(this).off(name$1, callback);
				},
				once(name$1, callback) {
					return getEventDispatcher(this).once(name$1, callback);
				},
				hasEventListeners(name$1) {
					return getEventDispatcher(this).has(name$1);
				}
			};
			const DOM$2 = DOMUtils.DOM;
			let customEventRootDelegates;
			const getEventTarget = (editor, eventName) => {
				if (eventName === "selectionchange") return editor.getDoc();
				if (!editor.inline && /^(?:mouse|touch|click|contextmenu|drop|dragover|dragend)/.test(eventName)) return editor.getDoc().documentElement;
				const eventRoot = getEventRoot(editor);
				if (eventRoot) {
					if (!editor.eventRoot) editor.eventRoot = DOM$2.select(eventRoot)[0];
					return editor.eventRoot;
				}
				return editor.getBody();
			};
			const isListening = (editor) => !editor.hidden && !isReadOnly(editor);
			const fireEvent = (editor, eventName, e) => {
				if (isListening(editor)) editor.dispatch(eventName, e);
				else if (isReadOnly(editor)) processReadonlyEvents(editor, e);
			};
			const bindEventDelegate = (editor, eventName) => {
				if (!editor.delegates) editor.delegates = {};
				if (editor.delegates[eventName] || editor.removed) return;
				const eventRootElm = getEventTarget(editor, eventName);
				if (getEventRoot(editor)) {
					if (!customEventRootDelegates) {
						customEventRootDelegates = {};
						editor.editorManager.on("removeEditor", () => {
							if (!editor.editorManager.activeEditor) {
								if (customEventRootDelegates) {
									each$d(customEventRootDelegates, (_value, name$1) => {
										editor.dom.unbind(getEventTarget(editor, name$1));
									});
									customEventRootDelegates = null;
								}
							}
						});
					}
					if (customEventRootDelegates[eventName]) return;
					const delegate = (e) => {
						const target = e.target;
						const editors$1 = editor.editorManager.get();
						let i = editors$1.length;
						while (i--) {
							const body = editors$1[i].getBody();
							if (body === target || DOM$2.isChildOf(target, body)) fireEvent(editors$1[i], eventName, e);
						}
					};
					customEventRootDelegates[eventName] = delegate;
					DOM$2.bind(eventRootElm, eventName, delegate);
				} else {
					const delegate = (e) => {
						fireEvent(editor, eventName, e);
					};
					DOM$2.bind(eventRootElm, eventName, delegate);
					editor.delegates[eventName] = delegate;
				}
			};
			const EditorObservable = {
				...Observable,
				bindPendingEventDelegates() {
					const self = this;
					Tools.each(self._pendingNativeEvents, (name$1) => {
						bindEventDelegate(self, name$1);
					});
				},
				toggleNativeEvent(name$1, state) {
					const self = this;
					if (name$1 === "focus" || name$1 === "blur") return;
					if (self.removed) return;
					if (state) if (self.initialized) bindEventDelegate(self, name$1);
					else if (!self._pendingNativeEvents) self._pendingNativeEvents = [name$1];
					else self._pendingNativeEvents.push(name$1);
					else if (self.initialized && self.delegates) {
						self.dom.unbind(getEventTarget(self, name$1), name$1, self.delegates[name$1]);
						delete self.delegates[name$1];
					}
				},
				unbindAllNativeEvents() {
					const self = this;
					const body = self.getBody();
					const dom$1 = self.dom;
					if (self.delegates) {
						each$d(self.delegates, (value$3, name$1) => {
							self.dom.unbind(getEventTarget(self, name$1), name$1, value$3);
						});
						delete self.delegates;
					}
					if (!self.inline && body && dom$1) {
						body.onload = null;
						dom$1.unbind(self.getWin());
						dom$1.unbind(self.getDoc());
					}
					if (dom$1) {
						dom$1.unbind(body);
						dom$1.unbind(self.getContainer());
					}
				}
			};
			const stringListProcessor = (value$3) => {
				if (isString(value$3)) return {
					value: value$3.split(/[ ,]/),
					valid: true
				};
				else if (isArrayOf(value$3, isString)) return {
					value: value$3,
					valid: true
				};
				else return {
					valid: false,
					message: `The value must be a string[] or a comma/space separated string.`
				};
			};
			const getBuiltInProcessor = (type$2) => {
				const validator = (() => {
					switch (type$2) {
						case "array": return isArray$1;
						case "boolean": return isBoolean;
						case "function": return isFunction;
						case "number": return isNumber;
						case "object": return isObject;
						case "string": return isString;
						case "string[]": return stringListProcessor;
						case "object[]": return (val) => isArrayOf(val, isObject);
						case "regexp": return (val) => is$4(val, RegExp);
						default: return always;
					}
				})();
				return (value$3) => processValue(value$3, validator, `The value must be a ${type$2}.`);
			};
			const isBuiltInSpec = (spec) => isString(spec.processor);
			const getErrorMessage = (message, result) => {
				return message + (isEmpty$3(result.message) ? "" : `. ${result.message}`);
			};
			const isValidResult = (result) => result.valid;
			const processValue = (value$3, processor, message = "") => {
				const result = processor(value$3);
				if (isBoolean(result)) return result ? {
					value: value$3,
					valid: true
				} : {
					valid: false,
					message
				};
				else return result;
			};
			const processDefaultValue = (name$1, defaultValue, processor) => {
				if (!isUndefined(defaultValue)) {
					const result = processValue(defaultValue, processor);
					if (isValidResult(result)) return result.value;
					else console.error(getErrorMessage(`Invalid default value passed for the "${name$1}" option`, result));
				}
			};
			const create$5 = (editor, initialOptions) => {
				const registry$1 = {};
				const values$1 = {};
				const setValue = (name$1, value$3, processor) => {
					const result = processValue(value$3, processor);
					if (isValidResult(result)) {
						values$1[name$1] = result.value;
						return true;
					} else {
						console.warn(getErrorMessage(`Invalid value passed for the ${name$1} option`, result));
						return false;
					}
				};
				const register$8 = (name$1, spec) => {
					const processor = isBuiltInSpec(spec) ? getBuiltInProcessor(spec.processor) : spec.processor;
					const defaultValue = processDefaultValue(name$1, spec.default, processor);
					registry$1[name$1] = {
						...spec,
						default: defaultValue,
						processor
					};
					get$a(values$1, name$1).orThunk(() => get$a(initialOptions, name$1)).each((value$3) => setValue(name$1, value$3, processor));
				};
				const isRegistered = (name$1) => has$2(registry$1, name$1);
				const get$10 = (name$1) => get$a(values$1, name$1).orThunk(() => get$a(registry$1, name$1).map((spec) => spec.default)).getOrUndefined();
				const set$4 = (name$1, value$3) => {
					if (!isRegistered(name$1)) {
						console.warn(`"${name$1}" is not a registered option. Ensure the option has been registered before setting a value.`);
						return false;
					} else {
						const spec = registry$1[name$1];
						if (spec.immutable) {
							console.error(`"${name$1}" is an immutable option and cannot be updated`);
							return false;
						} else return setValue(name$1, value$3, spec.processor);
					}
				};
				const unset = (name$1) => {
					const registered = isRegistered(name$1);
					if (registered) delete values$1[name$1];
					return registered;
				};
				const isSet = (name$1) => has$2(values$1, name$1);
				return {
					register: register$8,
					isRegistered,
					get: get$10,
					set: set$4,
					unset,
					isSet
				};
			};
			const defaultModes = ["design", "readonly"];
			const switchToMode = (editor, activeMode, availableModes, mode) => {
				const oldMode = availableModes[activeMode.get()];
				const newMode = availableModes[mode];
				try {
					newMode.activate();
				} catch (e) {
					console.error(`problem while activating editor mode ${mode}:`, e);
					return;
				}
				oldMode.deactivate();
				if (oldMode.editorReadOnly !== newMode.editorReadOnly) toggleReadOnly(editor, newMode.editorReadOnly);
				activeMode.set(mode);
				fireSwitchMode(editor, mode);
			};
			const setMode = (editor, availableModes, activeMode, mode) => {
				if (mode === activeMode.get()) return;
				else if (!has$2(availableModes, mode)) throw new Error(`Editor mode '${mode}' is invalid`);
				if (editor.initialized) switchToMode(editor, activeMode, availableModes, mode);
				else editor.on("init", () => switchToMode(editor, activeMode, availableModes, mode));
			};
			const registerMode = (availableModes, mode, api$2) => {
				if (contains$2(defaultModes, mode)) throw new Error(`Cannot override default mode ${mode}`);
				return {
					...availableModes,
					[mode]: {
						...api$2,
						deactivate: () => {
							try {
								api$2.deactivate();
							} catch (e) {
								console.error(`problem while deactivating editor mode ${mode}:`, e);
							}
						}
					}
				};
			};
			const create$4 = (editor) => {
				const activeMode = Cell("design");
				const availableModes = Cell({
					design: {
						activate: noop,
						deactivate: noop,
						editorReadOnly: false
					},
					readonly: {
						activate: noop,
						deactivate: noop,
						editorReadOnly: true
					}
				});
				registerReadOnlyContentFilters(editor);
				registerReadOnlySelectionBlockers(editor);
				return {
					isReadOnly: () => isReadOnly(editor),
					set: (mode) => setMode(editor, availableModes.get(), activeMode, mode),
					get: () => activeMode.get(),
					register: (mode, api$2) => {
						availableModes.set(registerMode(availableModes.get(), mode, api$2));
					}
				};
			};
			const each$2 = Tools.each, explode = Tools.explode;
			const keyCodeLookup = {
				f1: 112,
				f2: 113,
				f3: 114,
				f4: 115,
				f5: 116,
				f6: 117,
				f7: 118,
				f8: 119,
				f9: 120,
				f10: 121,
				f11: 122,
				f12: 123
			};
			const modifierNames = Tools.makeMap("alt,ctrl,shift,meta,access");
			const isModifier = (key) => key in modifierNames;
			const parseShortcut = (pattern) => {
				const shortcut = {};
				const isMac = Env.os.isMacOS() || Env.os.isiOS();
				each$2(explode(pattern.toLowerCase(), "+"), (value$3) => {
					if (isModifier(value$3)) shortcut[value$3] = true;
					else if (/^[0-9]{2,}$/.test(value$3)) shortcut.keyCode = parseInt(value$3, 10);
					else {
						shortcut.charCode = value$3.charCodeAt(0);
						shortcut.keyCode = keyCodeLookup[value$3] || value$3.toUpperCase().charCodeAt(0);
					}
				});
				const id = [shortcut.keyCode];
				let key;
				for (key in modifierNames) if (shortcut[key]) id.push(key);
				else shortcut[key] = false;
				shortcut.id = id.join(",");
				if (shortcut.access) {
					shortcut.alt = true;
					if (isMac) shortcut.ctrl = true;
					else shortcut.shift = true;
				}
				if (shortcut.meta) if (isMac) shortcut.meta = true;
				else {
					shortcut.ctrl = true;
					shortcut.meta = false;
				}
				return shortcut;
			};
			class Shortcuts {
				constructor(editor) {
					this.shortcuts = {};
					this.pendingPatterns = [];
					this.editor = editor;
					const self = this;
					editor.on("keyup keypress keydown", (e) => {
						if ((self.hasModifier(e) || self.isFunctionKey(e)) && !e.isDefaultPrevented()) {
							each$2(self.shortcuts, (shortcut) => {
								if (self.matchShortcut(e, shortcut)) {
									self.pendingPatterns = shortcut.subpatterns.slice(0);
									if (e.type === "keydown") self.executeShortcutAction(shortcut);
								}
							});
							if (self.matchShortcut(e, self.pendingPatterns[0])) {
								if (self.pendingPatterns.length === 1) {
									if (e.type === "keydown") self.executeShortcutAction(self.pendingPatterns[0]);
								}
								self.pendingPatterns.shift();
							}
						}
					});
				}
				add(pattern, desc, cmdFunc, scope) {
					const self = this;
					const func = self.normalizeCommandFunc(cmdFunc);
					each$2(explode(Tools.trim(pattern)), (pattern$1) => {
						const shortcut = self.createShortcut(pattern$1, desc, func, scope);
						self.shortcuts[shortcut.id] = shortcut;
					});
					return true;
				}
				remove(pattern) {
					const shortcut = this.createShortcut(pattern);
					if (this.shortcuts[shortcut.id]) {
						delete this.shortcuts[shortcut.id];
						return true;
					}
					return false;
				}
				normalizeCommandFunc(cmdFunc) {
					const self = this;
					const cmd = cmdFunc;
					if (typeof cmd === "string") return () => {
						self.editor.execCommand(cmd, false, null);
					};
					else if (Tools.isArray(cmd)) return () => {
						self.editor.execCommand(cmd[0], cmd[1], cmd[2]);
					};
					else return cmd;
				}
				createShortcut(pattern, desc, cmdFunc, scope) {
					const shortcuts = Tools.map(explode(pattern, ">"), parseShortcut);
					shortcuts[shortcuts.length - 1] = Tools.extend(shortcuts[shortcuts.length - 1], {
						func: cmdFunc,
						scope: scope || this.editor
					});
					return Tools.extend(shortcuts[0], {
						desc: this.editor.translate(desc),
						subpatterns: shortcuts.slice(1)
					});
				}
				hasModifier(e) {
					return e.altKey || e.ctrlKey || e.metaKey;
				}
				isFunctionKey(e) {
					return e.type === "keydown" && e.keyCode >= 112 && e.keyCode <= 123;
				}
				matchShortcut(e, shortcut) {
					if (!shortcut) return false;
					if (shortcut.ctrl !== e.ctrlKey || shortcut.meta !== e.metaKey) return false;
					if (shortcut.alt !== e.altKey || shortcut.shift !== e.shiftKey) return false;
					if (e.keyCode === shortcut.keyCode || e.charCode && e.charCode === shortcut.charCode) {
						e.preventDefault();
						return true;
					}
					return false;
				}
				executeShortcutAction(shortcut) {
					return shortcut.func ? shortcut.func.call(shortcut.scope) : null;
				}
			}
			const create$3 = () => {
				const buttons = {};
				const menuItems = {};
				const popups = {};
				const icons = {};
				const contextMenus = {};
				const contextToolbars = {};
				const sidebars = {};
				const views = {};
				const add$5 = (collection, type$2) => (name$1, spec) => {
					collection[name$1.toLowerCase()] = {
						...spec,
						type: type$2
					};
				};
				const addIcon = (name$1, svgData) => icons[name$1.toLowerCase()] = svgData;
				return {
					addButton: add$5(buttons, "button"),
					addGroupToolbarButton: add$5(buttons, "grouptoolbarbutton"),
					addToggleButton: add$5(buttons, "togglebutton"),
					addMenuButton: add$5(buttons, "menubutton"),
					addSplitButton: add$5(buttons, "splitbutton"),
					addMenuItem: add$5(menuItems, "menuitem"),
					addNestedMenuItem: add$5(menuItems, "nestedmenuitem"),
					addToggleMenuItem: add$5(menuItems, "togglemenuitem"),
					addAutocompleter: add$5(popups, "autocompleter"),
					addContextMenu: add$5(contextMenus, "contextmenu"),
					addContextToolbar: add$5(contextToolbars, "contexttoolbar"),
					addContextForm: add$5(contextToolbars, "contextform"),
					addSidebar: add$5(sidebars, "sidebar"),
					addView: add$5(views, "views"),
					addIcon,
					getAll: () => ({
						buttons,
						menuItems,
						icons,
						popups,
						contextMenus,
						contextToolbars,
						sidebars,
						views
					})
				};
			};
			const registry = () => {
				const bridge = create$3();
				return {
					addAutocompleter: bridge.addAutocompleter,
					addButton: bridge.addButton,
					addContextForm: bridge.addContextForm,
					addContextMenu: bridge.addContextMenu,
					addContextToolbar: bridge.addContextToolbar,
					addIcon: bridge.addIcon,
					addMenuButton: bridge.addMenuButton,
					addMenuItem: bridge.addMenuItem,
					addNestedMenuItem: bridge.addNestedMenuItem,
					addSidebar: bridge.addSidebar,
					addSplitButton: bridge.addSplitButton,
					addToggleButton: bridge.addToggleButton,
					addGroupToolbarButton: bridge.addGroupToolbarButton,
					addToggleMenuItem: bridge.addToggleMenuItem,
					addView: bridge.addView,
					getAll: bridge.getAll
				};
			};
			const DOM$1 = DOMUtils.DOM;
			const extend = Tools.extend, each$1 = Tools.each;
			class Editor {
				constructor(id, options, editorManager) {
					this.plugins = {};
					this.contentCSS = [];
					this.contentStyles = [];
					this.loadedCSS = {};
					this.isNotDirty = false;
					this.composing = false;
					this.destroyed = false;
					this.hasHiddenInput = false;
					this.iframeElement = null;
					this.initialized = false;
					this.readonly = false;
					this.removed = false;
					this.startContent = "";
					this._pendingNativeEvents = [];
					this._skinLoaded = false;
					this._editableRoot = true;
					this.editorManager = editorManager;
					this.documentBaseUrl = editorManager.documentBaseURL;
					extend(this, EditorObservable);
					const self = this;
					this.id = id;
					this.hidden = false;
					const normalizedOptions = normalizeOptions(editorManager.defaultOptions, options);
					this.options = create$5(self, normalizedOptions);
					register$7(self);
					const getOption$1 = this.options.get;
					if (getOption$1("deprecation_warnings")) logWarnings(options, normalizedOptions);
					const suffix = getOption$1("suffix");
					if (suffix) editorManager.suffix = suffix;
					this.suffix = editorManager.suffix;
					const baseUrl = getOption$1("base_url");
					if (baseUrl) editorManager._setBaseUrl(baseUrl);
					this.baseUri = editorManager.baseURI;
					const referrerPolicy = getReferrerPolicy(self);
					if (referrerPolicy) {
						ScriptLoader.ScriptLoader._setReferrerPolicy(referrerPolicy);
						DOMUtils.DOM.styleSheetLoader._setReferrerPolicy(referrerPolicy);
					}
					const contentCssCors = hasContentCssCors(self);
					if (isNonNullable(contentCssCors)) DOMUtils.DOM.styleSheetLoader._setContentCssCors(contentCssCors);
					AddOnManager.languageLoad = getOption$1("language_load");
					AddOnManager.baseURL = editorManager.baseURL;
					this.setDirty(false);
					this.documentBaseURI = new URI(getDocumentBaseUrl(self), { base_uri: this.baseUri });
					this.baseURI = this.baseUri;
					this.inline = isInline(self);
					this.hasVisual = isVisualAidsEnabled(self);
					this.shortcuts = new Shortcuts(this);
					this.editorCommands = new EditorCommands(this);
					registerCommands(this);
					const cacheSuffix = getOption$1("cache_suffix");
					if (cacheSuffix) Env.cacheSuffix = cacheSuffix.replace(/^[\?\&]+/, "");
					this.ui = {
						registry: registry(),
						styleSheetLoader: void 0,
						show: noop,
						hide: noop,
						setEnabled: noop,
						isEnabled: always
					};
					this.mode = create$4(self);
					editorManager.dispatch("SetupEditor", { editor: this });
					const setupCallback = getSetupCallback(self);
					if (isFunction(setupCallback)) setupCallback.call(self, self);
				}
				render() {
					render(this);
				}
				focus(skipFocus) {
					this.execCommand("mceFocus", false, skipFocus);
				}
				hasFocus() {
					return hasFocus(this);
				}
				translate(text$1) {
					return I18n.translate(text$1);
				}
				getParam(name$1, defaultVal, type$2) {
					const options = this.options;
					if (!options.isRegistered(name$1)) if (isNonNullable(type$2)) options.register(name$1, {
						processor: type$2,
						default: defaultVal
					});
					else options.register(name$1, {
						processor: always,
						default: defaultVal
					});
					return !options.isSet(name$1) && !isUndefined(defaultVal) ? defaultVal : options.get(name$1);
				}
				hasPlugin(name$1, loaded) {
					if (contains$2(getPlugins(this), name$1)) return loaded ? PluginManager.get(name$1) !== void 0 : true;
					else return false;
				}
				nodeChanged(args) {
					this._nodeChangeDispatcher.nodeChanged(args);
				}
				addCommand(name$1, callback, scope) {
					this.editorCommands.addCommand(name$1, callback, scope);
				}
				addQueryStateHandler(name$1, callback, scope) {
					this.editorCommands.addQueryStateHandler(name$1, callback, scope);
				}
				addQueryValueHandler(name$1, callback, scope) {
					this.editorCommands.addQueryValueHandler(name$1, callback, scope);
				}
				addShortcut(pattern, desc, cmdFunc, scope) {
					this.shortcuts.add(pattern, desc, cmdFunc, scope);
				}
				execCommand(cmd, ui, value$3, args) {
					return this.editorCommands.execCommand(cmd, ui, value$3, args);
				}
				queryCommandState(cmd) {
					return this.editorCommands.queryCommandState(cmd);
				}
				queryCommandValue(cmd) {
					return this.editorCommands.queryCommandValue(cmd);
				}
				queryCommandSupported(cmd) {
					return this.editorCommands.queryCommandSupported(cmd);
				}
				show() {
					const self = this;
					if (self.hidden) {
						self.hidden = false;
						if (self.inline) self.getBody().contentEditable = "true";
						else {
							DOM$1.show(self.getContainer());
							DOM$1.hide(self.id);
						}
						self.load();
						self.dispatch("show");
					}
				}
				hide() {
					const self = this;
					if (!self.hidden) {
						self.save();
						if (self.inline) {
							self.getBody().contentEditable = "false";
							if (self === self.editorManager.focusedEditor) self.editorManager.focusedEditor = null;
						} else {
							DOM$1.hide(self.getContainer());
							DOM$1.setStyle(self.id, "display", self.orgDisplay);
						}
						self.hidden = true;
						self.dispatch("hide");
					}
				}
				isHidden() {
					return this.hidden;
				}
				setProgressState(state, time) {
					this.dispatch("ProgressState", {
						state,
						time
					});
				}
				load(args = {}) {
					const self = this;
					const elm = self.getElement();
					if (self.removed) return "";
					if (elm) {
						const loadArgs = {
							...args,
							load: true
						};
						const value$3 = isTextareaOrInput(elm) ? elm.value : elm.innerHTML;
						const html$2 = self.setContent(value$3, loadArgs);
						if (!loadArgs.no_events) self.dispatch("LoadContent", {
							...loadArgs,
							element: elm
						});
						return html$2;
					} else return "";
				}
				save(args = {}) {
					const self = this;
					let elm = self.getElement();
					if (!elm || !self.initialized || self.removed) return "";
					const getArgs = {
						...args,
						save: true,
						element: elm
					};
					let html$2 = self.getContent(getArgs);
					const saveArgs = {
						...getArgs,
						content: html$2
					};
					if (!saveArgs.no_events) self.dispatch("SaveContent", saveArgs);
					if (saveArgs.format === "raw") self.dispatch("RawSaveContent", saveArgs);
					html$2 = saveArgs.content;
					if (!isTextareaOrInput(elm)) {
						if (args.is_removing || !self.inline) elm.innerHTML = html$2;
						const form = DOM$1.getParent(self.id, "form");
						if (form) each$1(form.elements, (elm$1) => {
							if (elm$1.name === self.id) {
								elm$1.value = html$2;
								return false;
							} else return true;
						});
					} else elm.value = html$2;
					saveArgs.element = getArgs.element = elm = null;
					if (saveArgs.set_dirty !== false) self.setDirty(false);
					return html$2;
				}
				setContent(content, args) {
					return setContent(this, content, args);
				}
				getContent(args) {
					return getContent(this, args);
				}
				insertContent(content, args) {
					if (args) content = extend({ content }, args);
					this.execCommand("mceInsertContent", false, content);
				}
				resetContent(initialContent) {
					if (initialContent === void 0) setContent(this, this.startContent, { format: "raw" });
					else setContent(this, initialContent);
					this.undoManager.reset();
					this.setDirty(false);
					this.nodeChanged();
				}
				isDirty() {
					return !this.isNotDirty;
				}
				setDirty(state) {
					const oldState = !this.isNotDirty;
					this.isNotDirty = !state;
					if (state && state !== oldState) this.dispatch("dirty");
				}
				getContainer() {
					const self = this;
					if (!self.container) self.container = self.editorContainer || DOM$1.get(self.id + "_parent");
					return self.container;
				}
				getContentAreaContainer() {
					return this.contentAreaContainer;
				}
				getElement() {
					if (!this.targetElm) this.targetElm = DOM$1.get(this.id);
					return this.targetElm;
				}
				getWin() {
					const self = this;
					if (!self.contentWindow) {
						const elm = self.iframeElement;
						if (elm) self.contentWindow = elm.contentWindow;
					}
					return self.contentWindow;
				}
				getDoc() {
					const self = this;
					if (!self.contentDocument) {
						const win = self.getWin();
						if (win) self.contentDocument = win.document;
					}
					return self.contentDocument;
				}
				getBody() {
					var _a, _b;
					const doc = this.getDoc();
					return (_b = (_a = this.bodyElement) !== null && _a !== void 0 ? _a : doc === null || doc === void 0 ? void 0 : doc.body) !== null && _b !== void 0 ? _b : null;
				}
				convertURL(url, name$1, elm) {
					const self = this, getOption$1 = self.options.get;
					const urlConverterCallback = getUrlConverterCallback(self);
					if (isFunction(urlConverterCallback)) return urlConverterCallback.call(self, url, elm, true, name$1);
					if (!getOption$1("convert_urls") || elm === "link" || isObject(elm) && elm.nodeName === "LINK" || url.indexOf("file:") === 0 || url.length === 0) return url;
					if (getOption$1("relative_urls")) return self.documentBaseURI.toRelative(url);
					url = self.documentBaseURI.toAbsolute(url, getOption$1("remove_script_host"));
					return url;
				}
				addVisual(elm) {
					addVisual(this, elm);
				}
				setEditableRoot(state) {
					setEditableRoot(this, state);
				}
				hasEditableRoot() {
					return hasEditableRoot(this);
				}
				remove() {
					remove$1(this);
				}
				destroy(automatic) {
					destroy(this, automatic);
				}
				uploadImages() {
					return this.editorUpload.uploadImages();
				}
				_scanForImages() {
					return this.editorUpload.scanForImages();
				}
			}
			const DOM = DOMUtils.DOM;
			const each = Tools.each;
			let boundGlobalEvents = false;
			let beforeUnloadDelegate;
			let editors = [];
			const globalEventDelegate = (e) => {
				const type$2 = e.type;
				each(EditorManager.get(), (editor) => {
					switch (type$2) {
						case "scroll":
							editor.dispatch("ScrollWindow", e);
							break;
						case "resize":
							editor.dispatch("ResizeWindow", e);
							break;
					}
				});
			};
			const toggleGlobalEvents = (state) => {
				if (state !== boundGlobalEvents) {
					const DOM$10 = DOMUtils.DOM;
					if (state) {
						DOM$10.bind(window, "resize", globalEventDelegate);
						DOM$10.bind(window, "scroll", globalEventDelegate);
					} else {
						DOM$10.unbind(window, "resize", globalEventDelegate);
						DOM$10.unbind(window, "scroll", globalEventDelegate);
					}
					boundGlobalEvents = state;
				}
			};
			const removeEditorFromList = (targetEditor) => {
				const oldEditors = editors;
				editors = filter$5(editors, (editor) => {
					return targetEditor !== editor;
				});
				if (EditorManager.activeEditor === targetEditor) EditorManager.activeEditor = editors.length > 0 ? editors[0] : null;
				if (EditorManager.focusedEditor === targetEditor) EditorManager.focusedEditor = null;
				return oldEditors.length !== editors.length;
			};
			const purgeDestroyedEditor = (editor) => {
				if (editor && editor.initialized && !(editor.getContainer() || editor.getBody()).parentNode) {
					removeEditorFromList(editor);
					editor.unbindAllNativeEvents();
					editor.destroy(true);
					editor.removed = true;
				}
			};
			const isQuirksMode = document.compatMode !== "CSS1Compat";
			const EditorManager = {
				...Observable,
				baseURI: null,
				baseURL: null,
				defaultOptions: {},
				documentBaseURL: null,
				suffix: null,
				majorVersion: "6",
				minorVersion: "7.0",
				releaseDate: "2023-08-30",
				i18n: I18n,
				activeEditor: null,
				focusedEditor: null,
				setup() {
					const self = this;
					let baseURL = "";
					let suffix = "";
					let documentBaseURL = URI.getDocumentBaseUrl(document.location);
					if (/^[^:]+:\/\/\/?[^\/]+\//.test(documentBaseURL)) {
						documentBaseURL = documentBaseURL.replace(/[\?#].*$/, "").replace(/[\/\\][^\/]+$/, "");
						if (!/[\/\\]$/.test(documentBaseURL)) documentBaseURL += "/";
					}
					const preInit$1 = window.tinymce || window.tinyMCEPreInit;
					if (preInit$1) {
						baseURL = preInit$1.base || preInit$1.baseURL;
						suffix = preInit$1.suffix;
					} else {
						const scripts = document.getElementsByTagName("script");
						for (let i = 0; i < scripts.length; i++) {
							const src = scripts[i].src || "";
							if (src === "") continue;
							const srcScript = src.substring(src.lastIndexOf("/"));
							if (/tinymce(\.full|\.jquery|)(\.min|\.dev|)\.js/.test(src)) {
								if (srcScript.indexOf(".min") !== -1) suffix = ".min";
								baseURL = src.substring(0, src.lastIndexOf("/"));
								break;
							}
						}
						if (!baseURL && document.currentScript) {
							const src = document.currentScript.src;
							if (src.indexOf(".min") !== -1) suffix = ".min";
							baseURL = src.substring(0, src.lastIndexOf("/"));
						}
					}
					self.baseURL = new URI(documentBaseURL).toAbsolute(baseURL);
					self.documentBaseURL = documentBaseURL;
					self.baseURI = new URI(self.baseURL);
					self.suffix = suffix;
					setup$v(self);
				},
				overrideDefaults(defaultOptions) {
					const baseUrl = defaultOptions.base_url;
					if (baseUrl) this._setBaseUrl(baseUrl);
					const suffix = defaultOptions.suffix;
					if (suffix) this.suffix = suffix;
					this.defaultOptions = defaultOptions;
					const pluginBaseUrls = defaultOptions.plugin_base_urls;
					if (pluginBaseUrls !== void 0) each$d(pluginBaseUrls, (pluginBaseUrl, pluginName) => {
						AddOnManager.PluginManager.urls[pluginName] = pluginBaseUrl;
					});
				},
				init(options) {
					const self = this;
					let result;
					const invalidInlineTargets = Tools.makeMap("area base basefont br col frame hr img input isindex link meta param embed source wbr track colgroup option table tbody tfoot thead tr th td script noscript style textarea video audio iframe object menu", " ");
					const isInvalidInlineTarget = (options$1, elm) => options$1.inline && elm.tagName.toLowerCase() in invalidInlineTargets;
					const createId = (elm) => {
						let id = elm.id;
						if (!id) {
							id = get$a(elm, "name").filter((name$1) => !DOM.get(name$1)).getOrThunk(DOM.uniqueId);
							elm.setAttribute("id", id);
						}
						return id;
					};
					const execCallback = (name$1) => {
						const callback = options[name$1];
						if (!callback) return;
						return callback.apply(self, []);
					};
					const findTargets = (options$1) => {
						if (Env.browser.isIE() || Env.browser.isEdge()) {
							initError("TinyMCE does not support the browser you are using. For a list of supported browsers please see: https://www.tiny.cloud/docs/tinymce/6/support/#supportedwebbrowsers");
							return [];
						} else if (isQuirksMode) {
							initError("Failed to initialize the editor as the document is not in standards mode. TinyMCE requires standards mode.");
							return [];
						} else if (isString(options$1.selector)) return DOM.select(options$1.selector);
						else if (isNonNullable(options$1.target)) return [options$1.target];
						else return [];
					};
					let provideResults = (editors$1) => {
						result = editors$1;
					};
					const initEditors = () => {
						let initCount = 0;
						const editors$1 = [];
						let targets;
						const createEditor = (id, options$1, targetElm) => {
							const editor = new Editor(id, options$1, self);
							editors$1.push(editor);
							editor.on("init", () => {
								if (++initCount === targets.length) provideResults(editors$1);
							});
							editor.targetElm = editor.targetElm || targetElm;
							editor.render();
						};
						DOM.unbind(window, "ready", initEditors);
						execCallback("onpageload");
						targets = unique$1(findTargets(options));
						Tools.each(targets, (elm) => {
							purgeDestroyedEditor(self.get(elm.id));
						});
						targets = Tools.grep(targets, (elm) => {
							return !self.get(elm.id);
						});
						if (targets.length === 0) provideResults([]);
						else each(targets, (elm) => {
							if (isInvalidInlineTarget(options, elm)) initError("Could not initialize inline editor on invalid inline target element", elm);
							else createEditor(createId(elm), options, elm);
						});
					};
					DOM.bind(window, "ready", initEditors);
					return new Promise((resolve$4) => {
						if (result) resolve$4(result);
						else provideResults = (editors$1) => {
							resolve$4(editors$1);
						};
					});
				},
				get(id) {
					if (arguments.length === 0) return editors.slice(0);
					else if (isString(id)) return find$2(editors, (editor) => {
						return editor.id === id;
					}).getOr(null);
					else if (isNumber(id)) return editors[id] ? editors[id] : null;
					else return null;
				},
				add(editor) {
					const self = this;
					const existingEditor = self.get(editor.id);
					if (existingEditor === editor) return editor;
					if (existingEditor === null) editors.push(editor);
					toggleGlobalEvents(true);
					self.activeEditor = editor;
					self.dispatch("AddEditor", { editor });
					if (!beforeUnloadDelegate) {
						beforeUnloadDelegate = (e) => {
							const event = self.dispatch("BeforeUnload");
							if (event.returnValue) {
								e.preventDefault();
								e.returnValue = event.returnValue;
								return event.returnValue;
							}
						};
						window.addEventListener("beforeunload", beforeUnloadDelegate);
					}
					return editor;
				},
				createEditor(id, options) {
					return this.add(new Editor(id, options, this));
				},
				remove(selector) {
					const self = this;
					let editor;
					if (!selector) {
						for (let i = editors.length - 1; i >= 0; i--) self.remove(editors[i]);
						return;
					}
					if (isString(selector)) {
						each(DOM.select(selector), (elm) => {
							editor = self.get(elm.id);
							if (editor) self.remove(editor);
						});
						return;
					}
					editor = selector;
					if (isNull(self.get(editor.id))) return null;
					if (removeEditorFromList(editor)) self.dispatch("RemoveEditor", { editor });
					if (editors.length === 0) window.removeEventListener("beforeunload", beforeUnloadDelegate);
					editor.remove();
					toggleGlobalEvents(editors.length > 0);
					return editor;
				},
				execCommand(cmd, ui, value$3) {
					var _a;
					const self = this;
					const editorId = isObject(value$3) ? (_a = value$3.id) !== null && _a !== void 0 ? _a : value$3.index : value$3;
					switch (cmd) {
						case "mceAddEditor":
							if (!self.get(editorId)) {
								const editorOptions = value$3.options;
								new Editor(editorId, editorOptions, self).render();
							}
							return true;
						case "mceRemoveEditor": {
							const editor = self.get(editorId);
							if (editor) editor.remove();
							return true;
						}
						case "mceToggleEditor": {
							const editor = self.get(editorId);
							if (!editor) {
								self.execCommand("mceAddEditor", false, value$3);
								return true;
							}
							if (editor.isHidden()) editor.show();
							else editor.hide();
							return true;
						}
					}
					if (self.activeEditor) return self.activeEditor.execCommand(cmd, ui, value$3);
					return false;
				},
				triggerSave: () => {
					each(editors, (editor) => {
						editor.save();
					});
				},
				addI18n: (code, items) => {
					I18n.add(code, items);
				},
				translate: (text$1) => {
					return I18n.translate(text$1);
				},
				setActive(editor) {
					const activeEditor = this.activeEditor;
					if (this.activeEditor !== editor) {
						if (activeEditor) activeEditor.dispatch("deactivate", { relatedTarget: editor });
						editor.dispatch("activate", { relatedTarget: activeEditor });
					}
					this.activeEditor = editor;
				},
				_setBaseUrl(baseUrl) {
					this.baseURL = new URI(this.documentBaseURL).toAbsolute(baseUrl.replace(/\/+$/, ""));
					this.baseURI = new URI(this.baseURL);
				}
			};
			EditorManager.setup();
			const setup = () => {
				const dataValue = value$2();
				const FakeClipboardItem = (items) => ({
					items,
					types: keys(items),
					getType: (type$2) => get$a(items, type$2).getOrUndefined()
				});
				const write$1 = (data$1) => {
					dataValue.set(data$1);
				};
				const read$5 = () => dataValue.get().getOrUndefined();
				return {
					FakeClipboardItem,
					write: write$1,
					read: read$5,
					clear: dataValue.clear
				};
			};
			const FakeClipboard = setup();
			const min = Math.min, max = Math.max, round = Math.round;
			const relativePosition = (rect, targetRect, rel) => {
				let x = targetRect.x;
				let y = targetRect.y;
				const w = rect.w;
				const h = rect.h;
				const targetW = targetRect.w;
				const targetH = targetRect.h;
				const relChars = (rel || "").split("");
				if (relChars[0] === "b") y += targetH;
				if (relChars[1] === "r") x += targetW;
				if (relChars[0] === "c") y += round(targetH / 2);
				if (relChars[1] === "c") x += round(targetW / 2);
				if (relChars[3] === "b") y -= h;
				if (relChars[4] === "r") x -= w;
				if (relChars[3] === "c") y -= round(h / 2);
				if (relChars[4] === "c") x -= round(w / 2);
				return create$2(x, y, w, h);
			};
			const findBestRelativePosition = (rect, targetRect, constrainRect, rels) => {
				for (let i = 0; i < rels.length; i++) {
					const pos = relativePosition(rect, targetRect, rels[i]);
					if (pos.x >= constrainRect.x && pos.x + pos.w <= constrainRect.w + constrainRect.x && pos.y >= constrainRect.y && pos.y + pos.h <= constrainRect.h + constrainRect.y) return rels[i];
				}
				return null;
			};
			const inflate = (rect, w, h) => {
				return create$2(rect.x - w, rect.y - h, rect.w + w * 2, rect.h + h * 2);
			};
			const intersect = (rect, cropRect) => {
				const x1 = max(rect.x, cropRect.x);
				const y1 = max(rect.y, cropRect.y);
				const x2 = min(rect.x + rect.w, cropRect.x + cropRect.w);
				const y2 = min(rect.y + rect.h, cropRect.y + cropRect.h);
				if (x2 - x1 < 0 || y2 - y1 < 0) return null;
				return create$2(x1, y1, x2 - x1, y2 - y1);
			};
			const clamp = (rect, clampRect, fixedSize) => {
				let x1 = rect.x;
				let y1 = rect.y;
				let x2 = rect.x + rect.w;
				let y2 = rect.y + rect.h;
				const cx2 = clampRect.x + clampRect.w;
				const cy2 = clampRect.y + clampRect.h;
				const underflowX1 = max(0, clampRect.x - x1);
				const underflowY1 = max(0, clampRect.y - y1);
				const overflowX2 = max(0, x2 - cx2);
				const overflowY2 = max(0, y2 - cy2);
				x1 += underflowX1;
				y1 += underflowY1;
				if (fixedSize) {
					x2 += underflowX1;
					y2 += underflowY1;
					x1 -= overflowX2;
					y1 -= overflowY2;
				}
				x2 -= overflowX2;
				y2 -= overflowY2;
				return create$2(x1, y1, x2 - x1, y2 - y1);
			};
			const create$2 = (x, y, w, h) => {
				return {
					x,
					y,
					w,
					h
				};
			};
			const fromClientRect = (clientRect) => {
				return create$2(clientRect.left, clientRect.top, clientRect.width, clientRect.height);
			};
			const Rect = {
				inflate,
				relativePosition,
				findBestRelativePosition,
				intersect,
				clamp,
				create: create$2,
				fromClientRect
			};
			const awaiter = (resolveCb, rejectCb, timeout = 1e3) => {
				let done = false;
				let timer = null;
				const complete = (completer) => (...args) => {
					if (!done) {
						done = true;
						if (timer !== null) {
							clearTimeout(timer);
							timer = null;
						}
						completer.apply(null, args);
					}
				};
				const resolve$4 = complete(resolveCb);
				const reject = complete(rejectCb);
				const start$2 = (...args) => {
					if (!done && timer === null) timer = setTimeout(() => reject.apply(null, args), timeout);
				};
				return {
					start: start$2,
					resolve: resolve$4,
					reject
				};
			};
			const create$1 = () => {
				const tasks = {};
				const resultFns = {};
				const load = (id, url) => {
					const loadErrMsg = `Script at URL "${url}" failed to load`;
					const runErrMsg = `Script at URL "${url}" did not call \`tinymce.Resource.add('${id}', data)\` within 1 second`;
					if (tasks[id] !== void 0) return tasks[id];
					else {
						const task = new Promise((resolve$4, reject) => {
							const waiter = awaiter(resolve$4, reject);
							resultFns[id] = waiter.resolve;
							ScriptLoader.ScriptLoader.loadScript(url).then(() => waiter.start(runErrMsg), () => waiter.reject(loadErrMsg));
						});
						tasks[id] = task;
						return task;
					}
				};
				const add$5 = (id, data$1) => {
					if (resultFns[id] !== void 0) {
						resultFns[id](data$1);
						delete resultFns[id];
					}
					tasks[id] = Promise.resolve(data$1);
				};
				const unload = (id) => {
					delete tasks[id];
				};
				return {
					load,
					add: add$5,
					unload
				};
			};
			const Resource = create$1();
			const create = () => (() => {
				let data$1 = {};
				let keys$1 = [];
				const storage = {
					getItem: (key) => {
						const item = data$1[key];
						return item ? item : null;
					},
					setItem: (key, value$3) => {
						keys$1.push(key);
						data$1[key] = String(value$3);
					},
					key: (index) => {
						return keys$1[index];
					},
					removeItem: (key) => {
						keys$1 = keys$1.filter((k) => k === key);
						delete data$1[key];
					},
					clear: () => {
						keys$1 = [];
						data$1 = {};
					},
					length: 0
				};
				Object.defineProperty(storage, "length", {
					get: () => keys$1.length,
					configurable: false,
					enumerable: false
				});
				return storage;
			})();
			let localStorage;
			try {
				const test = "__storage_test__";
				localStorage = window.localStorage;
				localStorage.setItem(test, test);
				localStorage.removeItem(test);
			} catch (e) {
				localStorage = create();
			}
			const publicApi = {
				geom: { Rect },
				util: {
					Delay,
					Tools,
					VK,
					URI,
					EventDispatcher,
					Observable,
					I18n,
					LocalStorage: localStorage,
					ImageUploader
				},
				dom: {
					EventUtils,
					TreeWalker: DomTreeWalker,
					TextSeeker,
					DOMUtils,
					ScriptLoader,
					RangeUtils,
					Serializer: DomSerializer,
					StyleSheetLoader,
					ControlSelection,
					BookmarkManager,
					Selection: EditorSelection,
					Event: EventUtils.Event
				},
				html: {
					Styles,
					Entities,
					Node: AstNode,
					Schema,
					DomParser,
					Writer,
					Serializer: HtmlSerializer
				},
				Env,
				AddOnManager,
				Annotator,
				Formatter,
				UndoManager,
				EditorCommands,
				WindowManager,
				NotificationManager,
				EditorObservable,
				Shortcuts,
				Editor,
				FocusManager,
				EditorManager,
				DOM: DOMUtils.DOM,
				ScriptLoader: ScriptLoader.ScriptLoader,
				PluginManager,
				ThemeManager,
				ModelManager,
				IconManager,
				Resource,
				FakeClipboard,
				trim: Tools.trim,
				isArray: Tools.isArray,
				is: Tools.is,
				toArray: Tools.toArray,
				makeMap: Tools.makeMap,
				each: Tools.each,
				map: Tools.map,
				grep: Tools.grep,
				inArray: Tools.inArray,
				extend: Tools.extend,
				walk: Tools.walk,
				resolve: Tools.resolve,
				explode: Tools.explode,
				_addCacheSuffix: Tools._addCacheSuffix
			};
			const tinymce$2 = Tools.extend(EditorManager, publicApi);
			const exportToModuleLoaders = (tinymce$3) => {
				if (typeof module === "object") try {
					module.exports = tinymce$3;
				} catch (_) {}
			};
			const exportToWindowGlobal = (tinymce$3) => {
				window.tinymce = tinymce$3;
				window.tinyMCE = tinymce$3;
			};
			exportToWindowGlobal(tinymce$2);
			exportToModuleLoaders(tinymce$2);
		})();
	}));

//#endregion
//#region node_modules/tinymce/icons/default/icons.js
	var require_icons = /* @__PURE__ */ __commonJSMin((() => {
		tinymce.IconManager.add("default", { icons: {
			"accessibility-check": "<svg width=\"24\" height=\"24\"><path d=\"M12 2a2 2 0 0 1 2 2 2 2 0 0 1-2 2 2 2 0 0 1-2-2c0-1.1.9-2 2-2Zm8 7h-5v12c0 .6-.4 1-1 1a1 1 0 0 1-1-1v-5c0-.6-.4-1-1-1a1 1 0 0 0-1 1v5c0 .6-.4 1-1 1a1 1 0 0 1-1-1V9H4a1 1 0 1 1 0-2h16c.6 0 1 .4 1 1s-.4 1-1 1Z\" fill-rule=\"nonzero\"/></svg>",
			"accordion-toggle": "<svg width=\"24\" height=\"24\"><path fill-rule=\"evenodd\" clip-rule=\"evenodd\" d=\"M12 15c0-.6.4-1 1-1h6c.6 0 1 .4 1 1s-.4 1-1 1h-6a1 1 0 0 1-1-1Z\"/><path opacity=\".2\" fill-rule=\"evenodd\" clip-rule=\"evenodd\" d=\"M4 15c0-.6.4-1 1-1h6c.6 0 1 .4 1 1s-.4 1-1 1H5a1 1 0 0 1-1-1Z\"/><path fill-rule=\"evenodd\" clip-rule=\"evenodd\" d=\"M12 19c0-.6.4-1 1-1h6c.6 0 1 .4 1 1s-.4 1-1 1h-6a1 1 0 0 1-1-1Z\"/><path opacity=\".2\" fill-rule=\"evenodd\" clip-rule=\"evenodd\" d=\"M4 19c0-.6.4-1 1-1h6c.6 0 1 .4 1 1s-.4 1-1 1H5a1 1 0 0 1-1-1Z\"/><path fill-rule=\"evenodd\" clip-rule=\"evenodd\" d=\"M12.3 7.3a1 1 0 0 1 1.4 0L16 9.6l2.3-2.3a1 1 0 1 1 1.4 1.4L16 12.4l-3.7-3.7a1 1 0 0 1 0-1.4ZM4.3 11.7a1 1 0 0 1 0-1.4L6.6 8 4.3 5.7a1 1 0 0 1 1.4-1.4L9.4 8l-3.7 3.7a1 1 0 0 1-1.4 0Z\"/></svg>",
			"accordion": "<svg width=\"24\" height=\"24\"><rect x=\"12\" y=\"7\" width=\"10\" height=\"2\" rx=\"1\"/><rect x=\"12\" y=\"11\" width=\"10\" height=\"2\" rx=\"1\"/><rect x=\"12\" y=\"15\" width=\"6\" height=\"2\" rx=\"1\"/><path fill-rule=\"evenodd\" clip-rule=\"evenodd\" d=\"M2.3 7.3a1 1 0 0 1 1.4 0L6 9.6l2.3-2.3a1 1 0 0 1 1.4 1.4L6 12.4 2.3 8.7a1 1 0 0 1 0-1.4Z\"/></svg>",
			"action-next": "<svg width=\"24\" height=\"24\"><path fill-rule=\"nonzero\" d=\"M5.7 7.3a1 1 0 0 0-1.4 1.4l7.7 7.7 7.7-7.7a1 1 0 1 0-1.4-1.4L12 13.6 5.7 7.3Z\"/></svg>",
			"action-prev": "<svg width=\"24\" height=\"24\"><path fill-rule=\"nonzero\" d=\"M18.3 15.7a1 1 0 0 0 1.4-1.4L12 6.6l-7.7 7.7a1 1 0 0 0 1.4 1.4L12 9.4l6.3 6.3Z\"/></svg>",
			"addtag": "<svg width=\"24\" height=\"24\"><path fill-rule=\"evenodd\" clip-rule=\"evenodd\" d=\"M15 5a2 2 0 0 1 1.6.8L21 12l-4.4 6.2a2 2 0 0 1-1.6.8h-3v-2h3l3.5-5L15 7H5v3H3V7c0-1.1.9-2 2-2h10Z\"/><path fill-rule=\"evenodd\" clip-rule=\"evenodd\" d=\"M6 12a1 1 0 0 0-1 1v2H3a1 1 0 1 0 0 2h2v2a1 1 0 1 0 2 0v-2h2a1 1 0 1 0 0-2H7v-2c0-.6-.4-1-1-1Z\"/></svg>",
			"ai-prompt": "<svg width=\"24\" height=\"24\"><g clip-path=\"url(#a)\"><path fill-rule=\"evenodd\" clip-rule=\"evenodd\" d=\"M15 6.7a1 1 0 0 0-1.4 0l-9.9 10a1 1 0 0 0 0 1.3l2.1 2.1c.4.4 1 .4 1.4 0l10-9.9c.3-.3.3-1 0-1.4l-2.2-2Zm1.4 2.8-2-2-3 2.7 2.2 2.2 2.8-2.9Z\"/><path d=\"m18.5 7.3-.7-1.5-1.5-.8 1.5-.7.7-1.5.7 1.5 1.5.7-1.5.8-.7 1.5ZM18.5 16.5l-.7-1.6-1.5-.7 1.5-.7.7-1.6.7 1.6 1.5.7-1.5.7-.7 1.6ZM9.7 7.3 9 5.8 7.5 5 9 4.3l.7-1.5.7 1.5L12 5l-1.5.8-.7 1.5Z\"/></g><defs><clipPath id=\"a\"><path d=\"M0 0h24v24H0z\"/></clipPath></defs></svg>",
			"ai": "<svg width=\"24\" height=\"24\"><path fill-rule=\"evenodd\" clip-rule=\"evenodd\" d=\"M5 3a3 3 0 0 0-3 3v12a3 3 0 0 0 3 3h14a3 3 0 0 0 3-3V6a3 3 0 0 0-3-3H5Zm6.8 11.5.5 1.2a68.3 68.3 0 0 0 .7 1.1l.4.1c.3 0 .5 0 .7-.3.2-.1.3-.3.3-.6l-.3-1-2.6-6.2a20.4 20.4 0 0 0-.5-1.3l-.5-.4-.7-.2c-.2 0-.5 0-.6.2-.2 0-.4.2-.5.4l-.3.6-.3.7L5.7 15l-.2.6-.1.4c0 .3 0 .5.3.7l.6.2c.3 0 .5 0 .7-.2l.4-1 .5-1.2h3.9ZM9.8 9l1.5 4h-3l1.5-4Zm5.6-.9v7.6c0 .4 0 .7.2 1l.7.2c.3 0 .6 0 .8-.3l.2-.9V8.1c0-.4 0-.7-.2-.9a1 1 0 0 0-.8-.3c-.2 0-.5.1-.7.3l-.2 1Z\"/></svg>",
			"align-center": "<svg width=\"24\" height=\"24\"><path d=\"M5 5h14c.6 0 1 .4 1 1s-.4 1-1 1H5a1 1 0 1 1 0-2Zm3 4h8c.6 0 1 .4 1 1s-.4 1-1 1H8a1 1 0 1 1 0-2Zm0 8h8c.6 0 1 .4 1 1s-.4 1-1 1H8a1 1 0 0 1 0-2Zm-3-4h14c.6 0 1 .4 1 1s-.4 1-1 1H5a1 1 0 0 1 0-2Z\" fill-rule=\"evenodd\"/></svg>",
			"align-justify": "<svg width=\"24\" height=\"24\"><path d=\"M5 5h14c.6 0 1 .4 1 1s-.4 1-1 1H5a1 1 0 1 1 0-2Zm0 4h14c.6 0 1 .4 1 1s-.4 1-1 1H5a1 1 0 1 1 0-2Zm0 4h14c.6 0 1 .4 1 1s-.4 1-1 1H5a1 1 0 0 1 0-2Zm0 4h14c.6 0 1 .4 1 1s-.4 1-1 1H5a1 1 0 0 1 0-2Z\" fill-rule=\"evenodd\"/></svg>",
			"align-left": "<svg width=\"24\" height=\"24\"><path d=\"M5 5h14c.6 0 1 .4 1 1s-.4 1-1 1H5a1 1 0 1 1 0-2Zm0 4h8c.6 0 1 .4 1 1s-.4 1-1 1H5a1 1 0 1 1 0-2Zm0 8h8c.6 0 1 .4 1 1s-.4 1-1 1H5a1 1 0 0 1 0-2Zm0-4h14c.6 0 1 .4 1 1s-.4 1-1 1H5a1 1 0 0 1 0-2Z\" fill-rule=\"evenodd\"/></svg>",
			"align-none": "<svg width=\"24\" height=\"24\"><path d=\"M14.2 5 13 7H5a1 1 0 1 1 0-2h9.2Zm4 0h.8a1 1 0 0 1 0 2h-2l1.2-2Zm-6.4 4-1.2 2H5a1 1 0 0 1 0-2h6.8Zm4 0H19a1 1 0 0 1 0 2h-4.4l1.2-2Zm-6.4 4-1.2 2H5a1 1 0 0 1 0-2h4.4Zm4 0H19a1 1 0 0 1 0 2h-6.8l1.2-2ZM7 17l-1.2 2H5a1 1 0 0 1 0-2h2Zm4 0h8a1 1 0 0 1 0 2H9.8l1.2-2Zm5.2-13.5 1.3.7-9.7 16.3-1.3-.7 9.7-16.3Z\" fill-rule=\"evenodd\"/></svg>",
			"align-right": "<svg width=\"24\" height=\"24\"><path d=\"M5 5h14c.6 0 1 .4 1 1s-.4 1-1 1H5a1 1 0 1 1 0-2Zm6 4h8c.6 0 1 .4 1 1s-.4 1-1 1h-8a1 1 0 0 1 0-2Zm0 8h8c.6 0 1 .4 1 1s-.4 1-1 1h-8a1 1 0 0 1 0-2Zm-6-4h14c.6 0 1 .4 1 1s-.4 1-1 1H5a1 1 0 0 1 0-2Z\" fill-rule=\"evenodd\"/></svg>",
			"arrow-left": "<svg width=\"24\" height=\"24\"><path d=\"m5.6 13 12 6a1 1 0 0 0 1.4-1V6a1 1 0 0 0-1.4-.9l-12 6a1 1 0 0 0 0 1.8Z\" fill-rule=\"evenodd\"/></svg>",
			"arrow-right": "<svg width=\"24\" height=\"24\"><path d=\"m18.5 13-12 6A1 1 0 0 1 5 18V6a1 1 0 0 1 1.4-.9l12 6a1 1 0 0 1 0 1.8Z\" fill-rule=\"evenodd\"/></svg>",
			"bold": "<svg width=\"24\" height=\"24\"><path d=\"M7.8 19c-.3 0-.5 0-.6-.2l-.2-.5V5.7c0-.2 0-.4.2-.5l.6-.2h5c1.5 0 2.7.3 3.5 1 .7.6 1.1 1.4 1.1 2.5a3 3 0 0 1-.6 1.9c-.4.6-1 1-1.6 1.2.4.1.9.3 1.3.6s.8.7 1 1.2c.4.4.5 1 .5 1.6 0 1.3-.4 2.3-1.3 3-.8.7-2.1 1-3.8 1H7.8Zm5-8.3c.6 0 1.2-.1 1.6-.5.4-.3.6-.7.6-1.3 0-1.1-.8-1.7-2.3-1.7H9.3v3.5h3.4Zm.5 6c.7 0 1.3-.1 1.7-.4.4-.4.6-.9.6-1.5s-.2-1-.7-1.4c-.4-.3-1-.4-2-.4H9.4v3.8h4Z\" fill-rule=\"evenodd\"/></svg>",
			"bookmark": "<svg width=\"24\" height=\"24\"><path d=\"M6 4v17l6-4 6 4V4c0-.6-.4-1-1-1H7a1 1 0 0 0-1 1Z\" fill-rule=\"nonzero\"/></svg>",
			"border-style": "<svg width=\"24\" height=\"24\"><g fill-rule=\"evenodd\"><rect width=\"18\" height=\"2\" x=\"3\" y=\"6\" rx=\"1\"/><rect width=\"2.8\" height=\"2\" x=\"3\" y=\"16\" rx=\"1\"/><rect width=\"2.8\" height=\"2\" x=\"6.8\" y=\"16\" rx=\"1\"/><rect width=\"2.8\" height=\"2\" x=\"10.6\" y=\"16\" rx=\"1\"/><rect width=\"2.8\" height=\"2\" x=\"14.4\" y=\"16\" rx=\"1\"/><rect width=\"2.8\" height=\"2\" x=\"18.2\" y=\"16\" rx=\"1\"/><rect width=\"8\" height=\"2\" x=\"3\" y=\"11\" rx=\"1\"/><rect width=\"8\" height=\"2\" x=\"13\" y=\"11\" rx=\"1\"/></g></svg>",
			"border-width": "<svg width=\"24\" height=\"24\"><g fill-rule=\"evenodd\"><rect width=\"18\" height=\"5\" x=\"3\" y=\"5\" rx=\"1\"/><rect width=\"18\" height=\"3.5\" x=\"3\" y=\"11.5\" rx=\"1\"/><rect width=\"18\" height=\"2\" x=\"3\" y=\"17\" rx=\"1\"/></g></svg>",
			"brightness": "<svg width=\"24\" height=\"24\"><path d=\"M12 17c.3 0 .5.1.7.3.2.2.3.4.3.7v1c0 .3-.1.5-.3.7a1 1 0 0 1-.7.3 1 1 0 0 1-.7-.3 1 1 0 0 1-.3-.7v-1c0-.3.1-.5.3-.7.2-.2.4-.3.7-.3Zm0-10a1 1 0 0 1-.7-.3A1 1 0 0 1 11 6V5c0-.3.1-.5.3-.7.2-.2.4-.3.7-.3.3 0 .5.1.7.3.2.2.3.4.3.7v1c0 .3-.1.5-.3.7a1 1 0 0 1-.7.3Zm7 4c.3 0 .5.1.7.3.2.2.3.4.3.7 0 .3-.1.5-.3.7a1 1 0 0 1-.7.3h-1a1 1 0 0 1-.7-.3 1 1 0 0 1-.3-.7c0-.3.1-.5.3-.7.2-.2.4-.3.7-.3h1ZM7 12c0 .3-.1.5-.3.7a1 1 0 0 1-.7.3H5a1 1 0 0 1-.7-.3A1 1 0 0 1 4 12c0-.3.1-.5.3-.7.2-.2.4-.3.7-.3h1c.3 0 .5.1.7.3.2.2.3.4.3.7Zm10 3.5.7.8c.2.1.3.4.3.6 0 .3-.1.6-.3.8a1 1 0 0 1-.8.3 1 1 0 0 1-.6-.3l-.8-.7a1 1 0 0 1-.3-.8c0-.2.1-.5.3-.7a1 1 0 0 1 1.4 0Zm-10-7-.7-.8a1 1 0 0 1-.3-.6c0-.3.1-.6.3-.8.2-.2.5-.3.8-.3.2 0 .5.1.7.3l.7.7c.2.2.3.5.3.8 0 .2-.1.5-.3.7a1 1 0 0 1-.7.3 1 1 0 0 1-.8-.3Zm10 0a1 1 0 0 1-.8.3 1 1 0 0 1-.7-.3 1 1 0 0 1-.3-.7c0-.3.1-.6.3-.8l.8-.7c.1-.2.4-.3.6-.3.3 0 .6.1.8.3.2.2.3.5.3.8 0 .2-.1.5-.3.7l-.7.7Zm-10 7c.2-.2.5-.3.8-.3.2 0 .5.1.7.3a1 1 0 0 1 0 1.4l-.8.8a1 1 0 0 1-.6.3 1 1 0 0 1-.8-.3 1 1 0 0 1-.3-.8c0-.2.1-.5.3-.6l.7-.8ZM12 8a4 4 0 0 1 3.7 2.4 4 4 0 0 1 0 3.2A4 4 0 0 1 12 16a4 4 0 0 1-3.7-2.4 4 4 0 0 1 0-3.2A4 4 0 0 1 12 8Zm0 6.5c.7 0 1.3-.2 1.8-.7.5-.5.7-1.1.7-1.8s-.2-1.3-.7-1.8c-.5-.5-1.1-.7-1.8-.7s-1.3.2-1.8.7c-.5.5-.7 1.1-.7 1.8s.2 1.3.7 1.8c.5.5 1.1.7 1.8.7Z\" fill-rule=\"evenodd\"/></svg>",
			"browse": "<svg width=\"24\" height=\"24\"><path d=\"M19 4a2 2 0 0 1 2 2v12a2 2 0 0 1-2 2h-4v-2h4V8H5v10h4v2H5a2 2 0 0 1-2-2V6c0-1.1.9-2 2-2h14Zm-8 9.4-2.3 2.3a1 1 0 1 1-1.4-1.4l4-4a1 1 0 0 1 1.4 0l4 4a1 1 0 0 1-1.4 1.4L13 13.4V20a1 1 0 0 1-2 0v-6.6Z\" fill-rule=\"nonzero\"/></svg>",
			"cancel": "<svg width=\"24\" height=\"24\"><path d=\"M12 4.6a7.4 7.4 0 1 1 0 14.8 7.4 7.4 0 0 1 0-14.8ZM12 3a9 9 0 1 0 0 18 9 9 0 0 0 0-18Zm0 8L14.8 8l1 1.1-2.7 2.8 2.7 2.7-1.1 1.1-2.7-2.7-2.7 2.7-1-1.1 2.6-2.7-2.7-2.7 1-1.1 2.8 2.7Z\" fill-rule=\"nonzero\"/></svg>",
			"cell-background-color": "<svg width=\"24\" height=\"24\"><path d=\"m15.7 2 1.6 1.6-2.7 2.6 5.9 5.8c.7.7.7 1.7 0 2.4l-6.3 6.1a1.7 1.7 0 0 1-2.4 0l-6.3-6.1c-.7-.7-.7-1.7 0-2.4L15.7 2ZM18 12l-4.5-4L9 12h9ZM4 16s2 2.4 2 3.8C6 21 5.1 22 4 22s-2-1-2-2.2C2 18.4 4 16 4 16Z\"/></svg>",
			"cell-border-color": "<svg width=\"24\" height=\"24\"><g fill-rule=\"evenodd\"><path fill-rule=\"nonzero\" d=\"M5 13v5h2v2H5a2 2 0 0 1-2-2v-5h2zm8-7V4h6a2 2 0 0 1 2 2h-8z\" opacity=\".2\"/><path fill-rule=\"nonzero\" d=\"M13 4v2H5v7H3V6c0-1.1.9-2 2-2h8zm-2.6 14.1.1-.1.1.1.2.3.2.2.2.2c.4.6.8 1.2.8 1.7 0 .8-.7 1.5-1.5 1.5S9 21.3 9 20.5c0-.5.4-1.1.8-1.7l.2-.2.2-.2.2-.3z\"/><path d=\"m13 11-2 2H5v-2h6V6h2z\"/><path fill-rule=\"nonzero\" d=\"m18.4 8 1 1-1.8 1.9 4 4c.5.4.5 1.1 0 1.6l-4.3 4.2a1.2 1.2 0 0 1-1.6 0l-4.4-4.2c-.4-.5-.4-1.2 0-1.7l7-6.8Zm1.6 7-3-3-3 3h6Z\"/></g></svg>",
			"change-case": "<svg width=\"24\" height=\"24\"><path d=\"M18.4 18.2v-.6c-.5.8-1.3 1.2-2.4 1.2-2.2 0-3.3-1.6-3.3-4.8 0-3.1 1-4.7 3.3-4.7 1.1 0 1.8.3 2.4 1.1v-.6c0-.5.4-.8.8-.8s.8.3.8.8v8.4c0 .5-.4.8-.8.8a.8.8 0 0 1-.8-.8zm-2-7.4c-1.3 0-1.8.9-1.8 3.2 0 2.4.5 3.3 1.7 3.3 1.3 0 1.8-.9 1.8-3.2 0-2.4-.5-3.3-1.7-3.3zM10 15.7H5.5l-.8 2.6a1 1 0 0 1-1 .7h-.2a.7.7 0 0 1-.7-1l4-12a1 1 0 0 1 2 0l4 12a.7.7 0 0 1-.8 1h-.2a1 1 0 0 1-1-.7l-.8-2.6zm-.3-1.5-2-6.5-1.9 6.5h3.9z\" fill-rule=\"evenodd\"/></svg>",
			"character-count": "<svg width=\"24\" height=\"24\"><path d=\"M4 11.5h16v1H4v-1Zm4.8-6.8V10H7.7V5.8h-1v-1h2ZM11 8.3V9h2v1h-3V7.7l2-1v-.9h-2v-1h3v2.4l-2 1Zm6.3-3.4V10h-3.1V9h2.1V8h-2.1V6.8h2.1v-1h-2.1v-1h3.1ZM5.8 16.4c0-.5.2-.8.5-1 .2-.2.6-.3 1.2-.3l.8.1c.2 0 .4.2.5.3l.4.4v2.8l.2.3H8.2V18.7l-.6.3H7c-.4 0-.7 0-1-.2a1 1 0 0 1-.3-.9c0-.3 0-.6.3-.8.3-.2.7-.4 1.2-.4l.6-.2h.3v-.2l-.1-.2a.8.8 0 0 0-.5-.1 1 1 0 0 0-.4 0l-.3.4h-1Zm2.3.8h-.2l-.2.1-.4.1a1 1 0 0 0-.4.2l-.2.2.1.3.5.1h.4l.4-.4v-.6Zm2-3.4h1.2v1.7l.5-.3h.5c.5 0 .9.1 1.2.5.3.4.5.8.5 1.4 0 .6-.2 1.1-.5 1.5-.3.4-.7.6-1.3.6l-.6-.1-.4-.4v.4h-1.1v-5.4Zm1.1 3.3c0 .3 0 .6.2.8a.7.7 0 0 0 1.2 0l.2-.8c0-.4 0-.6-.2-.8a.7.7 0 0 0-.6-.3l-.6.3-.2.8Zm6.1-.5c0-.2 0-.3-.2-.4a.8.8 0 0 0-.5-.2c-.3 0-.5.1-.6.3l-.2.9c0 .3 0 .6.2.8.1.2.3.3.6.3.2 0 .4 0 .5-.2l.2-.4h1.1c0 .5-.3.8-.6 1.1a2 2 0 0 1-1.3.4c-.5 0-1-.2-1.3-.6a2 2 0 0 1-.5-1.4c0-.6.1-1.1.5-1.5.3-.4.8-.5 1.4-.5.5 0 1 0 1.2.3.4.3.5.7.5 1.2h-1v-.1Z\" fill-rule=\"evenodd\"/></svg>",
			"checklist-rtl": "<svg width=\"24\" height=\"24\"><path d=\"M5 17h8c.6 0 1 .4 1 1s-.4 1-1 1H5a1 1 0 0 1 0-2zm0-6h8c.6 0 1 .4 1 1s-.4 1-1 1H5a1 1 0 0 1 0-2zm0-6h8c.6 0 1 .4 1 1s-.4 1-1 1H5a1 1 0 1 1 0-2zm14.2 11c.2-.4.6-.5.9-.3.3.2.4.6.2 1L18 20c-.2.3-.7.4-1 0l-1.3-1.3a.7.7 0 0 1 0-1c.3-.2.7-.2 1 0l.7.9 1.7-2.8zm0-6c.2-.4.6-.5.9-.3.3.2.4.6.2 1L18 14c-.2.3-.7.4-1 0l-1.3-1.3a.7.7 0 0 1 0-1c.3-.2.7-.2 1 0l.7.9 1.7-2.8zm0-6c.2-.4.6-.5.9-.3.3.2.4.6.2 1L18 8c-.2.3-.7.4-1 0l-1.3-1.3a.7.7 0 0 1 0-1c.3-.2.7-.2 1 0l.7.9 1.7-2.8z\" fill-rule=\"evenodd\"/></svg>",
			"checklist": "<svg width=\"24\" height=\"24\"><path d=\"M11 17h8c.6 0 1 .4 1 1s-.4 1-1 1h-8a1 1 0 0 1 0-2Zm0-6h8c.6 0 1 .4 1 1s-.4 1-1 1h-8a1 1 0 0 1 0-2Zm0-6h8a1 1 0 0 1 0 2h-8a1 1 0 0 1 0-2ZM7.2 16c.2-.4.6-.5.9-.3.3.2.4.6.2 1L6 20c-.2.3-.7.4-1 0l-1.3-1.3a.7.7 0 0 1 0-1c.3-.2.7-.2 1 0l.7.9 1.7-2.8Zm0-6c.2-.4.6-.5.9-.3.3.2.4.6.2 1L6 14c-.2.3-.7.4-1 0l-1.3-1.3a.7.7 0 0 1 0-1c.3-.2.7-.2 1 0l.7.9 1.7-2.8Zm0-6c.2-.4.6-.5.9-.3.3.2.4.6.2 1L6 8c-.2.3-.7.4-1 0L3.8 6.9a.7.7 0 0 1 0-1c.3-.2.7-.2 1 0l.7.9 1.7-2.8Z\" fill-rule=\"evenodd\"/></svg>",
			"checkmark": "<svg width=\"24\" height=\"24\"><path d=\"M18.2 5.4a1 1 0 0 1 1.6 1.2l-8 12a1 1 0 0 1-1.5.1l-5-5a1 1 0 1 1 1.4-1.4l4.1 4.1 7.4-11Z\" fill-rule=\"nonzero\"/></svg>",
			"chevron-down": "<svg width=\"10\" height=\"10\"><path d=\"M8.7 2.2c.3-.3.8-.3 1 0 .4.4.4.9 0 1.2L5.7 7.8c-.3.3-.9.3-1.2 0L.2 3.4a.8.8 0 0 1 0-1.2c.3-.3.8-.3 1.1 0L5 6l3.7-3.8Z\" fill-rule=\"nonzero\"/></svg>",
			"chevron-left": "<svg width=\"10\" height=\"10\"><path d=\"M7.8 1.3 4 5l3.8 3.7c.3.3.3.8 0 1-.4.4-.9.4-1.2 0L2.2 5.7a.8.8 0 0 1 0-1.2L6.6.2C7 0 7.4 0 7.8.2c.3.3.3.8 0 1.1Z\" fill-rule=\"nonzero\"/></svg>",
			"chevron-right": "<svg width=\"10\" height=\"10\"><path d=\"M2.2 1.3a.8.8 0 0 1 0-1c.4-.4.9-.4 1.2 0l4.4 4.1c.3.4.3.9 0 1.2L3.4 9.8c-.3.3-.8.3-1.2 0a.8.8 0 0 1 0-1.1L6 5 2.2 1.3Z\" fill-rule=\"nonzero\"/></svg>",
			"chevron-up": "<svg width=\"10\" height=\"10\"><path d=\"M8.7 7.8 5 4 1.3 7.8c-.3.3-.8.3-1 0a.8.8 0 0 1 0-1.2l4.1-4.4c.3-.3.9-.3 1.2 0l4.2 4.4c.3.3.3.9 0 1.2-.3.3-.8.3-1.1 0Z\" fill-rule=\"nonzero\"/></svg>",
			"close": "<svg width=\"24\" height=\"24\"><path d=\"M17.3 8.2 13.4 12l3.9 3.8a1 1 0 0 1-1.5 1.5L12 13.4l-3.8 3.9a1 1 0 0 1-1.5-1.5l3.9-3.8-3.9-3.8a1 1 0 0 1 1.5-1.5l3.8 3.9 3.8-3.9a1 1 0 0 1 1.5 1.5Z\" fill-rule=\"evenodd\"/></svg>",
			"code-sample": "<svg width=\"24\" height=\"26\"><path d=\"M7.1 11a2.8 2.8 0 0 1-.8 2 2.8 2.8 0 0 1 .8 2v1.7c0 .3.1.6.4.8.2.3.5.4.8.4.3 0 .4.2.4.4v.8c0 .2-.1.4-.4.4-.7 0-1.4-.3-2-.8-.5-.6-.8-1.3-.8-2V15c0-.3-.1-.6-.4-.8-.2-.3-.5-.4-.8-.4a.4.4 0 0 1-.4-.4v-.8c0-.2.2-.4.4-.4.3 0 .6-.1.8-.4.3-.2.4-.5.4-.8V9.3c0-.7.3-1.4.8-2 .6-.5 1.3-.8 2-.8.3 0 .4.2.4.4v.8c0 .2-.1.4-.4.4-.3 0-.6.1-.8.4-.3.2-.4.5-.4.8V11Zm9.8 0V9.3c0-.3-.1-.6-.4-.8-.2-.3-.5-.4-.8-.4a.4.4 0 0 1-.4-.4V7c0-.2.1-.4.4-.4.7 0 1.4.3 2 .8.5.6.8 1.3.8 2V11c0 .3.1.6.4.8.2.3.5.4.8.4.2 0 .4.2.4.4v.8c0 .2-.2.4-.4.4-.3 0-.6.1-.8.4-.3.2-.4.5-.4.8v1.7c0 .7-.3 1.4-.8 2-.6.5-1.3.8-2 .8a.4.4 0 0 1-.4-.4v-.8c0-.2.1-.4.4-.4.3 0 .6-.1.8-.4.3-.2.4-.5.4-.8V15a2.8 2.8 0 0 1 .8-2 2.8 2.8 0 0 1-.8-2Zm-3.3-.4c0 .4-.1.8-.5 1.1-.3.3-.7.5-1.1.5-.4 0-.8-.2-1.1-.5-.4-.3-.5-.7-.5-1.1 0-.5.1-.9.5-1.2.3-.3.7-.4 1.1-.4.4 0 .8.1 1.1.4.4.3.5.7.5 1.2ZM12 13c.4 0 .8.1 1.1.5.4.3.5.7.5 1.1 0 1-.1 1.6-.5 2a3 3 0 0 1-1.1 1c-.4.3-.8.4-1.1.4a.5.5 0 0 1-.5-.5V17a3 3 0 0 0 1-.2l.6-.6c-.6 0-1-.2-1.3-.5-.2-.3-.3-.7-.3-1 0-.5.1-1 .5-1.2.3-.4.7-.5 1.1-.5Z\" fill-rule=\"evenodd\"/></svg>",
			"color-levels": "<svg width=\"24\" height=\"24\"><path d=\"M17.5 11.4A9 9 0 0 1 18 14c0 .5 0 1-.2 1.4 0 .4-.3.9-.5 1.3a6.2 6.2 0 0 1-3.7 3 5.7 5.7 0 0 1-3.2 0A5.9 5.9 0 0 1 7.6 18a6.2 6.2 0 0 1-1.4-2.6 6.7 6.7 0 0 1 0-2.8c0-.4.1-.9.3-1.3a13.6 13.6 0 0 1 2.3-4A20 20 0 0 1 12 4a26.4 26.4 0 0 1 3.2 3.4 18.2 18.2 0 0 1 2.3 4Zm-2 4.5c.4-.7.5-1.4.5-2a7.3 7.3 0 0 0-1-3.2c.2.6.2 1.2.2 1.9a4.5 4.5 0 0 1-1.3 3 5.3 5.3 0 0 1-2.3 1.5 4.9 4.9 0 0 1-2 .1 4.3 4.3 0 0 0 2.4.8 4 4 0 0 0 2-.6 4 4 0 0 0 1.5-1.5Z\" fill-rule=\"evenodd\"/></svg>",
			"color-picker": "<svg width=\"24\" height=\"24\"><path d=\"M12 3a9 9 0 0 0 0 18 1.5 1.5 0 0 0 1.1-2.5c-.2-.3-.4-.6-.4-1 0-.8.7-1.5 1.5-1.5H16a5 5 0 0 0 5-5c0-4.4-4-8-9-8Zm-5.5 9a1.5 1.5 0 1 1 0-3 1.5 1.5 0 0 1 0 3Zm3-4a1.5 1.5 0 1 1 0-3 1.5 1.5 0 0 1 0 3Zm5 0a1.5 1.5 0 1 1 0-3 1.5 1.5 0 0 1 0 3Zm3 4a1.5 1.5 0 1 1 0-3 1.5 1.5 0 0 1 0 3Z\" fill-rule=\"nonzero\"/></svg>",
			"color-swatch-remove-color": "<svg width=\"24\" height=\"24\"><path stroke=\"#000\" stroke-width=\"2\" d=\"M21 3 3 21\" fill-rule=\"evenodd\"/></svg>",
			"color-swatch": "<svg width=\"24\" height=\"24\"><rect x=\"3\" y=\"3\" width=\"18\" height=\"18\" rx=\"1\" fill-rule=\"evenodd\"/></svg>",
			"comment-add": "<svg width=\"24\" height=\"24\"><g fill-rule=\"nonzero\"><path d=\"m9 19 3-2h7c.6 0 1-.4 1-1V6c0-.6-.4-1-1-1H5a1 1 0 0 0-1 1v10c0 .6.4 1 1 1h4v2Zm-2 4v-4H5a3 3 0 0 1-3-3V6a3 3 0 0 1 3-3h14a3 3 0 0 1 3 3v10a3 3 0 0 1-3 3h-6.4L7 23Z\"/><path d=\"M13 10h2a1 1 0 0 1 0 2h-2v2a1 1 0 0 1-2 0v-2H9a1 1 0 0 1 0-2h2V8a1 1 0 0 1 2 0v2Z\"/></g></svg>",
			"comment": "<svg width=\"24\" height=\"24\"><path fill-rule=\"nonzero\" d=\"m9 19 3-2h7c.6 0 1-.4 1-1V6c0-.6-.4-1-1-1H5a1 1 0 0 0-1 1v10c0 .6.4 1 1 1h4v2Zm-2 4v-4H5a3 3 0 0 1-3-3V6a3 3 0 0 1 3-3h14a3 3 0 0 1 3 3v10a3 3 0 0 1-3 3h-6.4L7 23Z\"/></svg>",
			"contrast": "<svg width=\"24\" height=\"24\"><path d=\"M12 4a7.8 7.8 0 0 1 5.7 2.3A8 8 0 1 1 12 4Zm-6 8a6 6 0 0 0 6 6V6a6 6 0 0 0-6 6Z\" fill-rule=\"evenodd\"/></svg>",
			"copy": "<svg width=\"24\" height=\"24\"><path d=\"M16 3H6a2 2 0 0 0-2 2v11h2V5h10V3Zm1 4a2 2 0 0 1 2 2v10a2 2 0 0 1-2 2h-7a2 2 0 0 1-2-2V9c0-1.2.9-2 2-2h7Zm0 12V9h-7v10h7Z\" fill-rule=\"nonzero\"/></svg>",
			"crop": "<svg width=\"24\" height=\"24\"><path d=\"M17 8v7h2c.6 0 1 .4 1 1s-.4 1-1 1h-2v2c0 .6-.4 1-1 1a1 1 0 0 1-1-1v-2H7V9H5a1 1 0 1 1 0-2h2V5c0-.6.4-1 1-1s1 .4 1 1v2h7l3-3 1 1-3 3ZM9 9v5l5-5H9Zm1 6h5v-5l-5 5Z\" fill-rule=\"evenodd\"/></svg>",
			"cut-column": "<svg width=\"24\" height=\"24\"><path fill-rule=\"evenodd\" d=\"M7.2 4.5c.9 0 1.6.4 2.2 1A3.7 3.7 0 0 1 10.5 8v.5l1 1 4-4 1-.5a3.3 3.3 0 0 1 2 0c.4 0 .7.3 1 .5L17 8h4v13h-6V10l-1.5 1.5.5.5v4l-2.5-2.5-1 1v.5c0 .4 0 .8-.3 1.2-.2.5-.4.9-.8 1.2-.6.7-1.3 1-2.2 1-.8.2-1.5 0-2-.6l-.5-.8-.2-1c0-.4 0-.8.3-1.2A3.9 3.9 0 0 1 7 12.7c.5-.2 1-.3 1.5-.2l1-1-1-1c-.5 0-1 0-1.5-.2-.5-.1-1-.4-1.4-.9-.4-.3-.6-.7-.8-1.2L4.5 7c0-.4 0-.7.2-1 0-.3.3-.6.5-.8.5-.5 1.2-.8 2-.7Zm12.3 5h-3v10h3v-10ZM8 13.8h-.3l-.4.2a2.8 2.8 0 0 0-.7.4v.1a2.8 2.8 0 0 0-.6.8l-.1.4v.7l.2.5.5.2h.7a2.6 2.6 0 0 0 .8-.3 2.4 2.4 0 0 0 .7-.7 2.5 2.5 0 0 0 .3-.8 1.5 1.5 0 0 0 0-.8 1 1 0 0 0-.2-.4 1 1 0 0 0-.5-.2H8Zm3.5-3.7c-.4 0-.7.1-1 .4-.3.3-.4.6-.4 1s.1.7.4 1c.3.3.6.4 1 .4s.7-.1 1-.4c.3-.3.4-.6.4-1s-.1-.7-.4-1c-.3-.3-.6-.4-1-.4ZM7 5.8h-.4a1 1 0 0 0-.5.3 1 1 0 0 0-.2.5v.7a2.5 2.5 0 0 0 .3.8l.2.3h.1l.4.4.4.2.4.1h.7L9 9l.2-.4a1.6 1.6 0 0 0 0-.8 2.6 2.6 0 0 0-.3-.8A2.5 2.5 0 0 0 7.7 6l-.4-.1H7Z\"/></svg>",
			"cut-row": "<svg width=\"24\" height=\"24\"><path fill-rule=\"evenodd\" d=\"M22 3v5H9l3 3 2-2h4l-4 4 1 1h.5c.4 0 .8 0 1.2.3.5.2.9.4 1.2.8.7.6 1 1.3 1 2.2.2.8 0 1.5-.6 2l-.8.5-1 .2c-.4 0-.8 0-1.2-.3a3.9 3.9 0 0 1-2.1-2.2c-.2-.5-.3-1-.2-1.5l-1-1-1 1c0 .5 0 1-.2 1.5-.1.5-.4 1-.9 1.4-.3.4-.7.6-1.2.8l-1.2.3c-.4 0-.7 0-1-.2-.3 0-.6-.3-.8-.5-.5-.5-.8-1.2-.7-2 0-.9.4-1.6 1-2.2A3.7 3.7 0 0 1 8.6 14H9l1-1-4-4-.5-1a3.3 3.3 0 0 1 0-2c0-.4.3-.7.5-1l2 2V3h14ZM8.5 15.3h-.3a2.6 2.6 0 0 0-.8.4 2.5 2.5 0 0 0-.9 1.1l-.1.4v.7l.2.5.5.2h.7a2.5 2.5 0 0 0 .8-.3L9 18V18l.4-.4.2-.4.1-.4v-.7a1 1 0 0 0-.2-.5 1 1 0 0 0-.4-.2h-.5Zm7 0H15a1 1 0 0 0-.4.3 1 1 0 0 0-.2.5 1.5 1.5 0 0 0 0 .7v.4a2.8 2.8 0 0 0 .5.7h.1a2.8 2.8 0 0 0 .8.6l.4.1h.7l.5-.2.2-.5v-.7a2.6 2.6 0 0 0-.3-.8 2.4 2.4 0 0 0-.7-.7 2.5 2.5 0 0 0-.8-.3h-.3ZM12 11.6c-.4 0-.7.1-1 .4-.3.3-.4.6-.4 1s.1.7.4 1c.3.3.6.4 1 .4s.7-.1 1-.4c.3-.3.4-.6.4-1s-.1-.7-.4-1c-.3-.3-.6-.4-1-.4Zm8.5-7.1h-11v2h11v-2Z\"/></svg>",
			"cut": "<svg width=\"24\" height=\"24\"><path d=\"M18 15c.6.7 1 1.4 1 2.3 0 .8-.2 1.5-.7 2l-.8.5-1 .2c-.4 0-.8 0-1.2-.3a3.9 3.9 0 0 1-2.1-2.2c-.2-.5-.3-1-.2-1.5l-1-1-1 1c0 .5 0 1-.2 1.5-.1.5-.4 1-.9 1.4-.3.4-.7.6-1.2.8l-1.2.3c-.4 0-.7 0-1-.2-.3 0-.6-.3-.8-.5-.5-.5-.8-1.2-.7-2 0-.9.4-1.6 1-2.2A3.7 3.7 0 0 1 8.6 14H9l1-1-4-4-.5-1a3.3 3.3 0 0 1 0-2c0-.4.3-.7.5-1l6 6 6-6 .5 1a3.3 3.3 0 0 1 0 2c0 .4-.3.7-.5 1l-4 4 1 1h.5c.4 0 .8 0 1.2.3.5.2.9.4 1.2.8Zm-8.5 2.2.1-.4v-.7a1 1 0 0 0-.2-.5 1 1 0 0 0-.4-.2 1.6 1.6 0 0 0-.8 0 2.6 2.6 0 0 0-.8.3 2.5 2.5 0 0 0-.9 1.1l-.1.4v.7l.2.5.5.2h.7a2.5 2.5 0 0 0 .8-.3 2.8 2.8 0 0 0 1-1Zm2.5-2.8c.4 0 .7-.1 1-.4.3-.3.4-.6.4-1s-.1-.7-.4-1c-.3-.3-.6-.4-1-.4s-.7.1-1 .4c-.3.3-.4.6-.4 1s.1.7.4 1c.3.3.6.4 1 .4Zm5.4 4 .2-.5v-.7a2.6 2.6 0 0 0-.3-.8 2.4 2.4 0 0 0-.7-.7 2.5 2.5 0 0 0-.8-.3 1.5 1.5 0 0 0-.8 0 1 1 0 0 0-.4.2 1 1 0 0 0-.2.5 1.5 1.5 0 0 0 0 .7v.4l.3.4.3.4a2.8 2.8 0 0 0 .8.5l.4.1h.7l.5-.2Z\" fill-rule=\"evenodd\"/></svg>",
			"document-properties": "<svg width=\"24\" height=\"24\"><path d=\"M14.4 3H7a2 2 0 0 0-2 2v14c0 1.1.9 2 2 2h10a2 2 0 0 0 2-2V7.6L14.4 3ZM17 19H7V5h6v4h4v10Z\" fill-rule=\"nonzero\"/></svg>",
			"drag": "<svg width=\"24\" height=\"24\"><path d=\"M13 5h2v2h-2V5Zm0 4h2v2h-2V9ZM9 9h2v2H9V9Zm4 4h2v2h-2v-2Zm-4 0h2v2H9v-2Zm0 4h2v2H9v-2Zm4 0h2v2h-2v-2ZM9 5h2v2H9V5Z\" fill-rule=\"evenodd\"/></svg>",
			"duplicate-column": "<svg width=\"24\" height=\"24\"><path d=\"M17 6v16h-7V6h7Zm-2 2h-3v12h3V8Zm-2-6v2H8v15H6V2h7Z\"/></svg>",
			"duplicate-row": "<svg width=\"24\" height=\"24\"><path d=\"M22 11v7H6v-7h16Zm-2 2H8v3h12v-3Zm-1-6v2H4v5H2V7h17Z\"/></svg>",
			"duplicate": "<svg width=\"24\" height=\"24\"><g fill-rule=\"nonzero\"><path d=\"M16 3v2H6v11H4V5c0-1.1.9-2 2-2h10Zm3 8h-2V9h-7v10h9a2 2 0 0 1-2 2h-7a2 2 0 0 1-2-2V9c0-1.2.9-2 2-2h7a2 2 0 0 1 2 2v2Z\"/><path d=\"M17 14h1a1 1 0 0 1 0 2h-1v1a1 1 0 0 1-2 0v-1h-1a1 1 0 0 1 0-2h1v-1a1 1 0 0 1 2 0v1Z\"/></g></svg>",
			"edit-block": "<svg width=\"24\" height=\"24\"><path fill-rule=\"nonzero\" d=\"m19.8 8.8-9.4 9.4c-.2.2-.5.4-.9.4l-5.4 1.2 1.2-5.4.5-.8 9.4-9.4c.7-.7 1.8-.7 2.5 0l2.1 2.1c.7.7.7 1.8 0 2.5Zm-2-.2 1-.9v-.3l-2.2-2.2a.3.3 0 0 0-.3 0l-1 1L18 8.5Zm-1 1-2.5-2.4-6 6 2.5 2.5 6-6Zm-7 7.1-2.6-2.4-.3.3-.1.2-.7 3 3.1-.6h.1l.4-.5Z\"/></svg>",
			"edit-image": "<svg width=\"24\" height=\"24\"><path d=\"M18 16h2V7a2 2 0 0 0-2-2H7v2h11v9ZM6 17h15a1 1 0 0 1 0 2h-1v1a1 1 0 0 1-2 0v-1H6a2 2 0 0 1-2-2V7H3a1 1 0 1 1 0-2h1V4a1 1 0 1 1 2 0v13Zm3-5.3 1.3 2 3-4.7 3.7 6H7l2-3.3Z\" fill-rule=\"nonzero\"/></svg>",
			"embed-page": "<svg width=\"24\" height=\"24\"><path d=\"M19 6V5H5v14h2A13 13 0 0 1 19 6Zm0 1.4c-.8.8-1.6 2.4-2.2 4.6H19V7.4Zm0 5.6h-2.4c-.4 1.8-.6 3.8-.6 6h3v-6Zm-4 6c0-2.2.2-4.2.6-6H13c-.7 1.8-1.1 3.8-1.1 6h3Zm-4 0c0-2.2.4-4.2 1-6H9.6A12 12 0 0 0 8 19h3ZM4 3h16c.6 0 1 .4 1 1v16c0 .6-.4 1-1 1H4a1 1 0 0 1-1-1V4c0-.6.4-1 1-1Zm11.8 9c.4-1.9 1-3.4 1.8-4.5a9.2 9.2 0 0 0-4 4.5h2.2Zm-3.4 0a12 12 0 0 1 2.8-4 12 12 0 0 0-5 4h2.2Z\" fill-rule=\"nonzero\"/></svg>",
			"embed": "<svg width=\"24\" height=\"24\"><path d=\"M4 3h16c.6 0 1 .4 1 1v16c0 .6-.4 1-1 1H4a1 1 0 0 1-1-1V4c0-.6.4-1 1-1Zm1 2v14h14V5H5Zm4.8 2.6 5.6 4a.5.5 0 0 1 0 .8l-5.6 4A.5.5 0 0 1 9 16V8a.5.5 0 0 1 .8-.4Z\" fill-rule=\"nonzero\"/></svg>",
			"emoji": "<svg width=\"24\" height=\"24\"><path d=\"M9 11c.6 0 1-.4 1-1s-.4-1-1-1a1 1 0 0 0-1 1c0 .6.4 1 1 1Zm6 0c.6 0 1-.4 1-1s-.4-1-1-1a1 1 0 0 0-1 1c0 .6.4 1 1 1Zm-3 5.5c2.1 0 4-1.5 4.4-3.5H7.6c.5 2 2.3 3.5 4.4 3.5ZM12 4a8 8 0 1 0 0 16 8 8 0 0 0 0-16Zm0 14.5a6.5 6.5 0 1 1 0-13 6.5 6.5 0 0 1 0 13Z\" fill-rule=\"nonzero\"/></svg>",
			"export": "<svg width=\"24\" height=\"24\"><g fill-rule=\"nonzero\"><path d=\"M14.4 3 18 7v1h-5V5H7v14h9a1 1 0 0 1 2 0c0 1-.8 2-1.9 2H7c-1 0-2-.8-2-1.9V5c0-1 .8-2 1.9-2h7.5Z\"/><path d=\"M18.1 12c.5 0 .9.4.9 1 0 .5-.3 1-.8 1h-7.3c-.5 0-.9-.4-.9-1 0-.5.3-1 .8-1h7.3Z\"/><path d=\"M16.4 9.2a1 1 0 0 1 1.4.2l2.4 3.6-2.4 3.6a1 1 0 0 1-1.7-1v-.2l1.7-2.4-1.6-2.4a1 1 0 0 1 .2-1.4Z\"/></g></svg>",
			"fill": "<svg width=\"24\" height=\"26\"><path d=\"m16.6 12-9-9-1.4 1.4 2.4 2.4-5.2 5.1c-.5.6-.5 1.6 0 2.2L9 19.6a1.5 1.5 0 0 0 2.2 0l5.5-5.5c.5-.6.5-1.6 0-2.2ZM5.2 13 10 8.2l4.8 4.8H5.2ZM19 14.5s-2 2.2-2 3.5c0 1.1.9 2 2 2a2 2 0 0 0 2-2c0-1.3-2-3.5-2-3.5Z\" fill-rule=\"nonzero\"/></svg>",
			"flip-horizontally": "<svg width=\"24\" height=\"24\"><path d=\"M14 19h2v-2h-2v2Zm4-8h2V9h-2v2ZM4 7v10c0 1.1.9 2 2 2h3v-2H6V7h3V5H6a2 2 0 0 0-2 2Zm14-2v2h2a2 2 0 0 0-2-2Zm-7 16h2V3h-2v18Zm7-6h2v-2h-2v2Zm-4-8h2V5h-2v2Zm4 12a2 2 0 0 0 2-2h-2v2Z\" fill-rule=\"nonzero\"/></svg>",
			"flip-vertically": "<svg width=\"24\" height=\"24\"><path d=\"M5 14v2h2v-2H5Zm8 4v2h2v-2h-2Zm4-14H7a2 2 0 0 0-2 2v3h2V6h10v3h2V6a2 2 0 0 0-2-2Zm2 14h-2v2a2 2 0 0 0 2-2ZM3 11v2h18v-2H3Zm6 7v2h2v-2H9Zm8-4v2h2v-2h-2ZM5 18c0 1.1.9 2 2 2v-2H5Z\" fill-rule=\"nonzero\"/></svg>",
			"footnote": "<svg width=\"24\" height=\"24\"><path d=\"M19 13c.6 0 1 .4 1 1s-.4 1-1 1H5a1 1 0 1 1 0-2h14Z\"/><path fill-rule=\"evenodd\" clip-rule=\"evenodd\" d=\"M19 4v6h-1V5h-1.5V4h2.6Z\"/><path d=\"M12 18c.6 0 1 .4 1 1s-.4 1-1 1H5a1 1 0 1 1 0-2h7ZM14 8c.6 0 1 .4 1 1s-.4 1-1 1H5a1 1 0 0 1 0-2h9Z\"/></svg>",
			"format-painter": "<svg width=\"24\" height=\"24\"><path d=\"M18 5V4c0-.5-.4-1-1-1H5a1 1 0 0 0-1 1v4c0 .6.5 1 1 1h12c.6 0 1-.4 1-1V7h1v4H9v9c0 .6.4 1 1 1h2c.6 0 1-.4 1-1v-7h8V5h-3Z\" fill-rule=\"nonzero\"/></svg>",
			"format": "<svg width=\"24\" height=\"24\"><path fill-rule=\"evenodd\" d=\"M17 5a1 1 0 0 1 0 2h-4v11a1 1 0 0 1-2 0V7H7a1 1 0 1 1 0-2h10Z\"/></svg>",
			"fullscreen": "<svg width=\"24\" height=\"24\"><path d=\"m15.3 10-1.2-1.3 2.9-3h-2.3a.9.9 0 1 1 0-1.7H19c.5 0 .9.4.9.9v4.4a.9.9 0 1 1-1.8 0V7l-2.9 3Zm0 4 3 3v-2.3a.9.9 0 1 1 1.7 0V19c0 .5-.4.9-.9.9h-4.4a.9.9 0 1 1 0-1.8H17l-3-2.9 1.3-1.2ZM10 15.4l-2.9 3h2.3a.9.9 0 1 1 0 1.7H5a.9.9 0 0 1-.9-.9v-4.4a.9.9 0 1 1 1.8 0V17l2.9-3 1.2 1.3ZM8.7 10 5.7 7v2.3a.9.9 0 0 1-1.7 0V5c0-.5.4-.9.9-.9h4.4a.9.9 0 0 1 0 1.8H7l3 2.9-1.3 1.2Z\" fill-rule=\"nonzero\"/></svg>",
			"gallery": "<svg width=\"24\" height=\"24\"><path fill-rule=\"nonzero\" d=\"m5 15.7 2.3-2.2c.3-.3.7-.3 1 0L11 16l5.1-5c.3-.4.8-.4 1 0l2 1.9V8H5v7.7ZM5 18V19h3l1.8-1.9-2-2L5 17.9Zm14-3-2.5-2.4-6.4 6.5H19v-4ZM4 6h16c.6 0 1 .4 1 1v13c0 .6-.4 1-1 1H4a1 1 0 0 1-1-1V7c0-.6.4-1 1-1Zm6 7a2 2 0 1 1 0-4 2 2 0 0 1 0 4ZM4.5 4h15a.5.5 0 1 1 0 1h-15a.5.5 0 0 1 0-1Zm2-2h11a.5.5 0 1 1 0 1h-11a.5.5 0 0 1 0-1Z\"/></svg>",
			"gamma": "<svg width=\"24\" height=\"24\"><path d=\"M4 3h16c.6 0 1 .4 1 1v16c0 .6-.4 1-1 1H4a1 1 0 0 1-1-1V4c0-.6.4-1 1-1Zm1 2v14h14V5H5Zm6.5 11.8V14L9.2 8.7a5.1 5.1 0 0 0-.4-.8l-.1-.2H8v-1l.3-.1.3-.1h.7a1 1 0 0 1 .6.5l.1.3a8.5 8.5 0 0 1 .3.6l1.9 4.6 2-5.2a1 1 0 0 1 1-.6.5.5 0 0 1 .5.6L13 14v2.8a.7.7 0 0 1-1.4 0Z\" fill-rule=\"nonzero\"/></svg>",
			"help": "<svg width=\"24\" height=\"24\"><g fill-rule=\"evenodd\"><path d=\"M12 5.5a6.5 6.5 0 0 0-6 9 6.3 6.3 0 0 0 1.4 2l1 1a6.3 6.3 0 0 0 3.6 1 6.5 6.5 0 0 0 6-9 6.3 6.3 0 0 0-1.4-2l-1-1a6.3 6.3 0 0 0-3.6-1ZM12 4a7.8 7.8 0 0 1 5.7 2.3A8 8 0 1 1 12 4Z\"/><path d=\"M9.6 9.7a.7.7 0 0 1-.7-.8c0-1.1 1.5-1.8 3.2-1.8 1.8 0 3.2.8 3.2 2.4 0 1.4-.4 2.1-1.5 2.8-.2 0-.3.1-.3.2a2 2 0 0 0-.8.8.8.8 0 0 1-1.4-.6c.3-.7.8-1 1.3-1.5l.4-.2c.7-.4.8-.6.8-1.5 0-.5-.6-.9-1.7-.9-.5 0-1 .1-1.4.3-.2 0-.3.1-.3.2v-.2c0 .4-.4.8-.8.8Z\" fill-rule=\"nonzero\"/><circle cx=\"12\" cy=\"16\" r=\"1\"/></g></svg>",
			"highlight-bg-color": "<svg width=\"24\" height=\"24\"><g fill-rule=\"evenodd\"><path class=\"tox-icon-highlight-bg-color__color\" d=\"M3 18h18v3H3z\"/><path fill-rule=\"nonzero\" d=\"M7.7 16.7H3l3.3-3.3-.7-.8L10.2 8l4 4.1-4 4.2c-.2.2-.6.2-.8 0l-.6-.7-1.1 1.1zm5-7.5L11 7.4l3-2.9a2 2 0 0 1 2.6 0L18 6c.7.7.7 2 0 2.7l-2.9 2.9-1.8-1.8-.5-.6\"/></g></svg>",
			"home": "<svg width=\"24\" height=\"24\"><path fill-rule=\"nonzero\" d=\"M10 20v-6h4v6h5v-8h3L12 3 2 12h3v8z\"/></svg>",
			"horizontal-rule": "<svg width=\"24\" height=\"24\"><path d=\"M4 11h16v2H4z\" fill-rule=\"evenodd\"/></svg>",
			"image-options": "<svg width=\"24\" height=\"24\"><path d=\"M6 10a2 2 0 0 0-2 2c0 1.1.9 2 2 2a2 2 0 0 0 2-2 2 2 0 0 0-2-2Zm12 0a2 2 0 0 0-2 2c0 1.1.9 2 2 2a2 2 0 0 0 2-2 2 2 0 0 0-2-2Zm-6 0a2 2 0 0 0-2 2c0 1.1.9 2 2 2a2 2 0 0 0 2-2 2 2 0 0 0-2-2Z\" fill-rule=\"nonzero\"/></svg>",
			"image": "<svg width=\"24\" height=\"24\"><path d=\"m5 15.7 3.3-3.2c.3-.3.7-.3 1 0L12 15l4.1-4c.3-.4.8-.4 1 0l2 1.9V5H5v10.7ZM5 18V19h3l2.8-2.9-2-2L5 17.9Zm14-3-2.5-2.4-6.4 6.5H19v-4ZM4 3h16c.6 0 1 .4 1 1v16c0 .6-.4 1-1 1H4a1 1 0 0 1-1-1V4c0-.6.4-1 1-1Zm6 8a2 2 0 1 0 0-4 2 2 0 0 0 0 4Z\" fill-rule=\"nonzero\"/></svg>",
			"indent": "<svg width=\"24\" height=\"24\"><path d=\"M7 5h12c.6 0 1 .4 1 1s-.4 1-1 1H7a1 1 0 1 1 0-2Zm5 4h7c.6 0 1 .4 1 1s-.4 1-1 1h-7a1 1 0 0 1 0-2Zm0 4h7c.6 0 1 .4 1 1s-.4 1-1 1h-7a1 1 0 0 1 0-2Zm-5 4h12a1 1 0 0 1 0 2H7a1 1 0 0 1 0-2Zm-2.6-3.8L6.2 12l-1.8-1.2a1 1 0 0 1 1.2-1.6l3 2a1 1 0 0 1 0 1.6l-3 2a1 1 0 1 1-1.2-1.6Z\" fill-rule=\"evenodd\"/></svg>",
			"info": "<svg width=\"24\" height=\"24\"><path d=\"M12 4a7.8 7.8 0 0 1 5.7 2.3A8 8 0 1 1 12 4Zm-1 3v2h2V7h-2Zm3 10v-1h-1v-5h-3v1h1v4h-1v1h4Z\" fill-rule=\"evenodd\"/></svg>",
			"insert-character": "<svg width=\"24\" height=\"24\"><path d=\"M15 18h4l1-2v4h-6v-3.3l1.4-1a6 6 0 0 0 1.8-2.9 6.3 6.3 0 0 0-.1-4.1 5.8 5.8 0 0 0-3-3.2c-.6-.3-1.3-.5-2.1-.5a5.1 5.1 0 0 0-3.9 1.8 6.3 6.3 0 0 0-1.3 6 6.2 6.2 0 0 0 1.8 3l1.4.9V20H4v-4l1 2h4v-.5l-2-1L5.4 15A6.5 6.5 0 0 1 4 11c0-1 .2-1.9.6-2.7A7 7 0 0 1 6.3 6C7.1 5.4 8 5 9 4.5c1-.3 2-.5 3.1-.5a8.8 8.8 0 0 1 5.7 2 7 7 0 0 1 1.7 2.3 6 6 0 0 1 .2 4.8c-.2.7-.6 1.3-1 1.9a7.6 7.6 0 0 1-3.6 2.5v.5Z\" fill-rule=\"evenodd\"/></svg>",
			"insert-time": "<svg width=\"24\" height=\"24\"><g fill-rule=\"nonzero\"><path d=\"M12 19a7 7 0 1 0 0-14 7 7 0 0 0 0 14Zm0 2a9 9 0 1 1 0-18 9 9 0 0 1 0 18Z\"/><path d=\"M16 12h-3V7c0-.6-.4-1-1-1a1 1 0 0 0-1 1v7h5c.6 0 1-.4 1-1s-.4-1-1-1Z\"/></g></svg>",
			"invert": "<svg width=\"24\" height=\"24\"><path d=\"M18 19.3 16.5 18a5.8 5.8 0 0 1-3.1 1.9 6.1 6.1 0 0 1-5.5-1.6A5.8 5.8 0 0 1 6 14v-.3l.1-1.2A13.9 13.9 0 0 1 7.7 9l-3-3 .7-.8 2.8 2.9 9 8.9 1.5 1.6-.7.6Zm0-5.5v.3l-.1 1.1-.4 1-1.2-1.2a4.3 4.3 0 0 0 .2-1v-.2c0-.4 0-.8-.2-1.3l-.5-1.4a14.8 14.8 0 0 0-3-4.2L12 6a26.1 26.1 0 0 0-2.2 2.5l-1-1a20.9 20.9 0 0 1 2.9-3.3L12 4l1 .8a22.2 22.2 0 0 1 4 5.4c.6 1.2 1 2.4 1 3.6Z\" fill-rule=\"evenodd\"/></svg>",
			"italic": "<svg width=\"24\" height=\"24\"><path d=\"m16.7 4.7-.1.9h-.3c-.6 0-1 0-1.4.3-.3.3-.4.6-.5 1.1l-2.1 9.8v.6c0 .5.4.8 1.4.8h.2l-.2.8H8l.2-.8h.2c1.1 0 1.8-.5 2-1.5l2-9.8.1-.5c0-.6-.4-.8-1.4-.8h-.3l.2-.9h5.8Z\" fill-rule=\"evenodd\"/></svg>",
			"language": "<svg width=\"24\" height=\"24\"><path d=\"M12 3a9 9 0 1 1 0 18 9 9 0 0 1 0-18Zm4.3 13.3c-.5 1-1.2 2-2 2.9a7.5 7.5 0 0 0 3.2-2.1l-.2-.2a6 6 0 0 0-1-.6Zm-8.6 0c-.5.2-.9.5-1.2.8.9 1 2 1.7 3.2 2a10 10 0 0 1-2-2.8Zm3.6-.8c-.8 0-1.6.1-2.2.3.5 1 1.2 1.9 2.1 2.7Zm1.5 0v3c.9-.8 1.6-1.7 2.1-2.7-.6-.2-1.4-.3-2.1-.3Zm-6-2.7H4.5c.2 1 .5 2.1 1 3h.3l1.3-1a10 10 0 0 1-.3-2Zm12.7 0h-2.3c0 .7-.1 1.4-.3 2l1.6 1.1c.5-1 .9-2 1-3.1Zm-3.8 0h-3V14c1 0 2 .1 2.7.4.2-.5.3-1 .3-1.6Zm-4.4 0h-3l.3 1.6c.8-.3 1.7-.4 2.7-.4v-1.3Zm-5.5-5c-.7 1-1.1 2.2-1.3 3.5h2.3c0-1 .2-1.8.5-2.6l-1.5-1Zm2.9 1.4v.1c-.2.6-.4 1.3-.4 2h3V9.4c-1 0-1.8-.1-2.6-.3Zm6.6 0h-.1l-2.4.3v1.8h3l-.5-2.1Zm3-1.4-.3.1-1.3.8c.3.8.5 1.6.5 2.6h2.3a7.5 7.5 0 0 0-1.3-3.5Zm-9 0 2 .2V5.5a9 9 0 0 0-2 2.2Zm3.5-2.3V8c.6 0 1.3 0 1.9-.2a9 9 0 0 0-2-2.3Zm-3-.7h-.1c-1.1.4-2.1 1-3 1.8l1.2.7a10 10 0 0 1 1.9-2.5Zm4.4 0 .1.1a10 10 0 0 1 1.8 2.4l1.1-.7a7.5 7.5 0 0 0-3-1.8Z\"/></svg>",
			"line-height": "<svg width=\"24\" height=\"24\"><path d=\"M21 5a1 1 0 0 1 .1 2H13a1 1 0 0 1-.1-2H21zm0 4a1 1 0 0 1 .1 2H13a1 1 0 0 1-.1-2H21zm0 4a1 1 0 0 1 .1 2H13a1 1 0 0 1-.1-2H21zm0 4a1 1 0 0 1 .1 2H13a1 1 0 0 1-.1-2H21zM7 3.6l3.7 3.7a1 1 0 0 1-1.3 1.5h-.1L8 7.3v9.2l1.3-1.3a1 1 0 0 1 1.3 0h.1c.4.4.4 1 0 1.3v.1L7 20.4l-3.7-3.7a1 1 0 0 1 1.3-1.5h.1L6 16.7V7.4L4.7 8.7a1 1 0 0 1-1.3 0h-.1a1 1 0 0 1 0-1.3v-.1L7 3.6z\"/></svg>",
			"line": "<svg width=\"24\" height=\"24\"><path d=\"m15 9-8 8H4v-3l8-8 3 3Zm1-1-3-3 1-1h1c-.2 0 0 0 0 0l2 2s0 .2 0 0v1l-1 1ZM4 18h16v2H4v-2Z\" fill-rule=\"evenodd\"/></svg>",
			"link": "<svg width=\"24\" height=\"24\"><path d=\"M6.2 12.3a1 1 0 0 1 1.4 1.4l-2 2a2 2 0 1 0 2.6 2.8l4.8-4.8a1 1 0 0 0 0-1.4 1 1 0 1 1 1.4-1.3 2.9 2.9 0 0 1 0 4L9.6 20a3.9 3.9 0 0 1-5.5-5.5l2-2Zm11.6-.6a1 1 0 0 1-1.4-1.4l2-2a2 2 0 1 0-2.6-2.8L11 10.3a1 1 0 0 0 0 1.4A1 1 0 1 1 9.6 13a2.9 2.9 0 0 1 0-4L14.4 4a3.9 3.9 0 0 1 5.5 5.5l-2 2Z\" fill-rule=\"nonzero\"/></svg>",
			"list-bull-circle": "<svg width=\"48\" height=\"48\"><g fill-rule=\"evenodd\"><path d=\"M11 16a2 2 0 1 0 0-4 2 2 0 0 0 0 4Zm0 1a3 3 0 1 1 0-6 3 3 0 0 1 0 6ZM11 26a2 2 0 1 0 0-4 2 2 0 0 0 0 4Zm0 1a3 3 0 1 1 0-6 3 3 0 0 1 0 6ZM11 36a2 2 0 1 0 0-4 2 2 0 0 0 0 4Zm0 1a3 3 0 1 1 0-6 3 3 0 0 1 0 6Z\" fill-rule=\"nonzero\"/><path opacity=\".2\" d=\"M18 12h22v4H18zM18 22h22v4H18zM18 32h22v4H18z\"/></g></svg>",
			"list-bull-default": "<svg width=\"48\" height=\"48\"><g fill-rule=\"evenodd\"><circle cx=\"11\" cy=\"14\" r=\"3\"/><circle cx=\"11\" cy=\"24\" r=\"3\"/><circle cx=\"11\" cy=\"34\" r=\"3\"/><path opacity=\".2\" d=\"M18 12h22v4H18zM18 22h22v4H18zM18 32h22v4H18z\"/></g></svg>",
			"list-bull-square": "<svg width=\"48\" height=\"48\"><g fill-rule=\"evenodd\"><path d=\"M8 11h6v6H8zM8 21h6v6H8zM8 31h6v6H8z\"/><path opacity=\".2\" d=\"M18 12h22v4H18zM18 22h22v4H18zM18 32h22v4H18z\"/></g></svg>",
			"list-num-default-rtl": "<svg width=\"48\" height=\"48\"><g fill-rule=\"evenodd\"><path opacity=\".2\" d=\"M8 12h22v4H8zM8 22h22v4H8zM8 32h22v4H8z\"/><path d=\"M37.4 17v-4.8h-.1l-1.5 1v-1.1l1.6-1.1h1.2v6zM33.3 17.1c-.5 0-.8-.3-.8-.7 0-.4.3-.7.8-.7.4 0 .7.3.7.7 0 .4-.3.7-.7.7zm1.7 5.7c0-1.2 1-2 2.2-2 1.3 0 2.1.8 2.1 1.8 0 .7-.3 1.2-1.3 2.2l-1.2 1v.2h2.6v1h-4.3v-.9l2-1.9c.8-.8 1-1.1 1-1.5 0-.5-.4-.8-1-.8-.5 0-.9.3-.9.9H35zm-1.7 4.3c-.5 0-.8-.3-.8-.7 0-.4.3-.7.8-.7.4 0 .7.3.7.7 0 .4-.3.7-.7.7zm3.2 7.3v-1h.7c.6 0 1-.3 1-.8 0-.4-.4-.7-1-.7s-1 .3-1 .8H35c0-1.1 1-1.8 2.2-1.8 1.2 0 2.1.6 2.1 1.6 0 .7-.4 1.2-1 1.3v.1c.7.1 1.3.7 1.3 1.4 0 1-1 1.9-2.4 1.9-1.3 0-2.2-.8-2.3-2h1.2c0 .6.5 1 1.1 1 .6 0 1-.4 1-1 0-.5-.3-.8-1-.8h-.7zm-3.3 2.7c-.4 0-.7-.3-.7-.7 0-.4.3-.7.7-.7.5 0 .8.3.8.7 0 .4-.3.7-.8.7z\"/></g></svg>",
			"list-num-default": "<svg width=\"48\" height=\"48\"><g fill-rule=\"evenodd\"><path opacity=\".2\" d=\"M18 12h22v4H18zM18 22h22v4H18zM18 32h22v4H18z\"/><path d=\"M10 17v-4.8l-1.5 1v-1.1l1.6-1h1.2V17h-1.2Zm3.6.1c-.4 0-.7-.3-.7-.7 0-.4.3-.7.7-.7.5 0 .7.3.7.7 0 .4-.2.7-.7.7Zm-5 5.7c0-1.2.8-2 2.1-2s2.1.8 2.1 1.8c0 .7-.3 1.2-1.4 2.2l-1.1 1v.2h2.6v1H8.6v-.9l2-1.9c.8-.8 1-1.1 1-1.5 0-.5-.4-.8-1-.8-.5 0-.9.3-.9.9H8.5Zm6.3 4.3c-.5 0-.7-.3-.7-.7 0-.4.2-.7.7-.7.4 0 .7.3.7.7 0 .4-.3.7-.7.7ZM10 34.4v-1h.7c.6 0 1-.3 1-.8 0-.4-.4-.7-1-.7s-1 .3-1 .8H8.6c0-1.1 1-1.8 2.2-1.8 1.3 0 2.1.6 2.1 1.6 0 .7-.4 1.2-1 1.3v.1c.8.1 1.3.7 1.3 1.4 0 1-1 1.9-2.4 1.9-1.3 0-2.2-.8-2.3-2h1.2c0 .6.5 1 1.1 1 .7 0 1-.4 1-1 0-.5-.3-.8-1-.8h-.7Zm4.7 2.7c-.4 0-.7-.3-.7-.7 0-.4.3-.7.7-.7.5 0 .8.3.8.7 0 .4-.3.7-.8.7Z\"/></g></svg>",
			"list-num-lower-alpha-rtl": "<svg width=\"48\" height=\"48\"><g fill-rule=\"evenodd\"><path opacity=\".2\" d=\"M8 12h22v4H8zM8 22h22v4H8zM8 32h22v4H8z\"/><path d=\"M36.5 16c-.9 0-1.5-.5-1.5-1.3s.6-1.3 1.8-1.4h1v-.4c0-.4-.2-.6-.7-.6-.4 0-.7.1-.8.4h-1.1c0-.8.8-1.4 2-1.4S39 12 39 13V16h-1.2v-.6c-.3.4-.8.7-1.4.7Zm.4-.8c.6 0 1-.4 1-.9V14h-1c-.5.1-.7.3-.7.6 0 .4.3.6.7.6ZM33.1 16.1c-.4 0-.7-.3-.7-.7 0-.4.3-.7.7-.7.5 0 .8.3.8.7 0 .4-.3.7-.8.7ZM37.7 26c-.7 0-1.2-.2-1.5-.7v.7H35v-6.3h1.2v2.5c.3-.5.8-.9 1.5-.9 1.1 0 1.8 1 1.8 2.4 0 1.5-.7 2.4-1.8 2.4Zm-.5-3.6c-.6 0-1 .5-1 1.3s.4 1.4 1 1.4c.7 0 1-.6 1-1.4 0-.8-.3-1.3-1-1.3ZM33.2 26.1c-.4 0-.7-.3-.7-.7 0-.4.3-.7.7-.7.5 0 .8.3.8.7 0 .4-.3.7-.8.7zm6 7h-1c-.1-.5-.4-.8-1-.8s-1 .5-1 1.4c0 1 .4 1.4 1 1.4.5 0 .9-.2 1-.7h1c0 1-.8 1.7-2 1.7-1.4 0-2.2-.9-2.2-2.4s.8-2.4 2.2-2.4c1.2 0 2 .7 2 1.7zm-6.1 3c-.5 0-.7-.3-.7-.7 0-.4.2-.7.7-.7.4 0 .7.3.7.7 0 .4-.3.7-.7.7z\"/></g></svg>",
			"list-num-lower-alpha": "<svg width=\"48\" height=\"48\"><g fill-rule=\"evenodd\"><path opacity=\".2\" d=\"M18 12h22v4H18zM18 22h22v4H18zM18 32h22v4H18z\"/><path d=\"M10.3 15.2c.5 0 1-.4 1-.9V14h-1c-.5.1-.8.3-.8.6 0 .4.3.6.8.6Zm-.4.9c-1 0-1.5-.6-1.5-1.4 0-.8.6-1.3 1.7-1.4h1.1v-.4c0-.4-.2-.6-.7-.6-.5 0-.8.1-.9.4h-1c0-.8.8-1.4 2-1.4 1.1 0 1.8.6 1.8 1.6V16h-1.1v-.6h-.1c-.2.4-.7.7-1.3.7Zm4.6 0c-.5 0-.7-.3-.7-.7 0-.4.2-.7.7-.7.4 0 .7.3.7.7 0 .4-.3.7-.7.7Zm-3.2 10c-.6 0-1.2-.3-1.4-.8v.7H8.5v-6.3H10v2.5c.3-.5.8-.9 1.4-.9 1.2 0 1.9 1 1.9 2.4 0 1.5-.7 2.4-1.9 2.4Zm-.4-3.7c-.7 0-1 .5-1 1.3s.3 1.4 1 1.4c.6 0 1-.6 1-1.4 0-.8-.4-1.3-1-1.3Zm4 3.7c-.5 0-.7-.3-.7-.7 0-.4.2-.7.7-.7.4 0 .7.3.7.7 0 .4-.3.7-.7.7Zm-2.2 7h-1.2c0-.5-.4-.8-.9-.8-.6 0-1 .5-1 1.4 0 1 .4 1.4 1 1.4.5 0 .8-.2 1-.7h1c0 1-.8 1.7-2 1.7-1.4 0-2.2-.9-2.2-2.4s.8-2.4 2.2-2.4c1.2 0 2 .7 2 1.7Zm1.8 3c-.5 0-.8-.3-.8-.7 0-.4.3-.7.8-.7.4 0 .7.3.7.7 0 .4-.3.7-.7.7Z\"/></g></svg>",
			"list-num-lower-greek-rtl": "<svg width=\"48\" height=\"48\"><g fill-rule=\"evenodd\"><path opacity=\".2\" d=\"M8 12h22v4H8zM8 22h22v4H8zM8 32h22v4H8z\"/><path d=\"M37.4 16c-1.2 0-2-.8-2-2.3 0-1.5.8-2.4 2-2.4.6 0 1 .4 1.3 1v-.9H40v3.2c0 .4.1.5.4.5h.2v.9h-.6c-.6 0-1-.2-1-.7h-.2c-.2.4-.7.8-1.3.8Zm.3-1c.6 0 1-.5 1-1.3s-.4-1.3-1-1.3-1 .5-1 1.3.4 1.4 1 1.4ZM33.3 16.1c-.5 0-.8-.3-.8-.7 0-.4.3-.7.8-.7.4 0 .7.3.7.7 0 .4-.3.7-.7.7ZM36 21.9c0-1.5.8-2.3 2.1-2.3 1.2 0 2 .6 2 1.6 0 .6-.3 1-.9 1.3.9.3 1.3.8 1.3 1.7 0 1.2-.7 1.9-1.8 1.9-.6 0-1.1-.3-1.4-.8v2.2H36V22Zm1.8 1.2v-1h.3c.5 0 .9-.2.9-.7 0-.5-.3-.8-.9-.8-.5 0-.8.3-.8 1v2.2c0 .8.4 1.3 1 1.3s1-.4 1-1-.4-1-1.2-1h-.3ZM33.3 26.1c-.5 0-.8-.3-.8-.7 0-.4.3-.7.8-.7.4 0 .7.3.7.7 0 .4-.3.7-.7.7ZM37.1 34.6 34.8 30h1.4l1.7 3.5 1.7-3.5h1.1l-2.2 4.6v.1c.5.8.7 1.4.7 1.8 0 .4-.2.8-.4 1-.2.2-.6.3-1 .3-.9 0-1.3-.4-1.3-1.2 0-.5.2-1 .5-1.7l.1-.2Zm.7 1a2 2 0 0 0-.4.9c0 .3.1.4.4.4.3 0 .4-.1.4-.4 0-.2-.1-.6-.4-1ZM33.3 36.1c-.5 0-.8-.3-.8-.7 0-.4.3-.7.8-.7.4 0 .7.3.7.7 0 .4-.3.7-.7.7Z\"/></g></svg>",
			"list-num-lower-greek": "<svg width=\"48\" height=\"48\"><g fill-rule=\"evenodd\"><path opacity=\".2\" d=\"M18 12h22v4H18zM18 22h22v4H18zM18 32h22v4H18z\"/><path d=\"M10.5 15c.7 0 1-.5 1-1.3s-.3-1.3-1-1.3c-.5 0-.9.5-.9 1.3s.4 1.4 1 1.4Zm-.3 1c-1.1 0-1.8-.8-1.8-2.3 0-1.5.7-2.4 1.8-2.4.7 0 1.1.4 1.3 1h.1v-.9h1.2v3.2c0 .4.1.5.4.5h.2v.9h-.6c-.6 0-1-.2-1.1-.7h-.1c-.2.4-.7.8-1.4.8Zm5 .1c-.5 0-.8-.3-.8-.7 0-.4.3-.7.7-.7.5 0 .8.3.8.7 0 .4-.3.7-.8.7Zm-4.9 7v-1h.3c.6 0 1-.2 1-.7 0-.5-.4-.8-1-.8-.5 0-.8.3-.8 1v2.2c0 .8.4 1.3 1.1 1.3.6 0 1-.4 1-1s-.5-1-1.3-1h-.3ZM8.6 22c0-1.5.7-2.3 2-2.3 1.2 0 2 .6 2 1.6 0 .6-.3 1-.8 1.3.8.3 1.3.8 1.3 1.7 0 1.2-.8 1.9-1.9 1.9-.6 0-1.1-.3-1.3-.8v2.2H8.5V22Zm6.2 4.2c-.4 0-.7-.3-.7-.7 0-.4.3-.7.7-.7.5 0 .7.3.7.7 0 .4-.2.7-.7.7Zm-4.5 8.5L8 30h1.4l1.7 3.5 1.7-3.5h1.1l-2.2 4.6v.1c.5.8.7 1.4.7 1.8 0 .4-.1.8-.4 1-.2.2-.6.3-1 .3-.9 0-1.3-.4-1.3-1.2 0-.5.2-1 .5-1.7l.1-.2Zm.7 1a2 2 0 0 0-.4.9c0 .3.1.4.4.4.3 0 .4-.1.4-.4 0-.2-.1-.6-.4-1Zm4.5.5c-.5 0-.8-.3-.8-.7 0-.4.3-.7.8-.7.4 0 .7.3.7.7 0 .4-.3.7-.7.7Z\"/></g></svg>",
			"list-num-lower-roman-rtl": "<svg width=\"48\" height=\"48\"><g fill-rule=\"evenodd\"><path opacity=\".2\" d=\"M8 12h22v4H8zM8 22h22v4H8zM8 32h22v4H8z\"/><path d=\"M32.9 16v-1.2h-1.3V16H33Zm0 10v-1.2h-1.3V26H33Zm0 10v-1.2h-1.3V36H33Z\"/><path fill-rule=\"nonzero\" d=\"M36 21h-1.5v5H36zM36 31h-1.5v5H36zM39 21h-1.5v5H39zM39 31h-1.5v5H39zM42 31h-1.5v5H42zM36 11h-1.5v5H36zM36 19h-1.5v1H36zM36 29h-1.5v1H36zM39 19h-1.5v1H39zM39 29h-1.5v1H39zM42 29h-1.5v1H42zM36 9h-1.5v1H36z\"/></g></svg>",
			"list-num-lower-roman": "<svg width=\"48\" height=\"48\"><g fill-rule=\"evenodd\"><path opacity=\".2\" d=\"M18 12h22v4H18zM18 22h22v4H18zM18 32h22v4H18z\"/><path d=\"M15.1 16v-1.2h1.3V16H15Zm0 10v-1.2h1.3V26H15Zm0 10v-1.2h1.3V36H15Z\"/><path fill-rule=\"nonzero\" d=\"M12 21h1.5v5H12zM12 31h1.5v5H12zM9 21h1.5v5H9zM9 31h1.5v5H9zM6 31h1.5v5H6zM12 11h1.5v5H12zM12 19h1.5v1H12zM12 29h1.5v1H12zM9 19h1.5v1H9zM9 29h1.5v1H9zM6 29h1.5v1H6zM12 9h1.5v1H12z\"/></g></svg>",
			"list-num-upper-alpha-rtl": "<svg width=\"48\" height=\"48\"><g fill-rule=\"evenodd\"><path opacity=\".2\" d=\"M8 12h22v4H8zM8 22h22v4H8zM8 32h22v4H8z\"/><path d=\"m39.3 17-.5-1.4h-2l-.5 1.4H35l2-6h1.6l2 6h-1.3Zm-1.6-4.7-.7 2.3h1.6l-.8-2.3ZM33.4 17c-.4 0-.7-.3-.7-.7 0-.4.3-.7.7-.7.5 0 .7.3.7.7 0 .4-.2.7-.7.7Zm4.7 9.9h-2.7v-6H38c1.2 0 1.9.6 1.9 1.5 0 .6-.5 1.2-1 1.3.7.1 1.3.7 1.3 1.5 0 1-.8 1.7-2 1.7Zm-1.4-5v1.5h1c.6 0 1-.3 1-.8 0-.4-.4-.7-1-.7h-1Zm0 4h1.1c.7 0 1.1-.3 1.1-.8 0-.6-.4-.9-1.1-.9h-1.1V26ZM33 27.1c-.5 0-.8-.3-.8-.7 0-.4.3-.7.8-.7.4 0 .7.3.7.7 0 .4-.3.7-.7.7Zm4.9 10c-1.8 0-2.8-1.1-2.8-3.1s1-3.1 2.8-3.1c1.4 0 2.5.9 2.6 2.2h-1.3c0-.7-.6-1.1-1.3-1.1-1 0-1.6.7-1.6 2s.6 2 1.6 2c.7 0 1.2-.4 1.4-1h1.2c-.1 1.3-1.2 2.2-2.6 2.2Zm-4.5 0c-.5 0-.8-.3-.8-.7 0-.4.3-.7.8-.7.4 0 .7.3.7.7 0 .4-.3.7-.7.7Z\"/></g></svg>",
			"list-num-upper-alpha": "<svg width=\"48\" height=\"48\"><g fill-rule=\"evenodd\"><path opacity=\".2\" d=\"M18 12h22v4H18zM18 22h22v4H18zM18 32h22v4H18z\"/><path d=\"m12.6 17-.5-1.4h-2L9.5 17H8.3l2-6H12l2 6h-1.3ZM11 12.3l-.7 2.3h1.6l-.8-2.3Zm4.7 4.8c-.4 0-.7-.3-.7-.7 0-.4.3-.7.7-.7.5 0 .7.3.7.7 0 .4-.2.7-.7.7ZM11.4 27H8.7v-6h2.6c1.2 0 1.9.6 1.9 1.5 0 .6-.5 1.2-1 1.3.7.1 1.3.7 1.3 1.5 0 1-.8 1.7-2 1.7ZM10 22v1.5h1c.6 0 1-.3 1-.8 0-.4-.4-.7-1-.7h-1Zm0 4H11c.7 0 1.1-.3 1.1-.8 0-.6-.4-.9-1.1-.9H10V26Zm5.4 1.1c-.5 0-.8-.3-.8-.7 0-.4.3-.7.8-.7.4 0 .7.3.7.7 0 .4-.3.7-.7.7Zm-4.1 10c-1.8 0-2.8-1.1-2.8-3.1s1-3.1 2.8-3.1c1.4 0 2.5.9 2.6 2.2h-1.3c0-.7-.6-1.1-1.3-1.1-1 0-1.6.7-1.6 2s.6 2 1.6 2c.7 0 1.2-.4 1.4-1h1.2c-.1 1.3-1.2 2.2-2.6 2.2Zm4.5 0c-.5 0-.8-.3-.8-.7 0-.4.3-.7.8-.7.4 0 .7.3.7.7 0 .4-.3.7-.7.7Z\"/></g></svg>",
			"list-num-upper-roman-rtl": "<svg width=\"48\" height=\"48\"><g fill-rule=\"evenodd\"><path opacity=\".2\" d=\"M8 12h22v4H8zM8 22h22v4H8zM8 32h22v4H8z\"/><path d=\"M31.6 17v-1.2H33V17h-1.3Zm0 10v-1.2H33V27h-1.3Zm0 10v-1.2H33V37h-1.3Z\"/><path fill-rule=\"nonzero\" d=\"M34.5 20H36v7h-1.5zM34.5 30H36v7h-1.5zM37.5 20H39v7h-1.5zM37.5 30H39v7h-1.5zM40.5 30H42v7h-1.5zM34.5 10H36v7h-1.5z\"/></g></svg>",
			"list-num-upper-roman": "<svg width=\"48\" height=\"48\"><g fill-rule=\"evenodd\"><path opacity=\".2\" d=\"M18 12h22v4H18zM18 22h22v4H18zM18 32h22v4H18z\"/><path d=\"M15.1 17v-1.2h1.3V17H15Zm0 10v-1.2h1.3V27H15Zm0 10v-1.2h1.3V37H15Z\"/><path fill-rule=\"nonzero\" d=\"M12 20h1.5v7H12zM12 30h1.5v7H12zM9 20h1.5v7H9zM9 30h1.5v7H9zM6 30h1.5v7H6zM12 10h1.5v7H12z\"/></g></svg>",
			"lock": "<svg width=\"24\" height=\"24\"><path d=\"M16.3 11c.2 0 .3 0 .5.2l.2.6v7.4c0 .3 0 .4-.2.6l-.6.2H7.8c-.3 0-.4 0-.6-.2a.7.7 0 0 1-.2-.6v-7.4c0-.3 0-.4.2-.6l.5-.2H8V8c0-.8.3-1.5.9-2.1.6-.6 1.3-.9 2.1-.9h2c.8 0 1.5.3 2.1.9.6.6.9 1.3.9 2.1v3h.3ZM10 8v3h4V8a1 1 0 0 0-.3-.7A1 1 0 0 0 13 7h-2a1 1 0 0 0-.7.3 1 1 0 0 0-.3.7Z\" fill-rule=\"evenodd\"/></svg>",
			"ltr": "<svg width=\"24\" height=\"24\"><path d=\"M11 5h7a1 1 0 0 1 0 2h-1v11a1 1 0 0 1-2 0V7h-2v11a1 1 0 0 1-2 0v-6c-.5 0-1 0-1.4-.3A3.4 3.4 0 0 1 7.8 10a3.3 3.3 0 0 1 0-2.8 3.4 3.4 0 0 1 1.8-1.8L11 5ZM4.4 16.2 6.2 15l-1.8-1.2a1 1 0 0 1 1.2-1.6l3 2a1 1 0 0 1 0 1.6l-3 2a1 1 0 1 1-1.2-1.6Z\" fill-rule=\"evenodd\"/></svg>",
			"minus": "<svg width=\"24\" height=\"24\"><path d=\"M19 11a1 1 0 0 1 .1 2H5a1 1 0 0 1-.1-2H19Z\"/></svg>",
			"more-drawer": "<svg width=\"24\" height=\"24\"><path d=\"M6 10a2 2 0 0 0-2 2c0 1.1.9 2 2 2a2 2 0 0 0 2-2 2 2 0 0 0-2-2Zm12 0a2 2 0 0 0-2 2c0 1.1.9 2 2 2a2 2 0 0 0 2-2 2 2 0 0 0-2-2Zm-6 0a2 2 0 0 0-2 2c0 1.1.9 2 2 2a2 2 0 0 0 2-2 2 2 0 0 0-2-2Z\" fill-rule=\"nonzero\"/></svg>",
			"new-document": "<svg width=\"24\" height=\"24\"><path d=\"M14.4 3H7a2 2 0 0 0-2 2v14c0 1.1.9 2 2 2h10a2 2 0 0 0 2-2V7.6L14.4 3ZM17 19H7V5h6v4h4v10Z\" fill-rule=\"nonzero\"/></svg>",
			"new-tab": "<svg width=\"24\" height=\"24\"><path d=\"m15 13 2-2v8H5V7h8l-2 2H7v8h8v-4Zm4-8v5.5l-2-2-5.6 5.5H10v-1.4L15.5 7l-2-2H19Z\" fill-rule=\"evenodd\"/></svg>",
			"non-breaking": "<svg width=\"24\" height=\"24\"><path d=\"M11 11H8a1 1 0 1 1 0-2h3V6c0-.6.4-1 1-1s1 .4 1 1v3h3c.6 0 1 .4 1 1s-.4 1-1 1h-3v3c0 .6-.4 1-1 1a1 1 0 0 1-1-1v-3Zm10 4v5H3v-5c0-.6.4-1 1-1s1 .4 1 1v3h14v-3c0-.6.4-1 1-1s1 .4 1 1Z\" fill-rule=\"evenodd\"/></svg>",
			"notice": "<svg width=\"24\" height=\"24\"><path d=\"M15.5 4 20 8.5v7L15.5 20h-7L4 15.5v-7L8.5 4h7ZM13 17v-2h-2v2h2Zm0-4V7h-2v6h2Z\" fill-rule=\"evenodd\" clip-rule=\"evenodd\"/></svg>",
			"ordered-list-rtl": "<svg width=\"24\" height=\"24\"><path d=\"M6 17h8a1 1 0 0 1 0 2H6a1 1 0 0 1 0-2Zm0-6h8a1 1 0 0 1 0 2H6a1 1 0 0 1 0-2Zm0-6h8a1 1 0 0 1 0 2H6a1 1 0 1 1 0-2Zm13-1v3.5a.5.5 0 1 1-1 0V5h-.5a.5.5 0 1 1 0-1H19Zm-1 8.8.2.2h1.3a.5.5 0 1 1 0 1h-1.6a1 1 0 0 1-.9-1V13c0-.4.3-.8.6-1l1.2-.4.2-.3a.2.2 0 0 0-.2-.2h-1.3a.5.5 0 0 1-.5-.5c0-.3.2-.5.5-.5h1.6c.5 0 .9.4.9 1v.1c0 .4-.3.8-.6 1l-1.2.4-.2.3Zm2 4.2v2c0 .6-.4 1-1 1h-1.5a.5.5 0 0 1 0-1h1.2a.3.3 0 1 0 0-.6h-1.3a.4.4 0 1 1 0-.8h1.3a.3.3 0 0 0 0-.6h-1.2a.5.5 0 1 1 0-1H19c.6 0 1 .4 1 1Z\" fill-rule=\"evenodd\"/></svg>",
			"ordered-list": "<svg width=\"24\" height=\"24\"><path d=\"M10 17h8c.6 0 1 .4 1 1s-.4 1-1 1h-8a1 1 0 0 1 0-2Zm0-6h8c.6 0 1 .4 1 1s-.4 1-1 1h-8a1 1 0 0 1 0-2Zm0-6h8c.6 0 1 .4 1 1s-.4 1-1 1h-8a1 1 0 1 1 0-2ZM6 4v3.5c0 .3-.2.5-.5.5a.5.5 0 0 1-.5-.5V5h-.5a.5.5 0 0 1 0-1H6Zm-1 8.8.2.2h1.3c.3 0 .5.2.5.5s-.2.5-.5.5H4.9a1 1 0 0 1-.9-1V13c0-.4.3-.8.6-1l1.2-.4.2-.3a.2.2 0 0 0-.2-.2H4.5a.5.5 0 0 1-.5-.5c0-.3.2-.5.5-.5h1.6c.5 0 .9.4.9 1v.1c0 .4-.3.8-.6 1l-1.2.4-.2.3ZM7 17v2c0 .6-.4 1-1 1H4.5a.5.5 0 0 1 0-1h1.2c.2 0 .3-.1.3-.3 0-.2-.1-.3-.3-.3H4.4a.4.4 0 1 1 0-.8h1.3c.2 0 .3-.1.3-.3 0-.2-.1-.3-.3-.3H4.5a.5.5 0 1 1 0-1H6c.6 0 1 .4 1 1Z\" fill-rule=\"evenodd\"/></svg>",
			"orientation": "<svg width=\"24\" height=\"24\"><path d=\"M7.3 6.4 1 13l6.4 6.5 6.5-6.5-6.5-6.5ZM3.7 13l3.6-3.7L11 13l-3.7 3.7-3.6-3.7ZM12 6l2.8 2.7c.3.3.3.8 0 1-.3.4-.9.4-1.2 0L9.2 5.7a.8.8 0 0 1 0-1.2L13.6.2c.3-.3.9-.3 1.2 0 .3.3.3.8 0 1.1L12 4h1a9 9 0 1 1-4.3 16.9l1.5-1.5A7 7 0 1 0 13 6h-1Z\" fill-rule=\"nonzero\"/></svg>",
			"outdent": "<svg width=\"24\" height=\"24\"><path d=\"M7 5h12c.6 0 1 .4 1 1s-.4 1-1 1H7a1 1 0 1 1 0-2Zm5 4h7c.6 0 1 .4 1 1s-.4 1-1 1h-7a1 1 0 0 1 0-2Zm0 4h7c.6 0 1 .4 1 1s-.4 1-1 1h-7a1 1 0 0 1 0-2Zm-5 4h12a1 1 0 0 1 0 2H7a1 1 0 0 1 0-2Zm1.6-3.8a1 1 0 0 1-1.2 1.6l-3-2a1 1 0 0 1 0-1.6l3-2a1 1 0 0 1 1.2 1.6L6.8 12l1.8 1.2Z\" fill-rule=\"evenodd\"/></svg>",
			"page-break": "<svg width=\"24\" height=\"24\"><g fill-rule=\"evenodd\"><path d=\"M5 11c.6 0 1 .4 1 1s-.4 1-1 1a1 1 0 0 1 0-2Zm3 0h1c.6 0 1 .4 1 1s-.4 1-1 1H8a1 1 0 0 1 0-2Zm4 0c.6 0 1 .4 1 1s-.4 1-1 1a1 1 0 0 1 0-2Zm3 0h1c.6 0 1 .4 1 1s-.4 1-1 1h-1a1 1 0 0 1 0-2Zm4 0c.6 0 1 .4 1 1s-.4 1-1 1a1 1 0 0 1 0-2ZM7 3v5h10V3c0-.6.4-1 1-1s1 .4 1 1v7H5V3c0-.6.4-1 1-1s1 .4 1 1ZM6 22a1 1 0 0 1-1-1v-7h14v7c0 .6-.4 1-1 1a1 1 0 0 1-1-1v-5H7v5c0 .6-.4 1-1 1Z\"/></g></svg>",
			"paragraph": "<svg width=\"24\" height=\"24\"><path fill-rule=\"evenodd\" d=\"M10 5h7a1 1 0 0 1 0 2h-1v11a1 1 0 0 1-2 0V7h-2v11a1 1 0 0 1-2 0v-6c-.5 0-1 0-1.4-.3A3.4 3.4 0 0 1 6.8 10a3.3 3.3 0 0 1 0-2.8 3.4 3.4 0 0 1 1.8-1.8L10 5Z\"/></svg>",
			"paste-column-after": "<svg width=\"24\" height=\"24\"><path fill-rule=\"evenodd\" d=\"M12 1a3 3 0 0 1 2.8 2H18c1 0 2 .8 2 1.9V7h-2V5h-2v1c0 .6-.4 1-1 1H9a1 1 0 0 1-1-1V5H6v13h7v2H6c-1 0-2-.8-2-1.9V5c0-1 .8-2 1.9-2H9.2A3 3 0 0 1 12 1Zm8 7v12h-6V8h6Zm-1.5 1.5h-3v9h3v-9ZM12 3a1 1 0 1 0 0 2 1 1 0 0 0 0-2Z\"/></svg>",
			"paste-column-before": "<svg width=\"24\" height=\"24\"><path fill-rule=\"evenodd\" d=\"M12 1a3 3 0 0 1 2.8 2H18c1 0 2 .8 2 1.9V18c0 1-.8 2-1.9 2H11v-2h7V5h-2v1c0 .6-.4 1-1 1H9a1 1 0 0 1-1-1V5H6v2H4V5c0-1 .8-2 1.9-2H9.2A3 3 0 0 1 12 1Zm-2 7v12H4V8h6ZM8.5 9.5h-3v9h3v-9ZM12 3a1 1 0 1 0 0 2 1 1 0 0 0 0-2Z\"/></svg>",
			"paste-row-after": "<svg width=\"24\" height=\"24\"><path fill-rule=\"evenodd\" d=\"M12 1a3 3 0 0 1 2.8 2H18c1 0 2 .8 2 1.9V11h-2V5h-2v1c0 .6-.4 1-1 1H9a1 1 0 0 1-1-1V5H6v13h14c0 1-.8 2-1.9 2H6c-1 0-2-.8-2-1.9V5c0-1 .8-2 1.9-2H9.2A3 3 0 0 1 12 1Zm10 11v5H8v-5h14Zm-1.5 1.5h-11v2h11v-2ZM12 3a1 1 0 1 0 0 2 1 1 0 0 0 0-2Z\"/></svg>",
			"paste-row-before": "<svg width=\"24\" height=\"24\"><path fill-rule=\"evenodd\" d=\"M12 1a3 3 0 0 1 2.8 2H18c1 0 2 .8 2 1.9V7h-2V5h-2v1c0 .6-.4 1-1 1H9a1 1 0 0 1-1-1V5H6v13h12v-4h2v4c0 1-.8 2-1.9 2H6c-1 0-2-.8-2-1.9V5c0-1 .8-2 1.9-2H9.2A3 3 0 0 1 12 1Zm10 7v5H8V8h14Zm-1.5 1.5h-11v2h11v-2ZM12 3a1 1 0 1 0 0 2 1 1 0 0 0 0-2Z\"/></svg>",
			"paste-text": "<svg width=\"24\" height=\"24\"><path d=\"M18 9V5h-2v1c0 .6-.4 1-1 1H9a1 1 0 0 1-1-1V5H6v13h3V9h9ZM9 20H6a2 2 0 0 1-2-2V5c0-1.1.9-2 2-2h3.2A3 3 0 0 1 12 1a3 3 0 0 1 2.8 2H18a2 2 0 0 1 2 2v4h1v12H9v-1Zm1.5-9.5v9h9v-9h-9ZM12 3a1 1 0 0 0-1 1c0 .5.4 1 1 1s1-.5 1-1-.4-1-1-1Zm0 9h6v2h-.5l-.5-1h-1v4h.8v1h-3.6v-1h.8v-4h-1l-.5 1H12v-2Z\" fill-rule=\"nonzero\"/></svg>",
			"paste": "<svg width=\"24\" height=\"24\"><path d=\"M18 9V5h-2v1c0 .6-.4 1-1 1H9a1 1 0 0 1-1-1V5H6v13h3V9h9ZM9 20H6a2 2 0 0 1-2-2V5c0-1.1.9-2 2-2h3.2A3 3 0 0 1 12 1a3 3 0 0 1 2.8 2H18a2 2 0 0 1 2 2v4h1v12H9v-1Zm1.5-9.5v9h9v-9h-9ZM12 3a1 1 0 0 0-1 1c0 .5.4 1 1 1s1-.5 1-1-.4-1-1-1Z\" fill-rule=\"nonzero\"/></svg>",
			"permanent-pen": "<svg width=\"24\" height=\"24\"><path d=\"M10.5 17.5 8 20H3v-3l3.5-3.5a2 2 0 0 1 0-3L14 3l1 1-7.3 7.3a1 1 0 0 0 0 1.4l3.6 3.6c.4.4 1 .4 1.4 0L20 9l1 1-7.6 7.6a2 2 0 0 1-2.8 0l-.1-.1Z\" fill-rule=\"nonzero\"/></svg>",
			"plus": "<svg width=\"24\" height=\"24\"><path d=\"M12 4c.5 0 1 .4 1 .9V11h6a1 1 0 0 1 .1 2H13v6a1 1 0 0 1-2 .1V13H5a1 1 0 0 1-.1-2H11V5c0-.6.4-1 1-1Z\"/></svg>",
			"preferences": "<svg width=\"24\" height=\"24\"><path d=\"m20.1 13.5-1.9.2a5.8 5.8 0 0 1-.6 1.5l1.2 1.5c.4.4.3 1 0 1.4l-.7.7a1 1 0 0 1-1.4 0l-1.5-1.2a6.2 6.2 0 0 1-1.5.6l-.2 1.9c0 .5-.5.9-1 .9h-1a1 1 0 0 1-1-.9l-.2-1.9a5.8 5.8 0 0 1-1.5-.6l-1.5 1.2a1 1 0 0 1-1.4 0l-.7-.7a1 1 0 0 1 0-1.4l1.2-1.5a6.2 6.2 0 0 1-.6-1.5l-1.9-.2a1 1 0 0 1-.9-1v-1c0-.5.4-1 .9-1l1.9-.2a5.8 5.8 0 0 1 .6-1.5L5.2 7.3a1 1 0 0 1 0-1.4l.7-.7a1 1 0 0 1 1.4 0l1.5 1.2a6.2 6.2 0 0 1 1.5-.6l.2-1.9c0-.5.5-.9 1-.9h1c.5 0 1 .4 1 .9l.2 1.9a5.8 5.8 0 0 1 1.5.6l1.5-1.2a1 1 0 0 1 1.4 0l.7.7c.3.4.4 1 0 1.4l-1.2 1.5a6.2 6.2 0 0 1 .6 1.5l1.9.2c.5 0 .9.5.9 1v1c0 .5-.4 1-.9 1ZM12 15a3 3 0 1 0 0-6 3 3 0 0 0 0 6Z\" fill-rule=\"evenodd\"/></svg>",
			"preview": "<svg width=\"24\" height=\"24\"><path d=\"M3.5 12.5c.5.8 1.1 1.6 1.8 2.3 2 2 4.2 3.2 6.7 3.2s4.7-1.2 6.7-3.2a16.2 16.2 0 0 0 2.1-2.8 15.7 15.7 0 0 0-2.1-2.8c-2-2-4.2-3.2-6.7-3.2a9.3 9.3 0 0 0-6.7 3.2A16.2 16.2 0 0 0 3.2 12c0 .2.2.3.3.5Zm-2.4-1 .7-1.2L4 7.8C6.2 5.4 8.9 4 12 4c3 0 5.8 1.4 8.1 3.8a18.2 18.2 0 0 1 2.8 3.7v1l-.7 1.2-2.1 2.5c-2.3 2.4-5 3.8-8.1 3.8-3 0-5.8-1.4-8.1-3.8a18.2 18.2 0 0 1-2.8-3.7 1 1 0 0 1 0-1Zm12-3.3a2 2 0 1 0 2.7 2.6 4 4 0 1 1-2.6-2.6Z\" fill-rule=\"nonzero\"/></svg>",
			"print": "<svg width=\"24\" height=\"24\"><path d=\"M18 8H6a3 3 0 0 0-3 3v6h2v3h14v-3h2v-6a3 3 0 0 0-3-3Zm-1 10H7v-4h10v4Zm.5-5c-.8 0-1.5-.7-1.5-1.5s.7-1.5 1.5-1.5 1.5.7 1.5 1.5-.7 1.5-1.5 1.5Zm.5-8H6v2h12V5Z\" fill-rule=\"nonzero\"/></svg>",
			"quote": "<svg width=\"24\" height=\"24\"><path d=\"M7.5 17h.9c.4 0 .7-.2.9-.6L11 13V8c0-.6-.4-1-1-1H6a1 1 0 0 0-1 1v4c0 .6.4 1 1 1h2l-1.3 2.7a1 1 0 0 0 .8 1.3Zm8 0h.9c.4 0 .7-.2.9-.6L19 13V8c0-.6-.4-1-1-1h-4a1 1 0 0 0-1 1v4c0 .6.4 1 1 1h2l-1.3 2.7a1 1 0 0 0 .8 1.3Z\" fill-rule=\"nonzero\"/></svg>",
			"redo": "<svg width=\"24\" height=\"24\"><path d=\"M17.6 10H12c-2.8 0-4.4 1.4-4.9 3.5-.4 2 .3 4 1.4 4.6a1 1 0 1 1-1 1.8c-2-1.2-2.9-4.1-2.3-6.8.6-3 3-5.1 6.8-5.1h5.6l-3.3-3.3a1 1 0 1 1 1.4-1.4l5 5a1 1 0 0 1 0 1.4l-5 5a1 1 0 0 1-1.4-1.4l3.3-3.3Z\" fill-rule=\"nonzero\"/></svg>",
			"reload": "<svg width=\"24\" height=\"24\"><g fill-rule=\"nonzero\"><path d=\"m5 22.1-1.2-4.7v-.2a1 1 0 0 1 1-1l5 .4a1 1 0 1 1-.2 2l-2.2-.2a7.8 7.8 0 0 0 8.4.2 7.5 7.5 0 0 0 3.5-6.4 1 1 0 1 1 2 0 9.5 9.5 0 0 1-4.5 8 9.9 9.9 0 0 1-10.2 0l.4 1.4a1 1 0 1 1-2 .5ZM13.6 7.4c0-.5.5-1 1-.9l2.8.2a8 8 0 0 0-9.5-1 7.5 7.5 0 0 0-3.6 7 1 1 0 0 1-2 0 9.5 9.5 0 0 1 4.5-8.6 10 10 0 0 1 10.9.3l-.3-1a1 1 0 0 1 2-.5l1.1 4.8a1 1 0 0 1-1 1.2l-5-.4a1 1 0 0 1-.9-1Z\"/></g></svg>",
			"remove-formatting": "<svg width=\"24\" height=\"24\"><path d=\"M13.2 6a1 1 0 0 1 0 .2l-2.6 10a1 1 0 0 1-1 .8h-.2a.8.8 0 0 1-.8-1l2.6-10H8a1 1 0 1 1 0-2h9a1 1 0 0 1 0 2h-3.8ZM5 18h7a1 1 0 0 1 0 2H5a1 1 0 0 1 0-2Zm13 1.5L16.5 18 15 19.5a.7.7 0 0 1-1-1l1.5-1.5-1.5-1.5a.7.7 0 0 1 1-1l1.5 1.5 1.5-1.5a.7.7 0 0 1 1 1L17.5 17l1.5 1.5a.7.7 0 0 1-1 1Z\" fill-rule=\"evenodd\"/></svg>",
			"remove": "<svg width=\"24\" height=\"24\"><path d=\"M16 7h3a1 1 0 0 1 0 2h-1v9a3 3 0 0 1-3 3H9a3 3 0 0 1-3-3V9H5a1 1 0 1 1 0-2h3V6a3 3 0 0 1 3-3h2a3 3 0 0 1 3 3v1Zm-2 0V6c0-.6-.4-1-1-1h-2a1 1 0 0 0-1 1v1h4Zm2 2H8v9c0 .6.4 1 1 1h6c.6 0 1-.4 1-1V9Zm-7 3a1 1 0 0 1 2 0v4a1 1 0 0 1-2 0v-4Zm4 0a1 1 0 0 1 2 0v4a1 1 0 0 1-2 0v-4Z\" fill-rule=\"nonzero\"/></svg>",
			"resize-handle": "<svg width=\"10\" height=\"10\"><g fill-rule=\"nonzero\"><path d=\"M8.1 1.1A.5.5 0 1 1 9 2l-7 7A.5.5 0 1 1 1 8l7-7ZM8.1 5.1A.5.5 0 1 1 9 6l-3 3A.5.5 0 1 1 5 8l3-3Z\"/></g></svg>",
			"resize": "<svg width=\"24\" height=\"24\"><path d=\"M4 5c0-.3.1-.5.3-.7.2-.2.4-.3.7-.3h6c.3 0 .5.1.7.3.2.2.3.4.3.7 0 .3-.1.5-.3.7a1 1 0 0 1-.7.3H7.4L18 16.6V13c0-.3.1-.5.3-.7.2-.2.4-.3.7-.3.3 0 .5.1.7.3.2.2.3.4.3.7v6c0 .3-.1.5-.3.7a1 1 0 0 1-.7.3h-6a1 1 0 0 1-.7-.3 1 1 0 0 1-.3-.7c0-.3.1-.5.3-.7.2-.2.4-.3.7-.3h3.6L6 7.4V11c0 .3-.1.5-.3.7a1 1 0 0 1-.7.3 1 1 0 0 1-.7-.3A1 1 0 0 1 4 11V5Z\" fill-rule=\"evenodd\"/></svg>",
			"restore-draft": "<svg width=\"24\" height=\"24\"><g fill-rule=\"evenodd\"><path d=\"M17 13c0 .6-.4 1-1 1h-4V8c0-.6.4-1 1-1s1 .4 1 1v4h2c.6 0 1 .4 1 1Z\"/><path d=\"M4.7 10H9a1 1 0 0 1 0 2H3a1 1 0 0 1-1-1V5a1 1 0 1 1 2 0v3l2.5-2.4a9.2 9.2 0 0 1 10.8-1.5A9 9 0 0 1 13.4 21c-2.4.1-4.7-.7-6.5-2.2a1 1 0 1 1 1.3-1.5 7.2 7.2 0 0 0 11.6-3.7 7 7 0 0 0-3.5-7.7A7.2 7.2 0 0 0 8 7L4.7 10Z\" fill-rule=\"nonzero\"/></g></svg>",
			"rotate-left": "<svg width=\"24\" height=\"24\"><path d=\"M4.7 10H9a1 1 0 0 1 0 2H3a1 1 0 0 1-1-1V5a1 1 0 1 1 2 0v3l2.5-2.4a9.2 9.2 0 0 1 10.8-1.5A9 9 0 0 1 13.4 21c-2.4.1-4.7-.7-6.5-2.2a1 1 0 1 1 1.3-1.5 7.2 7.2 0 0 0 11.6-3.7 7 7 0 0 0-3.5-7.7A7.2 7.2 0 0 0 8 7L4.7 10Z\" fill-rule=\"nonzero\"/></svg>",
			"rotate-right": "<svg width=\"24\" height=\"24\"><path d=\"M20 8V5a1 1 0 0 1 2 0v6c0 .6-.4 1-1 1h-6a1 1 0 0 1 0-2h4.3L16 7A7.2 7.2 0 0 0 7.7 6a7 7 0 0 0 3 13.1c1.9.1 3.7-.5 5-1.7a1 1 0 0 1 1.4 1.5A9.2 9.2 0 0 1 2.2 14c-.9-3.9 1-8 4.5-9.9 3.5-1.9 8-1.3 10.8 1.5L20 8Z\" fill-rule=\"nonzero\"/></svg>",
			"rtl": "<svg width=\"24\" height=\"24\"><path d=\"M8 5h8v2h-2v12h-2V7h-2v12H8v-7c-.5 0-1 0-1.4-.3A3.4 3.4 0 0 1 4.8 10a3.3 3.3 0 0 1 0-2.8 3.4 3.4 0 0 1 1.8-1.8L8 5Zm12 11.2a1 1 0 1 1-1 1.6l-3-2a1 1 0 0 1 0-1.6l3-2a1 1 0 1 1 1 1.6L18.4 15l1.8 1.2Z\" fill-rule=\"evenodd\"/></svg>",
			"save": "<svg width=\"24\" height=\"24\"><path d=\"M5 16h14a2 2 0 0 1 2 2v2a2 2 0 0 1-2 2H5a2 2 0 0 1-2-2v-2c0-1.1.9-2 2-2Zm0 2v2h14v-2H5Zm10 0h2v2h-2v-2Zm-4-6.4L8.7 9.3a1 1 0 1 0-1.4 1.4l4 4c.4.4 1 .4 1.4 0l4-4a1 1 0 1 0-1.4-1.4L13 11.6V4a1 1 0 0 0-2 0v7.6Z\" fill-rule=\"nonzero\"/></svg>",
			"search": "<svg width=\"24\" height=\"24\"><path d=\"M16 17.3a8 8 0 1 1 1.4-1.4l4.3 4.4a1 1 0 0 1-1.4 1.4l-4.4-4.3Zm-5-.3a6 6 0 1 0 0-12 6 6 0 0 0 0 12Z\" fill-rule=\"nonzero\"/></svg>",
			"select-all": "<svg width=\"24\" height=\"24\"><path d=\"M3 5h2V3a2 2 0 0 0-2 2Zm0 8h2v-2H3v2Zm4 8h2v-2H7v2ZM3 9h2V7H3v2Zm10-6h-2v2h2V3Zm6 0v2h2a2 2 0 0 0-2-2ZM5 21v-2H3c0 1.1.9 2 2 2Zm-2-4h2v-2H3v2ZM9 3H7v2h2V3Zm2 18h2v-2h-2v2Zm8-8h2v-2h-2v2Zm0 8a2 2 0 0 0 2-2h-2v2Zm0-12h2V7h-2v2Zm0 8h2v-2h-2v2Zm-4 4h2v-2h-2v2Zm0-16h2V3h-2v2ZM7 17h10V7H7v10Zm2-8h6v6H9V9Z\" fill-rule=\"nonzero\"/></svg>",
			"selected": "<svg width=\"24\" height=\"24\"><path fill-rule=\"nonzero\" d=\"M6 4h12a2 2 0 0 1 2 2v12a2 2 0 0 1-2 2H6a2 2 0 0 1-2-2V6c0-1.1.9-2 2-2Zm3.6 10.9L7 12.3a.7.7 0 0 0-1 1L9.6 17 18 8.6a.7.7 0 0 0 0-1 .7.7 0 0 0-1 0l-7.4 7.3Z\"/></svg>",
			"send": "<svg width=\"24\" height=\"24\"><path fill-rule=\"evenodd\" clip-rule=\"evenodd\" d=\"m13.3 22 7-18.3-18.3 7L9 15l4.3 7ZM18 6.8l-.7-.7L9.4 14l.7.7L18 6.8Z\"/></svg>",
			"settings": "<svg width=\"24\" height=\"24\"><path d=\"M11 6h8c.6 0 1 .4 1 1s-.4 1-1 1h-8v.3c0 .2 0 .3-.2.5l-.6.2H7.8c-.3 0-.4 0-.6-.2a.7.7 0 0 1-.2-.6V8H5a1 1 0 1 1 0-2h2v-.3c0-.2 0-.3.2-.5l.5-.2h2.5c.3 0 .4 0 .6.2l.2.5V6ZM8 8h2V6H8v2Zm9 2.8v.2h2c.6 0 1 .4 1 1s-.4 1-1 1h-2v.3c0 .2 0 .3-.2.5l-.6.2h-2.4c-.3 0-.4 0-.6-.2a.7.7 0 0 1-.2-.6V13H5a1 1 0 0 1 0-2h8v-.3c0-.2 0-.3.2-.5l.6-.2h2.4c.3 0 .4 0 .6.2l.2.6ZM14 13h2v-2h-2v2Zm-3 2.8v.2h8c.6 0 1 .4 1 1s-.4 1-1 1h-8v.3c0 .2 0 .3-.2.5l-.6.2H7.8c-.3 0-.4 0-.6-.2a.7.7 0 0 1-.2-.6V18H5a1 1 0 0 1 0-2h2v-.3c0-.2 0-.3.2-.5l.5-.2h2.5c.3 0 .4 0 .6.2l.2.6ZM8 18h2v-2H8v2Z\" fill-rule=\"evenodd\"/></svg>",
			"sharpen": "<svg width=\"24\" height=\"24\"><path d=\"m16 6 4 4-8 9-8-9 4-4h8Zm-4 10.2 5.5-6.2-.1-.1H12v-.3h5.1l-.2-.2H12V9h4.6l-.2-.2H12v-.3h4.1l-.2-.2H12V8h3.6l-.2-.2H8.7L6.5 10l.1.1H12v.3H6.9l.2.2H12v.3H7.3l.2.2H12v.3H7.7l.3.2h4v.3H8.2l.2.2H12v.3H8.6l.3.2H12v.3H9l.3.2H12v.3H9.5l.2.2H12v.3h-2l.2.2H12v.3h-1.6l.2.2H12v.3h-1.1l.2.2h.9v.3h-.7l.2.2h.5v.3h-.3l.3.2Z\" fill-rule=\"evenodd\"/></svg>",
			"sourcecode": "<svg width=\"24\" height=\"24\"><g fill-rule=\"nonzero\"><path d=\"M9.8 15.7c.3.3.3.8 0 1-.3.4-.9.4-1.2 0l-4.4-4.1a.8.8 0 0 1 0-1.2l4.4-4.2c.3-.3.9-.3 1.2 0 .3.3.3.8 0 1.1L6 12l3.8 3.7ZM14.2 15.7c-.3.3-.3.8 0 1 .4.4.9.4 1.2 0l4.4-4.1c.3-.3.3-.9 0-1.2l-4.4-4.2a.8.8 0 0 0-1.2 0c-.3.3-.3.8 0 1.1L18 12l-3.8 3.7Z\"/></g></svg>",
			"spell-check": "<svg width=\"24\" height=\"24\"><path d=\"M6 8v3H5V5c0-.3.1-.5.3-.7.2-.2.4-.3.7-.3h2c.3 0 .5.1.7.3.2.2.3.4.3.7v6H8V8H6Zm0-3v2h2V5H6Zm13 0h-3v5h3v1h-3a1 1 0 0 1-.7-.3 1 1 0 0 1-.3-.7V5c0-.3.1-.5.3-.7.2-.2.4-.3.7-.3h3v1Zm-5 1.5-.1.7c-.1.2-.3.3-.6.3.3 0 .5.1.6.3l.1.7V10c0 .3-.1.5-.3.7a1 1 0 0 1-.7.3h-3V4h3c.3 0 .5.1.7.3.2.2.3.4.3.7v1.5ZM13 10V8h-2v2h2Zm0-3V5h-2v2h2Zm3 5 1 1-6.5 7L7 15.5l1.3-1 2.2 2.2L16 12Z\" fill-rule=\"evenodd\"/></svg>",
			"strike-through": "<svg width=\"24\" height=\"24\"><g fill-rule=\"evenodd\"><path d=\"M15.6 8.5c-.5-.7-1-1.1-1.3-1.3-.6-.4-1.3-.6-2-.6-2.7 0-2.8 1.7-2.8 2.1 0 1.6 1.8 2 3.2 2.3 4.4.9 4.6 2.8 4.6 3.9 0 1.4-.7 4.1-5 4.1A6.2 6.2 0 0 1 7 16.4l1.5-1.1c.4.6 1.6 2 3.7 2 1.6 0 2.5-.4 3-1.2.4-.8.3-2-.8-2.6-.7-.4-1.6-.7-2.9-1-1-.2-3.9-.8-3.9-3.6C7.6 6 10.3 5 12.4 5c2.9 0 4.2 1.6 4.7 2.4l-1.5 1.1Z\"/><path d=\"M5 11h14a1 1 0 0 1 0 2H5a1 1 0 0 1 0-2Z\" fill-rule=\"nonzero\"/></g></svg>",
			"subscript": "<svg width=\"24\" height=\"24\"><path d=\"m10.4 10 4.6 4.6-1.4 1.4L9 11.4 4.4 16 3 14.6 7.6 10 3 5.4 4.4 4 9 8.6 13.6 4 15 5.4 10.4 10ZM21 19h-5v-1l1-.8 1.7-1.6c.3-.4.5-.8.5-1.2 0-.3 0-.6-.2-.7-.2-.2-.5-.3-.9-.3a2 2 0 0 0-.8.2l-.7.3-.4-1.1 1-.6 1.2-.2c.8 0 1.4.3 1.8.7.4.4.6.9.6 1.5s-.2 1.1-.5 1.6a8 8 0 0 1-1.3 1.3l-.6.6h2.6V19Z\" fill-rule=\"nonzero\"/></svg>",
			"superscript": "<svg width=\"24\" height=\"24\"><path d=\"M15 9.4 10.4 14l4.6 4.6-1.4 1.4L9 15.4 4.4 20 3 18.6 7.6 14 3 9.4 4.4 8 9 12.6 13.6 8 15 9.4Zm5.9 1.6h-5v-1l1-.8 1.7-1.6c.3-.5.5-.9.5-1.3 0-.3 0-.5-.2-.7-.2-.2-.5-.3-.9-.3l-.8.2-.7.4-.4-1.2c.2-.2.5-.4 1-.5.3-.2.8-.2 1.2-.2.8 0 1.4.2 1.8.6.4.4.6 1 .6 1.6 0 .5-.2 1-.5 1.5l-1.3 1.4-.6.5h2.6V11Z\" fill-rule=\"nonzero\"/></svg>",
			"table-caption": "<svg width=\"24\" height=\"24\"><g fill-rule=\"nonzero\"><rect width=\"12\" height=\"2\" x=\"3\" y=\"4\" rx=\"1\"/><path d=\"M19 8a2 2 0 0 1 2 2v8a2 2 0 0 1-2 2H5a2 2 0 0 1-2-2v-8c0-1.1.9-2 2-2h14ZM5 15v3h6v-3H5Zm14 0h-6v3h6v-3Zm0-5h-6v3h6v-3ZM5 13h6v-3H5v3Z\"/></g></svg>",
			"table-cell-classes": "<svg width=\"24\" height=\"24\"><g fill-rule=\"evenodd\"><path fill-rule=\"nonzero\" d=\"M13 4v9H3V6c0-1.1.9-2 2-2h8Zm-2 2H5v5h6V6Z\"/><path fill-rule=\"nonzero\" d=\"M13 4h6a2 2 0 0 1 2 2v7h-8v-2h6V6h-6V4Z\" opacity=\".2\"/><path d=\"m18 20-2.6 1.6.7-3-2.4-2 3.1-.2 1.2-2.9 1.2 2.9 3.1.2-2.4 2 .7 3z\"/><path fill-rule=\"nonzero\" d=\"M3 13v5c0 1.1.9 2 2 2h8v-7h-2v5H5v-5H3Z\" opacity=\".2\"/></g></svg>",
			"table-cell-properties": "<svg width=\"24\" height=\"24\"><path fill-rule=\"nonzero\" d=\"M19 4a2 2 0 0 1 2 2v12a2 2 0 0 1-2 2H5a2 2 0 0 1-2-2V6c0-1.1.9-2 2-2h14Zm-8 9H5v5h6v-5Zm8 0h-6v5h6v-5Zm-8-7H5v5h6V6Z\"/></svg>",
			"table-cell-select-all": "<svg width=\"24\" height=\"24\"><g fill-rule=\"evenodd\"><path fill-rule=\"nonzero\" d=\"M19 4a2 2 0 0 1 2 2v12a2 2 0 0 1-2 2H5a2 2 0 0 1-2-2V6c0-1.1.9-2 2-2h14Zm0 2H5v12h14V6Z\"/><path d=\"M13 6v5h6v2h-6v5h-2v-5H5v-2h6V6h2Z\" opacity=\".2\"/></g></svg>",
			"table-cell-select-inner": "<svg width=\"24\" height=\"24\"><g fill-rule=\"evenodd\"><path fill-rule=\"nonzero\" d=\"M19 4a2 2 0 0 1 2 2v12a2 2 0 0 1-2 2H5a2 2 0 0 1-2-2V6c0-1.1.9-2 2-2h14Zm0 2H5v12h14V6Z\" opacity=\".2\"/><path d=\"M13 6v5h6v2h-6v5h-2v-5H5v-2h6V6h2Z\"/></g></svg>",
			"table-classes": "<svg width=\"24\" height=\"24\"><g fill-rule=\"evenodd\"><path fill-rule=\"nonzero\" d=\"M19 4a2 2 0 0 1 2 2v7h-8v7H5a2 2 0 0 1-2-2V6c0-1.1.9-2 2-2h14Zm-8 9H5v5h6v-5Zm8-7h-6v5h6V6Zm-8 0H5v5h6V6Z\"/><path d=\"m18 20-2.6 1.6.7-3-2.4-2 3.1-.2 1.2-2.9 1.2 2.9 3.1.2-2.4 2 .7 3z\"/></g></svg>",
			"table-delete-column": "<svg width=\"24\" height=\"24\"><path fill-rule=\"nonzero\" d=\"M19 4a2 2 0 0 1 2 2v12a2 2 0 0 1-2 2H5a2 2 0 0 1-2-2V6c0-1.1.9-2 2-2h14Zm-4 4h-2V6h-2v2H9V6H5v12h4v-2h2v2h2v-2h2v2h4V6h-4v2Zm.3.5 1 1.2-3 2.3 3 2.3-1 1.2L12 13l-3.3 2.6-1-1.2 3-2.3-3-2.3 1-1.2L12 11l3.3-2.5Z\"/></svg>",
			"table-delete-row": "<svg width=\"24\" height=\"24\"><path fill-rule=\"nonzero\" d=\"M19 4a2 2 0 0 1 2 2v12a2 2 0 0 1-2 2H5a2 2 0 0 1-2-2V6c0-1.1.9-2 2-2h14Zm0 2H5v3h2.5v2H5v2h2.5v2H5v3h14v-3h-2.5v-2H19v-2h-2.5V9H19V6Zm-4.7 1.8 1.2 1L13 12l2.6 3.3-1.2 1-2.3-3-2.3 3-1.2-1L11 12 8.5 8.7l1.2-1 2.3 3 2.3-3Z\"/></svg>",
			"table-delete-table": "<svg width=\"24\" height=\"24\"><g fill-rule=\"nonzero\"><path d=\"M19 4a2 2 0 0 1 2 2v12a2 2 0 0 1-2 2H5a2 2 0 0 1-2-2V6c0-1.1.9-2 2-2h14ZM5 6v12h14V6H5Z\"/><path d=\"m14.4 8.6 1.1 1-2.4 2.4 2.4 2.4-1.1 1.1-2.4-2.4-2.4 2.4-1-1.1 2.3-2.4-2.3-2.4 1-1 2.4 2.3z\"/></g></svg>",
			"table-insert-column-after": "<svg width=\"24\" height=\"24\"><path fill-rule=\"nonzero\" d=\"M20 4c.6 0 1 .4 1 1v2a1 1 0 0 1-2 0V6h-8v12h8v-1a1 1 0 0 1 2 0v2c0 .5-.4 1-.9 1H5a2 2 0 0 1-2-2V6c0-1.1.9-2 2-2h15ZM9 13H5v5h4v-5Zm7-5c.5 0 1 .4 1 .9V11h2a1 1 0 0 1 .1 2H17v2a1 1 0 0 1-2 .1V13h-2a1 1 0 0 1-.1-2H15V9c0-.6.4-1 1-1ZM9 6H5v5h4V6Z\"/></svg>",
			"table-insert-column-before": "<svg width=\"24\" height=\"24\"><path fill-rule=\"nonzero\" d=\"M19 4a2 2 0 0 1 2 2v12a2 2 0 0 1-2 2H4a1 1 0 0 1-1-1v-2a1 1 0 0 1 2 0v1h8V6H5v1a1 1 0 1 1-2 0V5c0-.6.4-1 1-1h15Zm0 9h-4v5h4v-5ZM8 8c.5 0 1 .4 1 .9V11h2a1 1 0 0 1 .1 2H9v2a1 1 0 0 1-2 .1V13H5a1 1 0 0 1-.1-2H7V9c0-.6.4-1 1-1Zm11-2h-4v5h4V6Z\"/></svg>",
			"table-insert-row-above": "<svg width=\"24\" height=\"24\"><path fill-rule=\"nonzero\" d=\"M6 4a1 1 0 1 1 0 2H5v6h14V6h-1a1 1 0 0 1 0-2h2c.6 0 1 .4 1 1v13a2 2 0 0 1-2 2H5a2 2 0 0 1-2-2V5c0-.6.4-1 1-1h2Zm5 10H5v4h6v-4Zm8 0h-6v4h6v-4ZM12 3c.5 0 1 .4 1 .9V6h2a1 1 0 0 1 0 2h-2v2a1 1 0 0 1-2 .1V8H9a1 1 0 0 1 0-2h2V4c0-.6.4-1 1-1Z\"/></svg>",
			"table-insert-row-after": "<svg width=\"24\" height=\"24\"><path fill-rule=\"nonzero\" d=\"M12 13c.5 0 1 .4 1 .9V16h2a1 1 0 0 1 .1 2H13v2a1 1 0 0 1-2 .1V18H9a1 1 0 0 1-.1-2H11v-2c0-.6.4-1 1-1Zm6 7a1 1 0 0 1 0-2h1v-6H5v6h1a1 1 0 0 1 0 2H4a1 1 0 0 1-1-1V6c0-1.1.9-2 2-2h14a2 2 0 0 1 2 2v13c0 .5-.4 1-.9 1H18ZM11 6H5v4h6V6Zm8 0h-6v4h6V6Z\"/></svg>",
			"table-left-header": "<svg width=\"24\" height=\"24\"><path d=\"M19 4a2 2 0 0 1 2 2v12a2 2 0 0 1-2 2H5a2 2 0 0 1-2-2V6c0-1.1.9-2 2-2h14Zm0 9h-4v5h4v-5Zm-6 0H9v5h4v-5Zm0-7H9v5h4V6Zm6 0h-4v5h4V6Z\"/></svg>",
			"table-merge-cells": "<svg width=\"24\" height=\"24\"><path fill-rule=\"nonzero\" d=\"M19 4a2 2 0 0 1 2 2v12a2 2 0 0 1-2 2H5a2 2 0 0 1-2-2V6c0-1.1.9-2 2-2h14ZM5 15.5V18h3v-2.5H5Zm14-5h-9V18h9v-7.5ZM19 6h-4v2.5h4V6ZM8 6H5v2.5h3V6Zm5 0h-3v2.5h3V6Zm-8 7.5h3v-3H5v3Z\"/></svg>",
			"table-row-numbering-rtl": "<svg width=\"24\" height=\"24\"><path d=\"M6 4a2 2 0 0 0-2 2v13c0 1.1.9 2 2 2h12a2 2 0 0 0 2-2V6a2 2 0 0 0-2-2H6Zm0 12h8v3H6v-3Zm11 0c.6 0 1 .4 1 1v1a1 1 0 0 1-2 0v-1c0-.6.4-1 1-1ZM6 11h8v3H6v-3Zm11 0c.6 0 1 .4 1 1v1a1 1 0 0 1-2 0v-1c0-.6.4-1 1-1ZM6 6h8v3H6V6Zm11 0c.6 0 1 .4 1 1v1a1 1 0 1 1-2 0V7c0-.6.4-1 1-1Z\"/></svg>",
			"table-row-numbering": "<svg width=\"24\" height=\"24\"><path d=\"M18 4a2 2 0 0 1 2 2v13a2 2 0 0 1-2 2H6a2 2 0 0 1-2-2V6c0-1.1.9-2 2-2h12Zm0 12h-8v3h8v-3ZM7 16a1 1 0 0 0-1 1v1a1 1 0 0 0 2 0v-1c0-.6-.4-1-1-1Zm11-5h-8v3h8v-3ZM7 11a1 1 0 0 0-1 1v1a1 1 0 0 0 2 0v-1c0-.6-.4-1-1-1Zm11-5h-8v3h8V6ZM7 6a1 1 0 0 0-1 1v1a1 1 0 1 0 2 0V7c0-.6-.4-1-1-1Z\"/></svg>",
			"table-row-properties": "<svg width=\"24\" height=\"24\"><path fill-rule=\"nonzero\" d=\"M19 4a2 2 0 0 1 2 2v12a2 2 0 0 1-2 2H5a2 2 0 0 1-2-2V6c0-1.1.9-2 2-2h14ZM5 15v3h6v-3H5Zm14 0h-6v3h6v-3Zm0-9h-6v3h6V6ZM5 9h6V6H5v3Z\"/></svg>",
			"table-split-cells": "<svg width=\"24\" height=\"24\"><path fill-rule=\"nonzero\" d=\"M19 4a2 2 0 0 1 2 2v12a2 2 0 0 1-2 2H5a2 2 0 0 1-2-2V6c0-1.1.9-2 2-2h14ZM8 15.5H5V18h3v-2.5Zm11-5h-9V18h9v-7.5Zm-2.5 1 1 1-2 2 2 2-1 1-2-2-2 2-1-1 2-2-2-2 1-1 2 2 2-2Zm-8.5-1H5v3h3v-3ZM19 6h-4v2.5h4V6ZM8 6H5v2.5h3V6Zm5 0h-3v2.5h3V6Z\"/></svg>",
			"table-top-header": "<svg width=\"24\" height=\"24\"><path d=\"M19 4a2 2 0 0 1 2 2v12a2 2 0 0 1-2 2H5a2 2 0 0 1-2-2V6c0-1.1.9-2 2-2h14Zm-8 11H5v3h6v-3Zm8 0h-6v3h6v-3Zm0-5h-6v3h6v-3ZM5 13h6v-3H5v3Z\"/></svg>",
			"table": "<svg width=\"24\" height=\"24\"><path fill-rule=\"nonzero\" d=\"M19 4a2 2 0 0 1 2 2v12a2 2 0 0 1-2 2H5a2 2 0 0 1-2-2V6c0-1.1.9-2 2-2h14ZM5 14v4h6v-4H5Zm14 0h-6v4h6v-4Zm0-6h-6v4h6V8ZM5 12h6V8H5v4Z\"/></svg>",
			"template-add": "<svg width=\"24\" height=\"24\"><path fill-rule=\"evenodd\" clip-rule=\"evenodd\" d=\"M9 12v4H5a2 2 0 0 0-2 2v3h9.3a6 6 0 0 1-.3-2H5v-1h7a6 6 0 0 1 .8-2H11v-5l-.8-.6a3 3 0 1 1 3.6 0l-.8.6v4.7a6 6 0 0 1 2-1.9V12a5 5 0 1 0-6 0Z\"/><path d=\"M18 15c.5 0 1 .4 1 .9V18h2a1 1 0 0 1 .1 2H19v2a1 1 0 0 1-2 .1V20h-2a1 1 0 0 1-.1-2H17v-2c0-.6.4-1 1-1Z\"/></svg>",
			"template": "<svg width=\"24\" height=\"24\"><path d=\"M19 19v-1H5v1h14ZM9 16v-4a5 5 0 1 1 6 0v4h4a2 2 0 0 1 2 2v3H3v-3c0-1.1.9-2 2-2h4Zm4 0v-5l.8-.6a3 3 0 1 0-3.6 0l.8.6v5h2Z\" fill-rule=\"nonzero\"/></svg>",
			"temporary-placeholder": "<svg width=\"24\" height=\"24\"><g fill-rule=\"evenodd\"><path d=\"M9 7.6V6h2.5V4.5a.5.5 0 1 1 1 0V6H15v1.6a8 8 0 1 1-6 0Zm-2.6 5.3a.5.5 0 0 0 .3.6c.3 0 .6 0 .6-.3l.1-.2a5 5 0 0 1 3.3-2.8c.3-.1.4-.4.4-.6-.1-.3-.4-.5-.6-.4a6 6 0 0 0-4.1 3.7Z\"/><circle cx=\"14\" cy=\"4\" r=\"1\"/><circle cx=\"12\" cy=\"2\" r=\"1\"/><circle cx=\"10\" cy=\"4\" r=\"1\"/></g></svg>",
			"text-color": "<svg width=\"24\" height=\"24\"><g fill-rule=\"evenodd\"><path class=\"tox-icon-text-color__color\" d=\"M3 18h18v3H3z\"/><path d=\"M8.7 16h-.8a.5.5 0 0 1-.5-.6l2.7-9c.1-.3.3-.4.5-.4h2.8c.2 0 .4.1.5.4l2.7 9a.5.5 0 0 1-.5.6h-.8a.5.5 0 0 1-.4-.4l-.7-2.2c0-.3-.3-.4-.5-.4h-3.4c-.2 0-.4.1-.5.4l-.7 2.2c0 .3-.2.4-.4.4Zm2.6-7.6-.6 2a.5.5 0 0 0 .5.6h1.6a.5.5 0 0 0 .5-.6l-.6-2c0-.3-.3-.4-.5-.4h-.4c-.2 0-.4.1-.5.4Z\"/></g></svg>",
			"text-size-decrease": "<svg width=\"24\" height=\"24\"><path fill-rule=\"evenodd\" clip-rule=\"evenodd\" d=\"M14 5a1 1 0 1 1 0 2h-4v11a1 1 0 1 1-2 0V7H4a1 1 0 0 1 0-2h10ZM14 12a1 1 0 1 0 0 2h6a1 1 0 1 0 0-2h-6Z\"/></svg>",
			"text-size-increase": "<svg width=\"24\" height=\"24\"><path fill-rule=\"evenodd\" clip-rule=\"evenodd\" d=\"M14 5a1 1 0 1 1 0 2h-4v11a1 1 0 1 1-2 0V7H4a1 1 0 0 1 0-2h10ZM17 9a1 1 0 0 0-1 1v2h-2a1 1 0 1 0 0 2h2v2a1 1 0 1 0 2 0v-2h2a1 1 0 1 0 0-2h-2v-2c0-.6-.4-1-1-1Z\"/></svg>",
			"toc": "<svg width=\"24\" height=\"24\"><path d=\"M5 5c.6 0 1 .4 1 1s-.4 1-1 1a1 1 0 1 1 0-2Zm3 0h11c.6 0 1 .4 1 1s-.4 1-1 1H8a1 1 0 1 1 0-2Zm-3 8c.6 0 1 .4 1 1s-.4 1-1 1a1 1 0 0 1 0-2Zm3 0h11c.6 0 1 .4 1 1s-.4 1-1 1H8a1 1 0 0 1 0-2Zm0-4c.6 0 1 .4 1 1s-.4 1-1 1a1 1 0 1 1 0-2Zm3 0h8c.6 0 1 .4 1 1s-.4 1-1 1h-8a1 1 0 0 1 0-2Zm-3 8c.6 0 1 .4 1 1s-.4 1-1 1a1 1 0 0 1 0-2Zm3 0h8c.6 0 1 .4 1 1s-.4 1-1 1h-8a1 1 0 0 1 0-2Z\" fill-rule=\"evenodd\"/></svg>",
			"translate": "<svg width=\"24\" height=\"24\"><path d=\"m12.7 14.3-.3.7-.4.7-2.2-2.2-3.1 3c-.3.4-.8.4-1 0a.7.7 0 0 1 0-1l3.1-3A12.4 12.4 0 0 1 6.7 9H8a10.1 10.1 0 0 0 1.7 2.4c.5-.5 1-1.1 1.4-1.8l.9-2H4.7a.7.7 0 1 1 0-1.5h4.4v-.7c0-.4.3-.8.7-.8.4 0 .7.4.7.8v.7H15c.4 0 .8.3.8.7 0 .4-.4.8-.8.8h-1.4a12.3 12.3 0 0 1-1 2.4 13.5 13.5 0 0 1-1.7 2.3l1.9 1.8Zm4.3-3 2.7 7.3a.5.5 0 0 1-.4.7 1 1 0 0 1-1-.7l-.6-1.5h-3.4l-.6 1.5a1 1 0 0 1-1 .7.5.5 0 0 1-.4-.7l2.7-7.4a1 1 0 0 1 2 0Zm-2.2 4.4h2.4L16 12.5l-1.2 3.2Z\" fill-rule=\"evenodd\"/></svg>",
			"typography": "<svg width=\"24\" height=\"24\"><path fill-rule=\"evenodd\" clip-rule=\"evenodd\" d=\"M17 5a1 1 0 1 1 0 2h-4v11a1 1 0 1 1-2 0V7H7a1 1 0 0 1 0-2h10Z\"/><path d=\"m17.5 14 .8-1.7 1.7-.8-1.7-.8-.8-1.7-.8 1.7-1.7.8 1.7.8.8 1.7ZM7 14l1 2 2 1-2 1-1 2-1-2-2-1 2-1 1-2Z\"/></svg>",
			"underline": "<svg width=\"24\" height=\"24\"><path d=\"M16 5c.6 0 1 .4 1 1v5.5a4 4 0 0 1-.4 1.8l-1 1.4a5.3 5.3 0 0 1-5.5 1 5 5 0 0 1-1.6-1c-.5-.4-.8-.9-1.1-1.4a4 4 0 0 1-.4-1.8V6c0-.6.4-1 1-1s1 .4 1 1v5.5c0 .3 0 .6.2 1l.6.7a3.3 3.3 0 0 0 2.2.8 3.4 3.4 0 0 0 2.2-.8c.3-.2.4-.5.6-.8l.2-.9V6c0-.6.4-1 1-1ZM8 17h8c.6 0 1 .4 1 1s-.4 1-1 1H8a1 1 0 0 1 0-2Z\" fill-rule=\"evenodd\"/></svg>",
			"undo": "<svg width=\"24\" height=\"24\"><path d=\"M6.4 8H12c3.7 0 6.2 2 6.8 5.1.6 2.7-.4 5.6-2.3 6.8a1 1 0 0 1-1-1.8c1.1-.6 1.8-2.7 1.4-4.6-.5-2.1-2.1-3.5-4.9-3.5H6.4l3.3 3.3a1 1 0 1 1-1.4 1.4l-5-5a1 1 0 0 1 0-1.4l5-5a1 1 0 0 1 1.4 1.4L6.4 8Z\" fill-rule=\"nonzero\"/></svg>",
			"unlink": "<svg width=\"24\" height=\"24\"><path d=\"M6.2 12.3a1 1 0 0 1 1.4 1.4l-2 2a2 2 0 1 0 2.6 2.8l4.8-4.8a1 1 0 0 0 0-1.4 1 1 0 1 1 1.4-1.3 2.9 2.9 0 0 1 0 4L9.6 20a3.9 3.9 0 0 1-5.5-5.5l2-2Zm11.6-.6a1 1 0 0 1-1.4-1.4l2.1-2a2 2 0 1 0-2.7-2.8L11 10.3a1 1 0 0 0 0 1.4A1 1 0 1 1 9.6 13a2.9 2.9 0 0 1 0-4L14.4 4a3.9 3.9 0 0 1 5.5 5.5l-2 2ZM7.6 6.3a.8.8 0 0 1-1 1.1L3.3 4.2a.7.7 0 1 1 1-1l3.2 3.1ZM5.1 8.6a.8.8 0 0 1 0 1.5H3a.8.8 0 0 1 0-1.5H5Zm5-3.5a.8.8 0 0 1-1.5 0V3a.8.8 0 0 1 1.5 0V5Zm6 11.8a.8.8 0 0 1 1-1l3.2 3.2a.8.8 0 0 1-1 1L16 17Zm-2.2 2a.8.8 0 0 1 1.5 0V21a.8.8 0 0 1-1.5 0V19Zm5-3.5a.7.7 0 1 1 0-1.5H21a.8.8 0 0 1 0 1.5H19Z\" fill-rule=\"nonzero\"/></svg>",
			"unlock": "<svg width=\"24\" height=\"24\"><path d=\"M16 5c.8 0 1.5.3 2.1.9.6.6.9 1.3.9 2.1v3h-2V8a1 1 0 0 0-.3-.7A1 1 0 0 0 16 7h-2a1 1 0 0 0-.7.3 1 1 0 0 0-.3.7v3h.3c.2 0 .3 0 .5.2l.2.6v7.4c0 .3 0 .4-.2.6l-.6.2H4.8c-.3 0-.4 0-.6-.2a.7.7 0 0 1-.2-.6v-7.4c0-.3 0-.4.2-.6l.5-.2H11V8c0-.8.3-1.5.9-2.1.6-.6 1.3-.9 2.1-.9h2Z\" fill-rule=\"evenodd\"/></svg>",
			"unordered-list": "<svg width=\"24\" height=\"24\"><path d=\"M11 5h8c.6 0 1 .4 1 1s-.4 1-1 1h-8a1 1 0 0 1 0-2Zm0 6h8c.6 0 1 .4 1 1s-.4 1-1 1h-8a1 1 0 0 1 0-2Zm0 6h8c.6 0 1 .4 1 1s-.4 1-1 1h-8a1 1 0 0 1 0-2ZM4.5 6c0-.4.1-.8.4-1 .3-.4.7-.5 1.1-.5.4 0 .8.1 1 .4.4.3.5.7.5 1.1 0 .4-.1.8-.4 1-.3.4-.7.5-1.1.5-.4 0-.8-.1-1-.4-.4-.3-.5-.7-.5-1.1Zm0 6c0-.4.1-.8.4-1 .3-.4.7-.5 1.1-.5.4 0 .8.1 1 .4.4.3.5.7.5 1.1 0 .4-.1.8-.4 1-.3.4-.7.5-1.1.5-.4 0-.8-.1-1-.4-.4-.3-.5-.7-.5-1.1Zm0 6c0-.4.1-.8.4-1 .3-.4.7-.5 1.1-.5.4 0 .8.1 1 .4.4.3.5.7.5 1.1 0 .4-.1.8-.4 1-.3.4-.7.5-1.1.5-.4 0-.8-.1-1-.4-.4-.3-.5-.7-.5-1.1Z\" fill-rule=\"evenodd\"/></svg>",
			"unselected": "<svg width=\"24\" height=\"24\"><path fill-rule=\"nonzero\" d=\"M6 4h12a2 2 0 0 1 2 2v12a2 2 0 0 1-2 2H6a2 2 0 0 1-2-2V6c0-1.1.9-2 2-2Zm0 1a1 1 0 0 0-1 1v12c0 .6.4 1 1 1h12c.6 0 1-.4 1-1V6c0-.6-.4-1-1-1H6Z\"/></svg>",
			"upload": "<svg width=\"24\" height=\"24\"><path d=\"M18 19v-2a1 1 0 0 1 2 0v3c0 .6-.4 1-1 1H5a1 1 0 0 1-1-1v-3a1 1 0 0 1 2 0v2h12ZM11 6.4 8.7 8.7a1 1 0 0 1-1.4-1.4l4-4a1 1 0 0 1 1.4 0l4 4a1 1 0 1 1-1.4 1.4L13 6.4V16a1 1 0 0 1-2 0V6.4Z\" fill-rule=\"nonzero\"/></svg>",
			"user": "<svg width=\"24\" height=\"24\"><path d=\"M12 24a12 12 0 1 1 0-24 12 12 0 0 1 0 24Zm-8.7-5.3a11 11 0 0 0 17.4 0C19.4 16.3 14.6 15 12 15c-2.6 0-7.4 1.3-8.7 3.7ZM12 13c2.2 0 4-2 4-4.5S14.2 4 12 4 8 6 8 8.5 9.8 13 12 13Z\" fill-rule=\"nonzero\"/></svg>",
			"vertical-align": "<svg width=\"24\" height=\"24\"><g fill-rule=\"nonzero\"><rect width=\"18\" height=\"2\" x=\"3\" y=\"11\" rx=\"1\"/><path d=\"M12 2c.6 0 1 .4 1 1v4l2-1.3a1 1 0 0 1 1.2 1.5l-.1.1-4.1 3-4-3a1 1 0 0 1 1-1.7l2 1.5V3c0-.6.4-1 1-1zm0 11.8 4 2.9a1 1 0 0 1-1 1.7l-2-1.5V21c0 .5-.4 1-.9 1H12a1 1 0 0 1-1-1v-4l-2 1.3a1 1 0 0 1-1.2-.1l-.1-.1a1 1 0 0 1 .1-1.3l.1-.1 4.1-3z\"/></g></svg>",
			"visualblocks": "<svg width=\"24\" height=\"24\"><path d=\"M9 19v2H7v-2h2Zm-4 0v2a2 2 0 0 1-2-2h2Zm8 0v2h-2v-2h2Zm8 0a2 2 0 0 1-2 2v-2h2Zm-4 0v2h-2v-2h2ZM15 7a1 1 0 0 1 0 2v7a1 1 0 0 1-2 0V9h-1v7a1 1 0 0 1-2 0v-4a2.5 2.5 0 0 1-.2-5H15ZM5 15v2H3v-2h2Zm16 0v2h-2v-2h2ZM5 11v2H3v-2h2Zm16 0v2h-2v-2h2ZM5 7v2H3V7h2Zm16 0v2h-2V7h2ZM5 3v2H3c0-1.1.9-2 2-2Zm8 0v2h-2V3h2Zm6 0a2 2 0 0 1 2 2h-2V3ZM9 3v2H7V3h2Zm8 0v2h-2V3h2Z\" fill-rule=\"evenodd\"/></svg>",
			"visualchars": "<svg width=\"24\" height=\"24\"><path d=\"M10 5h7a1 1 0 0 1 0 2h-1v11a1 1 0 0 1-2 0V7h-2v11a1 1 0 0 1-2 0v-6c-.5 0-1 0-1.4-.3A3.4 3.4 0 0 1 6.8 10a3.3 3.3 0 0 1 0-2.8 3.4 3.4 0 0 1 1.8-1.8L10 5Z\" fill-rule=\"evenodd\"/></svg>",
			"warning": "<svg width=\"24\" height=\"24\"><path d=\"M19.8 18.3c.2.5.3.9 0 1.2-.1.3-.5.5-1 .5H5.2c-.5 0-.9-.2-1-.5-.3-.3-.2-.7 0-1.2L11 4.7l.5-.5.5-.2c.2 0 .3 0 .5.2.2 0 .3.3.5.5l6.8 13.6ZM12 18c.3 0 .5-.1.7-.3.2-.2.3-.4.3-.7a1 1 0 0 0-.3-.7 1 1 0 0 0-.7-.3 1 1 0 0 0-.7.3 1 1 0 0 0-.3.7c0 .3.1.5.3.7.2.2.4.3.7.3Zm.7-3 .3-4a1 1 0 0 0-.3-.7 1 1 0 0 0-.7-.3 1 1 0 0 0-.7.3 1 1 0 0 0-.3.7l.3 4h1.4Z\" fill-rule=\"evenodd\"/></svg>",
			"zoom-in": "<svg width=\"24\" height=\"24\"><path d=\"M16 17.3a8 8 0 1 1 1.4-1.4l4.3 4.4a1 1 0 0 1-1.4 1.4l-4.4-4.3Zm-5-.3a6 6 0 1 0 0-12 6 6 0 0 0 0 12Zm-1-9a1 1 0 0 1 2 0v6a1 1 0 0 1-2 0V8Zm-2 4a1 1 0 0 1 0-2h6a1 1 0 0 1 0 2H8Z\" fill-rule=\"nonzero\"/></svg>",
			"zoom-out": "<svg width=\"24\" height=\"24\"><path d=\"M16 17.3a8 8 0 1 1 1.4-1.4l4.3 4.4a1 1 0 0 1-1.4 1.4l-4.4-4.3Zm-5-.3a6 6 0 1 0 0-12 6 6 0 0 0 0 12Zm-3-5a1 1 0 0 1 0-2h6a1 1 0 0 1 0 2H8Z\" fill-rule=\"nonzero\"/></svg>"
		} });
	}));

//#endregion
//#region node_modules/tinymce/icons/default/index.js
var import_tinymce = /* @__PURE__ */ __toESM(require_tinymce(), 1);
	require_icons();

//#endregion
//#region node_modules/tinymce/models/dom/model.js
	var require_model = /* @__PURE__ */ __commonJSMin((() => {
		/**
		* TinyMCE version 6.7.0 (2023-08-30)
		*/
		(function() {
			"use strict";
			var global$1 = tinymce.util.Tools.resolve("tinymce.ModelManager");
			const hasProto = (v, constructor, predicate) => {
				var _a;
				if (predicate(v, constructor.prototype)) return true;
				else return ((_a = v.constructor) === null || _a === void 0 ? void 0 : _a.name) === constructor.name;
			};
			const typeOf = (x) => {
				const t = typeof x;
				if (x === null) return "null";
				else if (t === "object" && Array.isArray(x)) return "array";
				else if (t === "object" && hasProto(x, String, (o, proto) => proto.isPrototypeOf(o))) return "string";
				else return t;
			};
			const isType$1 = (type$1) => (value$2) => typeOf(value$2) === type$1;
			const isSimpleType = (type$1) => (value$2) => typeof value$2 === type$1;
			const eq$2 = (t) => (a) => t === a;
			const isString = isType$1("string");
			const isObject = isType$1("object");
			const isArray = isType$1("array");
			const isNull = eq$2(null);
			const isBoolean = isSimpleType("boolean");
			const isUndefined = eq$2(void 0);
			const isNullable = (a) => a === null || a === void 0;
			const isNonNullable = (a) => !isNullable(a);
			const isFunction = isSimpleType("function");
			const isNumber = isSimpleType("number");
			const noop = () => {};
			const compose = (fa, fb) => {
				return (...args) => {
					return fa(fb.apply(null, args));
				};
			};
			const compose1 = (fbc, fab) => (a) => fbc(fab(a));
			const constant = (value$2) => {
				return () => {
					return value$2;
				};
			};
			const identity = (x) => {
				return x;
			};
			const tripleEquals = (a, b) => {
				return a === b;
			};
			function curry(fn, ...initialArgs) {
				return (...restArgs) => {
					const all$2 = initialArgs.concat(restArgs);
					return fn.apply(null, all$2);
				};
			}
			const not = (f) => (t) => !f(t);
			const die = (msg) => {
				return () => {
					throw new Error(msg);
				};
			};
			const apply = (f) => {
				return f();
			};
			const never = constant(false);
			const always = constant(true);
			class Optional {
				constructor(tag, value$2) {
					this.tag = tag;
					this.value = value$2;
				}
				static some(value$2) {
					return new Optional(true, value$2);
				}
				static none() {
					return Optional.singletonNone;
				}
				fold(onNone, onSome) {
					if (this.tag) return onSome(this.value);
					else return onNone();
				}
				isSome() {
					return this.tag;
				}
				isNone() {
					return !this.tag;
				}
				map(mapper) {
					if (this.tag) return Optional.some(mapper(this.value));
					else return Optional.none();
				}
				bind(binder$1) {
					if (this.tag) return binder$1(this.value);
					else return Optional.none();
				}
				exists(predicate) {
					return this.tag && predicate(this.value);
				}
				forall(predicate) {
					return !this.tag || predicate(this.value);
				}
				filter(predicate) {
					if (!this.tag || predicate(this.value)) return this;
					else return Optional.none();
				}
				getOr(replacement) {
					return this.tag ? this.value : replacement;
				}
				or(replacement) {
					return this.tag ? this : replacement;
				}
				getOrThunk(thunk) {
					return this.tag ? this.value : thunk();
				}
				orThunk(thunk) {
					return this.tag ? this : thunk();
				}
				getOrDie(message) {
					if (!this.tag) throw new Error(message !== null && message !== void 0 ? message : "Called getOrDie on None");
					else return this.value;
				}
				static from(value$2) {
					return isNonNullable(value$2) ? Optional.some(value$2) : Optional.none();
				}
				getOrNull() {
					return this.tag ? this.value : null;
				}
				getOrUndefined() {
					return this.value;
				}
				each(worker) {
					if (this.tag) worker(this.value);
				}
				toArray() {
					return this.tag ? [this.value] : [];
				}
				toString() {
					return this.tag ? `some(${this.value})` : "none()";
				}
			}
			Optional.singletonNone = new Optional(false);
			const nativeSlice = Array.prototype.slice;
			const nativeIndexOf = Array.prototype.indexOf;
			const nativePush = Array.prototype.push;
			const rawIndexOf = (ts, t) => nativeIndexOf.call(ts, t);
			const contains$2 = (xs, x) => rawIndexOf(xs, x) > -1;
			const exists = (xs, pred) => {
				for (let i = 0, len = xs.length; i < len; i++) {
					const x = xs[i];
					if (pred(x, i)) return true;
				}
				return false;
			};
			const range$1 = (num, f) => {
				const r$1 = [];
				for (let i = 0; i < num; i++) r$1.push(f(i));
				return r$1;
			};
			const map$1 = (xs, f) => {
				const len = xs.length;
				const r$1 = new Array(len);
				for (let i = 0; i < len; i++) {
					const x = xs[i];
					r$1[i] = f(x, i);
				}
				return r$1;
			};
			const each$2 = (xs, f) => {
				for (let i = 0, len = xs.length; i < len; i++) {
					const x = xs[i];
					f(x, i);
				}
			};
			const eachr = (xs, f) => {
				for (let i = xs.length - 1; i >= 0; i--) {
					const x = xs[i];
					f(x, i);
				}
			};
			const partition = (xs, pred) => {
				const pass = [];
				const fail = [];
				for (let i = 0, len = xs.length; i < len; i++) {
					const x = xs[i];
					(pred(x, i) ? pass : fail).push(x);
				}
				return {
					pass,
					fail
				};
			};
			const filter$2 = (xs, pred) => {
				const r$1 = [];
				for (let i = 0, len = xs.length; i < len; i++) {
					const x = xs[i];
					if (pred(x, i)) r$1.push(x);
				}
				return r$1;
			};
			const foldr = (xs, f, acc) => {
				eachr(xs, (x, i) => {
					acc = f(acc, x, i);
				});
				return acc;
			};
			const foldl = (xs, f, acc) => {
				each$2(xs, (x, i) => {
					acc = f(acc, x, i);
				});
				return acc;
			};
			const findUntil = (xs, pred, until) => {
				for (let i = 0, len = xs.length; i < len; i++) {
					const x = xs[i];
					if (pred(x, i)) return Optional.some(x);
					else if (until(x, i)) break;
				}
				return Optional.none();
			};
			const find$1 = (xs, pred) => {
				return findUntil(xs, pred, never);
			};
			const findIndex = (xs, pred) => {
				for (let i = 0, len = xs.length; i < len; i++) {
					const x = xs[i];
					if (pred(x, i)) return Optional.some(i);
				}
				return Optional.none();
			};
			const flatten = (xs) => {
				const r$1 = [];
				for (let i = 0, len = xs.length; i < len; ++i) {
					if (!isArray(xs[i])) throw new Error("Arr.flatten item " + i + " was not an array, input: " + xs);
					nativePush.apply(r$1, xs[i]);
				}
				return r$1;
			};
			const bind$2 = (xs, f) => flatten(map$1(xs, f));
			const forall = (xs, pred) => {
				for (let i = 0, len = xs.length; i < len; ++i) {
					const x = xs[i];
					if (pred(x, i) !== true) return false;
				}
				return true;
			};
			const reverse = (xs) => {
				const r$1 = nativeSlice.call(xs, 0);
				r$1.reverse();
				return r$1;
			};
			const mapToObject = (xs, f) => {
				const r$1 = {};
				for (let i = 0, len = xs.length; i < len; i++) {
					const x = xs[i];
					r$1[String(x)] = f(x, i);
				}
				return r$1;
			};
			const sort$1 = (xs, comparator) => {
				const copy$3 = nativeSlice.call(xs, 0);
				copy$3.sort(comparator);
				return copy$3;
			};
			const get$d = (xs, i) => i >= 0 && i < xs.length ? Optional.some(xs[i]) : Optional.none();
			const head = (xs) => get$d(xs, 0);
			const last$2 = (xs) => get$d(xs, xs.length - 1);
			const findMap = (arr, f) => {
				for (let i = 0; i < arr.length; i++) {
					const r$1 = f(arr[i], i);
					if (r$1.isSome()) return r$1;
				}
				return Optional.none();
			};
			const keys = Object.keys;
			const hasOwnProperty = Object.hasOwnProperty;
			const each$1 = (obj, f) => {
				const props = keys(obj);
				for (let k = 0, len = props.length; k < len; k++) {
					const i = props[k];
					const x = obj[i];
					f(x, i);
				}
			};
			const map = (obj, f) => {
				return tupleMap(obj, (x, i) => ({
					k: i,
					v: f(x, i)
				}));
			};
			const tupleMap = (obj, f) => {
				const r$1 = {};
				each$1(obj, (x, i) => {
					const tuple = f(x, i);
					r$1[tuple.k] = tuple.v;
				});
				return r$1;
			};
			const objAcc = (r$1) => (x, i) => {
				r$1[i] = x;
			};
			const internalFilter = (obj, pred, onTrue, onFalse) => {
				each$1(obj, (x, i) => {
					(pred(x, i) ? onTrue : onFalse)(x, i);
				});
			};
			const filter$1 = (obj, pred) => {
				const t = {};
				internalFilter(obj, pred, objAcc(t), noop);
				return t;
			};
			const mapToArray = (obj, f) => {
				const r$1 = [];
				each$1(obj, (value$2, name$1) => {
					r$1.push(f(value$2, name$1));
				});
				return r$1;
			};
			const values = (obj) => {
				return mapToArray(obj, identity);
			};
			const get$c = (obj, key$1) => {
				return has$1(obj, key$1) ? Optional.from(obj[key$1]) : Optional.none();
			};
			const has$1 = (obj, key$1) => hasOwnProperty.call(obj, key$1);
			const hasNonNullableKey = (obj, key$1) => has$1(obj, key$1) && obj[key$1] !== void 0 && obj[key$1] !== null;
			const isEmpty = (r$1) => {
				for (const x in r$1) if (hasOwnProperty.call(r$1, x)) return false;
				return true;
			};
			const Global = typeof window !== "undefined" ? window : Function("return this;")();
			const path = (parts, scope) => {
				let o = scope !== void 0 && scope !== null ? scope : Global;
				for (let i = 0; i < parts.length && o !== void 0 && o !== null; ++i) o = o[parts[i]];
				return o;
			};
			const resolve$2 = (p, scope) => {
				return path(p.split("."), scope);
			};
			const unsafe = (name$1, scope) => {
				return resolve$2(name$1, scope);
			};
			const getOrDie = (name$1, scope) => {
				const actual = unsafe(name$1, scope);
				if (actual === void 0 || actual === null) throw new Error(name$1 + " not available on this browser");
				return actual;
			};
			const getPrototypeOf = Object.getPrototypeOf;
			const sandHTMLElement = (scope) => {
				return getOrDie("HTMLElement", scope);
			};
			const isPrototypeOf = (x) => {
				const scope = resolve$2("ownerDocument.defaultView", x);
				return isObject(x) && (sandHTMLElement(scope).prototype.isPrototypeOf(x) || /^HTML\w*Element$/.test(getPrototypeOf(x).constructor.name));
			};
			const COMMENT = 8;
			const DOCUMENT = 9;
			const DOCUMENT_FRAGMENT = 11;
			const ELEMENT = 1;
			const TEXT = 3;
			const name = (element) => {
				return element.dom.nodeName.toLowerCase();
			};
			const type = (element) => element.dom.nodeType;
			const isType = (t) => (element) => type(element) === t;
			const isComment = (element) => type(element) === COMMENT || name(element) === "#comment";
			const isHTMLElement = (element) => isElement(element) && isPrototypeOf(element.dom);
			const isElement = isType(ELEMENT);
			const isText = isType(TEXT);
			const isDocument = isType(DOCUMENT);
			const isDocumentFragment = isType(DOCUMENT_FRAGMENT);
			const isTag = (tag) => (e) => isElement(e) && name(e) === tag;
			const rawSet = (dom, key$1, value$2) => {
				if (isString(value$2) || isBoolean(value$2) || isNumber(value$2)) dom.setAttribute(key$1, value$2 + "");
				else {
					console.error("Invalid call to Attribute.set. Key ", key$1, ":: Value ", value$2, ":: Element ", dom);
					throw new Error("Attribute value was not simple");
				}
			};
			const set$2 = (element, key$1, value$2) => {
				rawSet(element.dom, key$1, value$2);
			};
			const setAll$1 = (element, attrs) => {
				const dom = element.dom;
				each$1(attrs, (v, k) => {
					rawSet(dom, k, v);
				});
			};
			const setOptions = (element, attrs) => {
				each$1(attrs, (v, k) => {
					v.fold(() => {
						remove$7(element, k);
					}, (value$2) => {
						rawSet(element.dom, k, value$2);
					});
				});
			};
			const get$b = (element, key$1) => {
				const v = element.dom.getAttribute(key$1);
				return v === null ? void 0 : v;
			};
			const getOpt = (element, key$1) => Optional.from(get$b(element, key$1));
			const remove$7 = (element, key$1) => {
				element.dom.removeAttribute(key$1);
			};
			const clone$2 = (element) => foldl(element.dom.attributes, (acc, attr) => {
				acc[attr.name] = attr.value;
				return acc;
			}, {});
			const fromHtml$1 = (html, scope) => {
				const div = (scope || document).createElement("div");
				div.innerHTML = html;
				if (!div.hasChildNodes() || div.childNodes.length > 1) {
					const message = "HTML does not have a single root node";
					console.error(message, html);
					throw new Error(message);
				}
				return fromDom$1(div.childNodes[0]);
			};
			const fromTag = (tag, scope) => {
				return fromDom$1((scope || document).createElement(tag));
			};
			const fromText = (text, scope) => {
				return fromDom$1((scope || document).createTextNode(text));
			};
			const fromDom$1 = (node) => {
				if (node === null || node === void 0) throw new Error("Node cannot be null or undefined");
				return { dom: node };
			};
			const fromPoint$1 = (docElm, x, y) => Optional.from(docElm.dom.elementFromPoint(x, y)).map(fromDom$1);
			const SugarElement = {
				fromHtml: fromHtml$1,
				fromTag,
				fromText,
				fromDom: fromDom$1,
				fromPoint: fromPoint$1
			};
			const is$2 = (element, selector) => {
				const dom = element.dom;
				if (dom.nodeType !== ELEMENT) return false;
				else {
					const elem = dom;
					if (elem.matches !== void 0) return elem.matches(selector);
					else if (elem.msMatchesSelector !== void 0) return elem.msMatchesSelector(selector);
					else if (elem.webkitMatchesSelector !== void 0) return elem.webkitMatchesSelector(selector);
					else if (elem.mozMatchesSelector !== void 0) return elem.mozMatchesSelector(selector);
					else throw new Error("Browser lacks native selectors");
				}
			};
			const bypassSelector = (dom) => dom.nodeType !== ELEMENT && dom.nodeType !== DOCUMENT && dom.nodeType !== DOCUMENT_FRAGMENT || dom.childElementCount === 0;
			const all$1 = (selector, scope) => {
				const base$1 = scope === void 0 ? document : scope.dom;
				return bypassSelector(base$1) ? [] : map$1(base$1.querySelectorAll(selector), SugarElement.fromDom);
			};
			const one = (selector, scope) => {
				const base$1 = scope === void 0 ? document : scope.dom;
				return bypassSelector(base$1) ? Optional.none() : Optional.from(base$1.querySelector(selector)).map(SugarElement.fromDom);
			};
			const eq$1 = (e1, e2) => e1.dom === e2.dom;
			const contains$1 = (e1, e2) => {
				const d1 = e1.dom;
				const d2 = e2.dom;
				return d1 === d2 ? false : d1.contains(d2);
			};
			const is$1 = is$2;
			const owner = (element) => SugarElement.fromDom(element.dom.ownerDocument);
			const documentOrOwner = (dos) => isDocument(dos) ? dos : owner(dos);
			const documentElement = (element) => SugarElement.fromDom(documentOrOwner(element).dom.documentElement);
			const defaultView = (element) => SugarElement.fromDom(documentOrOwner(element).dom.defaultView);
			const parent = (element) => Optional.from(element.dom.parentNode).map(SugarElement.fromDom);
			const parentElement = (element) => Optional.from(element.dom.parentElement).map(SugarElement.fromDom);
			const parents = (element, isRoot) => {
				const stop = isFunction(isRoot) ? isRoot : never;
				let dom = element.dom;
				const ret = [];
				while (dom.parentNode !== null && dom.parentNode !== void 0) {
					const rawParent = dom.parentNode;
					const p = SugarElement.fromDom(rawParent);
					ret.push(p);
					if (stop(p) === true) break;
					else dom = rawParent;
				}
				return ret;
			};
			const prevSibling = (element) => Optional.from(element.dom.previousSibling).map(SugarElement.fromDom);
			const nextSibling = (element) => Optional.from(element.dom.nextSibling).map(SugarElement.fromDom);
			const children$2 = (element) => map$1(element.dom.childNodes, SugarElement.fromDom);
			const child$2 = (element, index) => {
				const cs = element.dom.childNodes;
				return Optional.from(cs[index]).map(SugarElement.fromDom);
			};
			const firstChild = (element) => child$2(element, 0);
			const before$3 = (marker, element) => {
				parent(marker).each((v) => {
					v.dom.insertBefore(element.dom, marker.dom);
				});
			};
			const after$5 = (marker, element) => {
				nextSibling(marker).fold(() => {
					parent(marker).each((v) => {
						append$1(v, element);
					});
				}, (v) => {
					before$3(v, element);
				});
			};
			const prepend = (parent$1, element) => {
				firstChild(parent$1).fold(() => {
					append$1(parent$1, element);
				}, (v) => {
					parent$1.dom.insertBefore(element.dom, v.dom);
				});
			};
			const append$1 = (parent$1, element) => {
				parent$1.dom.appendChild(element.dom);
			};
			const appendAt = (parent$1, element, index) => {
				child$2(parent$1, index).fold(() => {
					append$1(parent$1, element);
				}, (v) => {
					before$3(v, element);
				});
			};
			const wrap = (element, wrapper) => {
				before$3(element, wrapper);
				append$1(wrapper, element);
			};
			const after$4 = (marker, elements) => {
				each$2(elements, (x, i) => {
					after$5(i === 0 ? marker : elements[i - 1], x);
				});
			};
			const append = (parent$1, elements) => {
				each$2(elements, (x) => {
					append$1(parent$1, x);
				});
			};
			const empty = (element) => {
				element.dom.textContent = "";
				each$2(children$2(element), (rogue) => {
					remove$6(rogue);
				});
			};
			const remove$6 = (element) => {
				const dom = element.dom;
				if (dom.parentNode !== null) dom.parentNode.removeChild(dom);
			};
			const unwrap = (wrapper) => {
				const children$3 = children$2(wrapper);
				if (children$3.length > 0) after$4(wrapper, children$3);
				remove$6(wrapper);
			};
			const clone$1 = (original, isDeep) => SugarElement.fromDom(original.dom.cloneNode(isDeep));
			const shallow = (original) => clone$1(original, false);
			const deep = (original) => clone$1(original, true);
			const shallowAs = (original, tag) => {
				const nu$3 = SugarElement.fromTag(tag);
				setAll$1(nu$3, clone$2(original));
				return nu$3;
			};
			const copy$2 = (original, tag) => {
				const nu$3 = shallowAs(original, tag);
				append(nu$3, children$2(deep(original)));
				return nu$3;
			};
			const mutate$1 = (original, tag) => {
				const nu$3 = shallowAs(original, tag);
				after$5(original, nu$3);
				append(nu$3, children$2(original));
				remove$6(original);
				return nu$3;
			};
			const validSectionList = [
				"tfoot",
				"thead",
				"tbody",
				"colgroup"
			];
			const isValidSection = (parentName) => contains$2(validSectionList, parentName);
			const grid = (rows$2, columns$2) => ({
				rows: rows$2,
				columns: columns$2
			});
			const address = (row$1, column) => ({
				row: row$1,
				column
			});
			const detail = (element, rowspan, colspan) => ({
				element,
				rowspan,
				colspan
			});
			const detailnew = (element, rowspan, colspan, isNew) => ({
				element,
				rowspan,
				colspan,
				isNew
			});
			const extended = (element, rowspan, colspan, row$1, column, isLocked) => ({
				element,
				rowspan,
				colspan,
				row: row$1,
				column,
				isLocked
			});
			const rowdetail = (element, cells$2, section$1) => ({
				element,
				cells: cells$2,
				section: section$1
			});
			const rowdetailnew = (element, cells$2, section$1, isNew) => ({
				element,
				cells: cells$2,
				section: section$1,
				isNew
			});
			const elementnew = (element, isNew, isLocked) => ({
				element,
				isNew,
				isLocked
			});
			const rowcells = (element, cells$2, section$1, isNew) => ({
				element,
				cells: cells$2,
				section: section$1,
				isNew
			});
			const bounds = (startRow, startCol, finishRow, finishCol) => ({
				startRow,
				startCol,
				finishRow,
				finishCol
			});
			const columnext = (element, colspan, column) => ({
				element,
				colspan,
				column
			});
			const colgroup = (element, columns$2) => ({
				element,
				columns: columns$2
			});
			const isShadowRoot = (dos) => isDocumentFragment(dos) && isNonNullable(dos.dom.host);
			const supported = isFunction(Element.prototype.attachShadow) && isFunction(Node.prototype.getRootNode);
			const isSupported$1 = constant(supported);
			const getRootNode = supported ? (e) => SugarElement.fromDom(e.dom.getRootNode()) : documentOrOwner;
			const getShadowRoot = (e) => {
				const r$1 = getRootNode(e);
				return isShadowRoot(r$1) ? Optional.some(r$1) : Optional.none();
			};
			const getShadowHost = (e) => SugarElement.fromDom(e.dom.host);
			const getOriginalEventTarget = (event) => {
				if (isSupported$1() && isNonNullable(event.target)) {
					const el = SugarElement.fromDom(event.target);
					if (isElement(el) && isOpenShadowHost(el)) {
						if (event.composed && event.composedPath) {
							const composedPath = event.composedPath();
							if (composedPath) return head(composedPath);
						}
					}
				}
				return Optional.from(event.target);
			};
			const isOpenShadowHost = (element) => isNonNullable(element.dom.shadowRoot);
			const inBody = (element) => {
				const dom = isText(element) ? element.dom.parentNode : element.dom;
				if (dom === void 0 || dom === null || dom.ownerDocument === null) return false;
				const doc = dom.ownerDocument;
				return getShadowRoot(SugarElement.fromDom(dom)).fold(() => doc.body.contains(dom), compose1(inBody, getShadowHost));
			};
			const body$1 = () => getBody$1(SugarElement.fromDom(document));
			const getBody$1 = (doc) => {
				const b = doc.dom.body;
				if (b === null || b === void 0) throw new Error("Body is not available yet");
				return SugarElement.fromDom(b);
			};
			const ancestors$4 = (scope, predicate, isRoot) => filter$2(parents(scope, isRoot), predicate);
			const children$1 = (scope, predicate) => filter$2(children$2(scope), predicate);
			const descendants$1 = (scope, predicate) => {
				let result = [];
				each$2(children$2(scope), (x) => {
					if (predicate(x)) result = result.concat([x]);
					result = result.concat(descendants$1(x, predicate));
				});
				return result;
			};
			const ancestors$3 = (scope, selector, isRoot) => ancestors$4(scope, (e) => is$2(e, selector), isRoot);
			const children = (scope, selector) => children$1(scope, (e) => is$2(e, selector));
			const descendants = (scope, selector) => all$1(selector, scope);
			var ClosestOrAncestor = (is$3, ancestor$3, scope, a, isRoot) => {
				if (is$3(scope, a)) return Optional.some(scope);
				else if (isFunction(isRoot) && isRoot(scope)) return Optional.none();
				else return ancestor$3(scope, a, isRoot);
			};
			const ancestor$2 = (scope, predicate, isRoot) => {
				let element = scope.dom;
				const stop = isFunction(isRoot) ? isRoot : never;
				while (element.parentNode) {
					element = element.parentNode;
					const el = SugarElement.fromDom(element);
					if (predicate(el)) return Optional.some(el);
					else if (stop(el)) break;
				}
				return Optional.none();
			};
			const closest$2 = (scope, predicate, isRoot) => {
				const is$3 = (s, test) => test(s);
				return ClosestOrAncestor(is$3, ancestor$2, scope, predicate, isRoot);
			};
			const child$1 = (scope, predicate) => {
				const pred = (node) => predicate(SugarElement.fromDom(node));
				return find$1(scope.dom.childNodes, pred).map(SugarElement.fromDom);
			};
			const descendant$1 = (scope, predicate) => {
				const descend = (node) => {
					for (let i = 0; i < node.childNodes.length; i++) {
						const child$3 = SugarElement.fromDom(node.childNodes[i]);
						if (predicate(child$3)) return Optional.some(child$3);
						const res = descend(node.childNodes[i]);
						if (res.isSome()) return res;
					}
					return Optional.none();
				};
				return descend(scope.dom);
			};
			const ancestor$1 = (scope, selector, isRoot) => ancestor$2(scope, (e) => is$2(e, selector), isRoot);
			const child = (scope, selector) => child$1(scope, (e) => is$2(e, selector));
			const descendant = (scope, selector) => one(selector, scope);
			const closest$1 = (scope, selector, isRoot) => {
				const is$3 = (element, selector$1) => is$2(element, selector$1);
				return ClosestOrAncestor(is$3, ancestor$1, scope, selector, isRoot);
			};
			const is = (lhs, rhs, comparator = tripleEquals) => lhs.exists((left$2) => comparator(left$2, rhs));
			const cat = (arr) => {
				const r$1 = [];
				const push = (x) => {
					r$1.push(x);
				};
				for (let i = 0; i < arr.length; i++) arr[i].each(push);
				return r$1;
			};
			const bindFrom = (a, f) => a !== void 0 && a !== null ? f(a) : Optional.none();
			const someIf = (b, a) => b ? Optional.some(a) : Optional.none();
			const checkRange = (str, substr, start) => substr === "" || str.length >= substr.length && str.substr(start, start + substr.length) === substr;
			const contains = (str, substr, start = 0, end) => {
				const idx = str.indexOf(substr, start);
				if (idx !== -1) return isUndefined(end) ? true : idx + substr.length <= end;
				else return false;
			};
			const startsWith = (str, prefix) => {
				return checkRange(str, prefix, 0);
			};
			const endsWith = (str, suffix) => {
				return checkRange(str, suffix, str.length - suffix.length);
			};
			const blank = (r$1) => (s) => s.replace(r$1, "");
			const trim = blank(/^\s+|\s+$/g);
			const isNotEmpty = (s) => s.length > 0;
			const toFloat = (value$2) => {
				const num = parseFloat(value$2);
				return isNaN(num) ? Optional.none() : Optional.some(num);
			};
			const isSupported = (dom) => dom.style !== void 0 && isFunction(dom.style.getPropertyValue);
			const internalSet = (dom, property, value$2) => {
				if (!isString(value$2)) {
					console.error("Invalid call to CSS.set. Property ", property, ":: Value ", value$2, ":: Element ", dom);
					throw new Error("CSS value must be a string: " + value$2);
				}
				if (isSupported(dom)) dom.style.setProperty(property, value$2);
			};
			const internalRemove = (dom, property) => {
				if (isSupported(dom)) dom.style.removeProperty(property);
			};
			const set$1 = (element, property, value$2) => {
				const dom = element.dom;
				internalSet(dom, property, value$2);
			};
			const setAll = (element, css$1) => {
				const dom = element.dom;
				each$1(css$1, (v, k) => {
					internalSet(dom, k, v);
				});
			};
			const get$a = (element, property) => {
				const dom = element.dom;
				const r$1 = window.getComputedStyle(dom).getPropertyValue(property);
				return r$1 === "" && !inBody(element) ? getUnsafeProperty(dom, property) : r$1;
			};
			const getUnsafeProperty = (dom, property) => isSupported(dom) ? dom.style.getPropertyValue(property) : "";
			const getRaw$2 = (element, property) => {
				const dom = element.dom;
				const raw = getUnsafeProperty(dom, property);
				return Optional.from(raw).filter((r$1) => r$1.length > 0);
			};
			const remove$5 = (element, property) => {
				const dom = element.dom;
				internalRemove(dom, property);
				if (is(getOpt(element, "style").map(trim), "")) remove$7(element, "style");
			};
			const copy$1 = (source, target) => {
				const sourceDom = source.dom;
				const targetDom = target.dom;
				if (isSupported(sourceDom) && isSupported(targetDom)) targetDom.style.cssText = sourceDom.style.cssText;
			};
			const getAttrValue = (cell$1, name$1, fallback$1 = 0) => getOpt(cell$1, name$1).map((value$2) => parseInt(value$2, 10)).getOr(fallback$1);
			const getSpan = (cell$1, type$1) => getAttrValue(cell$1, type$1, 1);
			const hasColspan = (cellOrCol) => {
				if (isTag("col")(cellOrCol)) return getAttrValue(cellOrCol, "span", 1) > 1;
				else return getSpan(cellOrCol, "colspan") > 1;
			};
			const hasRowspan = (cell$1) => getSpan(cell$1, "rowspan") > 1;
			const getCssValue = (element, property) => parseInt(get$a(element, property), 10);
			const minWidth = constant(10);
			const minHeight = constant(10);
			const firstLayer = (scope, selector) => {
				return filterFirstLayer(scope, selector, always);
			};
			const filterFirstLayer = (scope, selector, predicate) => {
				return bind$2(children$2(scope), (x) => {
					if (is$2(x, selector)) return predicate(x) ? [x] : [];
					else return filterFirstLayer(x, selector, predicate);
				});
			};
			const lookup = (tags, element, isRoot = never) => {
				if (isRoot(element)) return Optional.none();
				if (contains$2(tags, name(element))) return Optional.some(element);
				const isRootOrUpperTable = (elm) => is$2(elm, "table") || isRoot(elm);
				return ancestor$1(element, tags.join(","), isRootOrUpperTable);
			};
			const cell = (element, isRoot) => lookup(["td", "th"], element, isRoot);
			const cells$1 = (ancestor$3) => firstLayer(ancestor$3, "th,td");
			const columns$1 = (ancestor$3) => {
				if (is$2(ancestor$3, "colgroup")) return children(ancestor$3, "col");
				else return bind$2(columnGroups(ancestor$3), (columnGroup) => children(columnGroup, "col"));
			};
			const table = (element, isRoot) => closest$1(element, "table", isRoot);
			const rows$1 = (ancestor$3) => firstLayer(ancestor$3, "tr");
			const columnGroups = (ancestor$3) => table(ancestor$3).fold(constant([]), (table$1) => children(table$1, "colgroup"));
			const fromRowsOrColGroups = (elems, getSection) => map$1(elems, (row$1) => {
				if (name(row$1) === "colgroup") return rowdetail(row$1, map$1(columns$1(row$1), (column) => {
					return detail(column, 1, getAttrValue(column, "span", 1));
				}), "colgroup");
				else return rowdetail(row$1, map$1(cells$1(row$1), (cell$1) => {
					return detail(cell$1, getAttrValue(cell$1, "rowspan", 1), getAttrValue(cell$1, "colspan", 1));
				}), getSection(row$1));
			});
			const getParentSection = (group) => parent(group).map((parent$1) => {
				const parentName = name(parent$1);
				return isValidSection(parentName) ? parentName : "tbody";
			}).getOr("tbody");
			const fromTable$1 = (table$1) => {
				const rows$2 = rows$1(table$1);
				return fromRowsOrColGroups([...columnGroups(table$1), ...rows$2], getParentSection);
			};
			const fromPastedRows = (elems, section$1) => fromRowsOrColGroups(elems, () => section$1);
			const cached = (f) => {
				let called = false;
				let r$1;
				return (...args) => {
					if (!called) {
						called = true;
						r$1 = f.apply(null, args);
					}
					return r$1;
				};
			};
			const DeviceType = (os, browser, userAgent, mediaMatch$1) => {
				const isiPad = os.isiOS() && /ipad/i.test(userAgent) === true;
				const isiPhone = os.isiOS() && !isiPad;
				const isMobile = os.isiOS() || os.isAndroid();
				const isTouch = isMobile || mediaMatch$1("(pointer:coarse)");
				const isTablet = isiPad || !isiPhone && isMobile && mediaMatch$1("(min-device-width:768px)");
				const isPhone = isiPhone || isMobile && !isTablet;
				const iOSwebview = browser.isSafari() && os.isiOS() && /safari/i.test(userAgent) === false;
				const isDesktop = !isPhone && !isTablet && !iOSwebview;
				return {
					isiPad: constant(isiPad),
					isiPhone: constant(isiPhone),
					isTablet: constant(isTablet),
					isPhone: constant(isPhone),
					isTouch: constant(isTouch),
					isAndroid: os.isAndroid,
					isiOS: os.isiOS,
					isWebView: constant(iOSwebview),
					isDesktop: constant(isDesktop)
				};
			};
			const firstMatch = (regexes, s) => {
				for (let i = 0; i < regexes.length; i++) {
					const x = regexes[i];
					if (x.test(s)) return x;
				}
			};
			const find = (regexes, agent) => {
				const r$1 = firstMatch(regexes, agent);
				if (!r$1) return {
					major: 0,
					minor: 0
				};
				const group = (i) => {
					return Number(agent.replace(r$1, "$" + i));
				};
				return nu$2(group(1), group(2));
			};
			const detect$5 = (versionRegexes, agent) => {
				const cleanedAgent = String(agent).toLowerCase();
				if (versionRegexes.length === 0) return unknown$2();
				return find(versionRegexes, cleanedAgent);
			};
			const unknown$2 = () => {
				return nu$2(0, 0);
			};
			const nu$2 = (major, minor) => {
				return {
					major,
					minor
				};
			};
			const Version = {
				nu: nu$2,
				detect: detect$5,
				unknown: unknown$2
			};
			const detectBrowser$1 = (browsers$1, userAgentData) => {
				return findMap(userAgentData.brands, (uaBrand) => {
					const lcBrand = uaBrand.brand.toLowerCase();
					return find$1(browsers$1, (browser) => {
						var _a;
						return lcBrand === ((_a = browser.brand) === null || _a === void 0 ? void 0 : _a.toLowerCase());
					}).map((info) => ({
						current: info.name,
						version: Version.nu(parseInt(uaBrand.version, 10), 0)
					}));
				});
			};
			const detect$4 = (candidates, userAgent) => {
				const agent = String(userAgent).toLowerCase();
				return find$1(candidates, (candidate) => {
					return candidate.search(agent);
				});
			};
			const detectBrowser = (browsers$1, userAgent) => {
				return detect$4(browsers$1, userAgent).map((browser) => {
					const version = Version.detect(browser.versionRegexes, userAgent);
					return {
						current: browser.name,
						version
					};
				});
			};
			const detectOs = (oses$1, userAgent) => {
				return detect$4(oses$1, userAgent).map((os) => {
					const version = Version.detect(os.versionRegexes, userAgent);
					return {
						current: os.name,
						version
					};
				});
			};
			const normalVersionRegex = /.*?version\/\ ?([0-9]+)\.([0-9]+).*/;
			const checkContains = (target) => {
				return (uastring) => {
					return contains(uastring, target);
				};
			};
			const browsers = [
				{
					name: "Edge",
					versionRegexes: [/.*?edge\/ ?([0-9]+)\.([0-9]+)$/],
					search: (uastring) => {
						return contains(uastring, "edge/") && contains(uastring, "chrome") && contains(uastring, "safari") && contains(uastring, "applewebkit");
					}
				},
				{
					name: "Chromium",
					brand: "Chromium",
					versionRegexes: [/.*?chrome\/([0-9]+)\.([0-9]+).*/, normalVersionRegex],
					search: (uastring) => {
						return contains(uastring, "chrome") && !contains(uastring, "chromeframe");
					}
				},
				{
					name: "IE",
					versionRegexes: [/.*?msie\ ?([0-9]+)\.([0-9]+).*/, /.*?rv:([0-9]+)\.([0-9]+).*/],
					search: (uastring) => {
						return contains(uastring, "msie") || contains(uastring, "trident");
					}
				},
				{
					name: "Opera",
					versionRegexes: [normalVersionRegex, /.*?opera\/([0-9]+)\.([0-9]+).*/],
					search: checkContains("opera")
				},
				{
					name: "Firefox",
					versionRegexes: [/.*?firefox\/\ ?([0-9]+)\.([0-9]+).*/],
					search: checkContains("firefox")
				},
				{
					name: "Safari",
					versionRegexes: [normalVersionRegex, /.*?cpu os ([0-9]+)_([0-9]+).*/],
					search: (uastring) => {
						return (contains(uastring, "safari") || contains(uastring, "mobile/")) && contains(uastring, "applewebkit");
					}
				}
			];
			const oses = [
				{
					name: "Windows",
					search: checkContains("win"),
					versionRegexes: [/.*?windows\ nt\ ?([0-9]+)\.([0-9]+).*/]
				},
				{
					name: "iOS",
					search: (uastring) => {
						return contains(uastring, "iphone") || contains(uastring, "ipad");
					},
					versionRegexes: [
						/.*?version\/\ ?([0-9]+)\.([0-9]+).*/,
						/.*cpu os ([0-9]+)_([0-9]+).*/,
						/.*cpu iphone os ([0-9]+)_([0-9]+).*/
					]
				},
				{
					name: "Android",
					search: checkContains("android"),
					versionRegexes: [/.*?android\ ?([0-9]+)\.([0-9]+).*/]
				},
				{
					name: "macOS",
					search: checkContains("mac os x"),
					versionRegexes: [/.*?mac\ os\ x\ ?([0-9]+)_([0-9]+).*/]
				},
				{
					name: "Linux",
					search: checkContains("linux"),
					versionRegexes: []
				},
				{
					name: "Solaris",
					search: checkContains("sunos"),
					versionRegexes: []
				},
				{
					name: "FreeBSD",
					search: checkContains("freebsd"),
					versionRegexes: []
				},
				{
					name: "ChromeOS",
					search: checkContains("cros"),
					versionRegexes: [/.*?chrome\/([0-9]+)\.([0-9]+).*/]
				}
			];
			const PlatformInfo = {
				browsers: constant(browsers),
				oses: constant(oses)
			};
			const edge = "Edge";
			const chromium = "Chromium";
			const ie = "IE";
			const opera = "Opera";
			const firefox = "Firefox";
			const safari = "Safari";
			const unknown$1 = () => {
				return nu$1({
					current: void 0,
					version: Version.unknown()
				});
			};
			const nu$1 = (info) => {
				const current = info.current;
				const version = info.version;
				const isBrowser = (name$1) => () => current === name$1;
				return {
					current,
					version,
					isEdge: isBrowser(edge),
					isChromium: isBrowser(chromium),
					isIE: isBrowser(ie),
					isOpera: isBrowser(opera),
					isFirefox: isBrowser(firefox),
					isSafari: isBrowser(safari)
				};
			};
			const Browser = {
				unknown: unknown$1,
				nu: nu$1,
				edge: constant(edge),
				chromium: constant(chromium),
				ie: constant(ie),
				opera: constant(opera),
				firefox: constant(firefox),
				safari: constant(safari)
			};
			const windows = "Windows";
			const ios = "iOS";
			const android = "Android";
			const linux = "Linux";
			const macos = "macOS";
			const solaris = "Solaris";
			const freebsd = "FreeBSD";
			const chromeos = "ChromeOS";
			const unknown = () => {
				return nu({
					current: void 0,
					version: Version.unknown()
				});
			};
			const nu = (info) => {
				const current = info.current;
				const version = info.version;
				const isOS = (name$1) => () => current === name$1;
				return {
					current,
					version,
					isWindows: isOS(windows),
					isiOS: isOS(ios),
					isAndroid: isOS(android),
					isMacOS: isOS(macos),
					isLinux: isOS(linux),
					isSolaris: isOS(solaris),
					isFreeBSD: isOS(freebsd),
					isChromeOS: isOS(chromeos)
				};
			};
			const OperatingSystem = {
				unknown,
				nu,
				windows: constant(windows),
				ios: constant(ios),
				android: constant(android),
				linux: constant(linux),
				macos: constant(macos),
				solaris: constant(solaris),
				freebsd: constant(freebsd),
				chromeos: constant(chromeos)
			};
			const detect$3 = (userAgent, userAgentDataOpt, mediaMatch$1) => {
				const browsers$1 = PlatformInfo.browsers();
				const oses$1 = PlatformInfo.oses();
				const browser = userAgentDataOpt.bind((userAgentData) => detectBrowser$1(browsers$1, userAgentData)).orThunk(() => detectBrowser(browsers$1, userAgent)).fold(Browser.unknown, Browser.nu);
				const os = detectOs(oses$1, userAgent).fold(OperatingSystem.unknown, OperatingSystem.nu);
				return {
					browser,
					os,
					deviceType: DeviceType(os, browser, userAgent, mediaMatch$1)
				};
			};
			const PlatformDetection = { detect: detect$3 };
			const mediaMatch = (query) => window.matchMedia(query).matches;
			let platform = cached(() => PlatformDetection.detect(navigator.userAgent, Optional.from(navigator.userAgentData), mediaMatch));
			const detect$2 = () => platform();
			const Dimension = (name$1, getOffset) => {
				const set$3 = (element, h) => {
					if (!isNumber(h) && !h.match(/^[0-9]+$/)) throw new Error(name$1 + ".set accepts only positive integer values. Value was " + h);
					const dom = element.dom;
					if (isSupported(dom)) dom.style[name$1] = h + "px";
				};
				const get$10 = (element) => {
					const r$1 = getOffset(element);
					if (r$1 <= 0 || r$1 === null) {
						const css$1 = get$a(element, name$1);
						return parseFloat(css$1) || 0;
					}
					return r$1;
				};
				const getOuter$3 = get$10;
				const aggregate = (element, properties) => foldl(properties, (acc, property) => {
					const val = get$a(element, property);
					const value$2 = val === void 0 ? 0 : parseInt(val, 10);
					return isNaN(value$2) ? acc : acc + value$2;
				}, 0);
				const max = (element, value$2, properties) => {
					const cumulativeInclusions = aggregate(element, properties);
					return value$2 > cumulativeInclusions ? value$2 - cumulativeInclusions : 0;
				};
				return {
					set: set$3,
					get: get$10,
					getOuter: getOuter$3,
					aggregate,
					max
				};
			};
			const toNumber = (px, fallback$1) => toFloat(px).getOr(fallback$1);
			const getProp = (element, name$1, fallback$1) => toNumber(get$a(element, name$1), fallback$1);
			const calcContentBoxSize = (element, size, upper, lower) => {
				const paddingUpper = getProp(element, `padding-${upper}`, 0);
				const paddingLower = getProp(element, `padding-${lower}`, 0);
				const borderUpper = getProp(element, `border-${upper}-width`, 0);
				const borderLower = getProp(element, `border-${lower}-width`, 0);
				return size - paddingUpper - paddingLower - borderUpper - borderLower;
			};
			const getCalculatedWidth = (element, boxSizing) => {
				const dom = element.dom;
				const width$1 = dom.getBoundingClientRect().width || dom.offsetWidth;
				return boxSizing === "border-box" ? width$1 : calcContentBoxSize(element, width$1, "left", "right");
			};
			const getHeight$1 = (element) => getProp(element, "height", element.dom.offsetHeight);
			const getWidth = (element) => getProp(element, "width", element.dom.offsetWidth);
			const getInnerWidth = (element) => getCalculatedWidth(element, "content-box");
			const api$2 = Dimension("width", (element) => element.dom.offsetWidth);
			const get$9 = (element) => api$2.get(element);
			const getOuter$2 = (element) => api$2.getOuter(element);
			const getInner = getInnerWidth;
			const getRuntime$1 = getWidth;
			const addCells = (gridRow, index, cells$2) => {
				const existingCells = gridRow.cells;
				const before$2 = existingCells.slice(0, index);
				const after$3 = existingCells.slice(index);
				return setCells(gridRow, before$2.concat(cells$2).concat(after$3));
			};
			const addCell = (gridRow, index, cell$1) => addCells(gridRow, index, [cell$1]);
			const mutateCell = (gridRow, index, cell$1) => {
				const cells$2 = gridRow.cells;
				cells$2[index] = cell$1;
			};
			const setCells = (gridRow, cells$2) => rowcells(gridRow.element, cells$2, gridRow.section, gridRow.isNew);
			const mapCells = (gridRow, f) => {
				const cells$2 = gridRow.cells;
				const r$1 = map$1(cells$2, f);
				return rowcells(gridRow.element, r$1, gridRow.section, gridRow.isNew);
			};
			const getCell = (gridRow, index) => gridRow.cells[index];
			const getCellElement = (gridRow, index) => getCell(gridRow, index).element;
			const cellLength = (gridRow) => gridRow.cells.length;
			const extractGridDetails = (grid$1) => {
				const result = partition(grid$1, (row$1) => row$1.section === "colgroup");
				return {
					rows: result.fail,
					cols: result.pass
				};
			};
			const clone = (gridRow, cloneRow$1, cloneCell) => {
				const newCells = map$1(gridRow.cells, cloneCell);
				return rowcells(cloneRow$1(gridRow.element), newCells, gridRow.section, true);
			};
			const LOCKED_COL_ATTR = "data-snooker-locked-cols";
			const getLockedColumnsFromTable = (table$1) => getOpt(table$1, LOCKED_COL_ATTR).bind((lockedColStr) => Optional.from(lockedColStr.match(/\d+/g))).map((lockedCols) => mapToObject(lockedCols, always));
			const getLockedColumnsFromGrid = (grid$1) => {
				return sort$1(mapToArray(foldl(extractGridDetails(grid$1).rows, (acc, row$1) => {
					each$2(row$1.cells, (cell$1, idx) => {
						if (cell$1.isLocked) acc[idx] = true;
					});
					return acc;
				}, {}), (_val, key$1) => parseInt(key$1, 10)));
			};
			const key = (row$1, column) => {
				return row$1 + "," + column;
			};
			const getAt = (warehouse, row$1, column) => Optional.from(warehouse.access[key(row$1, column)]);
			const findItem = (warehouse, item, comparator) => {
				const filtered = filterItems(warehouse, (detail$1) => {
					return comparator(item, detail$1.element);
				});
				return filtered.length > 0 ? Optional.some(filtered[0]) : Optional.none();
			};
			const filterItems = (warehouse, predicate) => {
				return filter$2(bind$2(warehouse.all, (r$1) => {
					return r$1.cells;
				}), predicate);
			};
			const generateColumns = (rowData) => {
				const columnsGroup = {};
				let index = 0;
				each$2(rowData.cells, (column) => {
					const colspan = column.colspan;
					range$1(colspan, (columnIndex) => {
						const colIndex = index + columnIndex;
						columnsGroup[colIndex] = columnext(column.element, colspan, colIndex);
					});
					index += colspan;
				});
				return columnsGroup;
			};
			const generate$1 = (list) => {
				const access = {};
				const cells$2 = [];
				const lockedColumns = head(list).map((rowData) => rowData.element).bind(table).bind(getLockedColumnsFromTable).getOr({});
				let maxRows = 0;
				let maxColumns = 0;
				let rowCount = 0;
				const { pass: colgroupRows, fail: rows$2 } = partition(list, (rowData) => rowData.section === "colgroup");
				each$2(rows$2, (rowData) => {
					const currentRow = [];
					each$2(rowData.cells, (rowCell) => {
						let start = 0;
						while (access[key(rowCount, start)] !== void 0) start++;
						const isLocked = hasNonNullableKey(lockedColumns, start.toString());
						const current = extended(rowCell.element, rowCell.rowspan, rowCell.colspan, rowCount, start, isLocked);
						for (let occupiedColumnPosition = 0; occupiedColumnPosition < rowCell.colspan; occupiedColumnPosition++) for (let occupiedRowPosition = 0; occupiedRowPosition < rowCell.rowspan; occupiedRowPosition++) {
							const rowPosition = rowCount + occupiedRowPosition;
							const columnPosition = start + occupiedColumnPosition;
							const newpos = key(rowPosition, columnPosition);
							access[newpos] = current;
							maxColumns = Math.max(maxColumns, columnPosition + 1);
						}
						currentRow.push(current);
					});
					maxRows++;
					cells$2.push(rowdetail(rowData.element, currentRow, rowData.section));
					rowCount++;
				});
				const { columns: columns$2, colgroups } = last$2(colgroupRows).map((rowData) => {
					const columns$3 = generateColumns(rowData);
					return {
						colgroups: [colgroup(rowData.element, values(columns$3))],
						columns: columns$3
					};
				}).getOrThunk(() => ({
					colgroups: [],
					columns: {}
				}));
				return {
					grid: grid(maxRows, maxColumns),
					access,
					all: cells$2,
					columns: columns$2,
					colgroups
				};
			};
			const fromTable = (table$1) => {
				return generate$1(fromTable$1(table$1));
			};
			const justCells = (warehouse) => bind$2(warehouse.all, (w) => w.cells);
			const justColumns = (warehouse) => values(warehouse.columns);
			const hasColumns = (warehouse) => keys(warehouse.columns).length > 0;
			const getColumnAt = (warehouse, columnIndex) => Optional.from(warehouse.columns[columnIndex]);
			const Warehouse = {
				fromTable,
				generate: generate$1,
				getAt,
				findItem,
				filterItems,
				justCells,
				justColumns,
				hasColumns,
				getColumnAt
			};
			const columns = (warehouse, isValidCell = always) => {
				const grid$1 = warehouse.grid;
				const cols = range$1(grid$1.columns, identity);
				const rowsArr = range$1(grid$1.rows, identity);
				return map$1(cols, (col$1) => {
					const getBlock = () => bind$2(rowsArr, (r$1) => Warehouse.getAt(warehouse, r$1, col$1).filter((detail$1) => detail$1.column === col$1).toArray());
					const isValid = (detail$1) => detail$1.colspan === 1 && isValidCell(detail$1.element);
					const getFallback = () => Warehouse.getAt(warehouse, 0, col$1);
					return decide(getBlock, isValid, getFallback);
				});
			};
			const decide = (getBlock, isValid, getFallback) => {
				const inBlock = getBlock();
				return find$1(inBlock, isValid).orThunk(() => Optional.from(inBlock[0]).orThunk(getFallback)).map((detail$1) => detail$1.element);
			};
			const rows = (warehouse) => {
				const grid$1 = warehouse.grid;
				const rowsArr = range$1(grid$1.rows, identity);
				const cols = range$1(grid$1.columns, identity);
				return map$1(rowsArr, (row$1) => {
					const getBlock = () => bind$2(cols, (c) => Warehouse.getAt(warehouse, row$1, c).filter((detail$1) => detail$1.row === row$1).fold(constant([]), (detail$1) => [detail$1]));
					const isSingle = (detail$1) => detail$1.rowspan === 1;
					const getFallback = () => Warehouse.getAt(warehouse, row$1, 0);
					return decide(getBlock, isSingle, getFallback);
				});
			};
			const deduce = (xs, index) => {
				if (index < 0 || index >= xs.length - 1) return Optional.none();
				const current = xs[index].fold(() => {
					return findMap(reverse(xs.slice(0, index)), (a, i) => a.map((aa) => ({
						value: aa,
						delta: i + 1
					})));
				}, (c) => Optional.some({
					value: c,
					delta: 0
				}));
				const next = xs[index + 1].fold(() => {
					return findMap(xs.slice(index + 1), (a, i) => a.map((aa) => ({
						value: aa,
						delta: i + 1
					})));
				}, (n) => Optional.some({
					value: n,
					delta: 1
				}));
				return current.bind((c) => next.map((n) => {
					const extras = n.delta + c.delta;
					return Math.abs(n.value - c.value) / extras;
				}));
			};
			const onDirection = (isLtr, isRtl) => (element) => getDirection(element) === "rtl" ? isRtl : isLtr;
			const getDirection = (element) => get$a(element, "direction") === "rtl" ? "rtl" : "ltr";
			const api$1 = Dimension("height", (element) => {
				const dom = element.dom;
				return inBody(element) ? dom.getBoundingClientRect().height : dom.offsetHeight;
			});
			const get$8 = (element) => api$1.get(element);
			const getOuter$1 = (element) => api$1.getOuter(element);
			const getRuntime = getHeight$1;
			const r = (left$2, top) => {
				const translate$1 = (x, y) => r(left$2 + x, top + y);
				return {
					left: left$2,
					top,
					translate: translate$1
				};
			};
			const SugarPosition = r;
			const boxPosition = (dom) => {
				const box = dom.getBoundingClientRect();
				return SugarPosition(box.left, box.top);
			};
			const firstDefinedOrZero = (a, b) => {
				if (a !== void 0) return a;
				else return b !== void 0 ? b : 0;
			};
			const absolute = (element) => {
				const doc = element.dom.ownerDocument;
				const body$2 = doc.body;
				const win = doc.defaultView;
				const html = doc.documentElement;
				if (body$2 === element.dom) return SugarPosition(body$2.offsetLeft, body$2.offsetTop);
				const scrollTop = firstDefinedOrZero(win === null || win === void 0 ? void 0 : win.pageYOffset, html.scrollTop);
				const scrollLeft = firstDefinedOrZero(win === null || win === void 0 ? void 0 : win.pageXOffset, html.scrollLeft);
				const clientTop = firstDefinedOrZero(html.clientTop, body$2.clientTop);
				const clientLeft = firstDefinedOrZero(html.clientLeft, body$2.clientLeft);
				return viewport(element).translate(scrollLeft - clientLeft, scrollTop - clientTop);
			};
			const viewport = (element) => {
				const dom = element.dom;
				const body$2 = dom.ownerDocument.body;
				if (body$2 === dom) return SugarPosition(body$2.offsetLeft, body$2.offsetTop);
				if (!inBody(element)) return SugarPosition(0, 0);
				return boxPosition(dom);
			};
			const rowInfo = (row$1, y) => ({
				row: row$1,
				y
			});
			const colInfo = (col$1, x) => ({
				col: col$1,
				x
			});
			const rtlEdge = (cell$1) => {
				return absolute(cell$1).left + getOuter$2(cell$1);
			};
			const ltrEdge = (cell$1) => {
				return absolute(cell$1).left;
			};
			const getLeftEdge = (index, cell$1) => {
				return colInfo(index, ltrEdge(cell$1));
			};
			const getRightEdge = (index, cell$1) => {
				return colInfo(index, rtlEdge(cell$1));
			};
			const getTop$1 = (cell$1) => {
				return absolute(cell$1).top;
			};
			const getTopEdge = (index, cell$1) => {
				return rowInfo(index, getTop$1(cell$1));
			};
			const getBottomEdge = (index, cell$1) => {
				return rowInfo(index, getTop$1(cell$1) + getOuter$1(cell$1));
			};
			const findPositions = (getInnerEdge, getOuterEdge, array) => {
				if (array.length === 0) return [];
				const lines = map$1(array.slice(1), (cellOption, index) => {
					return cellOption.map((cell$1) => {
						return getInnerEdge(index, cell$1);
					});
				});
				const lastLine = array[array.length - 1].map((cell$1) => {
					return getOuterEdge(array.length - 1, cell$1);
				});
				return lines.concat([lastLine]);
			};
			const negate = (step) => {
				return -step;
			};
			const height = {
				delta: identity,
				positions: (optElements) => findPositions(getTopEdge, getBottomEdge, optElements),
				edge: getTop$1
			};
			const detect$1 = onDirection({
				delta: identity,
				edge: ltrEdge,
				positions: (optElements) => findPositions(getLeftEdge, getRightEdge, optElements)
			}, {
				delta: negate,
				edge: rtlEdge,
				positions: (optElements) => findPositions(getRightEdge, getLeftEdge, optElements)
			});
			const width = {
				delta: (amount, table$1) => detect$1(table$1).delta(amount, table$1),
				positions: (cols, table$1) => detect$1(table$1).positions(cols, table$1),
				edge: (cell$1) => detect$1(cell$1).edge(cell$1)
			};
			const units = {
				unsupportedLength: [
					"em",
					"ex",
					"cap",
					"ch",
					"ic",
					"rem",
					"lh",
					"rlh",
					"vw",
					"vh",
					"vi",
					"vb",
					"vmin",
					"vmax",
					"cm",
					"mm",
					"Q",
					"in",
					"pc",
					"pt",
					"px"
				],
				fixed: ["px", "pt"],
				relative: ["%"],
				empty: [""]
			};
			const pattern = (() => {
				const decimalDigits = "[0-9]+";
				const exponentPart = "[eE]" + ("[+-]?" + decimalDigits);
				const dot = "\\.";
				const opt = (input) => `(?:${input})?`;
				const float = `[+-]?(?:${[
					"Infinity",
					decimalDigits + dot + opt(decimalDigits) + opt(exponentPart),
					dot + decimalDigits + opt(exponentPart),
					decimalDigits + opt(exponentPart)
				].join("|")})`;
				return /* @__PURE__ */ new RegExp(`^(${float})(.*)$`);
			})();
			const isUnit = (unit, accepted) => exists(accepted, (acc) => exists(units[acc], (check) => unit === check));
			const parse = (input, accepted) => {
				return Optional.from(pattern.exec(input)).bind((array) => {
					const value$2 = Number(array[1]);
					const unitRaw = array[2];
					if (isUnit(unitRaw, accepted)) return Optional.some({
						value: value$2,
						unit: unitRaw
					});
					else return Optional.none();
				});
			};
			const rPercentageBasedSizeRegex = /(\d+(\.\d+)?)%/;
			const rPixelBasedSizeRegex = /(\d+(\.\d+)?)px|em/;
			const isCol$2 = isTag("col");
			const getPercentSize = (elm, outerGetter, innerGetter) => {
				const relativeParent = parentElement(elm).getOrThunk(() => getBody$1(owner(elm)));
				return outerGetter(elm) / innerGetter(relativeParent) * 100;
			};
			const setPixelWidth = (cell$1, amount) => {
				set$1(cell$1, "width", amount + "px");
			};
			const setPercentageWidth = (cell$1, amount) => {
				set$1(cell$1, "width", amount + "%");
			};
			const setHeight = (cell$1, amount) => {
				set$1(cell$1, "height", amount + "px");
			};
			const getHeightValue = (cell$1) => getRuntime(cell$1) + "px";
			const convert = (cell$1, number, getter, setter) => {
				const newSize = table(cell$1).map((table$1) => {
					const total$1 = getter(table$1);
					return Math.floor(number / 100 * total$1);
				}).getOr(number);
				setter(cell$1, newSize);
				return newSize;
			};
			const normalizePixelSize = (value$2, cell$1, getter, setter) => {
				const number = parseFloat(value$2);
				return endsWith(value$2, "%") && name(cell$1) !== "table" ? convert(cell$1, number, getter, setter) : number;
			};
			const getTotalHeight = (cell$1) => {
				const value$2 = getHeightValue(cell$1);
				if (!value$2) return get$8(cell$1);
				return normalizePixelSize(value$2, cell$1, get$8, setHeight);
			};
			const get$7 = (cell$1, type$1, f) => {
				return f(cell$1) / getSpan(cell$1, type$1);
			};
			const getRaw$1 = (element, prop) => {
				return getRaw$2(element, prop).orThunk(() => {
					return getOpt(element, prop).map((val) => val + "px");
				});
			};
			const getRawWidth$1 = (element) => getRaw$1(element, "width");
			const getRawHeight = (element) => getRaw$1(element, "height");
			const getPercentageWidth = (cell$1) => getPercentSize(cell$1, get$9, getInner);
			const getPixelWidth$1 = (cell$1) => isCol$2(cell$1) ? get$9(cell$1) : getRuntime$1(cell$1);
			const getHeight = (cell$1) => {
				return get$7(cell$1, "rowspan", getTotalHeight);
			};
			const getGenericWidth = (cell$1) => {
				return getRawWidth$1(cell$1).bind((w) => parse(w, [
					"fixed",
					"relative",
					"empty"
				]));
			};
			const setGenericWidth = (cell$1, amount, unit) => {
				set$1(cell$1, "width", amount + unit);
			};
			const getPixelTableWidth = (table$1) => get$9(table$1) + "px";
			const getPercentTableWidth = (table$1) => getPercentSize(table$1, get$9, getInner) + "%";
			const isPercentSizing$1 = (table$1) => getRawWidth$1(table$1).exists((size) => rPercentageBasedSizeRegex.test(size));
			const isPixelSizing$1 = (table$1) => getRawWidth$1(table$1).exists((size) => rPixelBasedSizeRegex.test(size));
			const isNoneSizing$1 = (table$1) => getRawWidth$1(table$1).isNone();
			const percentageBasedSizeRegex = constant(rPercentageBasedSizeRegex);
			const isCol$1 = isTag("col");
			const getRawW = (cell$1) => {
				return getRawWidth$1(cell$1).getOrThunk(() => getPixelWidth$1(cell$1) + "px");
			};
			const getRawH = (cell$1) => {
				return getRawHeight(cell$1).getOrThunk(() => getHeight(cell$1) + "px");
			};
			const justCols = (warehouse) => map$1(Warehouse.justColumns(warehouse), (column) => Optional.from(column.element));
			const isValidColumn = (cell$1) => {
				const browser = detect$2().browser;
				const supportsColWidths = browser.isChromium() || browser.isFirefox();
				return isCol$1(cell$1) ? supportsColWidths : true;
			};
			const getDimension = (cellOpt, index, backups, filter$3, getter, fallback$1) => cellOpt.filter(filter$3).fold(() => fallback$1(deduce(backups, index)), (cell$1) => getter(cell$1));
			const getWidthFrom = (warehouse, table$1, getWidth$1, fallback$1) => {
				const columnCells = columns(warehouse);
				const columns$1$1 = Warehouse.hasColumns(warehouse) ? justCols(warehouse) : columnCells;
				const backups = [Optional.some(width.edge(table$1))].concat(map$1(width.positions(columnCells, table$1), (pos) => pos.map((p) => p.x)));
				const colFilter = not(hasColspan);
				return map$1(columns$1$1, (cellOption, c) => {
					return getDimension(cellOption, c, backups, colFilter, (column) => {
						if (isValidColumn(column)) return getWidth$1(column);
						else return getDimension(bindFrom(columnCells[c], identity), c, backups, colFilter, (cell$1) => fallback$1(Optional.some(get$9(cell$1))), fallback$1);
					}, fallback$1);
				});
			};
			const getDeduced = (deduced) => {
				return deduced.map((d) => {
					return d + "px";
				}).getOr("");
			};
			const getRawWidths = (warehouse, table$1) => {
				return getWidthFrom(warehouse, table$1, getRawW, getDeduced);
			};
			const getPercentageWidths = (warehouse, table$1, tableSize) => {
				return getWidthFrom(warehouse, table$1, getPercentageWidth, (deduced) => {
					return deduced.fold(() => {
						return tableSize.minCellWidth();
					}, (cellWidth) => {
						return cellWidth / tableSize.pixelWidth() * 100;
					});
				});
			};
			const getPixelWidths = (warehouse, table$1, tableSize) => {
				return getWidthFrom(warehouse, table$1, getPixelWidth$1, (deduced) => {
					return deduced.getOrThunk(tableSize.minCellWidth);
				});
			};
			const getHeightFrom = (warehouse, table$1, direction, getHeight$2, fallback$1) => {
				const rows$1$1 = rows(warehouse);
				const backups = [Optional.some(direction.edge(table$1))].concat(map$1(direction.positions(rows$1$1, table$1), (pos) => pos.map((p) => p.y)));
				return map$1(rows$1$1, (cellOption, c) => {
					return getDimension(cellOption, c, backups, not(hasRowspan), getHeight$2, fallback$1);
				});
			};
			const getPixelHeights = (warehouse, table$1, direction) => {
				return getHeightFrom(warehouse, table$1, direction, getHeight, (deduced) => {
					return deduced.getOrThunk(minHeight);
				});
			};
			const getRawHeights = (warehouse, table$1, direction) => {
				return getHeightFrom(warehouse, table$1, direction, getRawH, getDeduced);
			};
			const widthLookup = (table$1, getter) => () => {
				if (inBody(table$1)) return getter(table$1);
				else return parseFloat(getRaw$2(table$1, "width").getOr("0"));
			};
			const noneSize = (table$1) => {
				const getWidth$1 = widthLookup(table$1, get$9);
				const zero$1 = constant(0);
				const getWidths = (warehouse, tableSize) => getPixelWidths(warehouse, table$1, tableSize);
				return {
					width: getWidth$1,
					pixelWidth: getWidth$1,
					getWidths,
					getCellDelta: zero$1,
					singleColumnWidth: constant([0]),
					minCellWidth: zero$1,
					setElementWidth: noop,
					adjustTableWidth: noop,
					isRelative: true,
					label: "none"
				};
			};
			const percentageSize = (table$1) => {
				const getFloatWidth = widthLookup(table$1, (elem) => parseFloat(getPercentTableWidth(elem)));
				const getWidth$1 = widthLookup(table$1, get$9);
				const getCellDelta = (delta) => delta / getWidth$1() * 100;
				const singleColumnWidth = (w, _delta) => [100 - w];
				const minCellWidth = () => minWidth() / getWidth$1() * 100;
				const adjustTableWidth = (delta) => {
					const currentWidth = getFloatWidth();
					setPercentageWidth(table$1, currentWidth + delta / 100 * currentWidth);
				};
				const getWidths = (warehouse, tableSize) => getPercentageWidths(warehouse, table$1, tableSize);
				return {
					width: getFloatWidth,
					pixelWidth: getWidth$1,
					getWidths,
					getCellDelta,
					singleColumnWidth,
					minCellWidth,
					setElementWidth: setPercentageWidth,
					adjustTableWidth,
					isRelative: true,
					label: "percent"
				};
			};
			const pixelSize = (table$1) => {
				const getWidth$1 = widthLookup(table$1, get$9);
				const getCellDelta = identity;
				const singleColumnWidth = (w, delta) => {
					return [Math.max(minWidth(), w + delta) - w];
				};
				const adjustTableWidth = (delta) => {
					setPixelWidth(table$1, getWidth$1() + delta);
				};
				const getWidths = (warehouse, tableSize) => getPixelWidths(warehouse, table$1, tableSize);
				return {
					width: getWidth$1,
					pixelWidth: getWidth$1,
					getWidths,
					getCellDelta,
					singleColumnWidth,
					minCellWidth: minWidth,
					setElementWidth: setPixelWidth,
					adjustTableWidth,
					isRelative: false,
					label: "pixel"
				};
			};
			const chooseSize = (element, width$1) => {
				if (percentageBasedSizeRegex().exec(width$1) !== null) return percentageSize(element);
				else return pixelSize(element);
			};
			const getTableSize = (table$1) => {
				return getRawWidth$1(table$1).fold(() => noneSize(table$1), (w) => chooseSize(table$1, w));
			};
			const TableSize = {
				getTableSize,
				pixelSize,
				percentageSize,
				noneSize
			};
			const statsStruct = (minRow, minCol, maxRow, maxCol, allCells, selectedCells) => ({
				minRow,
				minCol,
				maxRow,
				maxCol,
				allCells,
				selectedCells
			});
			const findSelectedStats = (house, isSelected) => {
				const totalColumns = house.grid.columns;
				let minRow = house.grid.rows;
				let minCol = totalColumns;
				let maxRow = 0;
				let maxCol = 0;
				const allCells = [];
				const selectedCells = [];
				each$1(house.access, (detail$1) => {
					allCells.push(detail$1);
					if (isSelected(detail$1)) {
						selectedCells.push(detail$1);
						const startRow = detail$1.row;
						const endRow = startRow + detail$1.rowspan - 1;
						const startCol = detail$1.column;
						const endCol = startCol + detail$1.colspan - 1;
						if (startRow < minRow) minRow = startRow;
						else if (endRow > maxRow) maxRow = endRow;
						if (startCol < minCol) minCol = startCol;
						else if (endCol > maxCol) maxCol = endCol;
					}
				});
				return statsStruct(minRow, minCol, maxRow, maxCol, allCells, selectedCells);
			};
			const makeCell = (list, seenSelected, rowIndex) => {
				const row$1 = list[rowIndex].element;
				const td = SugarElement.fromTag("td");
				append$1(td, SugarElement.fromTag("br"));
				(seenSelected ? append$1 : prepend)(row$1, td);
			};
			const fillInGaps = (list, house, stats, isSelected) => {
				const rows$2 = filter$2(list, (row$1) => row$1.section !== "colgroup");
				const totalColumns = house.grid.columns;
				const totalRows = house.grid.rows;
				for (let i = 0; i < totalRows; i++) {
					let seenSelected = false;
					for (let j = 0; j < totalColumns; j++) if (!(i < stats.minRow || i > stats.maxRow || j < stats.minCol || j > stats.maxCol)) if (Warehouse.getAt(house, i, j).filter(isSelected).isNone()) makeCell(rows$2, seenSelected, i);
					else seenSelected = true;
				}
			};
			const clean = (replica, stats, house, widthDelta) => {
				each$1(house.columns, (col$1) => {
					if (col$1.column < stats.minCol || col$1.column > stats.maxCol) remove$6(col$1.element);
				});
				each$2(filter$2(firstLayer(replica, "tr"), (row$1) => row$1.dom.childElementCount === 0), remove$6);
				if (stats.minCol === stats.maxCol || stats.minRow === stats.maxRow) each$2(firstLayer(replica, "th,td"), (cell$1) => {
					remove$7(cell$1, "rowspan");
					remove$7(cell$1, "colspan");
				});
				remove$7(replica, LOCKED_COL_ATTR);
				remove$7(replica, "data-snooker-col-series");
				TableSize.getTableSize(replica).adjustTableWidth(widthDelta);
			};
			const getTableWidthDelta = (table$1, warehouse, tableSize, stats) => {
				if (stats.minCol === 0 && warehouse.grid.columns === stats.maxCol + 1) return 0;
				const colWidths = getPixelWidths(warehouse, table$1, tableSize);
				const allColsWidth = foldl(colWidths, (acc, width$1) => acc + width$1, 0);
				const delta = foldl(colWidths.slice(stats.minCol, stats.maxCol + 1), (acc, width$1) => acc + width$1, 0) / allColsWidth * tableSize.pixelWidth() - tableSize.pixelWidth();
				return tableSize.getCellDelta(delta);
			};
			const extract$1 = (table$1, selectedSelector) => {
				const isSelected = (detail$1) => is$2(detail$1.element, selectedSelector);
				const replica = deep(table$1);
				const list = fromTable$1(replica);
				const tableSize = TableSize.getTableSize(table$1);
				const replicaHouse = Warehouse.generate(list);
				const replicaStats = findSelectedStats(replicaHouse, isSelected);
				const selector = "th:not(" + selectedSelector + "),td:not(" + selectedSelector + ")";
				each$2(filterFirstLayer(replica, "th,td", (cell$1) => is$2(cell$1, selector)), remove$6);
				fillInGaps(list, replicaHouse, replicaStats, isSelected);
				clean(replica, replicaStats, replicaHouse, getTableWidthDelta(table$1, Warehouse.fromTable(table$1), tableSize, replicaStats));
				return replica;
			};
			const nbsp = "\xA0";
			const NodeValue = (is$3, name$1) => {
				const get$10 = (element) => {
					if (!is$3(element)) throw new Error("Can only get " + name$1 + " value of a " + name$1 + " node");
					return getOption$1(element).getOr("");
				};
				const getOption$1 = (element) => is$3(element) ? Optional.from(element.dom.nodeValue) : Optional.none();
				const set$3 = (element, value$2) => {
					if (!is$3(element)) throw new Error("Can only set raw " + name$1 + " value of a " + name$1 + " node");
					element.dom.nodeValue = value$2;
				};
				return {
					get: get$10,
					getOption: getOption$1,
					set: set$3
				};
			};
			const api = NodeValue(isText, "text");
			const get$6 = (element) => api.get(element);
			const getOption = (element) => api.getOption(element);
			const set = (element, value$2) => api.set(element, value$2);
			const getEnd = (element) => name(element) === "img" ? 1 : getOption(element).fold(() => children$2(element).length, (v) => v.length);
			const isTextNodeWithCursorPosition = (el) => getOption(el).filter((text) => text.trim().length !== 0 || text.indexOf(nbsp) > -1).isSome();
			const isContentEditableFalse = (elem) => isHTMLElement(elem) && get$b(elem, "contenteditable") === "false";
			const elementsWithCursorPosition = ["img", "br"];
			const isCursorPosition = (elem) => {
				return isTextNodeWithCursorPosition(elem) || contains$2(elementsWithCursorPosition, name(elem)) || isContentEditableFalse(elem);
			};
			const first = (element) => descendant$1(element, isCursorPosition);
			const last$1 = (element) => descendantRtl(element, isCursorPosition);
			const descendantRtl = (scope, predicate) => {
				const descend = (element) => {
					const children$3 = children$2(element);
					for (let i = children$3.length - 1; i >= 0; i--) {
						const child$3 = children$3[i];
						if (predicate(child$3)) return Optional.some(child$3);
						const res = descend(child$3);
						if (res.isSome()) return res;
					}
					return Optional.none();
				};
				return descend(scope);
			};
			const transferableAttributes = { scope: ["row", "col"] };
			const createCell = (doc) => () => {
				const td = SugarElement.fromTag("td", doc.dom);
				append$1(td, SugarElement.fromTag("br", doc.dom));
				return td;
			};
			const createCol = (doc) => () => {
				return SugarElement.fromTag("col", doc.dom);
			};
			const createColgroup = (doc) => () => {
				return SugarElement.fromTag("colgroup", doc.dom);
			};
			const createRow$1 = (doc) => () => {
				return SugarElement.fromTag("tr", doc.dom);
			};
			const replace$1 = (cell$1, tag, attrs) => {
				const replica = copy$2(cell$1, tag);
				each$1(attrs, (v, k) => {
					if (v === null) remove$7(replica, k);
					else set$2(replica, k, v);
				});
				return replica;
			};
			const pasteReplace = (cell$1) => {
				return cell$1;
			};
			const cloneFormats = (oldCell, newCell, formats) => {
				return first(oldCell).map((firstText) => {
					return foldr(ancestors$3(firstText, formats.join(","), (element) => {
						return eq$1(element, oldCell);
					}), (last$3, parent$1) => {
						const clonedFormat = shallow(parent$1);
						append$1(last$3, clonedFormat);
						return clonedFormat;
					}, newCell);
				}).getOr(newCell);
			};
			const cloneAppropriateAttributes = (original, clone$3) => {
				each$1(transferableAttributes, (validAttributes, attributeName) => getOpt(original, attributeName).filter((attribute) => contains$2(validAttributes, attribute)).each((attribute) => set$2(clone$3, attributeName, attribute)));
			};
			const cellOperations = (mutate$2, doc, formatsToClone) => {
				const cloneCss = (prev, clone$3) => {
					copy$1(prev.element, clone$3);
					remove$5(clone$3, "height");
					if (prev.colspan !== 1) remove$5(clone$3, "width");
				};
				const newCell = (prev) => {
					const td = SugarElement.fromTag(name(prev.element), doc.dom);
					const formats = formatsToClone.getOr([
						"strong",
						"em",
						"b",
						"i",
						"span",
						"font",
						"h1",
						"h2",
						"h3",
						"h4",
						"h5",
						"h6",
						"p",
						"div"
					]);
					append$1(formats.length > 0 ? cloneFormats(prev.element, td, formats) : td, SugarElement.fromTag("br"));
					cloneCss(prev, td);
					cloneAppropriateAttributes(prev.element, td);
					mutate$2(prev.element, td);
					return td;
				};
				const newCol = (prev) => {
					const col$1 = SugarElement.fromTag(name(prev.element), doc.dom);
					cloneCss(prev, col$1);
					mutate$2(prev.element, col$1);
					return col$1;
				};
				return {
					col: newCol,
					colgroup: createColgroup(doc),
					row: createRow$1(doc),
					cell: newCell,
					replace: replace$1,
					colGap: createCol(doc),
					gap: createCell(doc)
				};
			};
			const paste$1 = (doc) => {
				return {
					col: createCol(doc),
					colgroup: createColgroup(doc),
					row: createRow$1(doc),
					cell: createCell(doc),
					replace: pasteReplace,
					colGap: createCol(doc),
					gap: createCell(doc)
				};
			};
			const fromHtml = (html, scope) => {
				const div = (scope || document).createElement("div");
				div.innerHTML = html;
				return children$2(SugarElement.fromDom(div));
			};
			const fromDom = (nodes) => map$1(nodes, SugarElement.fromDom);
			const option = (name$1) => (editor) => editor.options.get(name$1);
			const defaultWidth = "100%";
			const getPixelForcedWidth = (editor) => {
				var _a;
				const dom = editor.dom;
				const parentBlock = (_a = dom.getParent(editor.selection.getStart(), dom.isBlock)) !== null && _a !== void 0 ? _a : editor.getBody();
				return getInner(SugarElement.fromDom(parentBlock)) + "px";
			};
			const determineDefaultTableStyles = (editor, defaultStyles) => {
				if (isTableResponsiveForced(editor) || !shouldStyleWithCss(editor)) return defaultStyles;
				else if (isTablePixelsForced(editor)) return {
					...defaultStyles,
					width: getPixelForcedWidth(editor)
				};
				else return {
					...defaultStyles,
					width: defaultWidth
				};
			};
			const determineDefaultTableAttributes = (editor, defaultAttributes) => {
				if (isTableResponsiveForced(editor) || shouldStyleWithCss(editor)) return defaultAttributes;
				else if (isTablePixelsForced(editor)) return {
					...defaultAttributes,
					width: getPixelForcedWidth(editor)
				};
				else return {
					...defaultAttributes,
					width: defaultWidth
				};
			};
			const register = (editor) => {
				const registerOption = editor.options.register;
				registerOption("table_clone_elements", { processor: "string[]" });
				registerOption("table_use_colgroups", {
					processor: "boolean",
					default: true
				});
				registerOption("table_header_type", {
					processor: (value$2) => {
						const valid = contains$2([
							"section",
							"cells",
							"sectionCells",
							"auto"
						], value$2);
						return valid ? {
							value: value$2,
							valid
						} : {
							valid: false,
							message: "Must be one of: section, cells, sectionCells or auto."
						};
					},
					default: "section"
				});
				registerOption("table_sizing_mode", {
					processor: "string",
					default: "auto"
				});
				registerOption("table_default_attributes", {
					processor: "object",
					default: { border: "1" }
				});
				registerOption("table_default_styles", {
					processor: "object",
					default: { "border-collapse": "collapse" }
				});
				registerOption("table_column_resizing", {
					processor: (value$2) => {
						const valid = contains$2(["preservetable", "resizetable"], value$2);
						return valid ? {
							value: value$2,
							valid
						} : {
							valid: false,
							message: "Must be preservetable, or resizetable."
						};
					},
					default: "preservetable"
				});
				registerOption("table_resize_bars", {
					processor: "boolean",
					default: true
				});
				registerOption("table_style_by_css", {
					processor: "boolean",
					default: true
				});
				registerOption("table_merge_content_on_paste", {
					processor: "boolean",
					default: true
				});
			};
			const getTableCloneElements = (editor) => {
				return Optional.from(editor.options.get("table_clone_elements"));
			};
			const hasTableObjectResizing = (editor) => {
				return contains$2(editor.options.get("object_resizing").split(","), "table");
			};
			const getTableHeaderType = option("table_header_type");
			const getTableColumnResizingBehaviour = option("table_column_resizing");
			const isPreserveTableColumnResizing = (editor) => getTableColumnResizingBehaviour(editor) === "preservetable";
			const isResizeTableColumnResizing = (editor) => getTableColumnResizingBehaviour(editor) === "resizetable";
			const getTableSizingMode = option("table_sizing_mode");
			const isTablePercentagesForced = (editor) => getTableSizingMode(editor) === "relative";
			const isTablePixelsForced = (editor) => getTableSizingMode(editor) === "fixed";
			const isTableResponsiveForced = (editor) => getTableSizingMode(editor) === "responsive";
			const hasTableResizeBars = option("table_resize_bars");
			const shouldStyleWithCss = option("table_style_by_css");
			const shouldMergeContentOnPaste = option("table_merge_content_on_paste");
			const getTableDefaultAttributes = (editor) => {
				const options = editor.options;
				const defaultAttributes = options.get("table_default_attributes");
				return options.isSet("table_default_attributes") ? defaultAttributes : determineDefaultTableAttributes(editor, defaultAttributes);
			};
			const getTableDefaultStyles = (editor) => {
				const options = editor.options;
				const defaultStyles = options.get("table_default_styles");
				return options.isSet("table_default_styles") ? defaultStyles : determineDefaultTableStyles(editor, defaultStyles);
			};
			const tableUseColumnGroup = option("table_use_colgroups");
			const closest = (target) => closest$1(target, "[contenteditable]");
			const isEditable$1 = (element, assumeEditable = false) => {
				if (inBody(element)) return element.dom.isContentEditable;
				else return closest(element).fold(constant(assumeEditable), (editable) => getRaw(editable) === "true");
			};
			const getRaw = (element) => element.dom.contentEditable;
			const getBody = (editor) => SugarElement.fromDom(editor.getBody());
			const getIsRoot = (editor) => (element) => eq$1(element, getBody(editor));
			const removeDataStyle = (table$1) => {
				remove$7(table$1, "data-mce-style");
				const removeStyleAttribute = (element) => remove$7(element, "data-mce-style");
				each$2(cells$1(table$1), removeStyleAttribute);
				each$2(columns$1(table$1), removeStyleAttribute);
				each$2(rows$1(table$1), removeStyleAttribute);
			};
			const getSelectionStart = (editor) => SugarElement.fromDom(editor.selection.getStart());
			const getPixelWidth = (elm) => elm.getBoundingClientRect().width;
			const getPixelHeight = (elm) => elm.getBoundingClientRect().height;
			const getRawWidth = (editor, elm) => {
				const raw = editor.dom.getStyle(elm, "width") || editor.dom.getAttrib(elm, "width");
				return Optional.from(raw).filter(isNotEmpty);
			};
			const isPercentage$1 = (value$2) => /^(\d+(\.\d+)?)%$/.test(value$2);
			const isPixel = (value$2) => /^(\d+(\.\d+)?)px$/.test(value$2);
			const isInEditableContext$1 = (cell$1) => closest$2(cell$1, isTag("table")).exists(isEditable$1);
			const inSelection = (bounds$1, detail$1) => {
				const leftEdge = detail$1.column;
				const rightEdge = detail$1.column + detail$1.colspan - 1;
				const topEdge = detail$1.row;
				const bottomEdge = detail$1.row + detail$1.rowspan - 1;
				return leftEdge <= bounds$1.finishCol && rightEdge >= bounds$1.startCol && topEdge <= bounds$1.finishRow && bottomEdge >= bounds$1.startRow;
			};
			const isWithin = (bounds$1, detail$1) => {
				return detail$1.column >= bounds$1.startCol && detail$1.column + detail$1.colspan - 1 <= bounds$1.finishCol && detail$1.row >= bounds$1.startRow && detail$1.row + detail$1.rowspan - 1 <= bounds$1.finishRow;
			};
			const isRectangular = (warehouse, bounds$1) => {
				let isRect = true;
				const detailIsWithin = curry(isWithin, bounds$1);
				for (let i = bounds$1.startRow; i <= bounds$1.finishRow; i++) for (let j = bounds$1.startCol; j <= bounds$1.finishCol; j++) isRect = isRect && Warehouse.getAt(warehouse, i, j).exists(detailIsWithin);
				return isRect ? Optional.some(bounds$1) : Optional.none();
			};
			const getBounds = (detailA, detailB) => {
				return bounds(Math.min(detailA.row, detailB.row), Math.min(detailA.column, detailB.column), Math.max(detailA.row + detailA.rowspan - 1, detailB.row + detailB.rowspan - 1), Math.max(detailA.column + detailA.colspan - 1, detailB.column + detailB.colspan - 1));
			};
			const getAnyBox = (warehouse, startCell, finishCell) => {
				const startCoords = Warehouse.findItem(warehouse, startCell, eq$1);
				const finishCoords = Warehouse.findItem(warehouse, finishCell, eq$1);
				return startCoords.bind((sc) => {
					return finishCoords.map((fc) => {
						return getBounds(sc, fc);
					});
				});
			};
			const getBox$1 = (warehouse, startCell, finishCell) => {
				return getAnyBox(warehouse, startCell, finishCell).bind((bounds$1) => {
					return isRectangular(warehouse, bounds$1);
				});
			};
			const moveBy$1 = (warehouse, cell$1, row$1, column) => {
				return Warehouse.findItem(warehouse, cell$1, eq$1).bind((detail$1) => {
					const startRow = row$1 > 0 ? detail$1.row + detail$1.rowspan - 1 : detail$1.row;
					const startCol = column > 0 ? detail$1.column + detail$1.colspan - 1 : detail$1.column;
					return Warehouse.getAt(warehouse, startRow + row$1, startCol + column).map((d) => {
						return d.element;
					});
				});
			};
			const intercepts$1 = (warehouse, start, finish) => {
				return getAnyBox(warehouse, start, finish).map((bounds$1) => {
					return map$1(Warehouse.filterItems(warehouse, curry(inSelection, bounds$1)), (detail$1) => {
						return detail$1.element;
					});
				});
			};
			const parentCell = (warehouse, innerCell) => {
				const isContainedBy = (c1, c2) => {
					return contains$1(c2, c1);
				};
				return Warehouse.findItem(warehouse, innerCell, isContainedBy).map((detail$1) => {
					return detail$1.element;
				});
			};
			const moveBy = (cell$1, deltaRow, deltaColumn) => {
				return table(cell$1).bind((table$1) => {
					return moveBy$1(getWarehouse(table$1), cell$1, deltaRow, deltaColumn);
				});
			};
			const intercepts = (table$1, first$1, last$3) => {
				return intercepts$1(getWarehouse(table$1), first$1, last$3);
			};
			const nestedIntercepts = (table$1, first$1, firstTable, last$3, lastTable) => {
				const warehouse = getWarehouse(table$1);
				const optStartCell = eq$1(table$1, firstTable) ? Optional.some(first$1) : parentCell(warehouse, first$1);
				const optLastCell = eq$1(table$1, lastTable) ? Optional.some(last$3) : parentCell(warehouse, last$3);
				return optStartCell.bind((startCell) => optLastCell.bind((lastCell) => intercepts$1(warehouse, startCell, lastCell)));
			};
			const getBox = (table$1, first$1, last$3) => {
				return getBox$1(getWarehouse(table$1), first$1, last$3);
			};
			const getWarehouse = Warehouse.fromTable;
			var TagBoundaries = [
				"body",
				"p",
				"div",
				"article",
				"aside",
				"figcaption",
				"figure",
				"footer",
				"header",
				"nav",
				"section",
				"ol",
				"ul",
				"li",
				"table",
				"thead",
				"tbody",
				"tfoot",
				"caption",
				"tr",
				"td",
				"th",
				"h1",
				"h2",
				"h3",
				"h4",
				"h5",
				"h6",
				"blockquote",
				"pre",
				"address"
			];
			var DomUniverse = () => {
				const clone$3 = (element) => {
					return SugarElement.fromDom(element.dom.cloneNode(false));
				};
				const document$1 = (element) => documentOrOwner(element).dom;
				const isBoundary = (element) => {
					if (!isElement(element)) return false;
					if (name(element) === "body") return true;
					return contains$2(TagBoundaries, name(element));
				};
				const isEmptyTag$2 = (element) => {
					if (!isElement(element)) return false;
					return contains$2([
						"br",
						"img",
						"hr",
						"input"
					], name(element));
				};
				const isNonEditable = (element) => isElement(element) && get$b(element, "contenteditable") === "false";
				const comparePosition = (element, other) => {
					return element.dom.compareDocumentPosition(other.dom);
				};
				const copyAttributesTo = (source, destination) => {
					setAll$1(destination, clone$2(source));
				};
				const isSpecial = (element) => {
					return contains$2([
						"script",
						"noscript",
						"iframe",
						"noframes",
						"noembed",
						"title",
						"style",
						"textarea",
						"xmp"
					], name(element));
				};
				const getLanguage = (element) => isElement(element) ? getOpt(element, "lang") : Optional.none();
				return {
					up: constant({
						selector: ancestor$1,
						closest: closest$1,
						predicate: ancestor$2,
						all: parents
					}),
					down: constant({
						selector: descendants,
						predicate: descendants$1
					}),
					styles: constant({
						get: get$a,
						getRaw: getRaw$2,
						set: set$1,
						remove: remove$5
					}),
					attrs: constant({
						get: get$b,
						set: set$2,
						remove: remove$7,
						copyTo: copyAttributesTo
					}),
					insert: constant({
						before: before$3,
						after: after$5,
						afterAll: after$4,
						append: append$1,
						appendAll: append,
						prepend,
						wrap
					}),
					remove: constant({
						unwrap,
						remove: remove$6
					}),
					create: constant({
						nu: SugarElement.fromTag,
						clone: clone$3,
						text: SugarElement.fromText
					}),
					query: constant({
						comparePosition,
						prevSibling,
						nextSibling
					}),
					property: constant({
						children: children$2,
						name,
						parent,
						document: document$1,
						isText,
						isComment,
						isElement,
						isSpecial,
						getLanguage,
						getText: get$6,
						setText: set,
						isBoundary,
						isEmptyTag: isEmptyTag$2,
						isNonEditable
					}),
					eq: eq$1,
					is: is$1
				};
			};
			const all = (universe$4, look, elements, f) => {
				const head$1 = elements[0];
				return f(universe$4, look, head$1, elements.slice(1));
			};
			const oneAll = (universe$4, look, elements) => {
				return elements.length > 0 ? all(universe$4, look, elements, unsafeOne) : Optional.none();
			};
			const unsafeOne = (universe$4, look, head$1, tail) => {
				return foldr(tail, (b, a) => {
					return commonElement(universe$4, b, look(universe$4, a));
				}, look(universe$4, head$1));
			};
			const commonElement = (universe$4, start, end) => {
				return start.bind((s) => {
					return end.filter(curry(universe$4.eq, s));
				});
			};
			const eq = (universe$4, item) => {
				return curry(universe$4.eq, item);
			};
			const ancestors$2 = (universe$4, start, end, isRoot = never) => {
				const ps1 = [start].concat(universe$4.up().all(start));
				const ps2 = [end].concat(universe$4.up().all(end));
				const prune$1 = (path$1) => {
					return findIndex(path$1, isRoot).fold(() => {
						return path$1;
					}, (ind) => {
						return path$1.slice(0, ind + 1);
					});
				};
				const pruned1 = prune$1(ps1);
				const pruned2 = prune$1(ps2);
				return {
					firstpath: pruned1,
					secondpath: pruned2,
					shared: find$1(pruned1, (x) => {
						return exists(pruned2, eq(universe$4, x));
					})
				};
			};
			const sharedOne$1 = oneAll;
			const ancestors$1 = ancestors$2;
			const universe$3 = DomUniverse();
			const sharedOne = (look, elements) => {
				return sharedOne$1(universe$3, (_universe, element) => {
					return look(element);
				}, elements);
			};
			const ancestors = (start, finish, isRoot) => {
				return ancestors$1(universe$3, start, finish, isRoot);
			};
			const lookupTable = (container) => {
				return ancestor$1(container, "table");
			};
			const identify = (start, finish, isRoot) => {
				const getIsRoot$1 = (rootTable) => {
					return (element) => {
						return isRoot !== void 0 && isRoot(element) || eq$1(element, rootTable);
					};
				};
				if (eq$1(start, finish)) return Optional.some({
					boxes: Optional.some([start]),
					start,
					finish
				});
				else return lookupTable(start).bind((startTable) => {
					return lookupTable(finish).bind((finishTable) => {
						if (eq$1(startTable, finishTable)) return Optional.some({
							boxes: intercepts(startTable, start, finish),
							start,
							finish
						});
						else if (contains$1(startTable, finishTable)) {
							const ancestorCells = ancestors$3(finish, "td,th", getIsRoot$1(startTable));
							const finishCell = ancestorCells.length > 0 ? ancestorCells[ancestorCells.length - 1] : finish;
							return Optional.some({
								boxes: nestedIntercepts(startTable, start, startTable, finish, finishTable),
								start,
								finish: finishCell
							});
						} else if (contains$1(finishTable, startTable)) {
							const ancestorCells = ancestors$3(start, "td,th", getIsRoot$1(finishTable));
							const startCell = ancestorCells.length > 0 ? ancestorCells[ancestorCells.length - 1] : start;
							return Optional.some({
								boxes: nestedIntercepts(finishTable, start, startTable, finish, finishTable),
								start,
								finish: startCell
							});
						} else return ancestors(start, finish).shared.bind((lca) => {
							return closest$1(lca, "table", isRoot).bind((lcaTable) => {
								const finishAncestorCells = ancestors$3(finish, "td,th", getIsRoot$1(lcaTable));
								const finishCell = finishAncestorCells.length > 0 ? finishAncestorCells[finishAncestorCells.length - 1] : finish;
								const startAncestorCells = ancestors$3(start, "td,th", getIsRoot$1(lcaTable));
								const startCell = startAncestorCells.length > 0 ? startAncestorCells[startAncestorCells.length - 1] : start;
								return Optional.some({
									boxes: nestedIntercepts(lcaTable, start, startTable, finish, finishTable),
									start: startCell,
									finish: finishCell
								});
							});
						});
					});
				});
			};
			const retrieve$1 = (container, selector) => {
				const sels = descendants(container, selector);
				return sels.length > 0 ? Optional.some(sels) : Optional.none();
			};
			const getLast = (boxes, lastSelectedSelector) => {
				return find$1(boxes, (box) => {
					return is$2(box, lastSelectedSelector);
				});
			};
			const getEdges = (container, firstSelectedSelector, lastSelectedSelector) => {
				return descendant(container, firstSelectedSelector).bind((first$1) => {
					return descendant(container, lastSelectedSelector).bind((last$3) => {
						return sharedOne(lookupTable, [first$1, last$3]).map((table$1) => {
							return {
								first: first$1,
								last: last$3,
								table: table$1
							};
						});
					});
				});
			};
			const expandTo = (finish, firstSelectedSelector) => {
				return ancestor$1(finish, "table").bind((table$1) => {
					return descendant(table$1, firstSelectedSelector).bind((start) => {
						return identify(start, finish).bind((identified) => {
							return identified.boxes.map((boxes) => {
								return {
									boxes,
									start: identified.start,
									finish: identified.finish
								};
							});
						});
					});
				});
			};
			const shiftSelection = (boxes, deltaRow, deltaColumn, firstSelectedSelector, lastSelectedSelector) => {
				return getLast(boxes, lastSelectedSelector).bind((last$3) => {
					return moveBy(last$3, deltaRow, deltaColumn).bind((finish) => {
						return expandTo(finish, firstSelectedSelector);
					});
				});
			};
			const retrieve = (container, selector) => {
				return retrieve$1(container, selector);
			};
			const retrieveBox = (container, firstSelectedSelector, lastSelectedSelector) => {
				return getEdges(container, firstSelectedSelector, lastSelectedSelector).bind((edges) => {
					const isRoot = (ancestor$3) => {
						return eq$1(container, ancestor$3);
					};
					const sectionSelector = "thead,tfoot,tbody,table";
					const firstAncestor = ancestor$1(edges.first, sectionSelector, isRoot);
					const lastAncestor = ancestor$1(edges.last, sectionSelector, isRoot);
					return firstAncestor.bind((fA) => {
						return lastAncestor.bind((lA) => {
							return eq$1(fA, lA) ? getBox(edges.table, edges.first, edges.last) : Optional.none();
						});
					});
				});
			};
			const selection = identity;
			const unmergable = (selectedCells) => {
				const hasSpan = (elem, type$1) => getOpt(elem, type$1).exists((span) => parseInt(span, 10) > 1);
				const hasRowOrColSpan = (elem) => hasSpan(elem, "rowspan") || hasSpan(elem, "colspan");
				return selectedCells.length > 0 && forall(selectedCells, hasRowOrColSpan) ? Optional.some(selectedCells) : Optional.none();
			};
			const mergable = (table$1, selectedCells, ephemera$1) => {
				if (selectedCells.length <= 1) return Optional.none();
				else return retrieveBox(table$1, ephemera$1.firstSelectedSelector, ephemera$1.lastSelectedSelector).map((bounds$1) => ({
					bounds: bounds$1,
					cells: selectedCells
				}));
			};
			const strSelected = "data-mce-selected";
			const strSelectedSelector = "td[" + strSelected + "],th[data-mce-selected]";
			const strAttributeSelector = "[" + strSelected + "]";
			const strFirstSelected = "data-mce-first-selected";
			const strFirstSelectedSelector = "td[" + strFirstSelected + "],th[data-mce-first-selected]";
			const strLastSelected = "data-mce-last-selected";
			const strLastSelectedSelector = "td[" + strLastSelected + "],th[data-mce-last-selected]";
			const attributeSelector = strAttributeSelector;
			const ephemera = {
				selected: strSelected,
				selectedSelector: strSelectedSelector,
				firstSelected: strFirstSelected,
				firstSelectedSelector: strFirstSelectedSelector,
				lastSelected: strLastSelected,
				lastSelectedSelector: strLastSelectedSelector
			};
			const forMenu = (selectedCells, table$1, cell$1) => ({
				element: cell$1,
				mergable: mergable(table$1, selectedCells, ephemera),
				unmergable: unmergable(selectedCells),
				selection: selection(selectedCells)
			});
			const paste = (element, clipboard, generators) => ({
				element,
				clipboard,
				generators
			});
			const pasteRows = (selectedCells, _cell, clipboard, generators) => ({
				selection: selection(selectedCells),
				clipboard,
				generators
			});
			const getSelectionCellFallback = (element) => table(element).bind((table$1) => retrieve(table$1, ephemera.firstSelectedSelector)).fold(constant(element), (cells$2) => cells$2[0]);
			const getSelectionFromSelector = (selector) => (initCell, isRoot) => {
				const cellName = name(initCell);
				return closest$1(cellName === "col" || cellName === "colgroup" ? getSelectionCellFallback(initCell) : initCell, selector, isRoot);
			};
			const getSelectionCellOrCaption = getSelectionFromSelector("th,td,caption");
			const getSelectionCell = getSelectionFromSelector("th,td");
			const getCellsFromSelection = (editor) => fromDom(editor.model.table.getSelectedCells());
			const getCellsFromFakeSelection = (editor) => filter$2(getCellsFromSelection(editor), (cell$1) => is$2(cell$1, ephemera.selectedSelector));
			const extractSelected = (cells$2) => {
				return table(cells$2[0]).map((table$1) => {
					const replica = extract$1(table$1, attributeSelector);
					removeDataStyle(replica);
					return [replica];
				});
			};
			const serializeElements = (editor, elements) => map$1(elements, (elm) => editor.selection.serializer.serialize(elm.dom, {})).join("");
			const getTextContent = (elements) => map$1(elements, (element) => element.dom.innerText).join("");
			const registerEvents = (editor, actions) => {
				editor.on("BeforeGetContent", (e) => {
					const multiCellContext = (cells$2) => {
						e.preventDefault();
						extractSelected(cells$2).each((elements) => {
							e.content = e.format === "text" ? getTextContent(elements) : serializeElements(editor, elements);
						});
					};
					if (e.selection === true) {
						const cells$2 = getCellsFromFakeSelection(editor);
						if (cells$2.length >= 1) multiCellContext(cells$2);
					}
				});
				editor.on("BeforeSetContent", (e) => {
					if (e.selection === true && e.paste === true) head(getCellsFromSelection(editor)).each((cell$1) => {
						table(cell$1).each((table$1) => {
							const elements = filter$2(fromHtml(e.content), (content) => {
								return name(content) !== "meta";
							});
							const isTable$1 = isTag("table");
							if (shouldMergeContentOnPaste(editor) && elements.length === 1 && isTable$1(elements[0])) {
								e.preventDefault();
								const generators = paste$1(SugarElement.fromDom(editor.getDoc()));
								const targets = paste(cell$1, elements[0], generators);
								actions.pasteCells(table$1, targets).each(() => {
									editor.focus();
								});
							}
						});
					});
				});
			};
			const point = (element, offset) => ({
				element,
				offset
			});
			const scan$1 = (universe$4, element, direction) => {
				if (universe$4.property().isText(element) && universe$4.property().getText(element).trim().length === 0 || universe$4.property().isComment(element)) return direction(element).bind((elem) => {
					return scan$1(universe$4, elem, direction).orThunk(() => {
						return Optional.some(elem);
					});
				});
				else return Optional.none();
			};
			const toEnd = (universe$4, element) => {
				if (universe$4.property().isText(element)) return universe$4.property().getText(element).length;
				return universe$4.property().children(element).length;
			};
			const freefallRtl$2 = (universe$4, element) => {
				const candidate = scan$1(universe$4, element, universe$4.query().prevSibling).getOr(element);
				if (universe$4.property().isText(candidate)) return point(candidate, toEnd(universe$4, candidate));
				const children$3 = universe$4.property().children(candidate);
				return children$3.length > 0 ? freefallRtl$2(universe$4, children$3[children$3.length - 1]) : point(candidate, toEnd(universe$4, candidate));
			};
			const freefallRtl$1 = freefallRtl$2;
			const universe$2 = DomUniverse();
			const freefallRtl = (element) => {
				return freefallRtl$1(universe$2, element);
			};
			const halve = (main, other) => {
				if (!hasColspan(main)) getGenericWidth(main).each((w) => {
					const newWidth = w.value / 2;
					setGenericWidth(main, newWidth, w.unit);
					setGenericWidth(other, newWidth, w.unit);
				});
			};
			const zero = (array) => map$1(array, constant(0));
			const surround = (sizes, startIndex, endIndex, results, f) => f(sizes.slice(0, startIndex)).concat(results).concat(f(sizes.slice(endIndex)));
			const clampDeltaHelper = (predicate) => (sizes, index, delta, minCellSize) => {
				if (!predicate(delta)) return delta;
				else {
					const newSize = Math.max(minCellSize, sizes[index] - Math.abs(delta));
					const diff = Math.abs(newSize - sizes[index]);
					return delta >= 0 ? diff : -diff;
				}
			};
			const clampNegativeDelta = clampDeltaHelper((delta) => delta < 0);
			const clampDelta = clampDeltaHelper(always);
			const resizeTable = () => {
				const calcFixedDeltas = (sizes, index, next, delta, minCellSize) => {
					const clampedDelta = clampNegativeDelta(sizes, index, delta, minCellSize);
					return surround(sizes, index, next + 1, [clampedDelta, 0], zero);
				};
				const calcRelativeDeltas = (sizes, index, delta, minCellSize) => {
					const ratio = (100 + delta) / 100;
					const newThis = Math.max(minCellSize, (sizes[index] + delta) / ratio);
					return map$1(sizes, (size, idx) => {
						return (idx === index ? newThis : size / ratio) - size;
					});
				};
				const calcLeftEdgeDeltas = (sizes, index, next, delta, minCellSize, isRelative) => {
					if (isRelative) return calcRelativeDeltas(sizes, index, delta, minCellSize);
					else return calcFixedDeltas(sizes, index, next, delta, minCellSize);
				};
				const calcMiddleDeltas = (sizes, _prev, index, next, delta, minCellSize, isRelative) => calcLeftEdgeDeltas(sizes, index, next, delta, minCellSize, isRelative);
				const resizeTable$1 = (resizer, delta) => resizer(delta);
				const calcRightEdgeDeltas = (sizes, _prev, index, delta, minCellSize, isRelative) => {
					if (isRelative) return calcRelativeDeltas(sizes, index, delta, minCellSize);
					else {
						const clampedDelta = clampNegativeDelta(sizes, index, delta, minCellSize);
						return zero(sizes.slice(0, index)).concat([clampedDelta]);
					}
				};
				const calcRedestributedWidths = (sizes, totalWidth, pixelDelta, isRelative) => {
					if (isRelative) {
						const ratio = (totalWidth + pixelDelta) / totalWidth;
						const newSizes = map$1(sizes, (size) => size / ratio);
						return {
							delta: ratio * 100 - 100,
							newSizes
						};
					} else return {
						delta: pixelDelta,
						newSizes: sizes
					};
				};
				return {
					resizeTable: resizeTable$1,
					clampTableDelta: clampNegativeDelta,
					calcLeftEdgeDeltas,
					calcMiddleDeltas,
					calcRightEdgeDeltas,
					calcRedestributedWidths
				};
			};
			const preserveTable = () => {
				const calcLeftEdgeDeltas = (sizes, index, next, delta, minCellSize) => {
					const clampedDelta = clampDelta(sizes, delta >= 0 ? next : index, delta, minCellSize);
					return surround(sizes, index, next + 1, [clampedDelta, -clampedDelta], zero);
				};
				const calcMiddleDeltas = (sizes, _prev, index, next, delta, minCellSize) => calcLeftEdgeDeltas(sizes, index, next, delta, minCellSize);
				const resizeTable$1 = (resizer, delta, isLastColumn) => {
					if (isLastColumn) resizer(delta);
				};
				const calcRightEdgeDeltas = (sizes, _prev, _index, delta, _minCellSize, isRelative) => {
					if (isRelative) return zero(sizes);
					else return map$1(sizes, constant(delta / sizes.length));
				};
				const clampTableDelta = (sizes, index, delta, minCellSize, isLastColumn) => {
					if (isLastColumn) if (delta >= 0) return delta;
					else {
						const maxDelta = foldl(sizes, (a, b) => a + b - minCellSize, 0);
						return Math.max(-maxDelta, delta);
					}
					else return clampNegativeDelta(sizes, index, delta, minCellSize);
				};
				const calcRedestributedWidths = (sizes, _totalWidth, _pixelDelta, _isRelative) => ({
					delta: 0,
					newSizes: sizes
				});
				return {
					resizeTable: resizeTable$1,
					clampTableDelta,
					calcLeftEdgeDeltas,
					calcMiddleDeltas,
					calcRightEdgeDeltas,
					calcRedestributedWidths
				};
			};
			const getGridSize = (table$1) => {
				return Warehouse.fromTable(table$1).grid;
			};
			const isHeaderCell = isTag("th");
			const isHeaderCells = (cells$2) => forall(cells$2, (cell$1) => isHeaderCell(cell$1.element));
			const getRowHeaderType = (isHeaderRow, isHeaderCells$1) => {
				if (isHeaderRow && isHeaderCells$1) return "sectionCells";
				else if (isHeaderRow) return "section";
				else return "cells";
			};
			const getRowType = (row$1) => {
				const isHeaderRow = row$1.section === "thead";
				const isHeaderCells$1 = is(findCommonCellType(row$1.cells), "th");
				if (row$1.section === "tfoot") return { type: "footer" };
				else if (isHeaderRow || isHeaderCells$1) return {
					type: "header",
					subType: getRowHeaderType(isHeaderRow, isHeaderCells$1)
				};
				else return { type: "body" };
			};
			const findCommonCellType = (cells$2) => {
				const headerCells = filter$2(cells$2, (cell$1) => isHeaderCell(cell$1.element));
				if (headerCells.length === 0) return Optional.some("td");
				else if (headerCells.length === cells$2.length) return Optional.some("th");
				else return Optional.none();
			};
			const findCommonRowType = (rows$2) => {
				const rowTypes = map$1(rows$2, (row$1) => getRowType(row$1).type);
				const hasHeader = contains$2(rowTypes, "header");
				const hasFooter = contains$2(rowTypes, "footer");
				if (!hasHeader && !hasFooter) return Optional.some("body");
				else {
					const hasBody = contains$2(rowTypes, "body");
					if (hasHeader && !hasBody && !hasFooter) return Optional.some("header");
					else if (!hasHeader && !hasBody && hasFooter) return Optional.some("footer");
					else return Optional.none();
				}
			};
			const findTableRowHeaderType = (warehouse) => findMap(warehouse.all, (row$1) => {
				const rowType = getRowType(row$1);
				return rowType.type === "header" ? Optional.from(rowType.subType) : Optional.none();
			});
			const transformCell = (cell$1, comparator, substitution) => elementnew(substitution(cell$1.element, comparator), true, cell$1.isLocked);
			const transformRow = (row$1, section$1) => row$1.section !== section$1 ? rowcells(row$1.element, row$1.cells, section$1, row$1.isNew) : row$1;
			const section = () => ({
				transformRow,
				transformCell: (cell$1, comparator, substitution) => {
					const newCell = substitution(cell$1.element, comparator);
					return elementnew(name(newCell) !== "td" ? mutate$1(newCell, "td") : newCell, cell$1.isNew, cell$1.isLocked);
				}
			});
			const sectionCells = () => ({
				transformRow,
				transformCell
			});
			const cells = () => ({
				transformRow: (row$1, section$1) => {
					return transformRow(row$1, section$1 === "thead" ? "tbody" : section$1);
				},
				transformCell
			});
			const fallback = () => ({
				transformRow: identity,
				transformCell
			});
			const getTableSectionType = (table$1, fallback$1) => {
				switch (findTableRowHeaderType(Warehouse.fromTable(table$1)).getOr(fallback$1)) {
					case "section": return section();
					case "sectionCells": return sectionCells();
					case "cells": return cells();
				}
			};
			const TableSection = {
				getTableSectionType,
				section,
				sectionCells,
				cells,
				fallback
			};
			const setIfNot = (element, property, value$2, ignore) => {
				if (value$2 === ignore) remove$7(element, property);
				else set$2(element, property, value$2);
			};
			const insert$1 = (table$1, selector, element) => {
				last$2(children(table$1, selector)).fold(() => prepend(table$1, element), (child$3) => after$5(child$3, element));
			};
			const generateSection = (table$1, sectionName) => {
				const section$1 = child(table$1, sectionName).getOrThunk(() => {
					const newSection = SugarElement.fromTag(sectionName, owner(table$1).dom);
					if (sectionName === "thead") insert$1(table$1, "caption,colgroup", newSection);
					else if (sectionName === "colgroup") insert$1(table$1, "caption", newSection);
					else append$1(table$1, newSection);
					return newSection;
				});
				empty(section$1);
				return section$1;
			};
			const render$1 = (table$1, grid$1) => {
				const newRows = [];
				const newCells = [];
				const syncRows = (gridSection) => map$1(gridSection, (row$1) => {
					if (row$1.isNew) newRows.push(row$1.element);
					const tr = row$1.element;
					empty(tr);
					each$2(row$1.cells, (cell$1) => {
						if (cell$1.isNew) newCells.push(cell$1.element);
						setIfNot(cell$1.element, "colspan", cell$1.colspan, 1);
						setIfNot(cell$1.element, "rowspan", cell$1.rowspan, 1);
						append$1(tr, cell$1.element);
					});
					return tr;
				});
				const syncColGroup = (gridSection) => bind$2(gridSection, (colGroup) => map$1(colGroup.cells, (col$1) => {
					setIfNot(col$1.element, "span", col$1.colspan, 1);
					return col$1.element;
				}));
				const renderSection = (gridSection, sectionName) => {
					append(generateSection(table$1, sectionName), (sectionName === "colgroup" ? syncColGroup : syncRows)(gridSection));
				};
				const removeSection = (sectionName) => {
					child(table$1, sectionName).each(remove$6);
				};
				const renderOrRemoveSection = (gridSection, sectionName) => {
					if (gridSection.length > 0) renderSection(gridSection, sectionName);
					else removeSection(sectionName);
				};
				const headSection = [];
				const bodySection = [];
				const footSection = [];
				const columnGroupsSection = [];
				each$2(grid$1, (row$1) => {
					switch (row$1.section) {
						case "thead":
							headSection.push(row$1);
							break;
						case "tbody":
							bodySection.push(row$1);
							break;
						case "tfoot":
							footSection.push(row$1);
							break;
						case "colgroup":
							columnGroupsSection.push(row$1);
							break;
					}
				});
				renderOrRemoveSection(columnGroupsSection, "colgroup");
				renderOrRemoveSection(headSection, "thead");
				renderOrRemoveSection(bodySection, "tbody");
				renderOrRemoveSection(footSection, "tfoot");
				return {
					newRows,
					newCells
				};
			};
			const copy = (grid$1) => map$1(grid$1, (row$1) => {
				const tr = shallow(row$1.element);
				each$2(row$1.cells, (cell$1) => {
					const clonedCell = deep(cell$1.element);
					setIfNot(clonedCell, "colspan", cell$1.colspan, 1);
					setIfNot(clonedCell, "rowspan", cell$1.rowspan, 1);
					append$1(tr, clonedCell);
				});
				return tr;
			});
			const getColumn = (grid$1, index) => {
				return map$1(grid$1, (row$1) => {
					return getCell(row$1, index);
				});
			};
			const getRow = (grid$1, index) => {
				return grid$1[index];
			};
			const findDiff = (xs, comp) => {
				if (xs.length === 0) return 0;
				const first$1 = xs[0];
				return findIndex(xs, (x) => {
					return !comp(first$1.element, x.element);
				}).getOr(xs.length);
			};
			const subgrid = (grid$1, row$1, column, comparator) => {
				const gridRow = getRow(grid$1, row$1);
				const isColRow = gridRow.section === "colgroup";
				return {
					colspan: findDiff(gridRow.cells.slice(column), comparator),
					rowspan: isColRow ? 1 : findDiff(getColumn(grid$1.slice(row$1), column), comparator)
				};
			};
			const toDetails = (grid$1, comparator) => {
				const seen = map$1(grid$1, (row$1) => map$1(row$1.cells, never));
				const updateSeen = (rowIndex, columnIndex, rowspan, colspan) => {
					for (let row$1 = rowIndex; row$1 < rowIndex + rowspan; row$1++) for (let column = columnIndex; column < columnIndex + colspan; column++) seen[row$1][column] = true;
				};
				return map$1(grid$1, (row$1, rowIndex) => {
					const details = bind$2(row$1.cells, (cell$1, columnIndex) => {
						if (seen[rowIndex][columnIndex] === false) {
							const result = subgrid(grid$1, rowIndex, columnIndex, comparator);
							updateSeen(rowIndex, columnIndex, result.rowspan, result.colspan);
							return [detailnew(cell$1.element, result.rowspan, result.colspan, cell$1.isNew)];
						} else return [];
					});
					return rowdetailnew(row$1.element, details, row$1.section, row$1.isNew);
				});
			};
			const toGrid = (warehouse, generators, isNew) => {
				const grid$1 = [];
				each$2(warehouse.colgroups, (colgroup$1) => {
					const colgroupCols = [];
					for (let columnIndex = 0; columnIndex < warehouse.grid.columns; columnIndex++) {
						const element = Warehouse.getColumnAt(warehouse, columnIndex).map((column) => elementnew(column.element, isNew, false)).getOrThunk(() => elementnew(generators.colGap(), true, false));
						colgroupCols.push(element);
					}
					grid$1.push(rowcells(colgroup$1.element, colgroupCols, "colgroup", isNew));
				});
				for (let rowIndex = 0; rowIndex < warehouse.grid.rows; rowIndex++) {
					const rowCells = [];
					for (let columnIndex = 0; columnIndex < warehouse.grid.columns; columnIndex++) {
						const element = Warehouse.getAt(warehouse, rowIndex, columnIndex).map((item) => elementnew(item.element, isNew, item.isLocked)).getOrThunk(() => elementnew(generators.gap(), true, false));
						rowCells.push(element);
					}
					const rowDetail = warehouse.all[rowIndex];
					const row$1 = rowcells(rowDetail.element, rowCells, rowDetail.section, isNew);
					grid$1.push(row$1);
				}
				return grid$1;
			};
			const fromWarehouse = (warehouse, generators) => toGrid(warehouse, generators, false);
			const toDetailList = (grid$1) => toDetails(grid$1, eq$1);
			const findInWarehouse = (warehouse, element) => findMap(warehouse.all, (r$1) => find$1(r$1.cells, (e) => eq$1(element, e.element)));
			const extractCells = (warehouse, target, predicate) => {
				const cells$2 = cat(map$1(target.selection, (cell$1) => {
					return cell(cell$1).bind((lc) => findInWarehouse(warehouse, lc)).filter(predicate);
				}));
				return someIf(cells$2.length > 0, cells$2);
			};
			const run = (operation, extract$2, adjustment, postAction, genWrappers) => (table$1, target, generators, behaviours) => {
				const warehouse = Warehouse.fromTable(table$1);
				const tableSection = Optional.from(behaviours === null || behaviours === void 0 ? void 0 : behaviours.section).getOrThunk(TableSection.fallback);
				return extract$2(warehouse, target).map((info) => {
					const result = operation(fromWarehouse(warehouse, generators), info, eq$1, genWrappers(generators), tableSection);
					const lockedColumns = getLockedColumnsFromGrid(result.grid);
					return {
						info,
						grid: toDetailList(result.grid),
						cursor: result.cursor,
						lockedColumns
					};
				}).bind((out) => {
					const newElements = render$1(table$1, out.grid);
					const tableSizing = Optional.from(behaviours === null || behaviours === void 0 ? void 0 : behaviours.sizing).getOrThunk(() => TableSize.getTableSize(table$1));
					const resizing = Optional.from(behaviours === null || behaviours === void 0 ? void 0 : behaviours.resize).getOrThunk(preserveTable);
					adjustment(table$1, out.grid, out.info, {
						sizing: tableSizing,
						resize: resizing,
						section: tableSection
					});
					postAction(table$1);
					remove$7(table$1, LOCKED_COL_ATTR);
					if (out.lockedColumns.length > 0) set$2(table$1, LOCKED_COL_ATTR, out.lockedColumns.join(","));
					return Optional.some({
						cursor: out.cursor,
						newRows: newElements.newRows,
						newCells: newElements.newCells
					});
				});
			};
			const onPaste = (warehouse, target) => cell(target.element).bind((cell$1) => findInWarehouse(warehouse, cell$1).map((details) => {
				return {
					...details,
					generators: target.generators,
					clipboard: target.clipboard
				};
			}));
			const onPasteByEditor = (warehouse, target) => extractCells(warehouse, target, always).map((cells$2) => ({
				cells: cells$2,
				generators: target.generators,
				clipboard: target.clipboard
			}));
			const onMergable = (_warehouse, target) => target.mergable;
			const onUnmergable = (_warehouse, target) => target.unmergable;
			const onCells = (warehouse, target) => extractCells(warehouse, target, always);
			const onUnlockedCells = (warehouse, target) => extractCells(warehouse, target, (detail$1) => !detail$1.isLocked);
			const isUnlockedTableCell = (warehouse, cell$1) => findInWarehouse(warehouse, cell$1).exists((detail$1) => !detail$1.isLocked);
			const allUnlocked = (warehouse, cells$2) => forall(cells$2, (cell$1) => isUnlockedTableCell(warehouse, cell$1));
			const onUnlockedMergable = (warehouse, target) => onMergable(warehouse, target).filter((mergeable) => allUnlocked(warehouse, mergeable.cells));
			const onUnlockedUnmergable = (warehouse, target) => onUnmergable(warehouse, target).filter((cells$2) => allUnlocked(warehouse, cells$2));
			const merge$2 = (grid$1, bounds$1, comparator, substitution) => {
				const rows$2 = extractGridDetails(grid$1).rows;
				if (rows$2.length === 0) return grid$1;
				for (let i = bounds$1.startRow; i <= bounds$1.finishRow; i++) for (let j = bounds$1.startCol; j <= bounds$1.finishCol; j++) {
					const row$1 = rows$2[i];
					const isLocked = getCell(row$1, j).isLocked;
					mutateCell(row$1, j, elementnew(substitution(), false, isLocked));
				}
				return grid$1;
			};
			const unmerge = (grid$1, target, comparator, substitution) => {
				const rows$2 = extractGridDetails(grid$1).rows;
				let first$1 = true;
				for (let i = 0; i < rows$2.length; i++) for (let j = 0; j < cellLength(rows$2[0]); j++) {
					const row$1 = rows$2[i];
					const currentCell = getCell(row$1, j);
					const currentCellElm = currentCell.element;
					const isToReplace = comparator(currentCellElm, target);
					if (isToReplace && !first$1) mutateCell(row$1, j, elementnew(substitution(), true, currentCell.isLocked));
					else if (isToReplace) first$1 = false;
				}
				return grid$1;
			};
			const uniqueCells = (row$1, comparator) => {
				return foldl(row$1, (rest, cell$1) => {
					return exists(rest, (currentCell) => {
						return comparator(currentCell.element, cell$1.element);
					}) ? rest : rest.concat([cell$1]);
				}, []);
			};
			const splitCols = (grid$1, index, comparator, substitution) => {
				if (index > 0 && index < grid$1[0].cells.length) each$2(grid$1, (row$1) => {
					const prevCell = row$1.cells[index - 1];
					let offset = 0;
					const substitute = substitution();
					while (row$1.cells.length > index + offset && comparator(prevCell.element, row$1.cells[index + offset].element)) {
						mutateCell(row$1, index + offset, elementnew(substitute, true, row$1.cells[index + offset].isLocked));
						offset++;
					}
				});
				return grid$1;
			};
			const splitRows = (grid$1, index, comparator, substitution) => {
				const rows$2 = extractGridDetails(grid$1).rows;
				if (index > 0 && index < rows$2.length) {
					const rowPrevCells = rows$2[index - 1].cells;
					each$2(uniqueCells(rowPrevCells, comparator), (cell$1) => {
						let replacement = Optional.none();
						for (let i = index; i < rows$2.length; i++) for (let j = 0; j < cellLength(rows$2[0]); j++) {
							const row$1 = rows$2[i];
							const current = getCell(row$1, j);
							if (comparator(current.element, cell$1.element)) {
								if (replacement.isNone()) replacement = Optional.some(substitution());
								replacement.each((sub) => {
									mutateCell(row$1, j, elementnew(sub, true, current.isLocked));
								});
							}
						}
					});
				}
				return grid$1;
			};
			const value$1 = (value$2) => {
				const applyHelper = (fn) => fn(value$2);
				const constHelper = constant(value$2);
				const outputHelper = () => output;
				const output = {
					tag: true,
					inner: value$2,
					fold: (_onError, onValue) => onValue(value$2),
					isValue: always,
					isError: never,
					map: (mapper) => Result.value(mapper(value$2)),
					mapError: outputHelper,
					bind: applyHelper,
					exists: applyHelper,
					forall: applyHelper,
					getOr: constHelper,
					or: outputHelper,
					getOrThunk: constHelper,
					orThunk: outputHelper,
					getOrDie: constHelper,
					each: (fn) => {
						fn(value$2);
					},
					toOptional: () => Optional.some(value$2)
				};
				return output;
			};
			const error = (error$1) => {
				const outputHelper = () => output;
				const output = {
					tag: false,
					inner: error$1,
					fold: (onError, _onValue) => onError(error$1),
					isValue: never,
					isError: always,
					map: outputHelper,
					mapError: (mapper) => Result.error(mapper(error$1)),
					bind: outputHelper,
					exists: never,
					forall: always,
					getOr: identity,
					or: identity,
					getOrThunk: apply,
					orThunk: apply,
					getOrDie: die(String(error$1)),
					each: noop,
					toOptional: Optional.none
				};
				return output;
			};
			const fromOption = (optional, err) => optional.fold(() => error(err), value$1);
			const Result = {
				value: value$1,
				error,
				fromOption
			};
			const measure = (startAddress, gridA, gridB) => {
				if (startAddress.row >= gridA.length || startAddress.column > cellLength(gridA[0])) return Result.error("invalid start address out of table bounds, row: " + startAddress.row + ", column: " + startAddress.column);
				const rowRemainder = gridA.slice(startAddress.row);
				const colRemainder = rowRemainder[0].cells.slice(startAddress.column);
				const colRequired = cellLength(gridB[0]);
				const rowRequired = gridB.length;
				return Result.value({
					rowDelta: rowRemainder.length - rowRequired,
					colDelta: colRemainder.length - colRequired
				});
			};
			const measureWidth = (gridA, gridB) => {
				return {
					rowDelta: 0,
					colDelta: cellLength(gridA[0]) - cellLength(gridB[0])
				};
			};
			const measureHeight = (gridA, gridB) => {
				return {
					rowDelta: gridA.length - gridB.length,
					colDelta: 0
				};
			};
			const generateElements = (amount, row$1, generators, isLocked) => {
				const generator = row$1.section === "colgroup" ? generators.col : generators.cell;
				return range$1(amount, (idx) => elementnew(generator(), true, isLocked(idx)));
			};
			const rowFill = (grid$1, amount, generators, lockedColumns) => {
				const exampleRow = grid$1[grid$1.length - 1];
				return grid$1.concat(range$1(amount, () => {
					const row$1 = clone(exampleRow, exampleRow.section === "colgroup" ? generators.colgroup : generators.row, identity);
					return setCells(row$1, generateElements(row$1.cells.length, row$1, generators, (idx) => has$1(lockedColumns, idx.toString())));
				}));
			};
			const colFill = (grid$1, amount, generators, startIndex) => map$1(grid$1, (row$1) => {
				return addCells(row$1, startIndex, generateElements(amount, row$1, generators, never));
			});
			const lockedColFill = (grid$1, generators, lockedColumns) => map$1(grid$1, (row$1) => {
				return foldl(lockedColumns, (acc, colNum) => {
					const newChild = generateElements(1, row$1, generators, always)[0];
					return addCell(acc, colNum, newChild);
				}, row$1);
			});
			const tailor = (gridA, delta, generators) => {
				const fillCols = delta.colDelta < 0 ? colFill : identity;
				const fillRows = delta.rowDelta < 0 ? rowFill : identity;
				const lockedColumns = getLockedColumnsFromGrid(gridA);
				const gridWidth = cellLength(gridA[0]);
				const isLastColLocked = exists(lockedColumns, (locked) => locked === gridWidth - 1);
				const modifiedCols = fillCols(gridA, Math.abs(delta.colDelta), generators, isLastColLocked ? gridWidth - 1 : gridWidth);
				const newLockedColumns = getLockedColumnsFromGrid(modifiedCols);
				return fillRows(modifiedCols, Math.abs(delta.rowDelta), generators, mapToObject(newLockedColumns, always));
			};
			const isSpanning = (grid$1, row$1, col$1, comparator) => {
				const matching = curry(comparator, getCell(grid$1[row$1], col$1).element);
				const currentRow = grid$1[row$1];
				return grid$1.length > 1 && cellLength(currentRow) > 1 && (col$1 > 0 && matching(getCellElement(currentRow, col$1 - 1)) || col$1 < currentRow.cells.length - 1 && matching(getCellElement(currentRow, col$1 + 1)) || row$1 > 0 && matching(getCellElement(grid$1[row$1 - 1], col$1)) || row$1 < grid$1.length - 1 && matching(getCellElement(grid$1[row$1 + 1], col$1)));
			};
			const mergeTables = (startAddress, gridA, gridBRows, generator, comparator, lockedColumns) => {
				const startRow = startAddress.row;
				const startCol = startAddress.column;
				const mergeHeight = gridBRows.length;
				const mergeWidth = cellLength(gridBRows[0]);
				const endRow = startRow + mergeHeight;
				const endCol = startCol + mergeWidth + lockedColumns.length;
				const lockedColumnObj = mapToObject(lockedColumns, always);
				for (let r$1 = startRow; r$1 < endRow; r$1++) {
					let skippedCol = 0;
					for (let c = startCol; c < endCol; c++) {
						if (lockedColumnObj[c]) {
							skippedCol++;
							continue;
						}
						if (isSpanning(gridA, r$1, c, comparator)) unmerge(gridA, getCellElement(gridA[r$1], c), comparator, generator.cell);
						const gridBColIndex = c - startCol - skippedCol;
						const newCell = getCell(gridBRows[r$1 - startRow], gridBColIndex);
						const newCellElm = newCell.element;
						const replacement = generator.replace(newCellElm);
						mutateCell(gridA[r$1], c, elementnew(replacement, true, newCell.isLocked));
					}
				}
				return gridA;
			};
			const getValidStartAddress = (currentStartAddress, grid$1, lockedColumns) => {
				const gridColLength = cellLength(grid$1[0]);
				return {
					row: extractGridDetails(grid$1).cols.length + currentStartAddress.row,
					column: find$1(range$1(gridColLength - currentStartAddress.column, (num) => num + currentStartAddress.column), (num) => forall(lockedColumns, (col$1) => col$1 !== num)).getOr(gridColLength - 1)
				};
			};
			const getLockedColumnsWithinBounds = (startAddress, rows$2, lockedColumns) => filter$2(lockedColumns, (colNum) => colNum >= startAddress.column && colNum <= cellLength(rows$2[0]) + startAddress.column);
			const merge$1 = (startAddress, gridA, gridB, generator, comparator) => {
				const lockedColumns = getLockedColumnsFromGrid(gridA);
				const validStartAddress = getValidStartAddress(startAddress, gridA, lockedColumns);
				const gridBRows = extractGridDetails(gridB).rows;
				const lockedColumnsWithinBounds = getLockedColumnsWithinBounds(validStartAddress, gridBRows, lockedColumns);
				return measure(validStartAddress, gridA, gridBRows).map((diff) => {
					const fittedGrid = tailor(gridA, {
						...diff,
						colDelta: diff.colDelta - lockedColumnsWithinBounds.length
					}, generator);
					return mergeTables(validStartAddress, fittedGrid, gridBRows, generator, comparator, getLockedColumnsWithinBounds(validStartAddress, gridBRows, getLockedColumnsFromGrid(fittedGrid)));
				});
			};
			const insertCols = (index, gridA, gridB, generator, comparator) => {
				splitCols(gridA, index, comparator, generator.cell);
				const fittedNewGrid = tailor(gridB, measureHeight(gridB, gridA), generator);
				return map$1(tailor(gridA, measureHeight(gridA, fittedNewGrid), generator), (gridRow, i) => {
					return addCells(gridRow, index, fittedNewGrid[i].cells);
				});
			};
			const insertRows = (index, gridA, gridB, generator, comparator) => {
				splitRows(gridA, index, comparator, generator.cell);
				const locked = getLockedColumnsFromGrid(gridA);
				const diff = measureWidth(gridA, gridB);
				const fittedOldGrid = tailor(gridA, {
					...diff,
					colDelta: diff.colDelta - locked.length
				}, generator);
				const { cols: oldCols, rows: oldRows } = extractGridDetails(fittedOldGrid);
				const newLocked = getLockedColumnsFromGrid(fittedOldGrid);
				const secondDiff = measureWidth(gridB, gridA);
				const secondDelta = {
					...secondDiff,
					colDelta: secondDiff.colDelta + newLocked.length
				};
				const fittedNewGrid = tailor(lockedColFill(gridB, generator, newLocked), secondDelta, generator);
				return [
					...oldCols,
					...oldRows.slice(0, index),
					...fittedNewGrid,
					...oldRows.slice(index, oldRows.length)
				];
			};
			const cloneRow = (row$1, cloneCell, comparator, substitution) => clone(row$1, (elem) => substitution(elem, comparator), cloneCell);
			const insertRowAt = (grid$1, index, example, comparator, substitution) => {
				const { rows: rows$2, cols } = extractGridDetails(grid$1);
				const before$2 = rows$2.slice(0, index);
				const after$3 = rows$2.slice(index);
				const newRow = cloneRow(rows$2[example], (ex, c) => {
					return index > 0 && index < rows$2.length && comparator(getCellElement(rows$2[index - 1], c), getCellElement(rows$2[index], c)) ? getCell(rows$2[index], c) : elementnew(substitution(ex.element, comparator), true, ex.isLocked);
				}, comparator, substitution);
				return [
					...cols,
					...before$2,
					newRow,
					...after$3
				];
			};
			const getElementFor = (row$1, column, section$1, withinSpan, example, comparator, substitution) => {
				if (section$1 === "colgroup" || !withinSpan) return elementnew(substitution(getCell(row$1, example).element, comparator), true, false);
				else return getCell(row$1, column);
			};
			const insertColumnAt = (grid$1, index, example, comparator, substitution) => map$1(grid$1, (row$1) => {
				const withinSpan = index > 0 && index < cellLength(row$1) && comparator(getCellElement(row$1, index - 1), getCellElement(row$1, index));
				return addCell(row$1, index, getElementFor(row$1, index, row$1.section, withinSpan, example, comparator, substitution));
			});
			const deleteColumnsAt = (grid$1, columns$2) => bind$2(grid$1, (row$1) => {
				const existingCells = row$1.cells;
				const cells$2 = foldr(columns$2, (acc, column) => column >= 0 && column < acc.length ? acc.slice(0, column).concat(acc.slice(column + 1)) : acc, existingCells);
				return cells$2.length > 0 ? [rowcells(row$1.element, cells$2, row$1.section, row$1.isNew)] : [];
			});
			const deleteRowsAt = (grid$1, start, finish) => {
				const { rows: rows$2, cols } = extractGridDetails(grid$1);
				return [
					...cols,
					...rows$2.slice(0, start),
					...rows$2.slice(finish + 1)
				];
			};
			const notInStartRow = (grid$1, rowIndex, colIndex, comparator) => getCellElement(grid$1[rowIndex], colIndex) !== void 0 && rowIndex > 0 && comparator(getCellElement(grid$1[rowIndex - 1], colIndex), getCellElement(grid$1[rowIndex], colIndex));
			const notInStartColumn = (row$1, index, comparator) => index > 0 && comparator(getCellElement(row$1, index - 1), getCellElement(row$1, index));
			const isDuplicatedCell = (grid$1, rowIndex, colIndex, comparator) => notInStartRow(grid$1, rowIndex, colIndex, comparator) || notInStartColumn(grid$1[rowIndex], colIndex, comparator);
			const rowReplacerPredicate = (targetRow, columnHeaders) => {
				return forall(columnHeaders, identity) && isHeaderCells(targetRow.cells) ? always : (cell$1, _rowIndex, colIndex) => {
					return !(name(cell$1.element) === "th" && columnHeaders[colIndex]);
				};
			};
			const columnReplacePredicate = (targetColumn, rowHeaders) => {
				return forall(rowHeaders, identity) && isHeaderCells(targetColumn) ? always : (cell$1, rowIndex, _colIndex) => {
					return !(name(cell$1.element) === "th" && rowHeaders[rowIndex]);
				};
			};
			const determineScope = (applyScope, cell$1, newScope, isInHeader) => {
				const hasSpan = (scope) => scope === "row" ? hasRowspan(cell$1) : hasColspan(cell$1);
				const getScope = (scope) => hasSpan(scope) ? `${scope}group` : scope;
				if (applyScope) return isHeaderCell(cell$1) ? getScope(newScope) : null;
				else if (isInHeader && isHeaderCell(cell$1)) return getScope(newScope === "row" ? "col" : "row");
				else return null;
			};
			const rowScopeGenerator = (applyScope, columnHeaders) => (cell$1, rowIndex, columnIndex) => Optional.some(determineScope(applyScope, cell$1.element, "col", columnHeaders[columnIndex]));
			const columnScopeGenerator = (applyScope, rowHeaders) => (cell$1, rowIndex) => Optional.some(determineScope(applyScope, cell$1.element, "row", rowHeaders[rowIndex]));
			const replace = (cell$1, comparator, substitute) => elementnew(substitute(cell$1.element, comparator), true, cell$1.isLocked);
			const replaceIn = (grid$1, targets, comparator, substitute, replacer, genScope, shouldReplace) => {
				const isTarget = (cell$1) => {
					return exists(targets, (target) => {
						return comparator(cell$1.element, target.element);
					});
				};
				return map$1(grid$1, (row$1, rowIndex) => {
					return mapCells(row$1, (cell$1, colIndex) => {
						if (isTarget(cell$1)) {
							const newCell = shouldReplace(cell$1, rowIndex, colIndex) ? replacer(cell$1, comparator, substitute) : cell$1;
							genScope(newCell, rowIndex, colIndex).each((scope) => {
								setOptions(newCell.element, { scope: Optional.from(scope) });
							});
							return newCell;
						} else return cell$1;
					});
				});
			};
			const getColumnCells = (rows$2, columnIndex, comparator) => bind$2(rows$2, (row$1, i) => {
				return isDuplicatedCell(rows$2, i, columnIndex, comparator) ? [] : [getCell(row$1, columnIndex)];
			});
			const getRowCells = (rows$2, rowIndex, comparator) => {
				const targetRow = rows$2[rowIndex];
				return bind$2(targetRow.cells, (item, i) => {
					return isDuplicatedCell(rows$2, rowIndex, i, comparator) ? [] : [item];
				});
			};
			const replaceColumns = (grid$1, indexes, applyScope, comparator, substitution) => {
				const rows$2 = extractGridDetails(grid$1).rows;
				const targets = bind$2(indexes, (index) => getColumnCells(rows$2, index, comparator));
				const rowHeaders = map$1(rows$2, (row$1) => isHeaderCells(row$1.cells));
				const shouldReplaceCell = columnReplacePredicate(targets, rowHeaders);
				return replaceIn(grid$1, targets, comparator, substitution, replace, columnScopeGenerator(applyScope, rowHeaders), shouldReplaceCell);
			};
			const replaceRows = (grid$1, indexes, section$1, applyScope, comparator, substitution, tableSection) => {
				const { cols, rows: rows$2 } = extractGridDetails(grid$1);
				const targetRow = rows$2[indexes[0]];
				const targets = bind$2(indexes, (index) => getRowCells(rows$2, index, comparator));
				const columnHeaders = map$1(targetRow.cells, (_cell, index) => isHeaderCells(getColumnCells(rows$2, index, comparator)));
				const newRows = [...rows$2];
				each$2(indexes, (index) => {
					newRows[index] = tableSection.transformRow(rows$2[index], section$1);
				});
				const newGrid = [...cols, ...newRows];
				const shouldReplaceCell = rowReplacerPredicate(targetRow, columnHeaders);
				const scopeGenerator = rowScopeGenerator(applyScope, columnHeaders);
				return replaceIn(newGrid, targets, comparator, substitution, tableSection.transformCell, scopeGenerator, shouldReplaceCell);
			};
			const replaceCells = (grid$1, details, comparator, substitution) => {
				const rows$2 = extractGridDetails(grid$1).rows;
				return replaceIn(grid$1, map$1(details, (detail$1) => getCell(rows$2[detail$1.row], detail$1.column)), comparator, substitution, replace, Optional.none, always);
			};
			const generate = (cases) => {
				if (!isArray(cases)) throw new Error("cases must be an array");
				if (cases.length === 0) throw new Error("there must be at least one case");
				const constructors = [];
				const adt$6 = {};
				each$2(cases, (acase, count) => {
					const keys$1 = keys(acase);
					if (keys$1.length !== 1) throw new Error("one and only one name per case");
					const key$1 = keys$1[0];
					const value$2 = acase[key$1];
					if (adt$6[key$1] !== void 0) throw new Error("duplicate key detected:" + key$1);
					else if (key$1 === "cata") throw new Error("cannot have a case named cata (sorry)");
					else if (!isArray(value$2)) throw new Error("case arguments must be an array");
					constructors.push(key$1);
					adt$6[key$1] = (...args) => {
						const argLength = args.length;
						if (argLength !== value$2.length) throw new Error("Wrong number of arguments to case " + key$1 + ". Expected " + value$2.length + " (" + value$2 + "), got " + argLength);
						const match = (branches) => {
							const branchKeys = keys(branches);
							if (constructors.length !== branchKeys.length) throw new Error("Wrong number of arguments to match. Expected: " + constructors.join(",") + "\nActual: " + branchKeys.join(","));
							if (!forall(constructors, (reqKey) => {
								return contains$2(branchKeys, reqKey);
							})) throw new Error("Not all branches were specified when using match. Specified: " + branchKeys.join(", ") + "\nRequired: " + constructors.join(", "));
							return branches[key$1].apply(null, args);
						};
						return {
							fold: (...foldArgs) => {
								if (foldArgs.length !== cases.length) throw new Error("Wrong number of arguments to fold. Expected " + cases.length + ", got " + foldArgs.length);
								return foldArgs[count].apply(null, args);
							},
							match,
							log: (label) => {
								console.log(label, {
									constructors,
									constructor: key$1,
									params: args
								});
							}
						};
					};
				});
				return adt$6;
			};
			const Adt = { generate };
			const ColumnContext = { ...Adt.generate([
				{ none: [] },
				{ only: ["index"] },
				{ left: ["index", "next"] },
				{ middle: [
					"prev",
					"index",
					"next"
				] },
				{ right: ["prev", "index"] }
			]) };
			const neighbours = (input, index) => {
				if (input.length === 0) return ColumnContext.none();
				if (input.length === 1) return ColumnContext.only(0);
				if (index === 0) return ColumnContext.left(0, 1);
				if (index === input.length - 1) return ColumnContext.right(index - 1, index);
				if (index > 0 && index < input.length - 1) return ColumnContext.middle(index - 1, index, index + 1);
				return ColumnContext.none();
			};
			const determine = (input, column, step, tableSize, resize$1) => {
				const result = input.slice(0);
				const context = neighbours(input, column);
				const onNone = constant(map$1(result, constant(0)));
				const onOnly = (index) => tableSize.singleColumnWidth(result[index], step);
				const onLeft = (index, next) => resize$1.calcLeftEdgeDeltas(result, index, next, step, tableSize.minCellWidth(), tableSize.isRelative);
				const onMiddle = (prev, index, next) => resize$1.calcMiddleDeltas(result, prev, index, next, step, tableSize.minCellWidth(), tableSize.isRelative);
				const onRight = (prev, index) => resize$1.calcRightEdgeDeltas(result, prev, index, step, tableSize.minCellWidth(), tableSize.isRelative);
				return context.fold(onNone, onOnly, onLeft, onMiddle, onRight);
			};
			const total = (start, end, measures) => {
				let r$1 = 0;
				for (let i = start; i < end; i++) r$1 += measures[i] !== void 0 ? measures[i] : 0;
				return r$1;
			};
			const recalculateWidthForCells = (warehouse, widths) => {
				return map$1(Warehouse.justCells(warehouse), (cell$1) => {
					const width$1 = total(cell$1.column, cell$1.column + cell$1.colspan, widths);
					return {
						element: cell$1.element,
						width: width$1,
						colspan: cell$1.colspan
					};
				});
			};
			const recalculateWidthForColumns = (warehouse, widths) => {
				return map$1(Warehouse.justColumns(warehouse), (column, index) => ({
					element: column.element,
					width: widths[index],
					colspan: column.colspan
				}));
			};
			const recalculateHeightForCells = (warehouse, heights) => {
				return map$1(Warehouse.justCells(warehouse), (cell$1) => {
					const height$1 = total(cell$1.row, cell$1.row + cell$1.rowspan, heights);
					return {
						element: cell$1.element,
						height: height$1,
						rowspan: cell$1.rowspan
					};
				});
			};
			const matchRowHeight = (warehouse, heights) => {
				return map$1(warehouse.all, (row$1, i) => {
					return {
						element: row$1.element,
						height: heights[i]
					};
				});
			};
			const sumUp = (newSize) => foldr(newSize, (b, a) => b + a, 0);
			const recalculate = (warehouse, widths) => {
				if (Warehouse.hasColumns(warehouse)) return recalculateWidthForColumns(warehouse, widths);
				else return recalculateWidthForCells(warehouse, widths);
			};
			const recalculateAndApply = (warehouse, widths, tableSize) => {
				each$2(recalculate(warehouse, widths), (cell$1) => {
					tableSize.setElementWidth(cell$1.element, cell$1.width);
				});
			};
			const adjustWidth = (table$1, delta, index, resizing, tableSize) => {
				const warehouse = Warehouse.fromTable(table$1);
				const step = tableSize.getCellDelta(delta);
				const widths = tableSize.getWidths(warehouse, tableSize);
				const isLastColumn = index === warehouse.grid.columns - 1;
				const clampedStep = resizing.clampTableDelta(widths, index, step, tableSize.minCellWidth(), isLastColumn);
				recalculateAndApply(warehouse, map$1(determine(widths, index, clampedStep, tableSize, resizing), (dx, i) => dx + widths[i]), tableSize);
				resizing.resizeTable(tableSize.adjustTableWidth, clampedStep, isLastColumn);
			};
			const adjustHeight = (table$1, delta, index, direction) => {
				const warehouse = Warehouse.fromTable(table$1);
				const newHeights = map$1(getPixelHeights(warehouse, table$1, direction), (dy, i) => index === i ? Math.max(delta + dy, minHeight()) : dy);
				const newCellSizes = recalculateHeightForCells(warehouse, newHeights);
				each$2(matchRowHeight(warehouse, newHeights), (row$1) => {
					setHeight(row$1.element, row$1.height);
				});
				each$2(newCellSizes, (cell$1) => {
					setHeight(cell$1.element, cell$1.height);
				});
				setHeight(table$1, sumUp(newHeights));
			};
			const adjustAndRedistributeWidths$1 = (_table, list, details, tableSize, resizeBehaviour) => {
				const warehouse = Warehouse.generate(list);
				const sizes = tableSize.getWidths(warehouse, tableSize);
				const tablePixelWidth = tableSize.pixelWidth();
				const { newSizes, delta } = resizeBehaviour.calcRedestributedWidths(sizes, tablePixelWidth, details.pixelDelta, tableSize.isRelative);
				recalculateAndApply(warehouse, newSizes, tableSize);
				tableSize.adjustTableWidth(delta);
			};
			const adjustWidthTo = (_table, list, _info, tableSize) => {
				const warehouse = Warehouse.generate(list);
				recalculateAndApply(warehouse, tableSize.getWidths(warehouse, tableSize), tableSize);
			};
			const uniqueColumns = (details) => {
				const uniqueCheck = (rest, detail$1) => {
					return exists(rest, (currentDetail) => currentDetail.column === detail$1.column) ? rest : rest.concat([detail$1]);
				};
				return foldl(details, uniqueCheck, []).sort((detailA, detailB) => detailA.column - detailB.column);
			};
			const isCol = isTag("col");
			const isColgroup = isTag("colgroup");
			const isRow$1 = (element) => name(element) === "tr" || isColgroup(element);
			const elementToData = (element) => {
				return {
					element,
					colspan: getAttrValue(element, "colspan", 1),
					rowspan: getAttrValue(element, "rowspan", 1)
				};
			};
			const modification = (generators, toData = elementToData) => {
				const nuCell = (data) => isCol(data.element) ? generators.col(data) : generators.cell(data);
				const nuRow = (data) => isColgroup(data.element) ? generators.colgroup(data) : generators.row(data);
				const add$4 = (element) => {
					if (isRow$1(element)) return nuRow({ element });
					else {
						const cell$1 = element;
						const replacement = nuCell(toData(cell$1));
						recent = Optional.some({
							item: cell$1,
							replacement
						});
						return replacement;
					}
				};
				let recent = Optional.none();
				const getOrInit = (element, comparator) => {
					return recent.fold(() => {
						return add$4(element);
					}, (p) => {
						return comparator(element, p.item) ? p.replacement : add$4(element);
					});
				};
				return { getOrInit };
			};
			const transform$1 = (tag) => {
				return (generators) => {
					const list = [];
					const find$2 = (element, comparator) => {
						return find$1(list, (x) => {
							return comparator(x.item, element);
						});
					};
					const makeNew = (element) => {
						const attrs = tag === "td" ? { scope: null } : {};
						const cell$1 = generators.replace(element, tag, attrs);
						list.push({
							item: element,
							sub: cell$1
						});
						return cell$1;
					};
					const replaceOrInit = (element, comparator) => {
						if (isRow$1(element) || isCol(element)) return element;
						else {
							const cell$1 = element;
							return find$2(cell$1, comparator).fold(() => {
								return makeNew(cell$1);
							}, (p) => {
								return comparator(element, p.item) ? p.sub : makeNew(cell$1);
							});
						}
					};
					return { replaceOrInit };
				};
			};
			const getScopeAttribute = (cell$1) => getOpt(cell$1, "scope").map((attribute) => attribute.substr(0, 3));
			const merging = (generators) => {
				const unmerge$1 = (cell$1) => {
					const scope = getScopeAttribute(cell$1);
					scope.each((attribute) => set$2(cell$1, "scope", attribute));
					return () => {
						const raw = generators.cell({
							element: cell$1,
							colspan: 1,
							rowspan: 1
						});
						remove$5(raw, "width");
						remove$5(cell$1, "width");
						scope.each((attribute) => set$2(raw, "scope", attribute));
						return raw;
					};
				};
				const merge$3 = (cells$2) => {
					const getScopeProperty = () => {
						const stringAttributes = cat(map$1(cells$2, getScopeAttribute));
						if (stringAttributes.length === 0) return Optional.none();
						else {
							const baseScope = stringAttributes[0];
							const scopes = ["row", "col"];
							return exists(stringAttributes, (attribute) => {
								return attribute !== baseScope && contains$2(scopes, attribute);
							}) ? Optional.none() : Optional.from(baseScope);
						}
					};
					remove$5(cells$2[0], "width");
					getScopeProperty().fold(() => remove$7(cells$2[0], "scope"), (attribute) => set$2(cells$2[0], "scope", attribute + "group"));
					return constant(cells$2[0]);
				};
				return {
					unmerge: unmerge$1,
					merge: merge$3
				};
			};
			const Generators = {
				modification,
				transform: transform$1,
				merging
			};
			const blockList = [
				"body",
				"p",
				"div",
				"article",
				"aside",
				"figcaption",
				"figure",
				"footer",
				"header",
				"nav",
				"section",
				"ol",
				"ul",
				"table",
				"thead",
				"tfoot",
				"tbody",
				"caption",
				"tr",
				"td",
				"th",
				"h1",
				"h2",
				"h3",
				"h4",
				"h5",
				"h6",
				"blockquote",
				"pre",
				"address"
			];
			const isList$1 = (universe$4, item) => {
				return contains$2(["ol", "ul"], universe$4.property().name(item));
			};
			const isBlock$1 = (universe$4, item) => {
				return contains$2(blockList, universe$4.property().name(item));
			};
			const isEmptyTag$1 = (universe$4, item) => {
				return contains$2([
					"br",
					"img",
					"hr",
					"input"
				], universe$4.property().name(item));
			};
			const universe$1 = DomUniverse();
			const isBlock = (element) => {
				return isBlock$1(universe$1, element);
			};
			const isList = (element) => {
				return isList$1(universe$1, element);
			};
			const isEmptyTag = (element) => {
				return isEmptyTag$1(universe$1, element);
			};
			const merge = (cells$2) => {
				const isBr$1 = isTag("br");
				const advancedBr = (children$3) => {
					return forall(children$3, (c) => {
						return isBr$1(c) || isText(c) && get$6(c).trim().length === 0;
					});
				};
				const isListItem = (el) => {
					return name(el) === "li" || ancestor$2(el, isList).isSome();
				};
				const siblingIsBlock = (el) => {
					return nextSibling(el).map((rightSibling) => {
						if (isBlock(rightSibling)) return true;
						if (isEmptyTag(rightSibling)) return name(rightSibling) === "img" ? false : true;
						return false;
					}).getOr(false);
				};
				const markCell = (cell$1) => {
					return last$1(cell$1).bind((rightEdge) => {
						const rightSiblingIsBlock = siblingIsBlock(rightEdge);
						return parent(rightEdge).map((parent$1) => {
							return rightSiblingIsBlock === true || isListItem(parent$1) || isBr$1(rightEdge) || isBlock(parent$1) && !eq$1(cell$1, parent$1) ? [] : [SugarElement.fromTag("br")];
						});
					}).getOr([]);
				};
				const markContent = () => {
					const content = bind$2(cells$2, (cell$1) => {
						const children$3 = children$2(cell$1);
						return advancedBr(children$3) ? [] : children$3.concat(markCell(cell$1));
					});
					return content.length === 0 ? [SugarElement.fromTag("br")] : content;
				};
				const contents = markContent();
				empty(cells$2[0]);
				append(cells$2[0], contents);
			};
			const isEditable = (elem) => isEditable$1(elem, true);
			const prune = (table$1) => {
				if (cells$1(table$1).length === 0) remove$6(table$1);
			};
			const outcome = (grid$1, cursor) => ({
				grid: grid$1,
				cursor
			});
			const findEditableCursorPosition = (rows$2) => findMap(rows$2, (row$1) => findMap(row$1.cells, (cell$1) => {
				const elem = cell$1.element;
				return someIf(isEditable(elem), elem);
			}));
			const elementFromGrid = (grid$1, row$1, column) => {
				var _a, _b;
				const rows$2 = extractGridDetails(grid$1).rows;
				return Optional.from((_b = (_a = rows$2[row$1]) === null || _a === void 0 ? void 0 : _a.cells[column]) === null || _b === void 0 ? void 0 : _b.element).filter(isEditable).orThunk(() => findEditableCursorPosition(rows$2));
			};
			const bundle = (grid$1, row$1, column) => {
				return outcome(grid$1, elementFromGrid(grid$1, row$1, column));
			};
			const uniqueRows = (details) => {
				const rowCompilation = (rest, detail$1) => {
					return exists(rest, (currentDetail) => currentDetail.row === detail$1.row) ? rest : rest.concat([detail$1]);
				};
				return foldl(details, rowCompilation, []).sort((detailA, detailB) => detailA.row - detailB.row);
			};
			const opInsertRowsBefore = (grid$1, details, comparator, genWrappers) => {
				const targetIndex = details[0].row;
				const newGrid = foldr(uniqueRows(details), (acc, row$1) => {
					return {
						grid: insertRowAt(acc.grid, targetIndex, row$1.row + acc.delta, comparator, genWrappers.getOrInit),
						delta: acc.delta + 1
					};
				}, {
					grid: grid$1,
					delta: 0
				}).grid;
				return bundle(newGrid, targetIndex, details[0].column);
			};
			const opInsertRowsAfter = (grid$1, details, comparator, genWrappers) => {
				const rows$2 = uniqueRows(details);
				const target = rows$2[rows$2.length - 1];
				const targetIndex = target.row + target.rowspan;
				return bundle(foldr(rows$2, (newG, row$1) => {
					return insertRowAt(newG, targetIndex, row$1.row, comparator, genWrappers.getOrInit);
				}, grid$1), targetIndex, details[0].column);
			};
			const opInsertColumnsBefore = (grid$1, extractDetail, comparator, genWrappers) => {
				const details = extractDetail.details;
				const columns$2 = uniqueColumns(details);
				const targetIndex = columns$2[0].column;
				const newGrid = foldr(columns$2, (acc, col$1) => {
					return {
						grid: insertColumnAt(acc.grid, targetIndex, col$1.column + acc.delta, comparator, genWrappers.getOrInit),
						delta: acc.delta + 1
					};
				}, {
					grid: grid$1,
					delta: 0
				}).grid;
				return bundle(newGrid, details[0].row, targetIndex);
			};
			const opInsertColumnsAfter = (grid$1, extractDetail, comparator, genWrappers) => {
				const details = extractDetail.details;
				const target = details[details.length - 1];
				const targetIndex = target.column + target.colspan;
				return bundle(foldr(uniqueColumns(details), (newG, col$1) => {
					return insertColumnAt(newG, targetIndex, col$1.column, comparator, genWrappers.getOrInit);
				}, grid$1), details[0].row, targetIndex);
			};
			const opMakeColumnsHeader = (initialGrid, details, comparator, genWrappers) => {
				return bundle(replaceColumns(initialGrid, map$1(uniqueColumns(details), (detail$1) => detail$1.column), true, comparator, genWrappers.replaceOrInit), details[0].row, details[0].column);
			};
			const opMakeCellsHeader = (initialGrid, details, comparator, genWrappers) => {
				return bundle(replaceCells(initialGrid, details, comparator, genWrappers.replaceOrInit), details[0].row, details[0].column);
			};
			const opUnmakeColumnsHeader = (initialGrid, details, comparator, genWrappers) => {
				return bundle(replaceColumns(initialGrid, map$1(uniqueColumns(details), (detail$1) => detail$1.column), false, comparator, genWrappers.replaceOrInit), details[0].row, details[0].column);
			};
			const opUnmakeCellsHeader = (initialGrid, details, comparator, genWrappers) => {
				return bundle(replaceCells(initialGrid, details, comparator, genWrappers.replaceOrInit), details[0].row, details[0].column);
			};
			const makeRowsSection = (section$1, applyScope) => (initialGrid, details, comparator, genWrappers, tableSection) => {
				return bundle(replaceRows(initialGrid, map$1(uniqueRows(details), (detail$1) => detail$1.row), section$1, applyScope, comparator, genWrappers.replaceOrInit, tableSection), details[0].row, details[0].column);
			};
			const opMakeRowsHeader = makeRowsSection("thead", true);
			const opMakeRowsBody = makeRowsSection("tbody", false);
			const opMakeRowsFooter = makeRowsSection("tfoot", false);
			const opEraseColumns = (grid$1, extractDetail, _comparator, _genWrappers) => {
				const columns$2 = uniqueColumns(extractDetail.details);
				const newGrid = deleteColumnsAt(grid$1, map$1(columns$2, (column) => column.column));
				const maxColIndex = newGrid.length > 0 ? newGrid[0].cells.length - 1 : 0;
				return bundle(newGrid, columns$2[0].row, Math.min(columns$2[0].column, maxColIndex));
			};
			const opEraseRows = (grid$1, details, _comparator, _genWrappers) => {
				const rows$2 = uniqueRows(details);
				const newGrid = deleteRowsAt(grid$1, rows$2[0].row, rows$2[rows$2.length - 1].row);
				const maxRowIndex = newGrid.length > 0 ? newGrid.length - 1 : 0;
				return bundle(newGrid, Math.min(details[0].row, maxRowIndex), details[0].column);
			};
			const opMergeCells = (grid$1, mergable$1, comparator, genWrappers) => {
				const cells$2 = mergable$1.cells;
				merge(cells$2);
				return outcome(merge$2(grid$1, mergable$1.bounds, comparator, genWrappers.merge(cells$2)), Optional.from(cells$2[0]));
			};
			const opUnmergeCells = (grid$1, unmergable$1, comparator, genWrappers) => {
				const unmerge$1 = (b, cell$1) => unmerge(b, cell$1, comparator, genWrappers.unmerge(cell$1));
				return outcome(foldr(unmergable$1, unmerge$1, grid$1), Optional.from(unmergable$1[0]));
			};
			const opPasteCells = (grid$1, pasteDetails, comparator, _genWrappers) => {
				const gridify = (table$1, generators) => {
					return toGrid(Warehouse.fromTable(table$1), generators, true);
				};
				const gridB = gridify(pasteDetails.clipboard, pasteDetails.generators);
				return merge$1(address(pasteDetails.row, pasteDetails.column), grid$1, gridB, pasteDetails.generators, comparator).fold(() => outcome(grid$1, Optional.some(pasteDetails.element)), (newGrid) => {
					return bundle(newGrid, pasteDetails.row, pasteDetails.column);
				});
			};
			const gridifyRows = (rows$2, generators, context) => {
				const pasteDetails = fromPastedRows(rows$2, context.section);
				return toGrid(Warehouse.generate(pasteDetails), generators, true);
			};
			const opPasteColsBefore = (grid$1, pasteDetails, comparator, _genWrappers) => {
				const rows$2 = extractGridDetails(grid$1).rows;
				const index = pasteDetails.cells[0].column;
				const context = rows$2[pasteDetails.cells[0].row];
				return bundle(insertCols(index, grid$1, gridifyRows(pasteDetails.clipboard, pasteDetails.generators, context), pasteDetails.generators, comparator), pasteDetails.cells[0].row, pasteDetails.cells[0].column);
			};
			const opPasteColsAfter = (grid$1, pasteDetails, comparator, _genWrappers) => {
				const rows$2 = extractGridDetails(grid$1).rows;
				const index = pasteDetails.cells[pasteDetails.cells.length - 1].column + pasteDetails.cells[pasteDetails.cells.length - 1].colspan;
				const context = rows$2[pasteDetails.cells[0].row];
				return bundle(insertCols(index, grid$1, gridifyRows(pasteDetails.clipboard, pasteDetails.generators, context), pasteDetails.generators, comparator), pasteDetails.cells[0].row, pasteDetails.cells[0].column);
			};
			const opPasteRowsBefore = (grid$1, pasteDetails, comparator, _genWrappers) => {
				const rows$2 = extractGridDetails(grid$1).rows;
				const index = pasteDetails.cells[0].row;
				const context = rows$2[index];
				return bundle(insertRows(index, grid$1, gridifyRows(pasteDetails.clipboard, pasteDetails.generators, context), pasteDetails.generators, comparator), pasteDetails.cells[0].row, pasteDetails.cells[0].column);
			};
			const opPasteRowsAfter = (grid$1, pasteDetails, comparator, _genWrappers) => {
				const rows$2 = extractGridDetails(grid$1).rows;
				const index = pasteDetails.cells[pasteDetails.cells.length - 1].row + pasteDetails.cells[pasteDetails.cells.length - 1].rowspan;
				const context = rows$2[pasteDetails.cells[0].row];
				return bundle(insertRows(index, grid$1, gridifyRows(pasteDetails.clipboard, pasteDetails.generators, context), pasteDetails.generators, comparator), pasteDetails.cells[0].row, pasteDetails.cells[0].column);
			};
			const opGetColumnsType = (table$1, target) => {
				const house = Warehouse.fromTable(table$1);
				return onCells(house, target).bind((selectedCells) => {
					const lastSelectedCell = selectedCells[selectedCells.length - 1];
					const minColRange = selectedCells[0].column;
					const maxColRange = lastSelectedCell.column + lastSelectedCell.colspan;
					return findCommonCellType(flatten(map$1(house.all, (row$1) => filter$2(row$1.cells, (cell$1) => cell$1.column >= minColRange && cell$1.column < maxColRange))));
				}).getOr("");
			};
			const opGetCellsType = (table$1, target) => {
				return onCells(Warehouse.fromTable(table$1), target).bind(findCommonCellType).getOr("");
			};
			const opGetRowsType = (table$1, target) => {
				const house = Warehouse.fromTable(table$1);
				return onCells(house, target).bind((selectedCells) => {
					const lastSelectedCell = selectedCells[selectedCells.length - 1];
					const minRowRange = selectedCells[0].row;
					const maxRowRange = lastSelectedCell.row + lastSelectedCell.rowspan;
					return findCommonRowType(house.all.slice(minRowRange, maxRowRange));
				}).getOr("");
			};
			const resize = (table$1, list, details, behaviours) => adjustWidthTo(table$1, list, details, behaviours.sizing);
			const adjustAndRedistributeWidths = (table$1, list, details, behaviours) => adjustAndRedistributeWidths$1(table$1, list, details, behaviours.sizing, behaviours.resize);
			const firstColumnIsLocked = (_warehouse, details) => exists(details, (detail$1) => detail$1.column === 0 && detail$1.isLocked);
			const lastColumnIsLocked = (warehouse, details) => exists(details, (detail$1) => detail$1.column + detail$1.colspan >= warehouse.grid.columns && detail$1.isLocked);
			const getColumnsWidth = (warehouse, details) => {
				const columns$1$1 = columns(warehouse);
				return foldl(uniqueColumns(details), (acc, detail$1) => {
					return acc + columns$1$1[detail$1.column].map(getOuter$2).getOr(0);
				}, 0);
			};
			const insertColumnsExtractor = (before$2) => (warehouse, target) => onCells(warehouse, target).filter((details) => {
				return !(before$2 ? firstColumnIsLocked : lastColumnIsLocked)(warehouse, details);
			}).map((details) => ({
				details,
				pixelDelta: getColumnsWidth(warehouse, details)
			}));
			const eraseColumnsExtractor = (warehouse, target) => onUnlockedCells(warehouse, target).map((details) => ({
				details,
				pixelDelta: -getColumnsWidth(warehouse, details)
			}));
			const pasteColumnsExtractor = (before$2) => (warehouse, target) => onPasteByEditor(warehouse, target).filter((details) => {
				return !(before$2 ? firstColumnIsLocked : lastColumnIsLocked)(warehouse, details.cells);
			});
			const headerCellGenerator = Generators.transform("th");
			const bodyCellGenerator = Generators.transform("td");
			const insertRowsBefore = run(opInsertRowsBefore, onCells, noop, noop, Generators.modification);
			const insertRowsAfter = run(opInsertRowsAfter, onCells, noop, noop, Generators.modification);
			const insertColumnsBefore = run(opInsertColumnsBefore, insertColumnsExtractor(true), adjustAndRedistributeWidths, noop, Generators.modification);
			const insertColumnsAfter = run(opInsertColumnsAfter, insertColumnsExtractor(false), adjustAndRedistributeWidths, noop, Generators.modification);
			const eraseColumns = run(opEraseColumns, eraseColumnsExtractor, adjustAndRedistributeWidths, prune, Generators.modification);
			const eraseRows = run(opEraseRows, onCells, noop, prune, Generators.modification);
			const makeColumnsHeader = run(opMakeColumnsHeader, onUnlockedCells, noop, noop, headerCellGenerator);
			const unmakeColumnsHeader = run(opUnmakeColumnsHeader, onUnlockedCells, noop, noop, bodyCellGenerator);
			const makeRowsHeader = run(opMakeRowsHeader, onUnlockedCells, noop, noop, headerCellGenerator);
			const makeRowsBody = run(opMakeRowsBody, onUnlockedCells, noop, noop, bodyCellGenerator);
			const makeRowsFooter = run(opMakeRowsFooter, onUnlockedCells, noop, noop, bodyCellGenerator);
			const makeCellsHeader = run(opMakeCellsHeader, onUnlockedCells, noop, noop, headerCellGenerator);
			const unmakeCellsHeader = run(opUnmakeCellsHeader, onUnlockedCells, noop, noop, bodyCellGenerator);
			const mergeCells = run(opMergeCells, onUnlockedMergable, resize, noop, Generators.merging);
			const unmergeCells = run(opUnmergeCells, onUnlockedUnmergable, resize, noop, Generators.merging);
			const pasteCells = run(opPasteCells, onPaste, resize, noop, Generators.modification);
			const pasteColsBefore = run(opPasteColsBefore, pasteColumnsExtractor(true), noop, noop, Generators.modification);
			const pasteColsAfter = run(opPasteColsAfter, pasteColumnsExtractor(false), noop, noop, Generators.modification);
			const pasteRowsBefore = run(opPasteRowsBefore, onPasteByEditor, noop, noop, Generators.modification);
			const pasteRowsAfter = run(opPasteRowsAfter, onPasteByEditor, noop, noop, Generators.modification);
			const getColumnsType = opGetColumnsType;
			const getCellsType = opGetCellsType;
			const getRowsType = opGetRowsType;
			const fireNewRow = (editor, row$1) => editor.dispatch("NewRow", { node: row$1 });
			const fireNewCell = (editor, cell$1) => editor.dispatch("NewCell", { node: cell$1 });
			const fireTableModified = (editor, table$1, data) => {
				editor.dispatch("TableModified", {
					...data,
					table: table$1
				});
			};
			const fireTableSelectionChange = (editor, cells$2, start, finish, otherCells) => {
				editor.dispatch("TableSelectionChange", {
					cells: cells$2,
					start,
					finish,
					otherCells
				});
			};
			const fireTableSelectionClear = (editor) => {
				editor.dispatch("TableSelectionClear");
			};
			const fireObjectResizeStart = (editor, target, width$1, height$1, origin) => {
				editor.dispatch("ObjectResizeStart", {
					target,
					width: width$1,
					height: height$1,
					origin
				});
			};
			const fireObjectResized = (editor, target, width$1, height$1, origin) => {
				editor.dispatch("ObjectResized", {
					target,
					width: width$1,
					height: height$1,
					origin
				});
			};
			const styleModified = {
				structure: false,
				style: true
			};
			const structureModified = {
				structure: true,
				style: false
			};
			const styleAndStructureModified = {
				structure: true,
				style: true
			};
			const get$5 = (editor, table$1) => {
				if (isTablePercentagesForced(editor)) return TableSize.percentageSize(table$1);
				else if (isTablePixelsForced(editor)) return TableSize.pixelSize(table$1);
				else return TableSize.getTableSize(table$1);
			};
			const TableActions = (editor, resizeHandler, cellSelectionHandler) => {
				const isTableBody = (editor$1) => name(getBody(editor$1)) === "table";
				const lastRowGuard = (table$1) => !isTableBody(editor) || getGridSize(table$1).rows > 1;
				const lastColumnGuard = (table$1) => !isTableBody(editor) || getGridSize(table$1).columns > 1;
				const cloneFormats$1 = getTableCloneElements(editor);
				const colMutationOp = isResizeTableColumnResizing(editor) ? noop : halve;
				const getTableSectionType$1 = (table$1) => {
					switch (getTableHeaderType(editor)) {
						case "section": return TableSection.section();
						case "sectionCells": return TableSection.sectionCells();
						case "cells": return TableSection.cells();
						default: return TableSection.getTableSectionType(table$1, "section");
					}
				};
				const setSelectionFromAction = (table$1, result) => result.cursor.fold(() => {
					return head(cells$1(table$1)).filter(inBody).map((firstCell) => {
						cellSelectionHandler.clearSelectedCells(table$1.dom);
						const rng = editor.dom.createRng();
						rng.selectNode(firstCell.dom);
						editor.selection.setRng(rng);
						set$2(firstCell, "data-mce-selected", "1");
						return rng;
					});
				}, (cell$1) => {
					const des = freefallRtl(cell$1);
					const rng = editor.dom.createRng();
					rng.setStart(des.element.dom, des.offset);
					rng.setEnd(des.element.dom, des.offset);
					editor.selection.setRng(rng);
					cellSelectionHandler.clearSelectedCells(table$1.dom);
					return Optional.some(rng);
				});
				const execute = (operation, guard, mutate$2, effect) => (table$1, target, noEvents = false) => {
					removeDataStyle(table$1);
					const generators = cellOperations(mutate$2, SugarElement.fromDom(editor.getDoc()), cloneFormats$1);
					const behaviours = {
						sizing: get$5(editor, table$1),
						resize: isResizeTableColumnResizing(editor) ? resizeTable() : preserveTable(),
						section: getTableSectionType$1(table$1)
					};
					return guard(table$1) ? operation(table$1, target, generators, behaviours).bind((result) => {
						resizeHandler.refresh(table$1.dom);
						each$2(result.newRows, (row$1) => {
							fireNewRow(editor, row$1.dom);
						});
						each$2(result.newCells, (cell$1) => {
							fireNewCell(editor, cell$1.dom);
						});
						const range = setSelectionFromAction(table$1, result);
						if (inBody(table$1)) {
							removeDataStyle(table$1);
							if (!noEvents) fireTableModified(editor, table$1.dom, effect);
						}
						return range.map((rng) => ({
							rng,
							effect
						}));
					}) : Optional.none();
				};
				return {
					deleteRow: execute(eraseRows, lastRowGuard, noop, structureModified),
					deleteColumn: execute(eraseColumns, lastColumnGuard, noop, structureModified),
					insertRowsBefore: execute(insertRowsBefore, always, noop, structureModified),
					insertRowsAfter: execute(insertRowsAfter, always, noop, structureModified),
					insertColumnsBefore: execute(insertColumnsBefore, always, colMutationOp, structureModified),
					insertColumnsAfter: execute(insertColumnsAfter, always, colMutationOp, structureModified),
					mergeCells: execute(mergeCells, always, noop, structureModified),
					unmergeCells: execute(unmergeCells, always, noop, structureModified),
					pasteColsBefore: execute(pasteColsBefore, always, noop, structureModified),
					pasteColsAfter: execute(pasteColsAfter, always, noop, structureModified),
					pasteRowsBefore: execute(pasteRowsBefore, always, noop, structureModified),
					pasteRowsAfter: execute(pasteRowsAfter, always, noop, structureModified),
					pasteCells: execute(pasteCells, always, noop, styleAndStructureModified),
					makeCellsHeader: execute(makeCellsHeader, always, noop, structureModified),
					unmakeCellsHeader: execute(unmakeCellsHeader, always, noop, structureModified),
					makeColumnsHeader: execute(makeColumnsHeader, always, noop, structureModified),
					unmakeColumnsHeader: execute(unmakeColumnsHeader, always, noop, structureModified),
					makeRowsHeader: execute(makeRowsHeader, always, noop, structureModified),
					makeRowsBody: execute(makeRowsBody, always, noop, structureModified),
					makeRowsFooter: execute(makeRowsFooter, always, noop, structureModified),
					getTableRowType: getRowsType,
					getTableCellType: getCellsType,
					getTableColType: getColumnsType
				};
			};
			const constrainSpan = (element, property, value$2) => {
				const currentColspan = getAttrValue(element, property, 1);
				if (value$2 === 1 || currentColspan <= 1) remove$7(element, property);
				else set$2(element, property, Math.min(value$2, currentColspan));
			};
			const isColInRange = (minColRange, maxColRange) => (cell$1) => {
				const endCol = cell$1.column + cell$1.colspan - 1;
				const startCol = cell$1.column;
				return endCol >= minColRange && startCol < maxColRange;
			};
			const generateColGroup = (house, minColRange, maxColRange) => {
				if (Warehouse.hasColumns(house)) {
					const copiedCols = map$1(filter$2(Warehouse.justColumns(house), isColInRange(minColRange, maxColRange)), (c) => {
						const clonedCol = deep(c.element);
						constrainSpan(clonedCol, "span", maxColRange - minColRange);
						return clonedCol;
					});
					const fakeColgroup = SugarElement.fromTag("colgroup");
					append(fakeColgroup, copiedCols);
					return [fakeColgroup];
				} else return [];
			};
			const generateRows = (house, minColRange, maxColRange) => map$1(house.all, (row$1) => {
				const copiedCells = map$1(filter$2(row$1.cells, isColInRange(minColRange, maxColRange)), (cell$1) => {
					const clonedCell = deep(cell$1.element);
					constrainSpan(clonedCell, "colspan", maxColRange - minColRange);
					return clonedCell;
				});
				const fakeTR = SugarElement.fromTag("tr");
				append(fakeTR, copiedCells);
				return fakeTR;
			});
			const copyCols = (table$1, target) => {
				const house = Warehouse.fromTable(table$1);
				return onUnlockedCells(house, target).map((selectedCells) => {
					const lastSelectedCell = selectedCells[selectedCells.length - 1];
					const minColRange = selectedCells[0].column;
					const maxColRange = lastSelectedCell.column + lastSelectedCell.colspan;
					const fakeColGroups = generateColGroup(house, minColRange, maxColRange);
					const fakeRows = generateRows(house, minColRange, maxColRange);
					return [...fakeColGroups, ...fakeRows];
				});
			};
			const copyRows = (table$1, target, generators) => {
				const warehouse = Warehouse.fromTable(table$1);
				return onCells(warehouse, target).bind((selectedCells) => {
					const slicedDetails = toDetailList(bind$2(extractGridDetails(toGrid(warehouse, generators, false)).rows.slice(selectedCells[0].row, selectedCells[selectedCells.length - 1].row + selectedCells[selectedCells.length - 1].rowspan), (row$1) => {
						const newCells = filter$2(row$1.cells, (cell$1) => !cell$1.isLocked);
						return newCells.length > 0 ? [{
							...row$1,
							cells: newCells
						}] : [];
					}));
					return someIf(slicedDetails.length > 0, slicedDetails);
				}).map((slicedDetails) => copy(slicedDetails));
			};
			const adt$5 = Adt.generate([
				{ invalid: ["raw"] },
				{ pixels: ["value"] },
				{ percent: ["value"] }
			]);
			const validateFor = (suffix, type$1, value$2) => {
				const rawAmount = value$2.substring(0, value$2.length - suffix.length);
				const amount = parseFloat(rawAmount);
				return rawAmount === amount.toString() ? type$1(amount) : adt$5.invalid(value$2);
			};
			const from = (value$2) => {
				if (endsWith(value$2, "%")) return validateFor("%", adt$5.percent, value$2);
				if (endsWith(value$2, "px")) return validateFor("px", adt$5.pixels, value$2);
				return adt$5.invalid(value$2);
			};
			const Size = {
				...adt$5,
				from
			};
			const redistributeToPercent = (widths, totalWidth) => {
				return map$1(widths, (w) => {
					return Size.from(w).fold(() => {
						return w;
					}, (px) => {
						return px / totalWidth * 100 + "%";
					}, (pc) => {
						return pc + "%";
					});
				});
			};
			const redistributeToPx = (widths, totalWidth, newTotalWidth) => {
				const scale = newTotalWidth / totalWidth;
				return map$1(widths, (w) => {
					return Size.from(w).fold(() => {
						return w;
					}, (px) => {
						return px * scale + "px";
					}, (pc) => {
						return pc / 100 * newTotalWidth + "px";
					});
				});
			};
			const redistributeEmpty = (newWidthType, columns$2) => {
				return range$1(columns$2, newWidthType.fold(() => constant(""), (pixels) => {
					return constant(pixels / columns$2 + "px");
				}, () => {
					return constant(100 / columns$2 + "%");
				}));
			};
			const redistributeValues = (newWidthType, widths, totalWidth) => {
				return newWidthType.fold(() => {
					return widths;
				}, (px) => {
					return redistributeToPx(widths, totalWidth, px);
				}, (_pc) => {
					return redistributeToPercent(widths, totalWidth);
				});
			};
			const redistribute$1 = (widths, totalWidth, newWidth) => {
				const newType = Size.from(newWidth);
				return normalize(forall(widths, (s) => {
					return s === "0px";
				}) ? redistributeEmpty(newType, widths.length) : redistributeValues(newType, widths, totalWidth));
			};
			const sum = (values$1, fallback$1) => {
				if (values$1.length === 0) return fallback$1;
				return foldr(values$1, (rest, v) => {
					return Size.from(v).fold(constant(0), identity, identity) + rest;
				}, 0);
			};
			const roundDown = (num, unit) => {
				const floored = Math.floor(num);
				return {
					value: floored + unit,
					remainder: num - floored
				};
			};
			const add$3 = (value$2, amount) => {
				return Size.from(value$2).fold(constant(value$2), (px) => {
					return px + amount + "px";
				}, (pc) => {
					return pc + amount + "%";
				});
			};
			const normalize = (values$1) => {
				if (values$1.length === 0) return values$1;
				const scan$2 = foldr(values$1, (rest, value$2) => {
					const info = Size.from(value$2).fold(() => ({
						value: value$2,
						remainder: 0
					}), (num) => roundDown(num, "px"), (num) => ({
						value: num + "%",
						remainder: 0
					}));
					return {
						output: [info.value].concat(rest.output),
						remainder: rest.remainder + info.remainder
					};
				}, {
					output: [],
					remainder: 0
				});
				const r$1 = scan$2.output;
				return r$1.slice(0, r$1.length - 1).concat([add$3(r$1[r$1.length - 1], Math.round(scan$2.remainder))]);
			};
			const validate = Size.from;
			const redistributeToW = (newWidths, cells$2, unit) => {
				each$2(cells$2, (cell$1) => {
					const w = sum(newWidths.slice(cell$1.column, cell$1.colspan + cell$1.column), minWidth());
					set$1(cell$1.element, "width", w + unit);
				});
			};
			const redistributeToColumns = (newWidths, columns$2, unit) => {
				each$2(columns$2, (column, index) => {
					const width$1 = sum([newWidths[index]], minWidth());
					set$1(column.element, "width", width$1 + unit);
				});
			};
			const redistributeToH = (newHeights, rows$2, cells$2, unit) => {
				each$2(cells$2, (cell$1) => {
					const h = sum(newHeights.slice(cell$1.row, cell$1.rowspan + cell$1.row), minHeight());
					set$1(cell$1.element, "height", h + unit);
				});
				each$2(rows$2, (row$1, i) => {
					set$1(row$1.element, "height", newHeights[i]);
				});
			};
			const getUnit = (newSize) => {
				return validate(newSize).fold(constant("px"), constant("px"), constant("%"));
			};
			const redistribute = (table$1, optWidth, optHeight) => {
				const warehouse = Warehouse.fromTable(table$1);
				const rows$2 = warehouse.all;
				const cells$2 = Warehouse.justCells(warehouse);
				const columns$2 = Warehouse.justColumns(warehouse);
				optWidth.each((newWidth) => {
					const widthUnit = getUnit(newWidth);
					const totalWidth = get$9(table$1);
					const nuWidths = redistribute$1(getRawWidths(warehouse, table$1), totalWidth, newWidth);
					if (Warehouse.hasColumns(warehouse)) redistributeToColumns(nuWidths, columns$2, widthUnit);
					else redistributeToW(nuWidths, cells$2, widthUnit);
					set$1(table$1, "width", newWidth);
				});
				optHeight.each((newHeight) => {
					const hUnit = getUnit(newHeight);
					const totalHeight = get$8(table$1);
					redistributeToH(redistribute$1(getRawHeights(warehouse, table$1, height), totalHeight, newHeight), rows$2, cells$2, hUnit);
					set$1(table$1, "height", newHeight);
				});
			};
			const isPercentSizing = isPercentSizing$1;
			const isPixelSizing = isPixelSizing$1;
			const isNoneSizing = isNoneSizing$1;
			const cleanupLegacyAttributes = (element) => {
				remove$7(element, "width");
			};
			const convertToPercentSize = (table$1) => {
				const newWidth = getPercentTableWidth(table$1);
				redistribute(table$1, Optional.some(newWidth), Optional.none());
				cleanupLegacyAttributes(table$1);
			};
			const convertToPixelSize = (table$1) => {
				const newWidth = getPixelTableWidth(table$1);
				redistribute(table$1, Optional.some(newWidth), Optional.none());
				cleanupLegacyAttributes(table$1);
			};
			const convertToNoneSize = (table$1) => {
				remove$5(table$1, "width");
				const columns$2 = columns$1(table$1);
				each$2(columns$2.length > 0 ? columns$2 : cells$1(table$1), (cell$1) => {
					remove$5(cell$1, "width");
					cleanupLegacyAttributes(cell$1);
				});
				cleanupLegacyAttributes(table$1);
			};
			const DefaultRenderOptions = {
				styles: {
					"border-collapse": "collapse",
					"width": "100%"
				},
				attributes: { border: "1" },
				colGroups: false
			};
			const tableHeaderCell = () => SugarElement.fromTag("th");
			const tableCell = () => SugarElement.fromTag("td");
			const tableColumn = () => SugarElement.fromTag("col");
			const createRow = (columns$2, rowHeaders, columnHeaders, rowIndex) => {
				const tr = SugarElement.fromTag("tr");
				for (let j = 0; j < columns$2; j++) {
					const td = rowIndex < rowHeaders || j < columnHeaders ? tableHeaderCell() : tableCell();
					if (j < columnHeaders) set$2(td, "scope", "row");
					if (rowIndex < rowHeaders) set$2(td, "scope", "col");
					append$1(td, SugarElement.fromTag("br"));
					append$1(tr, td);
				}
				return tr;
			};
			const createGroupRow = (columns$2) => {
				const columnGroup = SugarElement.fromTag("colgroup");
				range$1(columns$2, () => append$1(columnGroup, tableColumn()));
				return columnGroup;
			};
			const createRows = (rows$2, columns$2, rowHeaders, columnHeaders) => range$1(rows$2, (r$1) => createRow(columns$2, rowHeaders, columnHeaders, r$1));
			const render = (rows$2, columns$2, rowHeaders, columnHeaders, headerType, renderOpts = DefaultRenderOptions) => {
				const table$1 = SugarElement.fromTag("table");
				const rowHeadersGoInThead = headerType !== "cells";
				setAll(table$1, renderOpts.styles);
				setAll$1(table$1, renderOpts.attributes);
				if (renderOpts.colGroups) append$1(table$1, createGroupRow(columns$2));
				const actualRowHeaders = Math.min(rows$2, rowHeaders);
				if (rowHeadersGoInThead && rowHeaders > 0) {
					const thead = SugarElement.fromTag("thead");
					append$1(table$1, thead);
					append(thead, createRows(rowHeaders, columns$2, headerType === "sectionCells" ? actualRowHeaders : 0, columnHeaders));
				}
				const tbody = SugarElement.fromTag("tbody");
				append$1(table$1, tbody);
				append(tbody, createRows(rowHeadersGoInThead ? rows$2 - actualRowHeaders : rows$2, columns$2, rowHeadersGoInThead ? 0 : rowHeaders, columnHeaders));
				return table$1;
			};
			const get$4 = (element) => element.dom.innerHTML;
			const getOuter = (element) => {
				const container = SugarElement.fromTag("div");
				append$1(container, SugarElement.fromDom(element.dom.cloneNode(true)));
				return get$4(container);
			};
			const placeCaretInCell = (editor, cell$1) => {
				editor.selection.select(cell$1.dom, true);
				editor.selection.collapse(true);
			};
			const selectFirstCellInTable = (editor, tableElm) => {
				descendant(tableElm, "td,th").each(curry(placeCaretInCell, editor));
			};
			const fireEvents = (editor, table$1) => {
				each$2(descendants(table$1, "tr"), (row$1) => {
					fireNewRow(editor, row$1.dom);
					each$2(descendants(row$1, "th,td"), (cell$1) => {
						fireNewCell(editor, cell$1.dom);
					});
				});
			};
			const isPercentage = (width$1) => isString(width$1) && width$1.indexOf("%") !== -1;
			const insert = (editor, columns$2, rows$2, colHeaders, rowHeaders) => {
				const defaultStyles = getTableDefaultStyles(editor);
				const options = {
					styles: defaultStyles,
					attributes: getTableDefaultAttributes(editor),
					colGroups: tableUseColumnGroup(editor)
				};
				editor.undoManager.ignore(() => {
					const table$1 = render(rows$2, columns$2, rowHeaders, colHeaders, getTableHeaderType(editor), options);
					set$2(table$1, "data-mce-id", "__mce");
					const html = getOuter(table$1);
					editor.insertContent(html);
					editor.addVisual();
				});
				return descendant(getBody(editor), "table[data-mce-id=\"__mce\"]").map((table$1) => {
					if (isTablePixelsForced(editor)) convertToPixelSize(table$1);
					else if (isTableResponsiveForced(editor)) convertToNoneSize(table$1);
					else if (isTablePercentagesForced(editor) || isPercentage(defaultStyles.width)) convertToPercentSize(table$1);
					removeDataStyle(table$1);
					remove$7(table$1, "data-mce-id");
					fireEvents(editor, table$1);
					selectFirstCellInTable(editor, table$1);
					return table$1.dom;
				}).getOrNull();
			};
			const insertTable = (editor, rows$2, columns$2, options = {}) => {
				const checkInput = (val) => isNumber(val) && val > 0;
				if (checkInput(rows$2) && checkInput(columns$2)) {
					const headerRows = options.headerRows || 0;
					return insert(editor, columns$2, rows$2, options.headerColumns || 0, headerRows);
				} else {
					console.error("Invalid values for mceInsertTable - rows and columns values are required to insert a table.");
					return null;
				}
			};
			var global = tinymce.util.Tools.resolve("tinymce.FakeClipboard");
			const tableTypeBase = "x-tinymce/dom-table-";
			const tableTypeRow = tableTypeBase + "rows";
			const tableTypeColumn = tableTypeBase + "columns";
			const setData = (items) => {
				const fakeClipboardItem = global.FakeClipboardItem(items);
				global.write([fakeClipboardItem]);
			};
			const getData = (type$1) => {
				var _a;
				return findMap((_a = global.read()) !== null && _a !== void 0 ? _a : [], (item) => Optional.from(item.getType(type$1)));
			};
			const clearData = (type$1) => {
				if (getData(type$1).isSome()) global.clear();
			};
			const setRows = (rowsOpt) => {
				rowsOpt.fold(clearRows, (rows$2) => setData({ [tableTypeRow]: rows$2 }));
			};
			const getRows = () => getData(tableTypeRow);
			const clearRows = () => clearData(tableTypeRow);
			const setColumns = (columnsOpt) => {
				columnsOpt.fold(clearColumns, (columns$2) => setData({ [tableTypeColumn]: columns$2 }));
			};
			const getColumns = () => getData(tableTypeColumn);
			const clearColumns = () => clearData(tableTypeColumn);
			const getSelectionStartCellOrCaption = (editor) => getSelectionCellOrCaption(getSelectionStart(editor), getIsRoot(editor)).filter(isInEditableContext$1);
			const getSelectionStartCell = (editor) => getSelectionCell(getSelectionStart(editor), getIsRoot(editor)).filter(isInEditableContext$1);
			const registerCommands = (editor, actions) => {
				const isRoot = getIsRoot(editor);
				const eraseTable = () => getSelectionStartCellOrCaption(editor).each((cellOrCaption) => {
					table(cellOrCaption, isRoot).filter(not(isRoot)).each((table$1) => {
						const cursor = SugarElement.fromText("");
						after$5(table$1, cursor);
						remove$6(table$1);
						if (editor.dom.isEmpty(editor.getBody())) {
							editor.setContent("");
							editor.selection.setCursorLocation();
						} else {
							const rng = editor.dom.createRng();
							rng.setStart(cursor.dom, 0);
							rng.setEnd(cursor.dom, 0);
							editor.selection.setRng(rng);
							editor.nodeChanged();
						}
					});
				});
				const setSizingMode = (sizing) => getSelectionStartCellOrCaption(editor).each((cellOrCaption) => {
					if (!(isTableResponsiveForced(editor) || isTablePixelsForced(editor) || isTablePercentagesForced(editor))) table(cellOrCaption, isRoot).each((table$1) => {
						if (sizing === "relative" && !isPercentSizing(table$1)) convertToPercentSize(table$1);
						else if (sizing === "fixed" && !isPixelSizing(table$1)) convertToPixelSize(table$1);
						else if (sizing === "responsive" && !isNoneSizing(table$1)) convertToNoneSize(table$1);
						removeDataStyle(table$1);
						fireTableModified(editor, table$1.dom, structureModified);
					});
				});
				const getTableFromCell = (cell$1) => table(cell$1, isRoot);
				const performActionOnSelection = (action) => getSelectionStartCell(editor).bind((cell$1) => getTableFromCell(cell$1).map((table$1) => action(table$1, cell$1)));
				const toggleTableClass = (_ui, clazz) => {
					performActionOnSelection((table$1) => {
						editor.formatter.toggle("tableclass", { value: clazz }, table$1.dom);
						fireTableModified(editor, table$1.dom, styleModified);
					});
				};
				const toggleTableCellClass = (_ui, clazz) => {
					performActionOnSelection((table$1) => {
						const selectedCells = getCellsFromSelection(editor);
						const formatterAction = forall(selectedCells, (cell$1) => editor.formatter.match("tablecellclass", { value: clazz }, cell$1.dom)) ? editor.formatter.remove : editor.formatter.apply;
						each$2(selectedCells, (cell$1) => formatterAction("tablecellclass", { value: clazz }, cell$1.dom));
						fireTableModified(editor, table$1.dom, styleModified);
					});
				};
				const toggleCaption = () => {
					getSelectionStartCellOrCaption(editor).each((cellOrCaption) => {
						table(cellOrCaption, isRoot).each((table$1) => {
							child(table$1, "caption").fold(() => {
								const caption = SugarElement.fromTag("caption");
								append$1(caption, SugarElement.fromText("Caption"));
								appendAt(table$1, caption, 0);
								editor.selection.setCursorLocation(caption.dom, 0);
							}, (caption) => {
								if (isTag("caption")(cellOrCaption)) one("td", table$1).each((td) => editor.selection.setCursorLocation(td.dom, 0));
								remove$6(caption);
							});
							fireTableModified(editor, table$1.dom, structureModified);
						});
					});
				};
				const postExecute = (_data) => {
					editor.focus();
				};
				const actOnSelection = (execute, noEvents = false) => performActionOnSelection((table$1, startCell) => {
					execute(table$1, forMenu(getCellsFromSelection(editor), table$1, startCell), noEvents).each(postExecute);
				});
				const copyRowSelection = () => performActionOnSelection((table$1, startCell) => {
					return copyRows(table$1, forMenu(getCellsFromSelection(editor), table$1, startCell), cellOperations(noop, SugarElement.fromDom(editor.getDoc()), Optional.none()));
				});
				const copyColSelection = () => performActionOnSelection((table$1, startCell) => {
					return copyCols(table$1, forMenu(getCellsFromSelection(editor), table$1, startCell));
				});
				const pasteOnSelection = (execute, getRows$1) => getRows$1().each((rows$2) => {
					const clonedRows = map$1(rows$2, (row$1) => deep(row$1));
					performActionOnSelection((table$1, startCell) => {
						const generators = paste$1(SugarElement.fromDom(editor.getDoc()));
						execute(table$1, pasteRows(getCellsFromSelection(editor), startCell, clonedRows, generators)).each(postExecute);
					});
				});
				const actOnType = (getAction) => (_ui, args) => get$c(args, "type").each((type$1) => {
					actOnSelection(getAction(type$1), args.no_events);
				});
				each$1({
					mceTableSplitCells: () => actOnSelection(actions.unmergeCells),
					mceTableMergeCells: () => actOnSelection(actions.mergeCells),
					mceTableInsertRowBefore: () => actOnSelection(actions.insertRowsBefore),
					mceTableInsertRowAfter: () => actOnSelection(actions.insertRowsAfter),
					mceTableInsertColBefore: () => actOnSelection(actions.insertColumnsBefore),
					mceTableInsertColAfter: () => actOnSelection(actions.insertColumnsAfter),
					mceTableDeleteCol: () => actOnSelection(actions.deleteColumn),
					mceTableDeleteRow: () => actOnSelection(actions.deleteRow),
					mceTableCutCol: () => copyColSelection().each((selection$1) => {
						setColumns(selection$1);
						actOnSelection(actions.deleteColumn);
					}),
					mceTableCutRow: () => copyRowSelection().each((selection$1) => {
						setRows(selection$1);
						actOnSelection(actions.deleteRow);
					}),
					mceTableCopyCol: () => copyColSelection().each((selection$1) => setColumns(selection$1)),
					mceTableCopyRow: () => copyRowSelection().each((selection$1) => setRows(selection$1)),
					mceTablePasteColBefore: () => pasteOnSelection(actions.pasteColsBefore, getColumns),
					mceTablePasteColAfter: () => pasteOnSelection(actions.pasteColsAfter, getColumns),
					mceTablePasteRowBefore: () => pasteOnSelection(actions.pasteRowsBefore, getRows),
					mceTablePasteRowAfter: () => pasteOnSelection(actions.pasteRowsAfter, getRows),
					mceTableDelete: eraseTable,
					mceTableCellToggleClass: toggleTableCellClass,
					mceTableToggleClass: toggleTableClass,
					mceTableToggleCaption: toggleCaption,
					mceTableSizingMode: (_ui, sizing) => setSizingMode(sizing),
					mceTableCellType: actOnType((type$1) => type$1 === "th" ? actions.makeCellsHeader : actions.unmakeCellsHeader),
					mceTableColType: actOnType((type$1) => type$1 === "th" ? actions.makeColumnsHeader : actions.unmakeColumnsHeader),
					mceTableRowType: actOnType((type$1) => {
						switch (type$1) {
							case "header": return actions.makeRowsHeader;
							case "footer": return actions.makeRowsFooter;
							default: return actions.makeRowsBody;
						}
					})
				}, (func, name$1) => editor.addCommand(name$1, func));
				editor.addCommand("mceInsertTable", (_ui, args) => {
					insertTable(editor, args.rows, args.columns, args.options);
				});
				editor.addCommand("mceTableApplyCellStyle", (_ui, args) => {
					const getFormatName = (style) => "tablecell" + style.toLowerCase().replace("-", "");
					if (!isObject(args)) return;
					const cells$2 = filter$2(getCellsFromSelection(editor), isInEditableContext$1);
					if (cells$2.length === 0) return;
					const validArgs = filter$1(args, (value$2, style) => editor.formatter.has(getFormatName(style)) && isString(value$2));
					if (isEmpty(validArgs)) return;
					each$1(validArgs, (value$2, style) => {
						const formatName = getFormatName(style);
						each$2(cells$2, (cell$1) => {
							if (value$2 === "") editor.formatter.remove(formatName, { value: null }, cell$1.dom, true);
							else editor.formatter.apply(formatName, { value: value$2 }, cell$1.dom);
						});
					});
					getTableFromCell(cells$2[0]).each((table$1) => fireTableModified(editor, table$1.dom, styleModified));
				});
			};
			const registerQueryCommands = (editor, actions) => {
				const isRoot = getIsRoot(editor);
				const lookupOnSelection = (action) => getSelectionCell(getSelectionStart(editor)).bind((cell$1) => table(cell$1, isRoot).map((table$1) => {
					return action(table$1, forMenu(getCellsFromSelection(editor), table$1, cell$1));
				})).getOr("");
				each$1({
					mceTableRowType: () => lookupOnSelection(actions.getTableRowType),
					mceTableCellType: () => lookupOnSelection(actions.getTableCellType),
					mceTableColType: () => lookupOnSelection(actions.getTableColType)
				}, (func, name$1) => editor.addQueryValueHandler(name$1, func));
			};
			const adt$4 = Adt.generate([
				{ before: ["element"] },
				{ on: ["element", "offset"] },
				{ after: ["element"] }
			]);
			const cata$1 = (subject, onBefore, onOn, onAfter) => subject.fold(onBefore, onOn, onAfter);
			const getStart$1 = (situ) => situ.fold(identity, identity, identity);
			const Situ = {
				before: adt$4.before,
				on: adt$4.on,
				after: adt$4.after,
				cata: cata$1,
				getStart: getStart$1
			};
			const create$4 = (selection$1, kill) => ({
				selection: selection$1,
				kill
			});
			const Response = { create: create$4 };
			const selectNode = (win, element) => {
				const rng = win.document.createRange();
				rng.selectNode(element.dom);
				return rng;
			};
			const selectNodeContents = (win, element) => {
				const rng = win.document.createRange();
				selectNodeContentsUsing(rng, element);
				return rng;
			};
			const selectNodeContentsUsing = (rng, element) => rng.selectNodeContents(element.dom);
			const setStart = (rng, situ) => {
				situ.fold((e) => {
					rng.setStartBefore(e.dom);
				}, (e, o) => {
					rng.setStart(e.dom, o);
				}, (e) => {
					rng.setStartAfter(e.dom);
				});
			};
			const setFinish = (rng, situ) => {
				situ.fold((e) => {
					rng.setEndBefore(e.dom);
				}, (e, o) => {
					rng.setEnd(e.dom, o);
				}, (e) => {
					rng.setEndAfter(e.dom);
				});
			};
			const relativeToNative = (win, startSitu, finishSitu) => {
				const range = win.document.createRange();
				setStart(range, startSitu);
				setFinish(range, finishSitu);
				return range;
			};
			const exactToNative = (win, start, soffset, finish, foffset) => {
				const rng = win.document.createRange();
				rng.setStart(start.dom, soffset);
				rng.setEnd(finish.dom, foffset);
				return rng;
			};
			const toRect = (rect) => ({
				left: rect.left,
				top: rect.top,
				right: rect.right,
				bottom: rect.bottom,
				width: rect.width,
				height: rect.height
			});
			const getFirstRect$1 = (rng) => {
				const rects = rng.getClientRects();
				const rect = rects.length > 0 ? rects[0] : rng.getBoundingClientRect();
				return rect.width > 0 || rect.height > 0 ? Optional.some(rect).map(toRect) : Optional.none();
			};
			const adt$3 = Adt.generate([{ ltr: [
				"start",
				"soffset",
				"finish",
				"foffset"
			] }, { rtl: [
				"start",
				"soffset",
				"finish",
				"foffset"
			] }]);
			const fromRange = (win, type$1, range) => type$1(SugarElement.fromDom(range.startContainer), range.startOffset, SugarElement.fromDom(range.endContainer), range.endOffset);
			const getRanges = (win, selection$1) => selection$1.match({
				domRange: (rng) => {
					return {
						ltr: constant(rng),
						rtl: Optional.none
					};
				},
				relative: (startSitu, finishSitu) => {
					return {
						ltr: cached(() => relativeToNative(win, startSitu, finishSitu)),
						rtl: cached(() => Optional.some(relativeToNative(win, finishSitu, startSitu)))
					};
				},
				exact: (start, soffset, finish, foffset) => {
					return {
						ltr: cached(() => exactToNative(win, start, soffset, finish, foffset)),
						rtl: cached(() => Optional.some(exactToNative(win, finish, foffset, start, soffset)))
					};
				}
			});
			const doDiagnose = (win, ranges) => {
				const rng = ranges.ltr();
				if (rng.collapsed) return ranges.rtl().filter((rev) => rev.collapsed === false).map((rev) => adt$3.rtl(SugarElement.fromDom(rev.endContainer), rev.endOffset, SugarElement.fromDom(rev.startContainer), rev.startOffset)).getOrThunk(() => fromRange(win, adt$3.ltr, rng));
				else return fromRange(win, adt$3.ltr, rng);
			};
			const diagnose = (win, selection$1) => {
				return doDiagnose(win, getRanges(win, selection$1));
			};
			const asLtrRange = (win, selection$1) => {
				return diagnose(win, selection$1).match({
					ltr: (start, soffset, finish, foffset) => {
						const rng = win.document.createRange();
						rng.setStart(start.dom, soffset);
						rng.setEnd(finish.dom, foffset);
						return rng;
					},
					rtl: (start, soffset, finish, foffset) => {
						const rng = win.document.createRange();
						rng.setStart(finish.dom, foffset);
						rng.setEnd(start.dom, soffset);
						return rng;
					}
				});
			};
			adt$3.ltr;
			adt$3.rtl;
			const create$3 = (start, soffset, finish, foffset) => ({
				start,
				soffset,
				finish,
				foffset
			});
			const SimRange = { create: create$3 };
			const create$2 = (start, soffset, finish, foffset) => {
				return {
					start: Situ.on(start, soffset),
					finish: Situ.on(finish, foffset)
				};
			};
			const Situs = { create: create$2 };
			const convertToRange = (win, selection$1) => {
				const rng = asLtrRange(win, selection$1);
				return SimRange.create(SugarElement.fromDom(rng.startContainer), rng.startOffset, SugarElement.fromDom(rng.endContainer), rng.endOffset);
			};
			const makeSitus = Situs.create;
			const sync = (container, isRoot, start, soffset, finish, foffset, selectRange) => {
				if (!(eq$1(start, finish) && soffset === foffset)) return closest$1(start, "td,th", isRoot).bind((s) => {
					return closest$1(finish, "td,th", isRoot).bind((f) => {
						return detect(container, isRoot, s, f, selectRange);
					});
				});
				else return Optional.none();
			};
			const detect = (container, isRoot, start, finish, selectRange) => {
				if (!eq$1(start, finish)) return identify(start, finish, isRoot).bind((cellSel) => {
					const boxes = cellSel.boxes.getOr([]);
					if (boxes.length > 1) {
						selectRange(container, boxes, cellSel.start, cellSel.finish);
						return Optional.some(Response.create(Optional.some(makeSitus(start, 0, start, getEnd(start))), true));
					} else return Optional.none();
				});
				else return Optional.none();
			};
			const update = (rows$2, columns$2, container, selected, annotations) => {
				const updateSelection = (newSels) => {
					annotations.clearBeforeUpdate(container);
					annotations.selectRange(container, newSels.boxes, newSels.start, newSels.finish);
					return newSels.boxes;
				};
				return shiftSelection(selected, rows$2, columns$2, annotations.firstSelectedSelector, annotations.lastSelectedSelector).map(updateSelection);
			};
			const traverse = (item, mode) => ({
				item,
				mode
			});
			const backtrack = (universe$4, item, _direction, transition = sidestep) => {
				return universe$4.property().parent(item).map((p) => {
					return traverse(p, transition);
				});
			};
			const sidestep = (universe$4, item, direction, transition = advance) => {
				return direction.sibling(universe$4, item).map((p) => {
					return traverse(p, transition);
				});
			};
			const advance = (universe$4, item, direction, transition = advance) => {
				const children$3 = universe$4.property().children(item);
				return direction.first(children$3).map((r$1) => {
					return traverse(r$1, transition);
				});
			};
			const successors = [
				{
					current: backtrack,
					next: sidestep,
					fallback: Optional.none()
				},
				{
					current: sidestep,
					next: advance,
					fallback: Optional.some(backtrack)
				},
				{
					current: advance,
					next: advance,
					fallback: Optional.some(sidestep)
				}
			];
			const go = (universe$4, item, mode, direction, rules = successors) => {
				return find$1(rules, (succ) => {
					return succ.current === mode;
				}).bind((rule) => {
					return rule.current(universe$4, item, direction, rule.next).orThunk(() => {
						return rule.fallback.bind((fb) => {
							return go(universe$4, item, fb, direction);
						});
					});
				});
			};
			const left$1 = () => {
				const sibling = (universe$4, item) => {
					return universe$4.query().prevSibling(item);
				};
				const first$1 = (children$3) => {
					return children$3.length > 0 ? Optional.some(children$3[children$3.length - 1]) : Optional.none();
				};
				return {
					sibling,
					first: first$1
				};
			};
			const right$1 = () => {
				const sibling = (universe$4, item) => {
					return universe$4.query().nextSibling(item);
				};
				const first$1 = (children$3) => {
					return children$3.length > 0 ? Optional.some(children$3[0]) : Optional.none();
				};
				return {
					sibling,
					first: first$1
				};
			};
			const Walkers = {
				left: left$1,
				right: right$1
			};
			const hone = (universe$4, item, predicate, mode, direction, isRoot) => {
				return go(universe$4, item, mode, direction).bind((n) => {
					if (isRoot(n.item)) return Optional.none();
					else return predicate(n.item) ? Optional.some(n.item) : hone(universe$4, n.item, predicate, n.mode, direction, isRoot);
				});
			};
			const left = (universe$4, item, predicate, isRoot) => {
				return hone(universe$4, item, predicate, sidestep, Walkers.left(), isRoot);
			};
			const right = (universe$4, item, predicate, isRoot) => {
				return hone(universe$4, item, predicate, sidestep, Walkers.right(), isRoot);
			};
			const isLeaf = (universe$4) => (element) => universe$4.property().children(element).length === 0;
			const before$1 = (universe$4, item, isRoot) => {
				return seekLeft$1(universe$4, item, isLeaf(universe$4), isRoot);
			};
			const after$2 = (universe$4, item, isRoot) => {
				return seekRight$1(universe$4, item, isLeaf(universe$4), isRoot);
			};
			const seekLeft$1 = left;
			const seekRight$1 = right;
			const universe = DomUniverse();
			const before = (element, isRoot) => {
				return before$1(universe, element, isRoot);
			};
			const after$1 = (element, isRoot) => {
				return after$2(universe, element, isRoot);
			};
			const seekLeft = (element, predicate, isRoot) => {
				return seekLeft$1(universe, element, predicate, isRoot);
			};
			const seekRight = (element, predicate, isRoot) => {
				return seekRight$1(universe, element, predicate, isRoot);
			};
			const ancestor = (scope, predicate, isRoot) => ancestor$2(scope, predicate, isRoot).isSome();
			const adt$2 = Adt.generate([
				{ none: ["message"] },
				{ success: [] },
				{ failedUp: ["cell"] },
				{ failedDown: ["cell"] }
			]);
			const isOverlapping = (bridge, before$2, after$3) => {
				const beforeBounds = bridge.getRect(before$2);
				const afterBounds = bridge.getRect(after$3);
				return afterBounds.right > beforeBounds.left && afterBounds.left < beforeBounds.right;
			};
			const isRow = (elem) => {
				return closest$1(elem, "tr");
			};
			const verify = (bridge, before$2, beforeOffset, after$3, afterOffset, failure, isRoot) => {
				return closest$1(after$3, "td,th", isRoot).bind((afterCell) => {
					return closest$1(before$2, "td,th", isRoot).map((beforeCell) => {
						if (!eq$1(afterCell, beforeCell)) return sharedOne(isRow, [afterCell, beforeCell]).fold(() => {
							return isOverlapping(bridge, beforeCell, afterCell) ? adt$2.success() : failure(beforeCell);
						}, (_sharedRow) => {
							return failure(beforeCell);
						});
						else return eq$1(after$3, afterCell) && getEnd(afterCell) === afterOffset ? failure(beforeCell) : adt$2.none("in same cell");
					});
				}).getOr(adt$2.none("default"));
			};
			const cata = (subject, onNone, onSuccess, onFailedUp, onFailedDown) => {
				return subject.fold(onNone, onSuccess, onFailedUp, onFailedDown);
			};
			const BeforeAfter = {
				...adt$2,
				verify,
				cata
			};
			const inParent = (parent$1, children$3, element, index) => ({
				parent: parent$1,
				children: children$3,
				element,
				index
			});
			const indexInParent = (element) => parent(element).bind((parent$1) => {
				const children$3 = children$2(parent$1);
				return indexOf(children$3, element).map((index) => inParent(parent$1, children$3, element, index));
			});
			const indexOf = (elements, element) => findIndex(elements, curry(eq$1, element));
			const isBr = isTag("br");
			const gatherer = (cand, gather, isRoot) => {
				return gather(cand, isRoot).bind((target) => {
					return isText(target) && get$6(target).trim().length === 0 ? gatherer(target, gather, isRoot) : Optional.some(target);
				});
			};
			const handleBr = (isRoot, element, direction) => {
				return direction.traverse(element).orThunk(() => {
					return gatherer(element, direction.gather, isRoot);
				}).map(direction.relative);
			};
			const findBr = (element, offset) => {
				return child$2(element, offset).filter(isBr).orThunk(() => {
					return child$2(element, offset - 1).filter(isBr);
				});
			};
			const handleParent = (isRoot, element, offset, direction) => {
				return findBr(element, offset).bind((br) => {
					return direction.traverse(br).fold(() => {
						return gatherer(br, direction.gather, isRoot).map(direction.relative);
					}, (adjacent) => {
						return indexInParent(adjacent).map((info) => {
							return Situ.on(info.parent, info.index);
						});
					});
				});
			};
			const tryBr = (isRoot, element, offset, direction) => {
				return (isBr(element) ? handleBr(isRoot, element, direction) : handleParent(isRoot, element, offset, direction)).map((tgt) => {
					return {
						start: tgt,
						finish: tgt
					};
				});
			};
			const process = (analysis) => {
				return BeforeAfter.cata(analysis, (_message) => {
					return Optional.none();
				}, () => {
					return Optional.none();
				}, (cell$1) => {
					return Optional.some(point(cell$1, 0));
				}, (cell$1) => {
					return Optional.some(point(cell$1, getEnd(cell$1)));
				});
			};
			const moveDown = (caret, amount) => {
				return {
					left: caret.left,
					top: caret.top + amount,
					right: caret.right,
					bottom: caret.bottom + amount
				};
			};
			const moveUp = (caret, amount) => {
				return {
					left: caret.left,
					top: caret.top - amount,
					right: caret.right,
					bottom: caret.bottom - amount
				};
			};
			const translate = (caret, xDelta, yDelta) => {
				return {
					left: caret.left + xDelta,
					top: caret.top + yDelta,
					right: caret.right + xDelta,
					bottom: caret.bottom + yDelta
				};
			};
			const getTop = (caret) => {
				return caret.top;
			};
			const getBottom = (caret) => {
				return caret.bottom;
			};
			const getPartialBox = (bridge, element, offset) => {
				if (offset >= 0 && offset < getEnd(element)) return bridge.getRangedRect(element, offset, element, offset + 1);
				else if (offset > 0) return bridge.getRangedRect(element, offset - 1, element, offset);
				return Optional.none();
			};
			const toCaret = (rect) => ({
				left: rect.left,
				top: rect.top,
				right: rect.right,
				bottom: rect.bottom
			});
			const getElemBox = (bridge, element) => {
				return Optional.some(bridge.getRect(element));
			};
			const getBoxAt = (bridge, element, offset) => {
				if (isElement(element)) return getElemBox(bridge, element).map(toCaret);
				else if (isText(element)) return getPartialBox(bridge, element, offset).map(toCaret);
				else return Optional.none();
			};
			const getEntireBox = (bridge, element) => {
				if (isElement(element)) return getElemBox(bridge, element).map(toCaret);
				else if (isText(element)) return bridge.getRangedRect(element, 0, element, getEnd(element)).map(toCaret);
				else return Optional.none();
			};
			const JUMP_SIZE = 5;
			const NUM_RETRIES = 100;
			const adt$1 = Adt.generate([{ none: [] }, { retry: ["caret"] }]);
			const isOutside = (caret, box) => {
				return caret.left < box.left || Math.abs(box.right - caret.left) < 1 || caret.left > box.right;
			};
			const inOutsideBlock = (bridge, element, caret) => {
				return closest$2(element, isBlock).fold(never, (cell$1) => {
					return getEntireBox(bridge, cell$1).exists((box) => {
						return isOutside(caret, box);
					});
				});
			};
			const adjustDown = (bridge, element, guessBox, original, caret) => {
				const lowerCaret = moveDown(caret, JUMP_SIZE);
				if (Math.abs(guessBox.bottom - original.bottom) < 1) return adt$1.retry(lowerCaret);
				else if (guessBox.top > caret.bottom) return adt$1.retry(lowerCaret);
				else if (guessBox.top === caret.bottom) return adt$1.retry(moveDown(caret, 1));
				else return inOutsideBlock(bridge, element, caret) ? adt$1.retry(translate(lowerCaret, JUMP_SIZE, 0)) : adt$1.none();
			};
			const adjustUp = (bridge, element, guessBox, original, caret) => {
				const higherCaret = moveUp(caret, JUMP_SIZE);
				if (Math.abs(guessBox.top - original.top) < 1) return adt$1.retry(higherCaret);
				else if (guessBox.bottom < caret.top) return adt$1.retry(higherCaret);
				else if (guessBox.bottom === caret.top) return adt$1.retry(moveUp(caret, 1));
				else return inOutsideBlock(bridge, element, caret) ? adt$1.retry(translate(higherCaret, JUMP_SIZE, 0)) : adt$1.none();
			};
			const upMovement = {
				point: getTop,
				adjuster: adjustUp,
				move: moveUp,
				gather: before
			};
			const downMovement = {
				point: getBottom,
				adjuster: adjustDown,
				move: moveDown,
				gather: after$1
			};
			const isAtTable = (bridge, x, y) => {
				return bridge.elementFromPoint(x, y).filter((elm) => {
					return name(elm) === "table";
				}).isSome();
			};
			const adjustForTable = (bridge, movement, original, caret, numRetries) => {
				return adjustTil(bridge, movement, original, movement.move(caret, JUMP_SIZE), numRetries);
			};
			const adjustTil = (bridge, movement, original, caret, numRetries) => {
				if (numRetries === 0) return Optional.some(caret);
				if (isAtTable(bridge, caret.left, movement.point(caret))) return adjustForTable(bridge, movement, original, caret, numRetries - 1);
				return bridge.situsFromPoint(caret.left, movement.point(caret)).bind((guess) => {
					return guess.start.fold(Optional.none, (element) => {
						return getEntireBox(bridge, element).bind((guessBox) => {
							return movement.adjuster(bridge, element, guessBox, original, caret).fold(Optional.none, (newCaret) => {
								return adjustTil(bridge, movement, original, newCaret, numRetries - 1);
							});
						}).orThunk(() => {
							return Optional.some(caret);
						});
					}, Optional.none);
				});
			};
			const checkScroll = (movement, adjusted, bridge) => {
				if (movement.point(adjusted) > bridge.getInnerHeight()) return Optional.some(movement.point(adjusted) - bridge.getInnerHeight());
				else if (movement.point(adjusted) < 0) return Optional.some(-movement.point(adjusted));
				else return Optional.none();
			};
			const retry = (movement, bridge, caret) => {
				const moved = movement.move(caret, JUMP_SIZE);
				const adjusted = adjustTil(bridge, movement, caret, moved, NUM_RETRIES).getOr(moved);
				return checkScroll(movement, adjusted, bridge).fold(() => {
					return bridge.situsFromPoint(adjusted.left, movement.point(adjusted));
				}, (delta) => {
					bridge.scrollBy(0, delta);
					return bridge.situsFromPoint(adjusted.left, movement.point(adjusted) - delta);
				});
			};
			const Retries = {
				tryUp: curry(retry, upMovement),
				tryDown: curry(retry, downMovement),
				getJumpSize: constant(JUMP_SIZE)
			};
			const MAX_RETRIES = 20;
			const findSpot = (bridge, isRoot, direction) => {
				return bridge.getSelection().bind((sel) => {
					return tryBr(isRoot, sel.finish, sel.foffset, direction).fold(() => {
						return Optional.some(point(sel.finish, sel.foffset));
					}, (brNeighbour) => {
						const range = bridge.fromSitus(brNeighbour);
						return process(BeforeAfter.verify(bridge, sel.finish, sel.foffset, range.finish, range.foffset, direction.failure, isRoot));
					});
				});
			};
			const scan = (bridge, isRoot, element, offset, direction, numRetries) => {
				if (numRetries === 0) return Optional.none();
				return tryCursor(bridge, isRoot, element, offset, direction).bind((situs) => {
					const range = bridge.fromSitus(situs);
					const analysis = BeforeAfter.verify(bridge, element, offset, range.finish, range.foffset, direction.failure, isRoot);
					return BeforeAfter.cata(analysis, () => {
						return Optional.none();
					}, () => {
						return Optional.some(situs);
					}, (cell$1) => {
						if (eq$1(element, cell$1) && offset === 0) return tryAgain(bridge, element, offset, moveUp, direction);
						else return scan(bridge, isRoot, cell$1, 0, direction, numRetries - 1);
					}, (cell$1) => {
						if (eq$1(element, cell$1) && offset === getEnd(cell$1)) return tryAgain(bridge, element, offset, moveDown, direction);
						else return scan(bridge, isRoot, cell$1, getEnd(cell$1), direction, numRetries - 1);
					});
				});
			};
			const tryAgain = (bridge, element, offset, move, direction) => {
				return getBoxAt(bridge, element, offset).bind((box) => {
					return tryAt(bridge, direction, move(box, Retries.getJumpSize()));
				});
			};
			const tryAt = (bridge, direction, box) => {
				const browser = detect$2().browser;
				if (browser.isChromium() || browser.isSafari() || browser.isFirefox()) return direction.retry(bridge, box);
				else return Optional.none();
			};
			const tryCursor = (bridge, isRoot, element, offset, direction) => {
				return getBoxAt(bridge, element, offset).bind((box) => {
					return tryAt(bridge, direction, box);
				});
			};
			const handle$1 = (bridge, isRoot, direction) => {
				return findSpot(bridge, isRoot, direction).bind((spot) => {
					return scan(bridge, isRoot, spot.element, spot.offset, direction, MAX_RETRIES).map(bridge.fromSitus);
				});
			};
			const inSameTable = (elem, table$1) => {
				return ancestor(elem, (e) => {
					return parent(e).exists((p) => {
						return eq$1(p, table$1);
					});
				});
			};
			const simulate = (bridge, isRoot, direction, initial, anchor) => {
				return closest$1(initial, "td,th", isRoot).bind((start) => {
					return closest$1(start, "table", isRoot).bind((table$1) => {
						if (!inSameTable(anchor, table$1)) return Optional.none();
						return handle$1(bridge, isRoot, direction).bind((range) => {
							return closest$1(range.finish, "td,th", isRoot).map((finish) => {
								return {
									start,
									finish,
									range
								};
							});
						});
					});
				});
			};
			const navigate = (bridge, isRoot, direction, initial, anchor, precheck) => {
				return precheck(initial, isRoot).orThunk(() => {
					return simulate(bridge, isRoot, direction, initial, anchor).map((info) => {
						const range = info.range;
						return Response.create(Optional.some(makeSitus(range.start, range.soffset, range.finish, range.foffset)), true);
					});
				});
			};
			const firstUpCheck = (initial, isRoot) => {
				return closest$1(initial, "tr", isRoot).bind((startRow) => {
					return closest$1(startRow, "table", isRoot).bind((table$1) => {
						if (eq$1(startRow, descendants(table$1, "tr")[0])) return seekLeft(table$1, (element) => {
							return last$1(element).isSome();
						}, isRoot).map((last$3) => {
							const lastOffset = getEnd(last$3);
							return Response.create(Optional.some(makeSitus(last$3, lastOffset, last$3, lastOffset)), true);
						});
						else return Optional.none();
					});
				});
			};
			const lastDownCheck = (initial, isRoot) => {
				return closest$1(initial, "tr", isRoot).bind((startRow) => {
					return closest$1(startRow, "table", isRoot).bind((table$1) => {
						const rows$2 = descendants(table$1, "tr");
						if (eq$1(startRow, rows$2[rows$2.length - 1])) return seekRight(table$1, (element) => {
							return first(element).isSome();
						}, isRoot).map((first$1) => {
							return Response.create(Optional.some(makeSitus(first$1, 0, first$1, 0)), true);
						});
						else return Optional.none();
					});
				});
			};
			const select = (bridge, container, isRoot, direction, initial, anchor, selectRange) => {
				return simulate(bridge, isRoot, direction, initial, anchor).bind((info) => {
					return detect(container, isRoot, info.start, info.finish, selectRange);
				});
			};
			const Cell = (initial) => {
				let value$2 = initial;
				const get$10 = () => {
					return value$2;
				};
				const set$3 = (v) => {
					value$2 = v;
				};
				return {
					get: get$10,
					set: set$3
				};
			};
			const singleton = (doRevoke) => {
				const subject = Cell(Optional.none());
				const revoke = () => subject.get().each(doRevoke);
				const clear$1 = () => {
					revoke();
					subject.set(Optional.none());
				};
				const isSet = () => subject.get().isSome();
				const get$10 = () => subject.get();
				const set$3 = (s) => {
					revoke();
					subject.set(Optional.some(s));
				};
				return {
					clear: clear$1,
					isSet,
					get: get$10,
					set: set$3
				};
			};
			const value = () => {
				const subject = singleton(noop);
				const on = (f) => subject.get().each(f);
				return {
					...subject,
					on
				};
			};
			const findCell = (target, isRoot) => closest$1(target, "td,th", isRoot);
			const isInEditableContext = (cell$1) => parentElement(cell$1).exists(isEditable$1);
			const MouseSelection = (bridge, container, isRoot, annotations) => {
				const cursor = value();
				const clearstate = cursor.clear;
				const applySelection = (event) => {
					cursor.on((start) => {
						annotations.clearBeforeUpdate(container);
						findCell(event.target, isRoot).each((finish) => {
							identify(start, finish, isRoot).each((cellSel) => {
								const boxes = cellSel.boxes.getOr([]);
								if (boxes.length === 1) {
									const singleCell = boxes[0];
									const isNonEditableCell = getRaw(singleCell) === "false";
									const isCellClosestContentEditable = is(closest(event.target), singleCell, eq$1);
									if (isNonEditableCell && isCellClosestContentEditable) {
										annotations.selectRange(container, boxes, singleCell, singleCell);
										bridge.selectContents(singleCell);
									}
								} else if (boxes.length > 1) {
									annotations.selectRange(container, boxes, cellSel.start, cellSel.finish);
									bridge.selectContents(finish);
								}
							});
						});
					});
				};
				const mousedown = (event) => {
					annotations.clear(container);
					findCell(event.target, isRoot).filter(isInEditableContext).each(cursor.set);
				};
				const mouseover = (event) => {
					applySelection(event);
				};
				const mouseup = (event) => {
					applySelection(event);
					clearstate();
				};
				return {
					clearstate,
					mousedown,
					mouseover,
					mouseup
				};
			};
			const down = {
				traverse: nextSibling,
				gather: after$1,
				relative: Situ.before,
				retry: Retries.tryDown,
				failure: BeforeAfter.failedDown
			};
			const up = {
				traverse: prevSibling,
				gather: before,
				relative: Situ.before,
				retry: Retries.tryUp,
				failure: BeforeAfter.failedUp
			};
			const isKey = (key$1) => {
				return (keycode) => {
					return keycode === key$1;
				};
			};
			const isUp = isKey(38);
			const isDown = isKey(40);
			const isNavigation = (keycode) => {
				return keycode >= 37 && keycode <= 40;
			};
			const ltr = {
				isBackward: isKey(37),
				isForward: isKey(39)
			};
			const rtl = {
				isBackward: isKey(39),
				isForward: isKey(37)
			};
			const get$3 = (_DOC) => {
				const doc = _DOC !== void 0 ? _DOC.dom : document;
				return SugarPosition(doc.body.scrollLeft || doc.documentElement.scrollLeft, doc.body.scrollTop || doc.documentElement.scrollTop);
			};
			const by = (x, y, _DOC) => {
				const win = (_DOC !== void 0 ? _DOC.dom : document).defaultView;
				if (win) win.scrollBy(x, y);
			};
			const adt = Adt.generate([
				{ domRange: ["rng"] },
				{ relative: ["startSitu", "finishSitu"] },
				{ exact: [
					"start",
					"soffset",
					"finish",
					"foffset"
				] }
			]);
			const exactFromRange = (simRange) => adt.exact(simRange.start, simRange.soffset, simRange.finish, simRange.foffset);
			const getStart = (selection$1) => selection$1.match({
				domRange: (rng) => SugarElement.fromDom(rng.startContainer),
				relative: (startSitu, _finishSitu) => Situ.getStart(startSitu),
				exact: (start, _soffset, _finish, _foffset) => start
			});
			const domRange = adt.domRange;
			const relative = adt.relative;
			const exact = adt.exact;
			const getWin = (selection$1) => {
				return defaultView(getStart(selection$1));
			};
			const SimSelection = {
				domRange,
				relative,
				exact,
				exactFromRange,
				getWin,
				range: SimRange.create
			};
			const caretPositionFromPoint = (doc, x, y) => {
				var _a, _b;
				return Optional.from((_b = (_a = doc.dom).caretPositionFromPoint) === null || _b === void 0 ? void 0 : _b.call(_a, x, y)).bind((pos) => {
					if (pos.offsetNode === null) return Optional.none();
					const r$1 = doc.dom.createRange();
					r$1.setStart(pos.offsetNode, pos.offset);
					r$1.collapse();
					return Optional.some(r$1);
				});
			};
			const caretRangeFromPoint = (doc, x, y) => {
				var _a, _b;
				return Optional.from((_b = (_a = doc.dom).caretRangeFromPoint) === null || _b === void 0 ? void 0 : _b.call(_a, x, y));
			};
			const availableSearch = (() => {
				if (document.caretPositionFromPoint) return caretPositionFromPoint;
				else if (document.caretRangeFromPoint) return caretRangeFromPoint;
				else return Optional.none;
			})();
			const fromPoint = (win, x, y) => {
				return availableSearch(SugarElement.fromDom(win.document), x, y).map((rng) => SimRange.create(SugarElement.fromDom(rng.startContainer), rng.startOffset, SugarElement.fromDom(rng.endContainer), rng.endOffset));
			};
			const beforeSpecial = (element, offset) => {
				const name$1 = name(element);
				if ("input" === name$1) return Situ.after(element);
				else if (!contains$2(["br", "img"], name$1)) return Situ.on(element, offset);
				else return offset === 0 ? Situ.before(element) : Situ.after(element);
			};
			const preprocessRelative = (startSitu, finishSitu) => {
				const start = startSitu.fold(Situ.before, beforeSpecial, Situ.after);
				const finish = finishSitu.fold(Situ.before, beforeSpecial, Situ.after);
				return SimSelection.relative(start, finish);
			};
			const preprocessExact = (start, soffset, finish, foffset) => {
				const startSitu = beforeSpecial(start, soffset);
				const finishSitu = beforeSpecial(finish, foffset);
				return SimSelection.relative(startSitu, finishSitu);
			};
			const makeRange = (start, soffset, finish, foffset) => {
				const rng = owner(start).dom.createRange();
				rng.setStart(start.dom, soffset);
				rng.setEnd(finish.dom, foffset);
				return rng;
			};
			const after = (start, soffset, finish, foffset) => {
				const r$1 = makeRange(start, soffset, finish, foffset);
				const same = eq$1(start, finish) && soffset === foffset;
				return r$1.collapsed && !same;
			};
			const getNativeSelection = (win) => Optional.from(win.getSelection());
			const doSetNativeRange = (win, rng) => {
				getNativeSelection(win).each((selection$1) => {
					selection$1.removeAllRanges();
					selection$1.addRange(rng);
				});
			};
			const doSetRange = (win, start, soffset, finish, foffset) => {
				doSetNativeRange(win, exactToNative(win, start, soffset, finish, foffset));
			};
			const setLegacyRtlRange = (win, selection$1, start, soffset, finish, foffset) => {
				selection$1.collapse(start.dom, soffset);
				selection$1.extend(finish.dom, foffset);
			};
			const setRangeFromRelative = (win, relative$1) => diagnose(win, relative$1).match({
				ltr: (start, soffset, finish, foffset) => {
					doSetRange(win, start, soffset, finish, foffset);
				},
				rtl: (start, soffset, finish, foffset) => {
					getNativeSelection(win).each((selection$1) => {
						if (selection$1.setBaseAndExtent) selection$1.setBaseAndExtent(start.dom, soffset, finish.dom, foffset);
						else if (selection$1.extend) try {
							setLegacyRtlRange(win, selection$1, start, soffset, finish, foffset);
						} catch (e) {
							doSetRange(win, finish, foffset, start, soffset);
						}
						else doSetRange(win, finish, foffset, start, soffset);
					});
				}
			});
			const setExact = (win, start, soffset, finish, foffset) => {
				setRangeFromRelative(win, preprocessExact(start, soffset, finish, foffset));
			};
			const setRelative = (win, startSitu, finishSitu) => {
				setRangeFromRelative(win, preprocessRelative(startSitu, finishSitu));
			};
			const readRange = (selection$1) => {
				if (selection$1.rangeCount > 0) {
					const firstRng = selection$1.getRangeAt(0);
					const lastRng = selection$1.getRangeAt(selection$1.rangeCount - 1);
					return Optional.some(SimRange.create(SugarElement.fromDom(firstRng.startContainer), firstRng.startOffset, SugarElement.fromDom(lastRng.endContainer), lastRng.endOffset));
				} else return Optional.none();
			};
			const doGetExact = (selection$1) => {
				if (selection$1.anchorNode === null || selection$1.focusNode === null) return readRange(selection$1);
				else {
					const anchor = SugarElement.fromDom(selection$1.anchorNode);
					const focus = SugarElement.fromDom(selection$1.focusNode);
					return after(anchor, selection$1.anchorOffset, focus, selection$1.focusOffset) ? Optional.some(SimRange.create(anchor, selection$1.anchorOffset, focus, selection$1.focusOffset)) : readRange(selection$1);
				}
			};
			const setToElement = (win, element, selectNodeContents$1 = true) => {
				doSetNativeRange(win, (selectNodeContents$1 ? selectNodeContents : selectNode)(win, element));
			};
			const getExact = (win) => getNativeSelection(win).filter((sel) => sel.rangeCount > 0).bind(doGetExact);
			const get$2 = (win) => getExact(win).map((range) => SimSelection.exact(range.start, range.soffset, range.finish, range.foffset));
			const getFirstRect = (win, selection$1) => {
				return getFirstRect$1(asLtrRange(win, selection$1));
			};
			const getAtPoint = (win, x, y) => fromPoint(win, x, y);
			const clear = (win) => {
				getNativeSelection(win).each((selection$1) => selection$1.removeAllRanges());
			};
			const WindowBridge = (win) => {
				const elementFromPoint = (x, y) => {
					return SugarElement.fromPoint(SugarElement.fromDom(win.document), x, y);
				};
				const getRect = (element) => {
					return element.dom.getBoundingClientRect();
				};
				const getRangedRect = (start, soffset, finish, foffset) => {
					return getFirstRect(win, SimSelection.exact(start, soffset, finish, foffset));
				};
				const getSelection = () => {
					return get$2(win).map((exactAdt) => {
						return convertToRange(win, exactAdt);
					});
				};
				const fromSitus = (situs) => {
					return convertToRange(win, SimSelection.relative(situs.start, situs.finish));
				};
				const situsFromPoint = (x, y) => {
					return getAtPoint(win, x, y).map((exact$1) => {
						return Situs.create(exact$1.start, exact$1.soffset, exact$1.finish, exact$1.foffset);
					});
				};
				const clearSelection = () => {
					clear(win);
				};
				const collapseSelection = (toStart = false) => {
					get$2(win).each((sel) => sel.fold((rng) => rng.collapse(toStart), (startSitu, finishSitu) => {
						const situ = toStart ? startSitu : finishSitu;
						setRelative(win, situ, situ);
					}, (start, soffset, finish, foffset) => {
						const node = toStart ? start : finish;
						const offset = toStart ? soffset : foffset;
						setExact(win, node, offset, node, offset);
					}));
				};
				const selectNode$1 = (element) => {
					setToElement(win, element, false);
				};
				const selectContents = (element) => {
					setToElement(win, element);
				};
				const setSelection = (sel) => {
					setExact(win, sel.start, sel.soffset, sel.finish, sel.foffset);
				};
				const setRelativeSelection = (start, finish) => {
					setRelative(win, start, finish);
				};
				const getInnerHeight = () => {
					return win.innerHeight;
				};
				const getScrollY = () => {
					return get$3(SugarElement.fromDom(win.document)).top;
				};
				const scrollBy = (x, y) => {
					by(x, y, SugarElement.fromDom(win.document));
				};
				return {
					elementFromPoint,
					getRect,
					getRangedRect,
					getSelection,
					fromSitus,
					situsFromPoint,
					clearSelection,
					collapseSelection,
					setSelection,
					setRelativeSelection,
					selectNode: selectNode$1,
					selectContents,
					getInnerHeight,
					getScrollY,
					scrollBy
				};
			};
			const rc = (rows$2, cols) => ({
				rows: rows$2,
				cols
			});
			const mouse = (win, container, isRoot, annotations) => {
				const handlers = MouseSelection(WindowBridge(win), container, isRoot, annotations);
				return {
					clearstate: handlers.clearstate,
					mousedown: handlers.mousedown,
					mouseover: handlers.mouseover,
					mouseup: handlers.mouseup
				};
			};
			const isEditableNode = (node) => closest$2(node, isHTMLElement).exists(isEditable$1);
			const isEditableSelection = (start, finish) => isEditableNode(start) || isEditableNode(finish);
			const keyboard = (win, container, isRoot, annotations) => {
				const bridge = WindowBridge(win);
				const clearToNavigate = () => {
					annotations.clear(container);
					return Optional.none();
				};
				const keydown = (event, start, soffset, finish, foffset, direction) => {
					const realEvent = event.raw;
					const keycode = realEvent.which;
					const shiftKey = realEvent.shiftKey === true;
					return retrieve$1(container, annotations.selectedSelector).fold(() => {
						if (isNavigation(keycode) && !shiftKey) annotations.clearBeforeUpdate(container);
						if (isNavigation(keycode) && shiftKey && !isEditableSelection(start, finish)) return Optional.none;
						else if (isDown(keycode) && shiftKey) return curry(select, bridge, container, isRoot, down, finish, start, annotations.selectRange);
						else if (isUp(keycode) && shiftKey) return curry(select, bridge, container, isRoot, up, finish, start, annotations.selectRange);
						else if (isDown(keycode)) return curry(navigate, bridge, isRoot, down, finish, start, lastDownCheck);
						else if (isUp(keycode)) return curry(navigate, bridge, isRoot, up, finish, start, firstUpCheck);
						else return Optional.none;
					}, (selected) => {
						const update$1 = (attempts) => {
							return () => {
								return findMap(attempts, (delta) => {
									return update(delta.rows, delta.cols, container, selected, annotations);
								}).fold(() => {
									return getEdges(container, annotations.firstSelectedSelector, annotations.lastSelectedSelector).map((edges) => {
										const relative$1 = isDown(keycode) || direction.isForward(keycode) ? Situ.after : Situ.before;
										bridge.setRelativeSelection(Situ.on(edges.first, 0), relative$1(edges.table));
										annotations.clear(container);
										return Response.create(Optional.none(), true);
									});
								}, (_) => {
									return Optional.some(Response.create(Optional.none(), true));
								});
							};
						};
						if (isNavigation(keycode) && shiftKey && !isEditableSelection(start, finish)) return Optional.none;
						else if (isDown(keycode) && shiftKey) return update$1([rc(1, 0)]);
						else if (isUp(keycode) && shiftKey) return update$1([rc(-1, 0)]);
						else if (direction.isBackward(keycode) && shiftKey) return update$1([rc(0, -1), rc(-1, 0)]);
						else if (direction.isForward(keycode) && shiftKey) return update$1([rc(0, 1), rc(1, 0)]);
						else if (isNavigation(keycode) && !shiftKey) return clearToNavigate;
						else return Optional.none;
					})();
				};
				const keyup = (event, start, soffset, finish, foffset) => {
					return retrieve$1(container, annotations.selectedSelector).fold(() => {
						const realEvent = event.raw;
						const keycode = realEvent.which;
						if (!(realEvent.shiftKey === true)) return Optional.none();
						if (isNavigation(keycode) && isEditableSelection(start, finish)) return sync(container, isRoot, start, soffset, finish, foffset, annotations.selectRange);
						else return Optional.none();
					}, Optional.none);
				};
				return {
					keydown,
					keyup
				};
			};
			const external = (win, container, isRoot, annotations) => {
				const bridge = WindowBridge(win);
				return (start, finish) => {
					annotations.clearBeforeUpdate(container);
					identify(start, finish, isRoot).each((cellSel) => {
						const boxes = cellSel.boxes.getOr([]);
						annotations.selectRange(container, boxes, cellSel.start, cellSel.finish);
						bridge.selectContents(finish);
						bridge.collapseSelection();
					});
				};
			};
			const read = (element, attr) => {
				const value$2 = get$b(element, attr);
				return value$2 === void 0 || value$2 === "" ? [] : value$2.split(" ");
			};
			const add$2 = (element, attr, id) => {
				set$2(element, attr, read(element, attr).concat([id]).join(" "));
				return true;
			};
			const remove$4 = (element, attr, id) => {
				const nu$3 = filter$2(read(element, attr), (v) => v !== id);
				if (nu$3.length > 0) set$2(element, attr, nu$3.join(" "));
				else remove$7(element, attr);
				return false;
			};
			const supports = (element) => element.dom.classList !== void 0;
			const get$1 = (element) => read(element, "class");
			const add$1 = (element, clazz) => add$2(element, "class", clazz);
			const remove$3 = (element, clazz) => remove$4(element, "class", clazz);
			const add = (element, clazz) => {
				if (supports(element)) element.dom.classList.add(clazz);
				else add$1(element, clazz);
			};
			const cleanClass = (element) => {
				if ((supports(element) ? element.dom.classList : get$1(element)).length === 0) remove$7(element, "class");
			};
			const remove$2 = (element, clazz) => {
				if (supports(element)) element.dom.classList.remove(clazz);
				else remove$3(element, clazz);
				cleanClass(element);
			};
			const has = (element, clazz) => supports(element) && element.dom.classList.contains(clazz);
			const remove$1 = (element, classes) => {
				each$2(classes, (x) => {
					remove$2(element, x);
				});
			};
			const addClass = (clazz) => (element) => {
				add(element, clazz);
			};
			const removeClasses = (classes) => (element) => {
				remove$1(element, classes);
			};
			const byClass = (ephemera$1) => {
				const addSelectionClass = addClass(ephemera$1.selected);
				const removeSelectionClasses = removeClasses([
					ephemera$1.selected,
					ephemera$1.lastSelected,
					ephemera$1.firstSelected
				]);
				const clear$1 = (container) => {
					each$2(descendants(container, ephemera$1.selectedSelector), removeSelectionClasses);
				};
				const selectRange = (container, cells$2, start, finish) => {
					clear$1(container);
					each$2(cells$2, addSelectionClass);
					add(start, ephemera$1.firstSelected);
					add(finish, ephemera$1.lastSelected);
				};
				return {
					clearBeforeUpdate: clear$1,
					clear: clear$1,
					selectRange,
					selectedSelector: ephemera$1.selectedSelector,
					firstSelectedSelector: ephemera$1.firstSelectedSelector,
					lastSelectedSelector: ephemera$1.lastSelectedSelector
				};
			};
			const byAttr = (ephemera$1, onSelection, onClear) => {
				const removeSelectionAttributes = (element) => {
					remove$7(element, ephemera$1.selected);
					remove$7(element, ephemera$1.firstSelected);
					remove$7(element, ephemera$1.lastSelected);
				};
				const addSelectionAttribute = (element) => {
					set$2(element, ephemera$1.selected, "1");
				};
				const clear$1 = (container) => {
					clearBeforeUpdate(container);
					onClear();
				};
				const clearBeforeUpdate = (container) => {
					each$2(descendants(container, `${ephemera$1.selectedSelector},${ephemera$1.firstSelectedSelector},${ephemera$1.lastSelectedSelector}`), removeSelectionAttributes);
				};
				const selectRange = (container, cells$2, start, finish) => {
					clear$1(container);
					each$2(cells$2, addSelectionAttribute);
					set$2(start, ephemera$1.firstSelected, "1");
					set$2(finish, ephemera$1.lastSelected, "1");
					onSelection(cells$2, start, finish);
				};
				return {
					clearBeforeUpdate,
					clear: clear$1,
					selectRange,
					selectedSelector: ephemera$1.selectedSelector,
					firstSelectedSelector: ephemera$1.firstSelectedSelector,
					lastSelectedSelector: ephemera$1.lastSelectedSelector
				};
			};
			const SelectionAnnotation = {
				byClass,
				byAttr
			};
			const fold = (subject, onNone, onMultiple, onSingle) => {
				switch (subject.tag) {
					case "none": return onNone();
					case "single": return onSingle(subject.element);
					case "multiple": return onMultiple(subject.elements);
				}
			};
			const none = () => ({ tag: "none" });
			const multiple = (elements) => ({
				tag: "multiple",
				elements
			});
			const single = (element) => ({
				tag: "single",
				element
			});
			const Selections = (lazyRoot, getStart$2, selectedSelector) => {
				const get$10 = () => retrieve(lazyRoot(), selectedSelector).fold(() => getStart$2().fold(none, single), multiple);
				return { get: get$10 };
			};
			const getUpOrLeftCells = (grid$1, selectedCells) => {
				return bind$2(toDetailList(grid$1.slice(0, selectedCells[selectedCells.length - 1].row + 1)), (detail$1) => {
					return map$1(detail$1.cells.slice(0, selectedCells[selectedCells.length - 1].column + 1), (cell$1) => cell$1.element);
				});
			};
			const getDownOrRightCells = (grid$1, selectedCells) => {
				return bind$2(toDetailList(grid$1.slice(selectedCells[0].row + selectedCells[0].rowspan - 1, grid$1.length)), (detail$1) => {
					return map$1(detail$1.cells.slice(selectedCells[0].column + selectedCells[0].colspan - 1, detail$1.cells.length), (cell$1) => cell$1.element);
				});
			};
			const getOtherCells = (table$1, target, generators) => {
				const warehouse = Warehouse.fromTable(table$1);
				return onCells(warehouse, target).map((selectedCells) => {
					const { rows: rows$2 } = extractGridDetails(toGrid(warehouse, generators, false));
					return {
						upOrLeftCells: getUpOrLeftCells(rows$2, selectedCells),
						downOrRightCells: getDownOrRightCells(rows$2, selectedCells)
					};
				});
			};
			const mkEvent = (target, x, y, stop, prevent, kill, raw) => ({
				target,
				x,
				y,
				stop,
				prevent,
				kill,
				raw
			});
			const fromRawEvent$1 = (rawEvent) => {
				const target = SugarElement.fromDom(getOriginalEventTarget(rawEvent).getOr(rawEvent.target));
				const stop = () => rawEvent.stopPropagation();
				const prevent = () => rawEvent.preventDefault();
				const kill = compose(prevent, stop);
				return mkEvent(target, rawEvent.clientX, rawEvent.clientY, stop, prevent, kill, rawEvent);
			};
			const handle = (filter$3, handler) => (rawEvent) => {
				if (filter$3(rawEvent)) handler(fromRawEvent$1(rawEvent));
			};
			const binder = (element, event, filter$3, handler, useCapture) => {
				const wrapped = handle(filter$3, handler);
				element.dom.addEventListener(event, wrapped, useCapture);
				return { unbind: curry(unbind, element, event, wrapped, useCapture) };
			};
			const bind$1 = (element, event, filter$3, handler) => binder(element, event, filter$3, handler, false);
			const unbind = (element, event, handler, useCapture) => {
				element.dom.removeEventListener(event, handler, useCapture);
			};
			const filter = always;
			const bind = (element, event, handler) => bind$1(element, event, filter, handler);
			const fromRawEvent = fromRawEvent$1;
			const hasInternalTarget = (e) => !has(SugarElement.fromDom(e.target), "ephox-snooker-resizer-bar");
			const TableCellSelectionHandler = (editor, resizeHandler) => {
				const cellSelection = Selections(() => SugarElement.fromDom(editor.getBody()), () => getSelectionCell(getSelectionStart(editor), getIsRoot(editor)), ephemera.selectedSelector);
				const onSelection = (cells$2, start, finish) => {
					table(start).each((table$1) => {
						const cloneFormats$1 = getTableCloneElements(editor);
						const generators = cellOperations(noop, SugarElement.fromDom(editor.getDoc()), cloneFormats$1);
						fireTableSelectionChange(editor, cells$2, start, finish, getOtherCells(table$1, { selection: getCellsFromSelection(editor) }, generators));
					});
				};
				const onClear = () => fireTableSelectionClear(editor);
				const annotations = SelectionAnnotation.byAttr(ephemera, onSelection, onClear);
				editor.on("init", (_e) => {
					const win = editor.getWin();
					const body$2 = getBody(editor);
					const isRoot = getIsRoot(editor);
					const syncSelection = () => {
						const sel = editor.selection;
						sharedOne(table, [SugarElement.fromDom(sel.getStart()), SugarElement.fromDom(sel.getEnd())]).fold(() => annotations.clear(body$2), noop);
					};
					const mouseHandlers = mouse(win, body$2, isRoot, annotations);
					const keyHandlers = keyboard(win, body$2, isRoot, annotations);
					const external$1 = external(win, body$2, isRoot, annotations);
					const hasShiftKey = (event) => event.raw.shiftKey === true;
					editor.on("TableSelectorChange", (e) => external$1(e.start, e.finish));
					const handleResponse = (event, response) => {
						if (!hasShiftKey(event)) return;
						if (response.kill) event.kill();
						response.selection.each((ns) => {
							const rng = asLtrRange(win, SimSelection.relative(ns.start, ns.finish));
							editor.selection.setRng(rng);
						});
					};
					const keyup = (event) => {
						const wrappedEvent = fromRawEvent(event);
						if (wrappedEvent.raw.shiftKey && isNavigation(wrappedEvent.raw.which)) {
							const rng = editor.selection.getRng();
							const start = SugarElement.fromDom(rng.startContainer);
							const end = SugarElement.fromDom(rng.endContainer);
							keyHandlers.keyup(wrappedEvent, start, rng.startOffset, end, rng.endOffset).each((response) => {
								handleResponse(wrappedEvent, response);
							});
						}
					};
					const keydown = (event) => {
						const wrappedEvent = fromRawEvent(event);
						resizeHandler.hide();
						const rng = editor.selection.getRng();
						const start = SugarElement.fromDom(rng.startContainer);
						const end = SugarElement.fromDom(rng.endContainer);
						const direction = onDirection(ltr, rtl)(SugarElement.fromDom(editor.selection.getStart()));
						keyHandlers.keydown(wrappedEvent, start, rng.startOffset, end, rng.endOffset, direction).each((response) => {
							handleResponse(wrappedEvent, response);
						});
						resizeHandler.show();
					};
					const isLeftMouse = (raw) => raw.button === 0;
					const isLeftButtonPressed = (raw) => {
						if (raw.buttons === void 0) return true;
						return (raw.buttons & 1) !== 0;
					};
					const dragStart = (_e$1) => {
						mouseHandlers.clearstate();
					};
					const mouseDown = (e) => {
						if (isLeftMouse(e) && hasInternalTarget(e)) mouseHandlers.mousedown(fromRawEvent(e));
					};
					const mouseOver = (e) => {
						if (isLeftButtonPressed(e) && hasInternalTarget(e)) mouseHandlers.mouseover(fromRawEvent(e));
					};
					const mouseUp = (e) => {
						if (isLeftMouse(e) && hasInternalTarget(e)) mouseHandlers.mouseup(fromRawEvent(e));
					};
					const getDoubleTap = () => {
						const lastTarget = Cell(SugarElement.fromDom(body$2));
						const lastTimeStamp = Cell(0);
						const touchEnd = (t) => {
							const target = SugarElement.fromDom(t.target);
							if (isTag("td")(target) || isTag("th")(target)) {
								const lT = lastTarget.get();
								const lTS = lastTimeStamp.get();
								if (eq$1(lT, target) && t.timeStamp - lTS < 300) {
									t.preventDefault();
									external$1(target, target);
								}
							}
							lastTarget.set(target);
							lastTimeStamp.set(t.timeStamp);
						};
						return { touchEnd };
					};
					const doubleTap = getDoubleTap();
					editor.on("dragstart", dragStart);
					editor.on("mousedown", mouseDown);
					editor.on("mouseover", mouseOver);
					editor.on("mouseup", mouseUp);
					editor.on("touchend", doubleTap.touchEnd);
					editor.on("keyup", keyup);
					editor.on("keydown", keydown);
					editor.on("NodeChange", syncSelection);
				});
				editor.on("PreInit", () => {
					editor.serializer.addTempAttr(ephemera.firstSelected);
					editor.serializer.addTempAttr(ephemera.lastSelected);
				});
				const clearSelectedCells = (container) => annotations.clear(SugarElement.fromDom(container));
				const getSelectedCells = () => fold(cellSelection.get(), constant([]), (cells$2) => {
					return map$1(cells$2, (cell$1) => cell$1.dom);
				}, (cell$1) => [cell$1.dom]);
				return {
					getSelectedCells,
					clearSelectedCells
				};
			};
			const Event$1 = (fields) => {
				let handlers = [];
				const bind$3 = (handler) => {
					if (handler === void 0) throw new Error("Event bind error: undefined handler");
					handlers.push(handler);
				};
				const unbind$1 = (handler) => {
					handlers = filter$2(handlers, (h) => {
						return h !== handler;
					});
				};
				const trigger = (...args) => {
					const event = {};
					each$2(fields, (name$1, i) => {
						event[name$1] = args[i];
					});
					each$2(handlers, (handler) => {
						handler(event);
					});
				};
				return {
					bind: bind$3,
					unbind: unbind$1,
					trigger
				};
			};
			const create$1 = (typeDefs) => {
				return {
					registry: map(typeDefs, (event) => {
						return {
							bind: event.bind,
							unbind: event.unbind
						};
					}),
					trigger: map(typeDefs, (event) => {
						return event.trigger;
					})
				};
			};
			const last = (fn, rate) => {
				let timer = null;
				const cancel = () => {
					if (!isNull(timer)) {
						clearTimeout(timer);
						timer = null;
					}
				};
				const throttle = (...args) => {
					cancel();
					timer = setTimeout(() => {
						timer = null;
						fn.apply(null, args);
					}, rate);
				};
				return {
					cancel,
					throttle
				};
			};
			const sort = (arr) => {
				return arr.slice(0).sort();
			};
			const reqMessage = (required, keys$1) => {
				throw new Error("All required keys (" + sort(required).join(", ") + ") were not specified. Specified keys were: " + sort(keys$1).join(", ") + ".");
			};
			const unsuppMessage = (unsupported) => {
				throw new Error("Unsupported keys for object: " + sort(unsupported).join(", "));
			};
			const validateStrArr = (label, array) => {
				if (!isArray(array)) throw new Error("The " + label + " fields must be an array. Was: " + array + ".");
				each$2(array, (a) => {
					if (!isString(a)) throw new Error("The value " + a + " in the " + label + " fields was not a string.");
				});
			};
			const invalidTypeMessage = (incorrect, type$1) => {
				throw new Error("All values need to be of type: " + type$1 + ". Keys (" + sort(incorrect).join(", ") + ") were not.");
			};
			const checkDupes = (everything) => {
				const sorted = sort(everything);
				find$1(sorted, (s, i) => {
					return i < sorted.length - 1 && s === sorted[i + 1];
				}).each((d) => {
					throw new Error("The field: " + d + " occurs more than once in the combined fields: [" + sorted.join(", ") + "].");
				});
			};
			const base = (handleUnsupported, required) => {
				return baseWith(handleUnsupported, required, {
					validate: isFunction,
					label: "function"
				});
			};
			const baseWith = (handleUnsupported, required, pred) => {
				if (required.length === 0) throw new Error("You must specify at least one required field.");
				validateStrArr("required", required);
				checkDupes(required);
				return (obj) => {
					const keys$1 = keys(obj);
					if (!forall(required, (req) => {
						return contains$2(keys$1, req);
					})) reqMessage(required, keys$1);
					handleUnsupported(required, keys$1);
					const invalidKeys = filter$2(required, (key$1) => {
						return !pred.validate(obj[key$1], key$1);
					});
					if (invalidKeys.length > 0) invalidTypeMessage(invalidKeys, pred.label);
					return obj;
				};
			};
			const handleExact = (required, keys$1) => {
				const unsupported = filter$2(keys$1, (key$1) => {
					return !contains$2(required, key$1);
				});
				if (unsupported.length > 0) unsuppMessage(unsupported);
			};
			const exactly = (required) => base(handleExact, required);
			const DragMode = exactly([
				"compare",
				"extract",
				"mutate",
				"sink"
			]);
			const DragSink = exactly([
				"element",
				"start",
				"stop",
				"destroy"
			]);
			const DragApi = exactly([
				"forceDrop",
				"drop",
				"move",
				"delayDrop"
			]);
			const InDrag = () => {
				let previous = Optional.none();
				const reset = () => {
					previous = Optional.none();
				};
				const update$1 = (mode, nu$3) => {
					const result = previous.map((old) => {
						return mode.compare(old, nu$3);
					});
					previous = Optional.some(nu$3);
					return result;
				};
				const onEvent = (event, mode) => {
					mode.extract(event).each((data) => {
						update$1(mode, data).each((d) => {
							events.trigger.move(d);
						});
					});
				};
				const events = create$1({ move: Event$1(["info"]) });
				return {
					onEvent,
					reset,
					events: events.registry
				};
			};
			const NoDrag = () => {
				return {
					onEvent: noop,
					reset: noop,
					events: create$1({ move: Event$1(["info"]) }).registry
				};
			};
			const Movement = () => {
				const noDragState = NoDrag();
				const inDragState = InDrag();
				let dragState = noDragState;
				const on = () => {
					dragState.reset();
					dragState = inDragState;
				};
				const off = () => {
					dragState.reset();
					dragState = noDragState;
				};
				const onEvent = (event, mode) => {
					dragState.onEvent(event, mode);
				};
				const isOn = () => {
					return dragState === inDragState;
				};
				return {
					on,
					off,
					isOn,
					onEvent,
					events: inDragState.events
				};
			};
			const setup = (mutation, mode, settings) => {
				let active = false;
				const events = create$1({
					start: Event$1([]),
					stop: Event$1([])
				});
				const movement = Movement();
				const drop = () => {
					sink$1.stop();
					if (movement.isOn()) {
						movement.off();
						events.trigger.stop();
					}
				};
				const throttledDrop = last(drop, 200);
				const go$1 = (parent$1) => {
					sink$1.start(parent$1);
					movement.on();
					events.trigger.start();
				};
				const mousemove = (event) => {
					throttledDrop.cancel();
					movement.onEvent(event, mode);
				};
				movement.events.move.bind((event) => {
					mode.mutate(mutation, event.info);
				});
				const on = () => {
					active = true;
				};
				const off = () => {
					active = false;
				};
				const isActive = () => active;
				const runIfActive = (f) => {
					return (...args) => {
						if (active) f.apply(null, args);
					};
				};
				const sink$1 = mode.sink(DragApi({
					forceDrop: drop,
					drop: runIfActive(drop),
					move: runIfActive(mousemove),
					delayDrop: runIfActive(throttledDrop.throttle)
				}), settings);
				const destroy$1 = () => {
					sink$1.destroy();
				};
				return {
					element: sink$1.element,
					go: go$1,
					on,
					off,
					isActive,
					destroy: destroy$1,
					events: events.registry
				};
			};
			const css = (namespace) => {
				const dashNamespace = namespace.replace(/\./g, "-");
				const resolve$3 = (str) => {
					return dashNamespace + "-" + str;
				};
				return { resolve: resolve$3 };
			};
			const resolve$1 = css("ephox-dragster").resolve;
			const Blocker = (options) => {
				const settings = {
					layerClass: resolve$1("blocker"),
					...options
				};
				const div = SugarElement.fromTag("div");
				set$2(div, "role", "presentation");
				setAll(div, {
					position: "fixed",
					left: "0px",
					top: "0px",
					width: "100%",
					height: "100%"
				});
				add(div, resolve$1("blocker"));
				add(div, settings.layerClass);
				const element = constant(div);
				const destroy$1 = () => {
					remove$6(div);
				};
				return {
					element,
					destroy: destroy$1
				};
			};
			const compare = (old, nu$3) => {
				return SugarPosition(nu$3.left - old.left, nu$3.top - old.top);
			};
			const extract = (event) => {
				return Optional.some(SugarPosition(event.x, event.y));
			};
			const mutate = (mutation, info) => {
				mutation.mutate(info.left, info.top);
			};
			const sink = (dragApi, settings) => {
				const blocker = Blocker(settings);
				const mdown = bind(blocker.element(), "mousedown", dragApi.forceDrop);
				const mup = bind(blocker.element(), "mouseup", dragApi.drop);
				const mmove = bind(blocker.element(), "mousemove", dragApi.move);
				const mout = bind(blocker.element(), "mouseout", dragApi.delayDrop);
				const destroy$1 = () => {
					blocker.destroy();
					mup.unbind();
					mmove.unbind();
					mout.unbind();
					mdown.unbind();
				};
				const start = (parent$1) => {
					append$1(parent$1, blocker.element());
				};
				const stop = () => {
					remove$6(blocker.element());
				};
				return DragSink({
					element: blocker.element,
					start,
					stop,
					destroy: destroy$1
				});
			};
			var MouseDrag = DragMode({
				compare,
				extract,
				sink,
				mutate
			});
			const transform = (mutation, settings = {}) => {
				var _a;
				return setup(mutation, (_a = settings.mode) !== null && _a !== void 0 ? _a : MouseDrag, settings);
			};
			const resolve = css("ephox-snooker").resolve;
			const Mutation = () => {
				const events = create$1({ drag: Event$1(["xDelta", "yDelta"]) });
				const mutate$2 = (x, y) => {
					events.trigger.drag(x, y);
				};
				return {
					mutate: mutate$2,
					events: events.registry
				};
			};
			const BarMutation = () => {
				const events = create$1({ drag: Event$1([
					"xDelta",
					"yDelta",
					"target"
				]) });
				let target = Optional.none();
				const delegate = Mutation();
				delegate.events.drag.bind((event) => {
					target.each((t) => {
						events.trigger.drag(event.xDelta, event.yDelta, t);
					});
				});
				const assign = (t) => {
					target = Optional.some(t);
				};
				const get$10 = () => {
					return target;
				};
				return {
					assign,
					get: get$10,
					mutate: delegate.mutate,
					events: events.registry
				};
			};
			const col = (column, x, y, w, h) => {
				const bar = SugarElement.fromTag("div");
				setAll(bar, {
					position: "absolute",
					left: x - w / 2 + "px",
					top: y + "px",
					height: h + "px",
					width: w + "px"
				});
				setAll$1(bar, {
					"data-column": column,
					"role": "presentation"
				});
				return bar;
			};
			const row = (r$1, x, y, w, h) => {
				const bar = SugarElement.fromTag("div");
				setAll(bar, {
					position: "absolute",
					left: x + "px",
					top: y - h / 2 + "px",
					height: h + "px",
					width: w + "px"
				});
				setAll$1(bar, {
					"data-row": r$1,
					"role": "presentation"
				});
				return bar;
			};
			const resizeBar = resolve("resizer-bar");
			const resizeRowBar = resolve("resizer-rows");
			const resizeColBar = resolve("resizer-cols");
			const BAR_THICKNESS = 7;
			const resizableRows = (warehouse, isResizable$1) => bind$2(warehouse.all, (row$1, i) => isResizable$1(row$1.element) ? [i] : []);
			const resizableColumns = (warehouse, isResizable$1) => {
				const resizableCols = [];
				range$1(warehouse.grid.columns, (index) => {
					if (Warehouse.getColumnAt(warehouse, index).map((col$1) => col$1.element).forall(isResizable$1)) resizableCols.push(index);
				});
				return filter$2(resizableCols, (colIndex) => {
					return forall(Warehouse.filterItems(warehouse, (cell$1) => cell$1.column === colIndex), (cell$1) => isResizable$1(cell$1.element));
				});
			};
			const destroy = (wire) => {
				each$2(descendants(wire.parent(), "." + resizeBar), remove$6);
			};
			const drawBar = (wire, positions, create$5) => {
				const origin = wire.origin();
				each$2(positions, (cpOption) => {
					cpOption.each((cp) => {
						const bar = create$5(origin, cp);
						add(bar, resizeBar);
						append$1(wire.parent(), bar);
					});
				});
			};
			const refreshCol = (wire, colPositions, position, tableHeight) => {
				drawBar(wire, colPositions, (origin, cp) => {
					const colBar = col(cp.col, cp.x - origin.left, position.top - origin.top, BAR_THICKNESS, tableHeight);
					add(colBar, resizeColBar);
					return colBar;
				});
			};
			const refreshRow = (wire, rowPositions, position, tableWidth) => {
				drawBar(wire, rowPositions, (origin, cp) => {
					const rowBar = row(cp.row, position.left - origin.left, cp.y - origin.top, tableWidth, BAR_THICKNESS);
					add(rowBar, resizeRowBar);
					return rowBar;
				});
			};
			const refreshGrid = (warhouse, wire, table$1, rows$2, cols) => {
				const position = absolute(table$1);
				const isResizable$1 = wire.isResizable;
				const rowPositions = rows$2.length > 0 ? height.positions(rows$2, table$1) : [];
				const resizableRowBars = rowPositions.length > 0 ? resizableRows(warhouse, isResizable$1) : [];
				refreshRow(wire, filter$2(rowPositions, (_pos, i) => exists(resizableRowBars, (barIndex) => i === barIndex)), position, getOuter$2(table$1));
				const colPositions = cols.length > 0 ? width.positions(cols, table$1) : [];
				const resizableColBars = colPositions.length > 0 ? resizableColumns(warhouse, isResizable$1) : [];
				refreshCol(wire, filter$2(colPositions, (_pos, i) => exists(resizableColBars, (barIndex) => i === barIndex)), position, getOuter$1(table$1));
			};
			const refresh = (wire, table$1) => {
				destroy(wire);
				if (wire.isResizable(table$1)) {
					const warehouse = Warehouse.fromTable(table$1);
					refreshGrid(warehouse, wire, table$1, rows(warehouse), columns(warehouse));
				}
			};
			const each = (wire, f) => {
				each$2(descendants(wire.parent(), "." + resizeBar), f);
			};
			const hide = (wire) => {
				each(wire, (bar) => {
					set$1(bar, "display", "none");
				});
			};
			const show = (wire) => {
				each(wire, (bar) => {
					set$1(bar, "display", "block");
				});
			};
			const isRowBar = (element) => {
				return has(element, resizeRowBar);
			};
			const isColBar = (element) => {
				return has(element, resizeColBar);
			};
			const resizeBarDragging = resolve("resizer-bar-dragging");
			const BarManager = (wire) => {
				const mutation = BarMutation();
				const resizing = transform(mutation, {});
				let hoverTable = Optional.none();
				const getResizer = (element, type$1) => {
					return Optional.from(get$b(element, type$1));
				};
				mutation.events.drag.bind((event) => {
					getResizer(event.target, "data-row").each((_dataRow) => {
						const currentRow = getCssValue(event.target, "top");
						set$1(event.target, "top", currentRow + event.yDelta + "px");
					});
					getResizer(event.target, "data-column").each((_dataCol) => {
						const currentCol = getCssValue(event.target, "left");
						set$1(event.target, "left", currentCol + event.xDelta + "px");
					});
				});
				const getDelta = (target, dir) => {
					return getCssValue(target, dir) - getAttrValue(target, "data-initial-" + dir, 0);
				};
				resizing.events.stop.bind(() => {
					mutation.get().each((target) => {
						hoverTable.each((table$1) => {
							getResizer(target, "data-row").each((row$1) => {
								const delta = getDelta(target, "top");
								remove$7(target, "data-initial-top");
								events.trigger.adjustHeight(table$1, delta, parseInt(row$1, 10));
							});
							getResizer(target, "data-column").each((column) => {
								const delta = getDelta(target, "left");
								remove$7(target, "data-initial-left");
								events.trigger.adjustWidth(table$1, delta, parseInt(column, 10));
							});
							refresh(wire, table$1);
						});
					});
				});
				const handler = (target, dir) => {
					events.trigger.startAdjust();
					mutation.assign(target);
					set$2(target, "data-initial-" + dir, getCssValue(target, dir));
					add(target, resizeBarDragging);
					set$1(target, "opacity", "0.2");
					resizing.go(wire.parent());
				};
				const mousedown = bind(wire.parent(), "mousedown", (event) => {
					if (isRowBar(event.target)) handler(event.target, "top");
					if (isColBar(event.target)) handler(event.target, "left");
				});
				const isRoot = (e) => {
					return eq$1(e, wire.view());
				};
				const findClosestEditableTable = (target) => closest$1(target, "table", isRoot).filter(isEditable$1);
				const mouseover = bind(wire.view(), "mouseover", (event) => {
					findClosestEditableTable(event.target).fold(() => {
						if (inBody(event.target)) destroy(wire);
					}, (table$1) => {
						if (resizing.isActive()) {
							hoverTable = Optional.some(table$1);
							refresh(wire, table$1);
						}
					});
				});
				const destroy$1 = () => {
					mousedown.unbind();
					mouseover.unbind();
					resizing.destroy();
					destroy(wire);
				};
				const refresh$1 = (tbl) => {
					refresh(wire, tbl);
				};
				const events = create$1({
					adjustHeight: Event$1([
						"table",
						"delta",
						"row"
					]),
					adjustWidth: Event$1([
						"table",
						"delta",
						"column"
					]),
					startAdjust: Event$1([])
				});
				return {
					destroy: destroy$1,
					refresh: refresh$1,
					on: resizing.on,
					off: resizing.off,
					hideBars: curry(hide, wire),
					showBars: curry(show, wire),
					events: events.registry
				};
			};
			const create = (wire, resizing, lazySizing) => {
				const hdirection = height;
				const vdirection = width;
				const manager = BarManager(wire);
				const events = create$1({
					beforeResize: Event$1(["table", "type"]),
					afterResize: Event$1(["table", "type"]),
					startDrag: Event$1([])
				});
				manager.events.adjustHeight.bind((event) => {
					const table$1 = event.table;
					events.trigger.beforeResize(table$1, "row");
					adjustHeight(table$1, hdirection.delta(event.delta, table$1), event.row, hdirection);
					events.trigger.afterResize(table$1, "row");
				});
				manager.events.startAdjust.bind((_event) => {
					events.trigger.startDrag();
				});
				manager.events.adjustWidth.bind((event) => {
					const table$1 = event.table;
					events.trigger.beforeResize(table$1, "col");
					const delta = vdirection.delta(event.delta, table$1);
					const tableSize = lazySizing(table$1);
					adjustWidth(table$1, delta, event.column, resizing, tableSize);
					events.trigger.afterResize(table$1, "col");
				});
				return {
					on: manager.on,
					off: manager.off,
					refreshBars: manager.refresh,
					hideBars: manager.hideBars,
					showBars: manager.showBars,
					destroy: manager.destroy,
					events: events.registry
				};
			};
			const TableResize = { create };
			const only = (element, isResizable$1) => {
				return {
					parent: constant(isDocument(element) ? documentElement(element) : element),
					view: constant(element),
					origin: constant(SugarPosition(0, 0)),
					isResizable: isResizable$1
				};
			};
			const detached = (editable, chrome, isResizable$1) => {
				const origin = () => absolute(chrome);
				return {
					parent: constant(chrome),
					view: constant(editable),
					origin,
					isResizable: isResizable$1
				};
			};
			const body = (editable, chrome, isResizable$1) => {
				return {
					parent: constant(chrome),
					view: constant(editable),
					origin: constant(SugarPosition(0, 0)),
					isResizable: isResizable$1
				};
			};
			const ResizeWire = {
				only,
				detached,
				body
			};
			const createContainer = () => {
				const container = SugarElement.fromTag("div");
				setAll(container, {
					position: "static",
					height: "0",
					width: "0",
					padding: "0",
					margin: "0",
					border: "0"
				});
				append$1(body$1(), container);
				return container;
			};
			const get = (editor, isResizable$1) => {
				return editor.inline ? ResizeWire.body(SugarElement.fromDom(editor.getBody()), createContainer(), isResizable$1) : ResizeWire.only(SugarElement.fromDom(editor.getDoc()), isResizable$1);
			};
			const remove = (editor, wire) => {
				if (editor.inline) remove$6(wire.parent());
			};
			const isTable = (node) => isNonNullable(node) && node.nodeName === "TABLE";
			const barResizerPrefix = "bar-";
			const isResizable = (elm) => get$b(elm, "data-mce-resize") !== "false";
			const syncPixels = (table$1) => {
				const warehouse = Warehouse.fromTable(table$1);
				if (!Warehouse.hasColumns(warehouse)) each$2(cells$1(table$1), (cell$1) => {
					set$1(cell$1, "width", get$a(cell$1, "width"));
					remove$7(cell$1, "width");
				});
			};
			const TableResizeHandler = (editor) => {
				const selectionRng = value();
				const tableResize = value();
				const resizeWire = value();
				let startW;
				let startRawW;
				const lazySizing = (table$1) => get$5(editor, table$1);
				const lazyResizingBehaviour = () => isPreserveTableColumnResizing(editor) ? preserveTable() : resizeTable();
				const getNumColumns = (table$1) => getGridSize(table$1).columns;
				const afterCornerResize = (table$1, origin, width$1) => {
					const isRightEdgeResize = endsWith(origin, "e");
					if (startRawW === "") convertToPercentSize(table$1);
					if (width$1 !== startW && startRawW !== "") {
						set$1(table$1, "width", startRawW);
						const resizing = lazyResizingBehaviour();
						const tableSize = lazySizing(table$1);
						const col$1 = isPreserveTableColumnResizing(editor) || isRightEdgeResize ? getNumColumns(table$1) - 1 : 0;
						adjustWidth(table$1, width$1 - startW, col$1, resizing, tableSize);
					} else if (isPercentage$1(startRawW)) set$1(table$1, "width", width$1 * parseFloat(startRawW.replace("%", "")) / startW + "%");
					if (isPixel(startRawW)) syncPixels(table$1);
				};
				const destroy$1 = () => {
					tableResize.on((sz) => {
						sz.destroy();
					});
					resizeWire.on((w) => {
						remove(editor, w);
					});
				};
				editor.on("init", () => {
					const rawWire = get(editor, isResizable);
					resizeWire.set(rawWire);
					if (hasTableObjectResizing(editor) && hasTableResizeBars(editor)) {
						const resizing = lazyResizingBehaviour();
						const sz = TableResize.create(rawWire, resizing, lazySizing);
						sz.on();
						sz.events.startDrag.bind((_event) => {
							selectionRng.set(editor.selection.getRng());
						});
						sz.events.beforeResize.bind((event) => {
							const rawTable = event.table.dom;
							fireObjectResizeStart(editor, rawTable, getPixelWidth(rawTable), getPixelHeight(rawTable), barResizerPrefix + event.type);
						});
						sz.events.afterResize.bind((event) => {
							const table$1 = event.table;
							const rawTable = table$1.dom;
							removeDataStyle(table$1);
							selectionRng.on((rng) => {
								editor.selection.setRng(rng);
								editor.focus();
							});
							fireObjectResized(editor, rawTable, getPixelWidth(rawTable), getPixelHeight(rawTable), barResizerPrefix + event.type);
							editor.undoManager.add();
						});
						tableResize.set(sz);
					}
				});
				editor.on("ObjectResizeStart", (e) => {
					const targetElm = e.target;
					if (isTable(targetElm)) {
						const table$1 = SugarElement.fromDom(targetElm);
						each$2(editor.dom.select(".mce-clonedresizable"), (clone$3) => {
							editor.dom.addClass(clone$3, "mce-" + getTableColumnResizingBehaviour(editor) + "-columns");
						});
						if (!isPixelSizing(table$1) && isTablePixelsForced(editor)) convertToPixelSize(table$1);
						else if (!isPercentSizing(table$1) && isTablePercentagesForced(editor)) convertToPercentSize(table$1);
						if (isNoneSizing(table$1) && startsWith(e.origin, barResizerPrefix)) convertToPercentSize(table$1);
						startW = e.width;
						startRawW = isTableResponsiveForced(editor) ? "" : getRawWidth(editor, targetElm).getOr("");
					}
				});
				editor.on("ObjectResized", (e) => {
					const targetElm = e.target;
					if (isTable(targetElm)) {
						const table$1 = SugarElement.fromDom(targetElm);
						const origin = e.origin;
						if (startsWith(origin, "corner-")) afterCornerResize(table$1, origin, e.width);
						removeDataStyle(table$1);
						fireTableModified(editor, table$1.dom, styleModified);
					}
				});
				editor.on("SwitchMode", () => {
					tableResize.on((resize$1) => {
						if (editor.mode.isReadOnly()) resize$1.hideBars();
						else resize$1.showBars();
					});
				});
				editor.on("dragstart dragend", (e) => {
					tableResize.on((resize$1) => {
						if (e.type === "dragstart") {
							resize$1.hideBars();
							resize$1.off();
						} else {
							resize$1.on();
							resize$1.showBars();
						}
					});
				});
				editor.on("remove", () => {
					destroy$1();
				});
				const refresh$1 = (table$1) => {
					tableResize.on((resize$1) => resize$1.refreshBars(SugarElement.fromDom(table$1)));
				};
				const hide$1 = () => {
					tableResize.on((resize$1) => resize$1.hideBars());
				};
				const show$1 = () => {
					tableResize.on((resize$1) => resize$1.showBars());
				};
				return {
					refresh: refresh$1,
					hide: hide$1,
					show: show$1
				};
			};
			const setupTable = (editor) => {
				register(editor);
				const resizeHandler = TableResizeHandler(editor);
				const cellSelectionHandler = TableCellSelectionHandler(editor, resizeHandler);
				const actions = TableActions(editor, resizeHandler, cellSelectionHandler);
				registerCommands(editor, actions);
				registerQueryCommands(editor, actions);
				registerEvents(editor, actions);
				return {
					getSelectedCells: cellSelectionHandler.getSelectedCells,
					clearSelectedCells: cellSelectionHandler.clearSelectedCells
				};
			};
			const DomModel = (editor) => {
				return { table: setupTable(editor) };
			};
			var Model = () => {
				global$1.add("dom", DomModel);
			};
			Model();
		})();
	}));

//#endregion
//#region node_modules/tinymce/models/dom/index.js
	require_model();

//#endregion
//#region node_modules/tinymce/themes/silver/theme.js
	var require_theme = /* @__PURE__ */ __commonJSMin((() => {
		/**
		* TinyMCE version 6.7.0 (2023-08-30)
		*/
		(function() {
			"use strict";
			const getPrototypeOf$2 = Object.getPrototypeOf;
			const hasProto = (v, constructor, predicate) => {
				var _a;
				if (predicate(v, constructor.prototype)) return true;
				else return ((_a = v.constructor) === null || _a === void 0 ? void 0 : _a.name) === constructor.name;
			};
			const typeOf = (x) => {
				const t$1 = typeof x;
				if (x === null) return "null";
				else if (t$1 === "object" && Array.isArray(x)) return "array";
				else if (t$1 === "object" && hasProto(x, String, (o, proto) => proto.isPrototypeOf(o))) return "string";
				else return t$1;
			};
			const isType$1 = (type$2) => (value$5) => typeOf(value$5) === type$2;
			const isSimpleType = (type$2) => (value$5) => typeof value$5 === type$2;
			const eq$1 = (t$1) => (a) => t$1 === a;
			const is$2 = (value$5, constructor) => isObject(value$5) && hasProto(value$5, constructor, (o, proto) => getPrototypeOf$2(o) === proto);
			const isString = isType$1("string");
			const isObject = isType$1("object");
			const isPlainObject = (value$5) => is$2(value$5, Object);
			const isArray = isType$1("array");
			const isNull = eq$1(null);
			const isBoolean = isSimpleType("boolean");
			const isUndefined = eq$1(void 0);
			const isNullable = (a) => a === null || a === void 0;
			const isNonNullable = (a) => !isNullable(a);
			const isFunction = isSimpleType("function");
			const isNumber = isSimpleType("number");
			const isArrayOf = (value$5, pred) => {
				if (isArray(value$5)) {
					for (let i = 0, len = value$5.length; i < len; ++i) if (!pred(value$5[i])) return false;
					return true;
				}
				return false;
			};
			const noop = () => {};
			const noarg = (f$1) => () => f$1();
			const compose = (fa, fb) => {
				return (...args) => {
					return fa(fb.apply(null, args));
				};
			};
			const compose1 = (fbc, fab) => (a) => fbc(fab(a));
			const constant$1 = (value$5) => {
				return () => {
					return value$5;
				};
			};
			const identity = (x) => {
				return x;
			};
			const tripleEquals = (a, b$1) => {
				return a === b$1;
			};
			function curry(fn, ...initialArgs) {
				return (...restArgs) => {
					const all$4 = initialArgs.concat(restArgs);
					return fn.apply(null, all$4);
				};
			}
			const not = (f$1) => (t$1) => !f$1(t$1);
			const die = (msg) => {
				return () => {
					throw new Error(msg);
				};
			};
			const apply$1 = (f$1) => {
				return f$1();
			};
			const never = constant$1(false);
			const always = constant$1(true);
			class Optional {
				constructor(tag, value$5) {
					this.tag = tag;
					this.value = value$5;
				}
				static some(value$5) {
					return new Optional(true, value$5);
				}
				static none() {
					return Optional.singletonNone;
				}
				fold(onNone, onSome) {
					if (this.tag) return onSome(this.value);
					else return onNone();
				}
				isSome() {
					return this.tag;
				}
				isNone() {
					return !this.tag;
				}
				map(mapper) {
					if (this.tag) return Optional.some(mapper(this.value));
					else return Optional.none();
				}
				bind(binder$1) {
					if (this.tag) return binder$1(this.value);
					else return Optional.none();
				}
				exists(predicate) {
					return this.tag && predicate(this.value);
				}
				forall(predicate) {
					return !this.tag || predicate(this.value);
				}
				filter(predicate) {
					if (!this.tag || predicate(this.value)) return this;
					else return Optional.none();
				}
				getOr(replacement) {
					return this.tag ? this.value : replacement;
				}
				or(replacement) {
					return this.tag ? this : replacement;
				}
				getOrThunk(thunk$1) {
					return this.tag ? this.value : thunk$1();
				}
				orThunk(thunk$1) {
					return this.tag ? this : thunk$1();
				}
				getOrDie(message) {
					if (!this.tag) throw new Error(message !== null && message !== void 0 ? message : "Called getOrDie on None");
					else return this.value;
				}
				static from(value$5) {
					return isNonNullable(value$5) ? Optional.some(value$5) : Optional.none();
				}
				getOrNull() {
					return this.tag ? this.value : null;
				}
				getOrUndefined() {
					return this.value;
				}
				each(worker) {
					if (this.tag) worker(this.value);
				}
				toArray() {
					return this.tag ? [this.value] : [];
				}
				toString() {
					return this.tag ? `some(${this.value})` : "none()";
				}
			}
			Optional.singletonNone = new Optional(false);
			const nativeSlice = Array.prototype.slice;
			const nativeIndexOf = Array.prototype.indexOf;
			const nativePush = Array.prototype.push;
			const rawIndexOf = (ts, t$1) => nativeIndexOf.call(ts, t$1);
			const indexOf = (xs, x) => {
				const r$2 = rawIndexOf(xs, x);
				return r$2 === -1 ? Optional.none() : Optional.some(r$2);
			};
			const contains$2 = (xs, x) => rawIndexOf(xs, x) > -1;
			const exists = (xs, pred) => {
				for (let i = 0, len = xs.length; i < len; i++) {
					const x = xs[i];
					if (pred(x, i)) return true;
				}
				return false;
			};
			const range$2 = (num, f$1) => {
				const r$2 = [];
				for (let i = 0; i < num; i++) r$2.push(f$1(i));
				return r$2;
			};
			const chunk$1 = (array, size) => {
				const r$2 = [];
				for (let i = 0; i < array.length; i += size) {
					const s = nativeSlice.call(array, i, i + size);
					r$2.push(s);
				}
				return r$2;
			};
			const map$2 = (xs, f$1) => {
				const len = xs.length;
				const r$2 = new Array(len);
				for (let i = 0; i < len; i++) {
					const x = xs[i];
					r$2[i] = f$1(x, i);
				}
				return r$2;
			};
			const each$1 = (xs, f$1) => {
				for (let i = 0, len = xs.length; i < len; i++) {
					const x = xs[i];
					f$1(x, i);
				}
			};
			const eachr = (xs, f$1) => {
				for (let i = xs.length - 1; i >= 0; i--) {
					const x = xs[i];
					f$1(x, i);
				}
			};
			const partition$3 = (xs, pred) => {
				const pass = [];
				const fail = [];
				for (let i = 0, len = xs.length; i < len; i++) {
					const x = xs[i];
					(pred(x, i) ? pass : fail).push(x);
				}
				return {
					pass,
					fail
				};
			};
			const filter$2 = (xs, pred) => {
				const r$2 = [];
				for (let i = 0, len = xs.length; i < len; i++) {
					const x = xs[i];
					if (pred(x, i)) r$2.push(x);
				}
				return r$2;
			};
			const foldr = (xs, f$1, acc) => {
				eachr(xs, (x, i) => {
					acc = f$1(acc, x, i);
				});
				return acc;
			};
			const foldl = (xs, f$1, acc) => {
				each$1(xs, (x, i) => {
					acc = f$1(acc, x, i);
				});
				return acc;
			};
			const findUntil = (xs, pred, until) => {
				for (let i = 0, len = xs.length; i < len; i++) {
					const x = xs[i];
					if (pred(x, i)) return Optional.some(x);
					else if (until(x, i)) break;
				}
				return Optional.none();
			};
			const find$5 = (xs, pred) => {
				return findUntil(xs, pred, never);
			};
			const findIndex$1 = (xs, pred) => {
				for (let i = 0, len = xs.length; i < len; i++) {
					const x = xs[i];
					if (pred(x, i)) return Optional.some(i);
				}
				return Optional.none();
			};
			const flatten = (xs) => {
				const r$2 = [];
				for (let i = 0, len = xs.length; i < len; ++i) {
					if (!isArray(xs[i])) throw new Error("Arr.flatten item " + i + " was not an array, input: " + xs);
					nativePush.apply(r$2, xs[i]);
				}
				return r$2;
			};
			const bind$3 = (xs, f$1) => flatten(map$2(xs, f$1));
			const forall = (xs, pred) => {
				for (let i = 0, len = xs.length; i < len; ++i) {
					const x = xs[i];
					if (pred(x, i) !== true) return false;
				}
				return true;
			};
			const reverse = (xs) => {
				const r$2 = nativeSlice.call(xs, 0);
				r$2.reverse();
				return r$2;
			};
			const difference = (a1, a2) => filter$2(a1, (x) => !contains$2(a2, x));
			const mapToObject = (xs, f$1) => {
				const r$2 = {};
				for (let i = 0, len = xs.length; i < len; i++) {
					const x = xs[i];
					r$2[String(x)] = f$1(x, i);
				}
				return r$2;
			};
			const pure$2 = (x) => [x];
			const sort = (xs, comparator) => {
				const copy = nativeSlice.call(xs, 0);
				copy.sort(comparator);
				return copy;
			};
			const get$h = (xs, i) => i >= 0 && i < xs.length ? Optional.some(xs[i]) : Optional.none();
			const head = (xs) => get$h(xs, 0);
			const last$1 = (xs) => get$h(xs, xs.length - 1);
			const from = isFunction(Array.from) ? Array.from : (x) => nativeSlice.call(x);
			const findMap = (arr, f$1) => {
				for (let i = 0; i < arr.length; i++) {
					const r$2 = f$1(arr[i], i);
					if (r$2.isSome()) return r$2;
				}
				return Optional.none();
			};
			const keys = Object.keys;
			const hasOwnProperty$1 = Object.hasOwnProperty;
			const each = (obj, f$1) => {
				const props = keys(obj);
				for (let k = 0, len = props.length; k < len; k++) {
					const i = props[k];
					const x = obj[i];
					f$1(x, i);
				}
			};
			const map$1 = (obj, f$1) => {
				return tupleMap(obj, (x, i) => ({
					k: i,
					v: f$1(x, i)
				}));
			};
			const tupleMap = (obj, f$1) => {
				const r$2 = {};
				each(obj, (x, i) => {
					const tuple = f$1(x, i);
					r$2[tuple.k] = tuple.v;
				});
				return r$2;
			};
			const objAcc = (r$2) => (x, i) => {
				r$2[i] = x;
			};
			const internalFilter = (obj, pred, onTrue, onFalse) => {
				each(obj, (x, i) => {
					(pred(x, i) ? onTrue : onFalse)(x, i);
				});
			};
			const bifilter = (obj, pred) => {
				const t$1 = {};
				const f$1 = {};
				internalFilter(obj, pred, objAcc(t$1), objAcc(f$1));
				return {
					t: t$1,
					f: f$1
				};
			};
			const filter$1 = (obj, pred) => {
				const t$1 = {};
				internalFilter(obj, pred, objAcc(t$1), noop);
				return t$1;
			};
			const mapToArray = (obj, f$1) => {
				const r$2 = [];
				each(obj, (value$5, name$4) => {
					r$2.push(f$1(value$5, name$4));
				});
				return r$2;
			};
			const find$4 = (obj, pred) => {
				const props = keys(obj);
				for (let k = 0, len = props.length; k < len; k++) {
					const i = props[k];
					const x = obj[i];
					if (pred(x, i, obj)) return Optional.some(x);
				}
				return Optional.none();
			};
			const values = (obj) => {
				return mapToArray(obj, identity);
			};
			const get$g = (obj, key) => {
				return has$2(obj, key) ? Optional.from(obj[key]) : Optional.none();
			};
			const has$2 = (obj, key) => hasOwnProperty$1.call(obj, key);
			const hasNonNullableKey = (obj, key) => has$2(obj, key) && obj[key] !== void 0 && obj[key] !== null;
			const is$1 = (lhs, rhs, comparator = tripleEquals) => lhs.exists((left$1) => comparator(left$1, rhs));
			const equals = (lhs, rhs, comparator = tripleEquals) => lift2(lhs, rhs, comparator).getOr(lhs.isNone() && rhs.isNone());
			const cat = (arr) => {
				const r$2 = [];
				const push = (x) => {
					r$2.push(x);
				};
				for (let i = 0; i < arr.length; i++) arr[i].each(push);
				return r$2;
			};
			const sequence = (arr) => {
				const r$2 = [];
				for (let i = 0; i < arr.length; i++) {
					const x = arr[i];
					if (x.isSome()) r$2.push(x.getOrDie());
					else return Optional.none();
				}
				return Optional.some(r$2);
			};
			const lift2 = (oa, ob, f$1) => oa.isSome() && ob.isSome() ? Optional.some(f$1(oa.getOrDie(), ob.getOrDie())) : Optional.none();
			const lift3 = (oa, ob, oc, f$1) => oa.isSome() && ob.isSome() && oc.isSome() ? Optional.some(f$1(oa.getOrDie(), ob.getOrDie(), oc.getOrDie())) : Optional.none();
			const mapFrom = (a, f$1) => a !== void 0 && a !== null ? Optional.some(f$1(a)) : Optional.none();
			const someIf = (b$1, a) => b$1 ? Optional.some(a) : Optional.none();
			const addToEnd = (str, suffix$1) => {
				return str + suffix$1;
			};
			const removeFromStart = (str, numChars) => {
				return str.substring(numChars);
			};
			const checkRange = (str, substr, start) => substr === "" || str.length >= substr.length && str.substr(start, start + substr.length) === substr;
			const removeLeading = (str, prefix$2) => {
				return startsWith(str, prefix$2) ? removeFromStart(str, prefix$2.length) : str;
			};
			const ensureTrailing = (str, suffix$1) => {
				return endsWith(str, suffix$1) ? str : addToEnd(str, suffix$1);
			};
			const contains$1 = (str, substr, start = 0, end) => {
				const idx = str.indexOf(substr, start);
				if (idx !== -1) return isUndefined(end) ? true : idx + substr.length <= end;
				else return false;
			};
			const startsWith = (str, prefix$2) => {
				return checkRange(str, prefix$2, 0);
			};
			const endsWith = (str, suffix$1) => {
				return checkRange(str, suffix$1, str.length - suffix$1.length);
			};
			const blank = (r$2) => (s) => s.replace(r$2, "");
			const trim$1 = blank(/^\s+|\s+$/g);
			const isNotEmpty = (s) => s.length > 0;
			const isEmpty = (s) => !isNotEmpty(s);
			const isSupported$1 = (dom$3) => dom$3.style !== void 0 && isFunction(dom$3.style.getPropertyValue);
			const fromHtml$2 = (html$2, scope) => {
				const div = (scope || document).createElement("div");
				div.innerHTML = html$2;
				if (!div.hasChildNodes() || div.childNodes.length > 1) {
					const message = "HTML does not have a single root node";
					console.error(message, html$2);
					throw new Error(message);
				}
				return fromDom(div.childNodes[0]);
			};
			const fromTag = (tag, scope) => {
				return fromDom((scope || document).createElement(tag));
			};
			const fromText = (text$3, scope) => {
				return fromDom((scope || document).createTextNode(text$3));
			};
			const fromDom = (node) => {
				if (node === null || node === void 0) throw new Error("Node cannot be null or undefined");
				return { dom: node };
			};
			const fromPoint = (docElm, x, y) => Optional.from(docElm.dom.elementFromPoint(x, y)).map(fromDom);
			const SugarElement = {
				fromHtml: fromHtml$2,
				fromTag,
				fromText,
				fromDom,
				fromPoint
			};
			const Global = typeof window !== "undefined" ? window : Function("return this;")();
			const path$1 = (parts$10, scope) => {
				let o = scope !== void 0 && scope !== null ? scope : Global;
				for (let i = 0; i < parts$10.length && o !== void 0 && o !== null; ++i) o = o[parts$10[i]];
				return o;
			};
			const resolve = (p, scope) => {
				return path$1(p.split("."), scope);
			};
			const unsafe = (name$4, scope) => {
				return resolve(name$4, scope);
			};
			const getOrDie$1 = (name$4, scope) => {
				const actual = unsafe(name$4, scope);
				if (actual === void 0 || actual === null) throw new Error(name$4 + " not available on this browser");
				return actual;
			};
			const getPrototypeOf$1 = Object.getPrototypeOf;
			const sandHTMLElement = (scope) => {
				return getOrDie$1("HTMLElement", scope);
			};
			const isPrototypeOf = (x) => {
				const scope = resolve("ownerDocument.defaultView", x);
				return isObject(x) && (sandHTMLElement(scope).prototype.isPrototypeOf(x) || /^HTML\w*Element$/.test(getPrototypeOf$1(x).constructor.name));
			};
			const DOCUMENT = 9;
			const DOCUMENT_FRAGMENT = 11;
			const ELEMENT = 1;
			const TEXT = 3;
			const name$3 = (element$1) => {
				return element$1.dom.nodeName.toLowerCase();
			};
			const type$1 = (element$1) => element$1.dom.nodeType;
			const isType = (t$1) => (element$1) => type$1(element$1) === t$1;
			const isHTMLElement = (element$1) => isElement$1(element$1) && isPrototypeOf(element$1.dom);
			const isElement$1 = isType(ELEMENT);
			const isText = isType(TEXT);
			const isDocument = isType(DOCUMENT);
			const isDocumentFragment = isType(DOCUMENT_FRAGMENT);
			const isTag = (tag) => (e) => isElement$1(e) && name$3(e) === tag;
			const is = (element$1, selector) => {
				const dom$3 = element$1.dom;
				if (dom$3.nodeType !== ELEMENT) return false;
				else {
					const elem = dom$3;
					if (elem.matches !== void 0) return elem.matches(selector);
					else if (elem.msMatchesSelector !== void 0) return elem.msMatchesSelector(selector);
					else if (elem.webkitMatchesSelector !== void 0) return elem.webkitMatchesSelector(selector);
					else if (elem.mozMatchesSelector !== void 0) return elem.mozMatchesSelector(selector);
					else throw new Error("Browser lacks native selectors");
				}
			};
			const bypassSelector = (dom$3) => dom$3.nodeType !== ELEMENT && dom$3.nodeType !== DOCUMENT && dom$3.nodeType !== DOCUMENT_FRAGMENT || dom$3.childElementCount === 0;
			const all$3 = (selector, scope) => {
				const base$1 = scope === void 0 ? document : scope.dom;
				return bypassSelector(base$1) ? [] : map$2(base$1.querySelectorAll(selector), SugarElement.fromDom);
			};
			const one = (selector, scope) => {
				const base$1 = scope === void 0 ? document : scope.dom;
				return bypassSelector(base$1) ? Optional.none() : Optional.from(base$1.querySelector(selector)).map(SugarElement.fromDom);
			};
			const eq = (e1, e2) => e1.dom === e2.dom;
			const contains = (e1, e2) => {
				const d1 = e1.dom;
				const d2 = e2.dom;
				return d1 === d2 ? false : d1.contains(d2);
			};
			const owner$4 = (element$1) => SugarElement.fromDom(element$1.dom.ownerDocument);
			const documentOrOwner = (dos) => isDocument(dos) ? dos : owner$4(dos);
			const documentElement = (element$1) => SugarElement.fromDom(documentOrOwner(element$1).dom.documentElement);
			const defaultView = (element$1) => SugarElement.fromDom(documentOrOwner(element$1).dom.defaultView);
			const parent = (element$1) => Optional.from(element$1.dom.parentNode).map(SugarElement.fromDom);
			const parentNode = (element$1) => parent(element$1);
			const parentElement = (element$1) => Optional.from(element$1.dom.parentElement).map(SugarElement.fromDom);
			const parents = (element$1, isRoot) => {
				const stop$1 = isFunction(isRoot) ? isRoot : never;
				let dom$3 = element$1.dom;
				const ret = [];
				while (dom$3.parentNode !== null && dom$3.parentNode !== void 0) {
					const rawParent = dom$3.parentNode;
					const p = SugarElement.fromDom(rawParent);
					ret.push(p);
					if (stop$1(p) === true) break;
					else dom$3 = rawParent;
				}
				return ret;
			};
			const offsetParent = (element$1) => Optional.from(element$1.dom.offsetParent).map(SugarElement.fromDom);
			const nextSibling = (element$1) => Optional.from(element$1.dom.nextSibling).map(SugarElement.fromDom);
			const children = (element$1) => map$2(element$1.dom.childNodes, SugarElement.fromDom);
			const child$2 = (element$1, index) => {
				const cs = element$1.dom.childNodes;
				return Optional.from(cs[index]).map(SugarElement.fromDom);
			};
			const firstChild = (element$1) => child$2(element$1, 0);
			const spot = (element$1, offset$1) => ({
				element: element$1,
				offset: offset$1
			});
			const leaf = (element$1, offset$1) => {
				const cs = children(element$1);
				return cs.length > 0 && offset$1 < cs.length ? spot(cs[offset$1], 0) : spot(element$1, offset$1);
			};
			const isShadowRoot = (dos) => isDocumentFragment(dos) && isNonNullable(dos.dom.host);
			const supported = isFunction(Element.prototype.attachShadow) && isFunction(Node.prototype.getRootNode);
			const isSupported = constant$1(supported);
			const getRootNode = supported ? (e) => SugarElement.fromDom(e.dom.getRootNode()) : documentOrOwner;
			const getContentContainer = (dos) => isShadowRoot(dos) ? dos : SugarElement.fromDom(documentOrOwner(dos).dom.body);
			const isInShadowRoot = (e) => getShadowRoot(e).isSome();
			const getShadowRoot = (e) => {
				const r$2 = getRootNode(e);
				return isShadowRoot(r$2) ? Optional.some(r$2) : Optional.none();
			};
			const getShadowHost = (e) => SugarElement.fromDom(e.dom.host);
			const getOriginalEventTarget = (event) => {
				if (isSupported() && isNonNullable(event.target)) {
					const el = SugarElement.fromDom(event.target);
					if (isElement$1(el) && isOpenShadowHost(el)) {
						if (event.composed && event.composedPath) {
							const composedPath = event.composedPath();
							if (composedPath) return head(composedPath);
						}
					}
				}
				return Optional.from(event.target);
			};
			const isOpenShadowHost = (element$1) => isNonNullable(element$1.dom.shadowRoot);
			const inBody = (element$1) => {
				const dom$3 = isText(element$1) ? element$1.dom.parentNode : element$1.dom;
				if (dom$3 === void 0 || dom$3 === null || dom$3.ownerDocument === null) return false;
				const doc = dom$3.ownerDocument;
				return getShadowRoot(SugarElement.fromDom(dom$3)).fold(() => doc.body.contains(dom$3), compose1(inBody, getShadowHost));
			};
			const body = () => getBody(SugarElement.fromDom(document));
			const getBody = (doc) => {
				const b$1 = doc.dom.body;
				if (b$1 === null || b$1 === void 0) throw new Error("Body is not available yet");
				return SugarElement.fromDom(b$1);
			};
			const rawSet = (dom$3, key, value$5) => {
				if (isString(value$5) || isBoolean(value$5) || isNumber(value$5)) dom$3.setAttribute(key, value$5 + "");
				else {
					console.error("Invalid call to Attribute.set. Key ", key, ":: Value ", value$5, ":: Element ", dom$3);
					throw new Error("Attribute value was not simple");
				}
			};
			const set$9 = (element$1, key, value$5) => {
				rawSet(element$1.dom, key, value$5);
			};
			const setAll$1 = (element$1, attrs) => {
				const dom$3 = element$1.dom;
				each(attrs, (v, k) => {
					rawSet(dom$3, k, v);
				});
			};
			const get$f = (element$1, key) => {
				const v = element$1.dom.getAttribute(key);
				return v === null ? void 0 : v;
			};
			const getOpt = (element$1, key) => Optional.from(get$f(element$1, key));
			const has$1 = (element$1, key) => {
				const dom$3 = element$1.dom;
				return dom$3 && dom$3.hasAttribute ? dom$3.hasAttribute(key) : false;
			};
			const remove$7 = (element$1, key) => {
				element$1.dom.removeAttribute(key);
			};
			const clone$2 = (element$1) => foldl(element$1.dom.attributes, (acc, attr) => {
				acc[attr.name] = attr.value;
				return acc;
			}, {});
			const internalSet = (dom$3, property, value$5) => {
				if (!isString(value$5)) {
					console.error("Invalid call to CSS.set. Property ", property, ":: Value ", value$5, ":: Element ", dom$3);
					throw new Error("CSS value must be a string: " + value$5);
				}
				if (isSupported$1(dom$3)) dom$3.style.setProperty(property, value$5);
			};
			const internalRemove = (dom$3, property) => {
				if (isSupported$1(dom$3)) dom$3.style.removeProperty(property);
			};
			const set$8 = (element$1, property, value$5) => {
				const dom$3 = element$1.dom;
				internalSet(dom$3, property, value$5);
			};
			const setAll = (element$1, css) => {
				const dom$3 = element$1.dom;
				each(css, (v, k) => {
					internalSet(dom$3, k, v);
				});
			};
			const setOptions = (element$1, css) => {
				const dom$3 = element$1.dom;
				each(css, (v, k) => {
					v.fold(() => {
						internalRemove(dom$3, k);
					}, (value$5) => {
						internalSet(dom$3, k, value$5);
					});
				});
			};
			const get$e = (element$1, property) => {
				const dom$3 = element$1.dom;
				const r$2 = window.getComputedStyle(dom$3).getPropertyValue(property);
				return r$2 === "" && !inBody(element$1) ? getUnsafeProperty(dom$3, property) : r$2;
			};
			const getUnsafeProperty = (dom$3, property) => isSupported$1(dom$3) ? dom$3.style.getPropertyValue(property) : "";
			const getRaw = (element$1, property) => {
				const dom$3 = element$1.dom;
				const raw = getUnsafeProperty(dom$3, property);
				return Optional.from(raw).filter((r$2) => r$2.length > 0);
			};
			const getAllRaw = (element$1) => {
				const css = {};
				const dom$3 = element$1.dom;
				if (isSupported$1(dom$3)) for (let i = 0; i < dom$3.style.length; i++) {
					const ruleName = dom$3.style.item(i);
					css[ruleName] = dom$3.style[ruleName];
				}
				return css;
			};
			const isValidValue$1 = (tag, property, value$5) => {
				const element$1 = SugarElement.fromTag(tag);
				set$8(element$1, property, value$5);
				return getRaw(element$1, property).isSome();
			};
			const remove$6 = (element$1, property) => {
				const dom$3 = element$1.dom;
				internalRemove(dom$3, property);
				if (is$1(getOpt(element$1, "style").map(trim$1), "")) remove$7(element$1, "style");
			};
			const reflow = (e) => e.dom.offsetWidth;
			const Dimension = (name$4, getOffset$1) => {
				const set$10 = (element$1, h) => {
					if (!isNumber(h) && !h.match(/^[0-9]+$/)) throw new Error(name$4 + ".set accepts only positive integer values. Value was " + h);
					const dom$3 = element$1.dom;
					if (isSupported$1(dom$3)) dom$3.style[name$4] = h + "px";
				};
				const get$10 = (element$1) => {
					const r$2 = getOffset$1(element$1);
					if (r$2 <= 0 || r$2 === null) {
						const css = get$e(element$1, name$4);
						return parseFloat(css) || 0;
					}
					return r$2;
				};
				const getOuter$3 = get$10;
				const aggregate = (element$1, properties$1) => foldl(properties$1, (acc, property) => {
					const val = get$e(element$1, property);
					const value$5 = val === void 0 ? 0 : parseInt(val, 10);
					return isNaN(value$5) ? acc : acc + value$5;
				}, 0);
				const max$1 = (element$1, value$5, properties$1) => {
					const cumulativeInclusions = aggregate(element$1, properties$1);
					return value$5 > cumulativeInclusions ? value$5 - cumulativeInclusions : 0;
				};
				return {
					set: set$10,
					get: get$10,
					getOuter: getOuter$3,
					aggregate,
					max: max$1
				};
			};
			const api$2 = Dimension("height", (element$1) => {
				const dom$3 = element$1.dom;
				return inBody(element$1) ? dom$3.getBoundingClientRect().height : dom$3.offsetHeight;
			});
			const get$d = (element$1) => api$2.get(element$1);
			const getOuter$2 = (element$1) => api$2.getOuter(element$1);
			const setMax$1 = (element$1, value$5) => {
				set$8(element$1, "max-height", api$2.max(element$1, value$5, [
					"margin-top",
					"border-top-width",
					"padding-top",
					"padding-bottom",
					"border-bottom-width",
					"margin-bottom"
				]) + "px");
			};
			const r$1 = (left$1, top$1) => {
				const translate$3 = (x, y) => r$1(left$1 + x, top$1 + y);
				return {
					left: left$1,
					top: top$1,
					translate: translate$3
				};
			};
			const SugarPosition = r$1;
			const boxPosition = (dom$3) => {
				const box$2 = dom$3.getBoundingClientRect();
				return SugarPosition(box$2.left, box$2.top);
			};
			const firstDefinedOrZero = (a, b$1) => {
				if (a !== void 0) return a;
				else return b$1 !== void 0 ? b$1 : 0;
			};
			const absolute$3 = (element$1) => {
				const doc = element$1.dom.ownerDocument;
				const body$1 = doc.body;
				const win$1 = doc.defaultView;
				const html$2 = doc.documentElement;
				if (body$1 === element$1.dom) return SugarPosition(body$1.offsetLeft, body$1.offsetTop);
				const scrollTop = firstDefinedOrZero(win$1 === null || win$1 === void 0 ? void 0 : win$1.pageYOffset, html$2.scrollTop);
				const scrollLeft = firstDefinedOrZero(win$1 === null || win$1 === void 0 ? void 0 : win$1.pageXOffset, html$2.scrollLeft);
				const clientTop = firstDefinedOrZero(html$2.clientTop, body$1.clientTop);
				const clientLeft = firstDefinedOrZero(html$2.clientLeft, body$1.clientLeft);
				return viewport$1(element$1).translate(scrollLeft - clientLeft, scrollTop - clientTop);
			};
			const viewport$1 = (element$1) => {
				const dom$3 = element$1.dom;
				const body$1 = dom$3.ownerDocument.body;
				if (body$1 === dom$3) return SugarPosition(body$1.offsetLeft, body$1.offsetTop);
				if (!inBody(element$1)) return SugarPosition(0, 0);
				return boxPosition(dom$3);
			};
			const api$1 = Dimension("width", (element$1) => element$1.dom.offsetWidth);
			const set$7 = (element$1, h) => api$1.set(element$1, h);
			const get$c = (element$1) => api$1.get(element$1);
			const getOuter$1 = (element$1) => api$1.getOuter(element$1);
			const setMax = (element$1, value$5) => {
				set$8(element$1, "max-width", api$1.max(element$1, value$5, [
					"margin-left",
					"border-left-width",
					"padding-left",
					"padding-right",
					"border-right-width",
					"margin-right"
				]) + "px");
			};
			const cached = (f$1) => {
				let called = false;
				let r$2;
				return (...args) => {
					if (!called) {
						called = true;
						r$2 = f$1.apply(null, args);
					}
					return r$2;
				};
			};
			const DeviceType = (os, browser$1, userAgent, mediaMatch$1) => {
				const isiPad = os.isiOS() && /ipad/i.test(userAgent) === true;
				const isiPhone = os.isiOS() && !isiPad;
				const isMobile = os.isiOS() || os.isAndroid();
				const isTouch$1 = isMobile || mediaMatch$1("(pointer:coarse)");
				const isTablet$1 = isiPad || !isiPhone && isMobile && mediaMatch$1("(min-device-width:768px)");
				const isPhone$1 = isiPhone || isMobile && !isTablet$1;
				const iOSwebview = browser$1.isSafari() && os.isiOS() && /safari/i.test(userAgent) === false;
				const isDesktop = !isPhone$1 && !isTablet$1 && !iOSwebview;
				return {
					isiPad: constant$1(isiPad),
					isiPhone: constant$1(isiPhone),
					isTablet: constant$1(isTablet$1),
					isPhone: constant$1(isPhone$1),
					isTouch: constant$1(isTouch$1),
					isAndroid: os.isAndroid,
					isiOS: os.isiOS,
					isWebView: constant$1(iOSwebview),
					isDesktop: constant$1(isDesktop)
				};
			};
			const firstMatch = (regexes, s) => {
				for (let i = 0; i < regexes.length; i++) {
					const x = regexes[i];
					if (x.test(s)) return x;
				}
			};
			const find$3 = (regexes, agent) => {
				const r$2 = firstMatch(regexes, agent);
				if (!r$2) return {
					major: 0,
					minor: 0
				};
				const group$1 = (i) => {
					return Number(agent.replace(r$2, "$" + i));
				};
				return nu$d(group$1(1), group$1(2));
			};
			const detect$5 = (versionRegexes, agent) => {
				const cleanedAgent = String(agent).toLowerCase();
				if (versionRegexes.length === 0) return unknown$3();
				return find$3(versionRegexes, cleanedAgent);
			};
			const unknown$3 = () => {
				return nu$d(0, 0);
			};
			const nu$d = (major, minor) => {
				return {
					major,
					minor
				};
			};
			const Version = {
				nu: nu$d,
				detect: detect$5,
				unknown: unknown$3
			};
			const detectBrowser$1 = (browsers$1, userAgentData) => {
				return findMap(userAgentData.brands, (uaBrand) => {
					const lcBrand = uaBrand.brand.toLowerCase();
					return find$5(browsers$1, (browser$1) => {
						var _a;
						return lcBrand === ((_a = browser$1.brand) === null || _a === void 0 ? void 0 : _a.toLowerCase());
					}).map((info) => ({
						current: info.name,
						version: Version.nu(parseInt(uaBrand.version, 10), 0)
					}));
				});
			};
			const detect$4 = (candidates, userAgent) => {
				const agent = String(userAgent).toLowerCase();
				return find$5(candidates, (candidate) => {
					return candidate.search(agent);
				});
			};
			const detectBrowser = (browsers$1, userAgent) => {
				return detect$4(browsers$1, userAgent).map((browser$1) => {
					const version = Version.detect(browser$1.versionRegexes, userAgent);
					return {
						current: browser$1.name,
						version
					};
				});
			};
			const detectOs = (oses$1, userAgent) => {
				return detect$4(oses$1, userAgent).map((os) => {
					const version = Version.detect(os.versionRegexes, userAgent);
					return {
						current: os.name,
						version
					};
				});
			};
			const normalVersionRegex = /.*?version\/\ ?([0-9]+)\.([0-9]+).*/;
			const checkContains = (target) => {
				return (uastring) => {
					return contains$1(uastring, target);
				};
			};
			const browsers = [
				{
					name: "Edge",
					versionRegexes: [/.*?edge\/ ?([0-9]+)\.([0-9]+)$/],
					search: (uastring) => {
						return contains$1(uastring, "edge/") && contains$1(uastring, "chrome") && contains$1(uastring, "safari") && contains$1(uastring, "applewebkit");
					}
				},
				{
					name: "Chromium",
					brand: "Chromium",
					versionRegexes: [/.*?chrome\/([0-9]+)\.([0-9]+).*/, normalVersionRegex],
					search: (uastring) => {
						return contains$1(uastring, "chrome") && !contains$1(uastring, "chromeframe");
					}
				},
				{
					name: "IE",
					versionRegexes: [/.*?msie\ ?([0-9]+)\.([0-9]+).*/, /.*?rv:([0-9]+)\.([0-9]+).*/],
					search: (uastring) => {
						return contains$1(uastring, "msie") || contains$1(uastring, "trident");
					}
				},
				{
					name: "Opera",
					versionRegexes: [normalVersionRegex, /.*?opera\/([0-9]+)\.([0-9]+).*/],
					search: checkContains("opera")
				},
				{
					name: "Firefox",
					versionRegexes: [/.*?firefox\/\ ?([0-9]+)\.([0-9]+).*/],
					search: checkContains("firefox")
				},
				{
					name: "Safari",
					versionRegexes: [normalVersionRegex, /.*?cpu os ([0-9]+)_([0-9]+).*/],
					search: (uastring) => {
						return (contains$1(uastring, "safari") || contains$1(uastring, "mobile/")) && contains$1(uastring, "applewebkit");
					}
				}
			];
			const oses = [
				{
					name: "Windows",
					search: checkContains("win"),
					versionRegexes: [/.*?windows\ nt\ ?([0-9]+)\.([0-9]+).*/]
				},
				{
					name: "iOS",
					search: (uastring) => {
						return contains$1(uastring, "iphone") || contains$1(uastring, "ipad");
					},
					versionRegexes: [
						/.*?version\/\ ?([0-9]+)\.([0-9]+).*/,
						/.*cpu os ([0-9]+)_([0-9]+).*/,
						/.*cpu iphone os ([0-9]+)_([0-9]+).*/
					]
				},
				{
					name: "Android",
					search: checkContains("android"),
					versionRegexes: [/.*?android\ ?([0-9]+)\.([0-9]+).*/]
				},
				{
					name: "macOS",
					search: checkContains("mac os x"),
					versionRegexes: [/.*?mac\ os\ x\ ?([0-9]+)_([0-9]+).*/]
				},
				{
					name: "Linux",
					search: checkContains("linux"),
					versionRegexes: []
				},
				{
					name: "Solaris",
					search: checkContains("sunos"),
					versionRegexes: []
				},
				{
					name: "FreeBSD",
					search: checkContains("freebsd"),
					versionRegexes: []
				},
				{
					name: "ChromeOS",
					search: checkContains("cros"),
					versionRegexes: [/.*?chrome\/([0-9]+)\.([0-9]+).*/]
				}
			];
			const PlatformInfo = {
				browsers: constant$1(browsers),
				oses: constant$1(oses)
			};
			const edge = "Edge";
			const chromium = "Chromium";
			const ie = "IE";
			const opera = "Opera";
			const firefox = "Firefox";
			const safari = "Safari";
			const unknown$2 = () => {
				return nu$c({
					current: void 0,
					version: Version.unknown()
				});
			};
			const nu$c = (info) => {
				const current = info.current;
				const version = info.version;
				const isBrowser = (name$4) => () => current === name$4;
				return {
					current,
					version,
					isEdge: isBrowser(edge),
					isChromium: isBrowser(chromium),
					isIE: isBrowser(ie),
					isOpera: isBrowser(opera),
					isFirefox: isBrowser(firefox),
					isSafari: isBrowser(safari)
				};
			};
			const Browser = {
				unknown: unknown$2,
				nu: nu$c,
				edge: constant$1(edge),
				chromium: constant$1(chromium),
				ie: constant$1(ie),
				opera: constant$1(opera),
				firefox: constant$1(firefox),
				safari: constant$1(safari)
			};
			const windows = "Windows";
			const ios = "iOS";
			const android = "Android";
			const linux = "Linux";
			const macos = "macOS";
			const solaris = "Solaris";
			const freebsd = "FreeBSD";
			const chromeos = "ChromeOS";
			const unknown$1 = () => {
				return nu$b({
					current: void 0,
					version: Version.unknown()
				});
			};
			const nu$b = (info) => {
				const current = info.current;
				const version = info.version;
				const isOS = (name$4) => () => current === name$4;
				return {
					current,
					version,
					isWindows: isOS(windows),
					isiOS: isOS(ios),
					isAndroid: isOS(android),
					isMacOS: isOS(macos),
					isLinux: isOS(linux),
					isSolaris: isOS(solaris),
					isFreeBSD: isOS(freebsd),
					isChromeOS: isOS(chromeos)
				};
			};
			const OperatingSystem = {
				unknown: unknown$1,
				nu: nu$b,
				windows: constant$1(windows),
				ios: constant$1(ios),
				android: constant$1(android),
				linux: constant$1(linux),
				macos: constant$1(macos),
				solaris: constant$1(solaris),
				freebsd: constant$1(freebsd),
				chromeos: constant$1(chromeos)
			};
			const detect$3 = (userAgent, userAgentDataOpt, mediaMatch$1) => {
				const browsers$1 = PlatformInfo.browsers();
				const oses$1 = PlatformInfo.oses();
				const browser$1 = userAgentDataOpt.bind((userAgentData) => detectBrowser$1(browsers$1, userAgentData)).orThunk(() => detectBrowser(browsers$1, userAgent)).fold(Browser.unknown, Browser.nu);
				const os = detectOs(oses$1, userAgent).fold(OperatingSystem.unknown, OperatingSystem.nu);
				return {
					browser: browser$1,
					os,
					deviceType: DeviceType(os, browser$1, userAgent, mediaMatch$1)
				};
			};
			const PlatformDetection = { detect: detect$3 };
			const mediaMatch = (query$1) => window.matchMedia(query$1).matches;
			let platform = cached(() => PlatformDetection.detect(navigator.userAgent, Optional.from(navigator.userAgentData), mediaMatch));
			const detect$2 = () => platform();
			const mkEvent = (target, x, y, stop$1, prevent, kill, raw) => ({
				target,
				x,
				y,
				stop: stop$1,
				prevent,
				kill,
				raw
			});
			const fromRawEvent$1 = (rawEvent) => {
				const target = SugarElement.fromDom(getOriginalEventTarget(rawEvent).getOr(rawEvent.target));
				const stop$1 = () => rawEvent.stopPropagation();
				const prevent = () => rawEvent.preventDefault();
				const kill = compose(prevent, stop$1);
				return mkEvent(target, rawEvent.clientX, rawEvent.clientY, stop$1, prevent, kill, rawEvent);
			};
			const handle = (filter$3, handler) => (rawEvent) => {
				if (filter$3(rawEvent)) handler(fromRawEvent$1(rawEvent));
			};
			const binder = (element$1, event, filter$3, handler, useCapture) => {
				const wrapped = handle(filter$3, handler);
				element$1.dom.addEventListener(event, wrapped, useCapture);
				return { unbind: curry(unbind, element$1, event, wrapped, useCapture) };
			};
			const bind$2 = (element$1, event, filter$3, handler) => binder(element$1, event, filter$3, handler, false);
			const capture$1 = (element$1, event, filter$3, handler) => binder(element$1, event, filter$3, handler, true);
			const unbind = (element$1, event, handler, useCapture) => {
				element$1.dom.removeEventListener(event, handler, useCapture);
			};
			const before$1 = (marker, element$1) => {
				parent(marker).each((v) => {
					v.dom.insertBefore(element$1.dom, marker.dom);
				});
			};
			const after$2 = (marker, element$1) => {
				nextSibling(marker).fold(() => {
					parent(marker).each((v) => {
						append$2(v, element$1);
					});
				}, (v) => {
					before$1(v, element$1);
				});
			};
			const prepend$1 = (parent$1, element$1) => {
				firstChild(parent$1).fold(() => {
					append$2(parent$1, element$1);
				}, (v) => {
					parent$1.dom.insertBefore(element$1.dom, v.dom);
				});
			};
			const append$2 = (parent$1, element$1) => {
				parent$1.dom.appendChild(element$1.dom);
			};
			const appendAt = (parent$1, element$1, index) => {
				child$2(parent$1, index).fold(() => {
					append$2(parent$1, element$1);
				}, (v) => {
					before$1(v, element$1);
				});
			};
			const append$1 = (parent$1, elements) => {
				each$1(elements, (x) => {
					append$2(parent$1, x);
				});
			};
			const empty = (element$1) => {
				element$1.dom.textContent = "";
				each$1(children(element$1), (rogue) => {
					remove$5(rogue);
				});
			};
			const remove$5 = (element$1) => {
				const dom$3 = element$1.dom;
				if (dom$3.parentNode !== null) dom$3.parentNode.removeChild(dom$3);
			};
			const get$b = (_DOC) => {
				const doc = _DOC !== void 0 ? _DOC.dom : document;
				return SugarPosition(doc.body.scrollLeft || doc.documentElement.scrollLeft, doc.body.scrollTop || doc.documentElement.scrollTop);
			};
			const to = (x, y, _DOC) => {
				const win$1 = (_DOC !== void 0 ? _DOC.dom : document).defaultView;
				if (win$1) win$1.scrollTo(x, y);
			};
			const get$a = (_win) => {
				const win$1 = _win === void 0 ? window : _win;
				if (detect$2().browser.isFirefox()) return Optional.none();
				else return Optional.from(win$1.visualViewport);
			};
			const bounds$1 = (x, y, width$1, height$1) => ({
				x,
				y,
				width: width$1,
				height: height$1,
				right: x + width$1,
				bottom: y + height$1
			});
			const getBounds$3 = (_win) => {
				const win$1 = _win === void 0 ? window : _win;
				const doc = win$1.document;
				const scroll = get$b(SugarElement.fromDom(doc));
				return get$a(win$1).fold(() => {
					const html$2 = win$1.document.documentElement;
					const width$1 = html$2.clientWidth;
					const height$1 = html$2.clientHeight;
					return bounds$1(scroll.left, scroll.top, width$1, height$1);
				}, (visualViewport) => bounds$1(Math.max(visualViewport.pageLeft, scroll.left), Math.max(visualViewport.pageTop, scroll.top), visualViewport.width, visualViewport.height));
			};
			const getDocument = () => SugarElement.fromDom(document);
			const walkUp = (navigation, doc) => {
				return navigation.view(doc).fold(constant$1([]), (f$1) => {
					const rest = walkUp(navigation, navigation.owner(f$1));
					return [f$1].concat(rest);
				});
			};
			const pathTo = (element$1, navigation) => {
				const paths = walkUp(navigation, navigation.owner(element$1));
				return Optional.some(paths);
			};
			const view = (doc) => {
				var _a;
				return (doc.dom === document ? Optional.none() : Optional.from((_a = doc.dom.defaultView) === null || _a === void 0 ? void 0 : _a.frameElement)).map(SugarElement.fromDom);
			};
			const owner$3 = (element$1) => owner$4(element$1);
			var Navigation = /* @__PURE__ */ Object.freeze({
				__proto__: null,
				view,
				owner: owner$3
			});
			const find$2 = (element$1) => {
				const scroll = get$b(getDocument());
				return pathTo(element$1, Navigation).fold(curry(absolute$3, element$1), (frames) => {
					const offset$1 = viewport$1(element$1);
					const r$2 = foldr(frames, (b$1, a) => {
						const loc = viewport$1(a);
						return {
							left: b$1.left + loc.left,
							top: b$1.top + loc.top
						};
					}, {
						left: 0,
						top: 0
					});
					return SugarPosition(r$2.left + offset$1.left + scroll.left, r$2.top + offset$1.top + scroll.top);
				});
			};
			const pointed = (point$1, width$1, height$1) => ({
				point: point$1,
				width: width$1,
				height: height$1
			});
			const rect = (x, y, width$1, height$1) => ({
				x,
				y,
				width: width$1,
				height: height$1
			});
			const bounds = (x, y, width$1, height$1) => ({
				x,
				y,
				width: width$1,
				height: height$1,
				right: x + width$1,
				bottom: y + height$1
			});
			const box$1 = (element$1) => {
				const xy = absolute$3(element$1);
				const w = getOuter$1(element$1);
				const h = getOuter$2(element$1);
				return bounds(xy.left, xy.top, w, h);
			};
			const absolute$2 = (element$1) => {
				const position$3 = find$2(element$1);
				const width$1 = getOuter$1(element$1);
				const height$1 = getOuter$2(element$1);
				return bounds(position$3.left, position$3.top, width$1, height$1);
			};
			const constrain = (original$1, constraint) => {
				const left$1 = Math.max(original$1.x, constraint.x);
				const top$1 = Math.max(original$1.y, constraint.y);
				const right$1 = Math.min(original$1.right, constraint.right);
				const bottom$1 = Math.min(original$1.bottom, constraint.bottom);
				return bounds(left$1, top$1, right$1 - left$1, bottom$1 - top$1);
			};
			const constrainByMany = (original$1, constraints) => {
				return foldl(constraints, (acc, c) => constrain(acc, c), original$1);
			};
			const win = () => getBounds$3(window);
			var global$a = tinymce.util.Tools.resolve("tinymce.ThemeManager");
			const value$4 = (value$5) => {
				const applyHelper = (fn) => fn(value$5);
				const constHelper = constant$1(value$5);
				const outputHelper = () => output$2;
				const output$2 = {
					tag: true,
					inner: value$5,
					fold: (_onError, onValue) => onValue(value$5),
					isValue: always,
					isError: never,
					map: (mapper) => Result.value(mapper(value$5)),
					mapError: outputHelper,
					bind: applyHelper,
					exists: applyHelper,
					forall: applyHelper,
					getOr: constHelper,
					or: outputHelper,
					getOrThunk: constHelper,
					orThunk: outputHelper,
					getOrDie: constHelper,
					each: (fn) => {
						fn(value$5);
					},
					toOptional: () => Optional.some(value$5)
				};
				return output$2;
			};
			const error$1 = (error$2) => {
				const outputHelper = () => output$2;
				const output$2 = {
					tag: false,
					inner: error$2,
					fold: (onError, _onValue) => onError(error$2),
					isValue: never,
					isError: always,
					map: outputHelper,
					mapError: (mapper) => Result.error(mapper(error$2)),
					bind: outputHelper,
					exists: never,
					forall: always,
					getOr: identity,
					or: identity,
					getOrThunk: apply$1,
					orThunk: apply$1,
					getOrDie: die(String(error$2)),
					each: noop,
					toOptional: Optional.none
				};
				return output$2;
			};
			const fromOption = (optional$1, err) => optional$1.fold(() => error$1(err), value$4);
			const Result = {
				value: value$4,
				error: error$1,
				fromOption
			};
			var SimpleResultType;
			(function(SimpleResultType$1) {
				SimpleResultType$1[SimpleResultType$1["Error"] = 0] = "Error";
				SimpleResultType$1[SimpleResultType$1["Value"] = 1] = "Value";
			})(SimpleResultType || (SimpleResultType = {}));
			const fold$1 = (res, onError, onValue) => res.stype === SimpleResultType.Error ? onError(res.serror) : onValue(res.svalue);
			const partition$2 = (results) => {
				const values$1 = [];
				const errors = [];
				each$1(results, (obj) => {
					fold$1(obj, (err) => errors.push(err), (val) => values$1.push(val));
				});
				return {
					values: values$1,
					errors
				};
			};
			const mapError = (res, f$1) => {
				if (res.stype === SimpleResultType.Error) return {
					stype: SimpleResultType.Error,
					serror: f$1(res.serror)
				};
				else return res;
			};
			const map = (res, f$1) => {
				if (res.stype === SimpleResultType.Value) return {
					stype: SimpleResultType.Value,
					svalue: f$1(res.svalue)
				};
				else return res;
			};
			const bind$1 = (res, f$1) => {
				if (res.stype === SimpleResultType.Value) return f$1(res.svalue);
				else return res;
			};
			const bindError = (res, f$1) => {
				if (res.stype === SimpleResultType.Error) return f$1(res.serror);
				else return res;
			};
			const svalue = (v) => ({
				stype: SimpleResultType.Value,
				svalue: v
			});
			const serror = (e) => ({
				stype: SimpleResultType.Error,
				serror: e
			});
			const toResult$1 = (res) => fold$1(res, Result.error, Result.value);
			const fromResult$1 = (res) => res.fold(serror, svalue);
			const SimpleResult = {
				fromResult: fromResult$1,
				toResult: toResult$1,
				svalue,
				partition: partition$2,
				serror,
				bind: bind$1,
				bindError,
				map,
				mapError,
				fold: fold$1
			};
			const field$2 = (key, newKey, presence, prop) => ({
				tag: "field",
				key,
				newKey,
				presence,
				prop
			});
			const customField$1 = (newKey, instantiator) => ({
				tag: "custom",
				newKey,
				instantiator
			});
			const fold = (value$5, ifField, ifCustom) => {
				switch (value$5.tag) {
					case "field": return ifField(value$5.key, value$5.newKey, value$5.presence, value$5.prop);
					case "custom": return ifCustom(value$5.newKey, value$5.instantiator);
				}
			};
			const shallow$1 = (old, nu$10) => {
				return nu$10;
			};
			const deep = (old, nu$10) => {
				return isPlainObject(old) && isPlainObject(nu$10) ? deepMerge(old, nu$10) : nu$10;
			};
			const baseMerge = (merger) => {
				return (...objects) => {
					if (objects.length === 0) throw new Error(`Can't merge zero objects`);
					const ret = {};
					for (let j = 0; j < objects.length; j++) {
						const curObject = objects[j];
						for (const key in curObject) if (has$2(curObject, key)) ret[key] = merger(ret[key], curObject[key]);
					}
					return ret;
				};
			};
			const deepMerge = baseMerge(deep);
			const merge$1 = baseMerge(shallow$1);
			const required$2 = () => ({
				tag: "required",
				process: {}
			});
			const defaultedThunk = (fallbackThunk) => ({
				tag: "defaultedThunk",
				process: fallbackThunk
			});
			const defaulted$1 = (fallback$1) => defaultedThunk(constant$1(fallback$1));
			const asOption = () => ({
				tag: "option",
				process: {}
			});
			const mergeWithThunk = (baseThunk) => ({
				tag: "mergeWithThunk",
				process: baseThunk
			});
			const mergeWith = (base$1) => mergeWithThunk(constant$1(base$1));
			const mergeValues$1 = (values$1, base$1) => values$1.length > 0 ? SimpleResult.svalue(deepMerge(base$1, merge$1.apply(void 0, values$1))) : SimpleResult.svalue(base$1);
			const mergeErrors$1 = (errors) => compose(SimpleResult.serror, flatten)(errors);
			const consolidateObj = (objects, base$1) => {
				const partition$4 = SimpleResult.partition(objects);
				return partition$4.errors.length > 0 ? mergeErrors$1(partition$4.errors) : mergeValues$1(partition$4.values, base$1);
			};
			const consolidateArr = (objects) => {
				const partitions = SimpleResult.partition(objects);
				return partitions.errors.length > 0 ? mergeErrors$1(partitions.errors) : SimpleResult.svalue(partitions.values);
			};
			const ResultCombine = {
				consolidateObj,
				consolidateArr
			};
			const formatObj = (input$1) => {
				return isObject(input$1) && keys(input$1).length > 100 ? " removed due to size" : JSON.stringify(input$1, null, 2);
			};
			const formatErrors = (errors) => {
				return map$2(errors.length > 10 ? errors.slice(0, 10).concat([{
					path: [],
					getErrorInfo: constant$1("... (only showing first ten failures)")
				}]) : errors, (e) => {
					return "Failed path: (" + e.path.join(" > ") + ")\n" + e.getErrorInfo();
				});
			};
			const nu$a = (path$2, getErrorInfo) => {
				return SimpleResult.serror([{
					path: path$2,
					getErrorInfo
				}]);
			};
			const missingRequired = (path$2, key, obj) => nu$a(path$2, () => "Could not find valid *required* value for \"" + key + "\" in " + formatObj(obj));
			const missingKey = (path$2, key) => nu$a(path$2, () => "Choice schema did not contain choice key: \"" + key + "\"");
			const missingBranch = (path$2, branches, branch) => nu$a(path$2, () => "The chosen schema: \"" + branch + "\" did not exist in branches: " + formatObj(branches));
			const unsupportedFields = (path$2, unsupported) => nu$a(path$2, () => "There are unsupported fields: [" + unsupported.join(", ") + "] specified");
			const custom = (path$2, err) => nu$a(path$2, constant$1(err));
			const value$3 = (validator) => {
				const extract$1 = (path$2, val) => {
					return SimpleResult.bindError(validator(val), (err) => custom(path$2, err));
				};
				return {
					extract: extract$1,
					toString: constant$1("val")
				};
			};
			const anyValue$1 = value$3(SimpleResult.svalue);
			const requiredAccess = (path$2, obj, key, bundle) => get$g(obj, key).fold(() => missingRequired(path$2, key, obj), bundle);
			const fallbackAccess = (obj, key, fallback$1, bundle) => {
				return bundle(get$g(obj, key).getOrThunk(() => fallback$1(obj)));
			};
			const optionAccess = (obj, key, bundle) => bundle(get$g(obj, key));
			const optionDefaultedAccess = (obj, key, fallback$1, bundle) => {
				return bundle(get$g(obj, key).map((val) => val === true ? fallback$1(obj) : val));
			};
			const extractField = (field$3, path$2, obj, key, prop) => {
				const bundle = (av) => prop.extract(path$2.concat([key]), av);
				const bundleAsOption = (optValue) => optValue.fold(() => SimpleResult.svalue(Optional.none()), (ov) => {
					const result = prop.extract(path$2.concat([key]), ov);
					return SimpleResult.map(result, Optional.some);
				});
				switch (field$3.tag) {
					case "required": return requiredAccess(path$2, obj, key, bundle);
					case "defaultedThunk": return fallbackAccess(obj, key, field$3.process, bundle);
					case "option": return optionAccess(obj, key, bundleAsOption);
					case "defaultedOptionThunk": return optionDefaultedAccess(obj, key, field$3.process, bundleAsOption);
					case "mergeWithThunk": return fallbackAccess(obj, key, constant$1({}), (v) => {
						return bundle(deepMerge(field$3.process(obj), v));
					});
				}
			};
			const extractFields = (path$2, obj, fields) => {
				const success = {};
				const errors = [];
				for (const field$3 of fields) fold(field$3, (key, newKey, presence, prop) => {
					const result = extractField(presence, path$2, obj, key, prop);
					SimpleResult.fold(result, (err) => {
						errors.push(...err);
					}, (res) => {
						success[newKey] = res;
					});
				}, (newKey, instantiator) => {
					success[newKey] = instantiator(obj);
				});
				return errors.length > 0 ? SimpleResult.serror(errors) : SimpleResult.svalue(success);
			};
			const valueThunk = (getDelegate) => {
				const extract$1 = (path$2, val) => getDelegate().extract(path$2, val);
				const toString$1 = () => getDelegate().toString();
				return {
					extract: extract$1,
					toString: toString$1
				};
			};
			const getSetKeys = (obj) => keys(filter$1(obj, isNonNullable));
			const objOfOnly = (fields) => {
				const delegate = objOf(fields);
				const fieldNames = foldr(fields, (acc, value$5) => {
					return fold(value$5, (key) => deepMerge(acc, { [key]: true }), constant$1(acc));
				}, {});
				const extract$1 = (path$2, o) => {
					const extra = filter$2(isBoolean(o) ? [] : getSetKeys(o), (k) => !hasNonNullableKey(fieldNames, k));
					return extra.length === 0 ? delegate.extract(path$2, o) : unsupportedFields(path$2, extra);
				};
				return {
					extract: extract$1,
					toString: delegate.toString
				};
			};
			const objOf = (values$1) => {
				const extract$1 = (path$2, o) => extractFields(path$2, o, values$1);
				const toString$1 = () => {
					return "obj{\n" + map$2(values$1, (value$5) => fold(value$5, (key, _okey, _presence, prop) => key + " -> " + prop.toString(), (newKey, _instantiator) => "state(" + newKey + ")")).join("\n") + "}";
				};
				return {
					extract: extract$1,
					toString: toString$1
				};
			};
			const arrOf = (prop) => {
				const extract$1 = (path$2, array) => {
					const results = map$2(array, (a, i) => prop.extract(path$2.concat(["[" + i + "]"]), a));
					return ResultCombine.consolidateArr(results);
				};
				const toString$1 = () => "array(" + prop.toString() + ")";
				return {
					extract: extract$1,
					toString: toString$1
				};
			};
			const oneOf = (props, rawF) => {
				const f$1 = rawF !== void 0 ? rawF : identity;
				const extract$1 = (path$2, val) => {
					const errors = [];
					for (const prop of props) {
						const res = prop.extract(path$2, val);
						if (res.stype === SimpleResultType.Value) return {
							stype: SimpleResultType.Value,
							svalue: f$1(res.svalue)
						};
						errors.push(res);
					}
					return ResultCombine.consolidateArr(errors);
				};
				const toString$1 = () => "oneOf(" + map$2(props, (prop) => prop.toString()).join(", ") + ")";
				return {
					extract: extract$1,
					toString: toString$1
				};
			};
			const setOf$1 = (validator, prop) => {
				const validateKeys = (path$2, keys$1) => arrOf(value$3(validator)).extract(path$2, keys$1);
				const extract$1 = (path$2, o) => {
					const validatedKeys = validateKeys(path$2, keys(o));
					return SimpleResult.bind(validatedKeys, (validKeys) => {
						return objOf(map$2(validKeys, (vk) => {
							return field$2(vk, vk, required$2(), prop);
						})).extract(path$2, o);
					});
				};
				const toString$1 = () => "setOf(" + prop.toString() + ")";
				return {
					extract: extract$1,
					toString: toString$1
				};
			};
			const thunk = (_desc, processor) => {
				const getP = cached(processor);
				const extract$1 = (path$2, val) => getP().extract(path$2, val);
				const toString$1 = () => getP().toString();
				return {
					extract: extract$1,
					toString: toString$1
				};
			};
			const arrOfObj = compose(arrOf, objOf);
			const anyValue = constant$1(anyValue$1);
			const typedValue = (validator, expectedType) => value$3((a) => {
				const actualType = typeof a;
				return validator(a) ? SimpleResult.svalue(a) : SimpleResult.serror(`Expected type: ${expectedType} but got: ${actualType}`);
			});
			const number = typedValue(isNumber, "number");
			const string = typedValue(isString, "string");
			const boolean = typedValue(isBoolean, "boolean");
			const functionProcessor = typedValue(isFunction, "function");
			const isPostMessageable = (val) => {
				if (Object(val) !== val) return true;
				switch ({}.toString.call(val).slice(8, -1)) {
					case "Boolean":
					case "Number":
					case "String":
					case "Date":
					case "RegExp":
					case "Blob":
					case "FileList":
					case "ImageData":
					case "ImageBitmap":
					case "ArrayBuffer": return true;
					case "Array":
					case "Object": return Object.keys(val).every((prop) => isPostMessageable(val[prop]));
					default: return false;
				}
			};
			const postMessageable = value$3((a) => {
				if (isPostMessageable(a)) return SimpleResult.svalue(a);
				else return SimpleResult.serror("Expected value to be acceptable for sending via postMessage");
			});
			const chooseFrom = (path$2, input$1, branches, ch) => {
				return get$g(branches, ch).fold(() => missingBranch(path$2, branches, ch), (vp) => vp.extract(path$2.concat(["branch: " + ch]), input$1));
			};
			const choose$2 = (key, branches) => {
				const extract$1 = (path$2, input$1) => {
					return get$g(input$1, key).fold(() => missingKey(path$2, key), (chosen) => chooseFrom(path$2, input$1, branches, chosen));
				};
				const toString$1 = () => "chooseOn(" + key + "). Possible values: " + keys(branches);
				return {
					extract: extract$1,
					toString: toString$1
				};
			};
			const arrOfVal = () => arrOf(anyValue$1);
			const valueOf = (validator) => value$3((v) => validator(v).fold(SimpleResult.serror, SimpleResult.svalue));
			const setOf = (validator, prop) => setOf$1((v) => SimpleResult.fromResult(validator(v)), prop);
			const extractValue = (label$1, prop, obj) => {
				const res = prop.extract([label$1], obj);
				return SimpleResult.mapError(res, (errs) => ({
					input: obj,
					errors: errs
				}));
			};
			const asRaw = (label$1, prop, obj) => SimpleResult.toResult(extractValue(label$1, prop, obj));
			const getOrDie = (extraction) => {
				return extraction.fold((errInfo) => {
					throw new Error(formatError(errInfo));
				}, identity);
			};
			const asRawOrDie$1 = (label$1, prop, obj) => getOrDie(asRaw(label$1, prop, obj));
			const formatError = (errInfo) => {
				return "Errors: \n" + formatErrors(errInfo.errors).join("\n") + "\n\nInput object: " + formatObj(errInfo.input);
			};
			const choose$1 = (key, branches) => choose$2(key, map$1(branches, objOf));
			const thunkOf = (desc, schema$10) => thunk(desc, schema$10);
			const field$1 = field$2;
			const customField = customField$1;
			const validateEnum = (values$1) => valueOf((value$5) => contains$2(values$1, value$5) ? Result.value(value$5) : Result.error(`Unsupported value: "${value$5}", choose one of "${values$1.join(", ")}".`));
			const required$1 = (key) => field$1(key, key, required$2(), anyValue());
			const requiredOf = (key, schema$10) => field$1(key, key, required$2(), schema$10);
			const requiredNumber = (key) => requiredOf(key, number);
			const requiredString = (key) => requiredOf(key, string);
			const requiredStringEnum = (key, values$1) => field$1(key, key, required$2(), validateEnum(values$1));
			const requiredBoolean = (key) => requiredOf(key, boolean);
			const requiredFunction = (key) => requiredOf(key, functionProcessor);
			const forbid = (key, message) => field$1(key, key, asOption(), value$3((_v) => SimpleResult.serror("The field: " + key + " is forbidden. " + message)));
			const requiredObjOf = (key, objSchema) => field$1(key, key, required$2(), objOf(objSchema));
			const requiredArrayOfObj = (key, objFields) => field$1(key, key, required$2(), arrOfObj(objFields));
			const requiredArrayOf = (key, schema$10) => field$1(key, key, required$2(), arrOf(schema$10));
			const option$3 = (key) => field$1(key, key, asOption(), anyValue());
			const optionOf = (key, schema$10) => field$1(key, key, asOption(), schema$10);
			const optionNumber = (key) => optionOf(key, number);
			const optionString = (key) => optionOf(key, string);
			const optionStringEnum = (key, values$1) => optionOf(key, validateEnum(values$1));
			const optionFunction = (key) => optionOf(key, functionProcessor);
			const optionArrayOf = (key, schema$10) => optionOf(key, arrOf(schema$10));
			const optionObjOf = (key, objSchema) => optionOf(key, objOf(objSchema));
			const optionObjOfOnly = (key, objSchema) => optionOf(key, objOfOnly(objSchema));
			const defaulted = (key, fallback$1) => field$1(key, key, defaulted$1(fallback$1), anyValue());
			const defaultedOf = (key, fallback$1, schema$10) => field$1(key, key, defaulted$1(fallback$1), schema$10);
			const defaultedNumber = (key, fallback$1) => defaultedOf(key, fallback$1, number);
			const defaultedString = (key, fallback$1) => defaultedOf(key, fallback$1, string);
			const defaultedStringEnum = (key, fallback$1, values$1) => defaultedOf(key, fallback$1, validateEnum(values$1));
			const defaultedBoolean = (key, fallback$1) => defaultedOf(key, fallback$1, boolean);
			const defaultedFunction = (key, fallback$1) => defaultedOf(key, fallback$1, functionProcessor);
			const defaultedPostMsg = (key, fallback$1) => defaultedOf(key, fallback$1, postMessageable);
			const defaultedArrayOf = (key, fallback$1, schema$10) => defaultedOf(key, fallback$1, arrOf(schema$10));
			const defaultedObjOf = (key, fallback$1, objSchema) => defaultedOf(key, fallback$1, objOf(objSchema));
			const Cell = (initial) => {
				let value$5 = initial;
				const get$10 = () => {
					return value$5;
				};
				const set$10 = (v) => {
					value$5 = v;
				};
				return {
					get: get$10,
					set: set$10
				};
			};
			const generate$7 = (cases) => {
				if (!isArray(cases)) throw new Error("cases must be an array");
				if (cases.length === 0) throw new Error("there must be at least one case");
				const constructors = [];
				const adt$10 = {};
				each$1(cases, (acase, count) => {
					const keys$1 = keys(acase);
					if (keys$1.length !== 1) throw new Error("one and only one name per case");
					const key = keys$1[0];
					const value$5 = acase[key];
					if (adt$10[key] !== void 0) throw new Error("duplicate key detected:" + key);
					else if (key === "cata") throw new Error("cannot have a case named cata (sorry)");
					else if (!isArray(value$5)) throw new Error("case arguments must be an array");
					constructors.push(key);
					adt$10[key] = (...args) => {
						const argLength = args.length;
						if (argLength !== value$5.length) throw new Error("Wrong number of arguments to case " + key + ". Expected " + value$5.length + " (" + value$5 + "), got " + argLength);
						const match = (branches) => {
							const branchKeys = keys(branches);
							if (constructors.length !== branchKeys.length) throw new Error("Wrong number of arguments to match. Expected: " + constructors.join(",") + "\nActual: " + branchKeys.join(","));
							if (!forall(constructors, (reqKey) => {
								return contains$2(branchKeys, reqKey);
							})) throw new Error("Not all branches were specified when using match. Specified: " + branchKeys.join(", ") + "\nRequired: " + constructors.join(", "));
							return branches[key].apply(null, args);
						};
						return {
							fold: (...foldArgs) => {
								if (foldArgs.length !== cases.length) throw new Error("Wrong number of arguments to fold. Expected " + cases.length + ", got " + foldArgs.length);
								return foldArgs[count].apply(null, args);
							},
							match,
							log: (label$1) => {
								console.log(label$1, {
									constructors,
									constructor: key,
									params: args
								});
							}
						};
					};
				});
				return adt$10;
			};
			const Adt = { generate: generate$7 };
			Adt.generate([
				{ bothErrors: ["error1", "error2"] },
				{ firstError: ["error1", "value2"] },
				{ secondError: ["value1", "error2"] },
				{ bothValues: ["value1", "value2"] }
			]);
			const partition$1 = (results) => {
				const errors = [];
				const values$1 = [];
				each$1(results, (result) => {
					result.fold((err) => {
						errors.push(err);
					}, (value$5) => {
						values$1.push(value$5);
					});
				});
				return {
					errors,
					values: values$1
				};
			};
			const exclude$1 = (obj, fields) => {
				const r$2 = {};
				each(obj, (v, k) => {
					if (!contains$2(fields, k)) r$2[k] = v;
				});
				return r$2;
			};
			const wrap$2 = (key, value$5) => ({ [key]: value$5 });
			const wrapAll$1 = (keyvalues) => {
				const r$2 = {};
				each$1(keyvalues, (kv) => {
					r$2[kv.key] = kv.value;
				});
				return r$2;
			};
			const exclude = (obj, fields) => exclude$1(obj, fields);
			const wrap$1 = (key, value$5) => wrap$2(key, value$5);
			const wrapAll = (keyvalues) => wrapAll$1(keyvalues);
			const mergeValues = (values$1, base$1) => {
				return values$1.length === 0 ? Result.value(base$1) : Result.value(deepMerge(base$1, merge$1.apply(void 0, values$1)));
			};
			const mergeErrors = (errors) => Result.error(flatten(errors));
			const consolidate = (objs, base$1) => {
				const partitions = partition$1(objs);
				return partitions.errors.length > 0 ? mergeErrors(partitions.errors) : mergeValues(partitions.values, base$1);
			};
			const ensureIsRoot = (isRoot) => isFunction(isRoot) ? isRoot : never;
			const ancestor$2 = (scope, transform$1, isRoot) => {
				let element$1 = scope.dom;
				const stop$1 = ensureIsRoot(isRoot);
				while (element$1.parentNode) {
					element$1 = element$1.parentNode;
					const el = SugarElement.fromDom(element$1);
					const transformed = transform$1(el);
					if (transformed.isSome()) return transformed;
					else if (stop$1(el)) break;
				}
				return Optional.none();
			};
			const closest$4 = (scope, transform$1, isRoot) => {
				const current = transform$1(scope);
				const stop$1 = ensureIsRoot(isRoot);
				return current.orThunk(() => stop$1(scope) ? Optional.none() : ancestor$2(scope, transform$1, stop$1));
			};
			const isSource = (component, simulatedEvent) => eq(component.element, simulatedEvent.event.target);
			const defaultEventHandler = {
				can: always,
				abort: never,
				run: noop
			};
			const nu$9 = (parts$10) => {
				if (!hasNonNullableKey(parts$10, "can") && !hasNonNullableKey(parts$10, "abort") && !hasNonNullableKey(parts$10, "run")) throw new Error("EventHandler defined by: " + JSON.stringify(parts$10, null, 2) + " does not have can, abort, or run!");
				return {
					...defaultEventHandler,
					...parts$10
				};
			};
			const all$2 = (handlers$1, f$1) => (...args) => foldl(handlers$1, (acc, handler) => acc && f$1(handler).apply(void 0, args), true);
			const any = (handlers$1, f$1) => (...args) => foldl(handlers$1, (acc, handler) => acc || f$1(handler).apply(void 0, args), false);
			const read$2 = (handler) => isFunction(handler) ? {
				can: always,
				abort: never,
				run: handler
			} : handler;
			const fuse$1 = (handlers$1) => {
				const can$1 = all$2(handlers$1, (handler) => handler.can);
				const abort$1 = any(handlers$1, (handler) => handler.abort);
				const run$2 = (...args) => {
					each$1(handlers$1, (handler) => {
						handler.run.apply(void 0, args);
					});
				};
				return {
					can: can$1,
					abort: abort$1,
					run: run$2
				};
			};
			const constant = constant$1;
			const touchstart = constant("touchstart");
			const touchmove = constant("touchmove");
			const touchend = constant("touchend");
			const touchcancel = constant("touchcancel");
			const mousedown = constant("mousedown");
			const mousemove = constant("mousemove");
			const mouseout = constant("mouseout");
			const mouseup = constant("mouseup");
			const mouseover = constant("mouseover");
			const focusin = constant("focusin");
			const focusout = constant("focusout");
			const keydown = constant("keydown");
			const keyup = constant("keyup");
			const input = constant("input");
			const change = constant("change");
			const click = constant("click");
			const transitioncancel = constant("transitioncancel");
			const transitionend = constant("transitionend");
			const transitionstart = constant("transitionstart");
			const selectstart = constant("selectstart");
			const prefixName = (name$4) => constant$1("alloy." + name$4);
			const alloy = { tap: prefixName("tap") };
			const focus$4 = prefixName("focus");
			const postBlur = prefixName("blur.post");
			const postPaste = prefixName("paste.post");
			const receive = prefixName("receive");
			const execute$5 = prefixName("execute");
			const focusItem = prefixName("focus.item");
			const tap = alloy.tap;
			const longpress = prefixName("longpress");
			const sandboxClose = prefixName("sandbox.close");
			const typeaheadCancel = prefixName("typeahead.cancel");
			const systemInit = prefixName("system.init");
			const documentTouchmove = prefixName("system.touchmove");
			const documentTouchend = prefixName("system.touchend");
			const windowScroll = prefixName("system.scroll");
			const windowResize = prefixName("system.resize");
			const attachedToDom = prefixName("system.attached");
			const detachedFromDom = prefixName("system.detached");
			const dismissRequested = prefixName("system.dismissRequested");
			const repositionRequested = prefixName("system.repositionRequested");
			const focusShifted = prefixName("focusmanager.shifted");
			const slotVisibility = prefixName("slotcontainer.visibility");
			const externalElementScroll = prefixName("system.external.element.scroll");
			const changeTab = prefixName("change.tab");
			const dismissTab = prefixName("dismiss.tab");
			const highlight$1 = prefixName("highlight");
			const dehighlight$1 = prefixName("dehighlight");
			const emit = (component, event) => {
				dispatchWith(component, component.element, event, {});
			};
			const emitWith = (component, event, properties$1) => {
				dispatchWith(component, component.element, event, properties$1);
			};
			const emitExecute = (component) => {
				emit(component, execute$5());
			};
			const dispatch = (component, target, event) => {
				dispatchWith(component, target, event, {});
			};
			const dispatchWith = (component, target, event, properties$1) => {
				const data = {
					target,
					...properties$1
				};
				component.getSystem().triggerEvent(event, target, data);
			};
			const retargetAndDispatchWith = (component, target, eventName, properties$1) => {
				const data = {
					...properties$1,
					target
				};
				component.getSystem().triggerEvent(eventName, target, data);
			};
			const dispatchEvent = (component, target, event, simulatedEvent) => {
				component.getSystem().triggerEvent(event, target, simulatedEvent.event);
			};
			const derive$2 = (configs) => wrapAll(configs);
			const abort = (name$4, predicate) => {
				return {
					key: name$4,
					value: nu$9({ abort: predicate })
				};
			};
			const can = (name$4, predicate) => {
				return {
					key: name$4,
					value: nu$9({ can: predicate })
				};
			};
			const preventDefault = (name$4) => {
				return {
					key: name$4,
					value: nu$9({ run: (component, simulatedEvent) => {
						simulatedEvent.event.prevent();
					} })
				};
			};
			const run$1 = (name$4, handler) => {
				return {
					key: name$4,
					value: nu$9({ run: handler })
				};
			};
			const runActionExtra = (name$4, action, extra) => {
				return {
					key: name$4,
					value: nu$9({ run: (component, simulatedEvent) => {
						action.apply(void 0, [component, simulatedEvent].concat(extra));
					} })
				};
			};
			const runOnName = (name$4) => {
				return (handler) => run$1(name$4, handler);
			};
			const runOnSourceName = (name$4) => {
				return (handler) => ({
					key: name$4,
					value: nu$9({ run: (component, simulatedEvent) => {
						if (isSource(component, simulatedEvent)) handler(component, simulatedEvent);
					} })
				});
			};
			const redirectToUid = (name$4, uid) => {
				return run$1(name$4, (component, simulatedEvent) => {
					component.getSystem().getByUid(uid).each((redirectee) => {
						dispatchEvent(redirectee, redirectee.element, name$4, simulatedEvent);
					});
				});
			};
			const redirectToPart = (name$4, detail, partName) => {
				const uid = detail.partUids[partName];
				return redirectToUid(name$4, uid);
			};
			const runWithTarget = (name$4, f$1) => {
				return run$1(name$4, (component, simulatedEvent) => {
					const ev = simulatedEvent.event;
					f$1(component, component.getSystem().getByDom(ev.target).getOrThunk(() => {
						return closest$4(ev.target, (el) => component.getSystem().getByDom(el).toOptional(), never).getOr(component);
					}), simulatedEvent);
				});
			};
			const cutter = (name$4) => {
				return run$1(name$4, (component, simulatedEvent) => {
					simulatedEvent.cut();
				});
			};
			const stopper = (name$4) => {
				return run$1(name$4, (component, simulatedEvent) => {
					simulatedEvent.stop();
				});
			};
			const runOnSource = (name$4, f$1) => {
				return runOnSourceName(name$4)(f$1);
			};
			const runOnAttached = runOnSourceName(attachedToDom());
			const runOnDetached = runOnSourceName(detachedFromDom());
			const runOnInit = runOnSourceName(systemInit());
			const runOnExecute$1 = runOnName(execute$5());
			const fromHtml$1 = (html$2, scope) => {
				const div = (scope || document).createElement("div");
				div.innerHTML = html$2;
				return children(SugarElement.fromDom(div));
			};
			const get$9 = (element$1) => element$1.dom.innerHTML;
			const set$6 = (element$1, content) => {
				const docDom = owner$4(element$1).dom;
				const fragment = SugarElement.fromDom(docDom.createDocumentFragment());
				append$1(fragment, fromHtml$1(content, docDom));
				empty(element$1);
				append$2(element$1, fragment);
			};
			const getOuter = (element$1) => {
				const container = SugarElement.fromTag("div");
				append$2(container, SugarElement.fromDom(element$1.dom.cloneNode(true)));
				return get$9(container);
			};
			const clone$1 = (original$1, isDeep) => SugarElement.fromDom(original$1.dom.cloneNode(isDeep));
			const shallow = (original$1) => clone$1(original$1, false);
			const getHtml = (element$1) => {
				if (isShadowRoot(element$1)) return "#shadow-root";
				else return getOuter(shallow(element$1));
			};
			const element = (elem) => getHtml(elem);
			const isRecursive = (component, originator, target) => eq(originator, component.element) && !eq(originator, target);
			const events$i = derive$2([can(focus$4(), (component, simulatedEvent) => {
				const event = simulatedEvent.event;
				const originator = event.originator;
				const target = event.target;
				if (isRecursive(component, originator, target)) {
					console.warn(focus$4() + " did not get interpreted by the desired target. \nOriginator: " + element(originator) + "\nTarget: " + element(target) + "\nCheck the " + focus$4() + " event handlers");
					return false;
				} else return true;
			})]);
			var DefaultEvents = /* @__PURE__ */ Object.freeze({
				__proto__: null,
				events: events$i
			});
			let unique = 0;
			const generate$6 = (prefix$2) => {
				const time = (/* @__PURE__ */ new Date()).getTime();
				const random = Math.floor(Math.random() * 1e9);
				unique++;
				return prefix$2 + "_" + random + unique + String(time);
			};
			const prefix$1 = constant$1("alloy-id-");
			const idAttr$1 = constant$1("data-alloy-id");
			const prefix = prefix$1();
			const idAttr = idAttr$1();
			const write = (label$1, elem) => {
				const id = generate$6(prefix + label$1);
				writeOnly(elem, id);
				return id;
			};
			const writeOnly = (elem, uid) => {
				Object.defineProperty(elem.dom, idAttr, {
					value: uid,
					writable: true
				});
			};
			const read$1 = (elem) => {
				const id = isElement$1(elem) ? elem.dom[idAttr] : null;
				return Optional.from(id);
			};
			const generate$5 = (prefix$2) => generate$6(prefix$2);
			const make$8 = identity;
			const NoContextApi = (getComp) => {
				const getMessage = (event) => `The component must be in a context to execute: ${event}` + (getComp ? "\n" + element(getComp().element) + " is not in context." : "");
				const fail = (event) => () => {
					throw new Error(getMessage(event));
				};
				const warn = (event) => () => {
					console.warn(getMessage(event));
				};
				return {
					debugInfo: constant$1("fake"),
					triggerEvent: warn("triggerEvent"),
					triggerFocus: warn("triggerFocus"),
					triggerEscape: warn("triggerEscape"),
					broadcast: warn("broadcast"),
					broadcastOn: warn("broadcastOn"),
					broadcastEvent: warn("broadcastEvent"),
					build: fail("build"),
					buildOrPatch: fail("buildOrPatch"),
					addToWorld: fail("addToWorld"),
					removeFromWorld: fail("removeFromWorld"),
					addToGui: fail("addToGui"),
					removeFromGui: fail("removeFromGui"),
					getByUid: fail("getByUid"),
					getByDom: fail("getByDom"),
					isConnected: never
				};
			};
			const singleton$1 = NoContextApi();
			const markAsBehaviourApi = (f$1, apiName, apiFunction) => {
				const delegate = apiFunction.toString();
				const endIndex = delegate.indexOf(")") + 1;
				const openBracketIndex = delegate.indexOf("(");
				const parameters = delegate.substring(openBracketIndex + 1, endIndex - 1).split(/,\s*/);
				f$1.toFunctionAnnotation = () => ({
					name: apiName,
					parameters: cleanParameters(parameters.slice(0, 1).concat(parameters.slice(3)))
				});
				return f$1;
			};
			const cleanParameters = (parameters) => map$2(parameters, (p) => endsWith(p, "/*") ? p.substring(0, p.length - 2) : p);
			const markAsExtraApi = (f$1, extraName) => {
				const delegate = f$1.toString();
				const endIndex = delegate.indexOf(")") + 1;
				const openBracketIndex = delegate.indexOf("(");
				const parameters = delegate.substring(openBracketIndex + 1, endIndex - 1).split(/,\s*/);
				f$1.toFunctionAnnotation = () => ({
					name: extraName,
					parameters: cleanParameters(parameters)
				});
				return f$1;
			};
			const markAsSketchApi = (f$1, apiFunction) => {
				const delegate = apiFunction.toString();
				const endIndex = delegate.indexOf(")") + 1;
				const openBracketIndex = delegate.indexOf("(");
				const parameters = delegate.substring(openBracketIndex + 1, endIndex - 1).split(/,\s*/);
				f$1.toFunctionAnnotation = () => ({
					name: "OVERRIDE",
					parameters: cleanParameters(parameters.slice(1))
				});
				return f$1;
			};
			const premadeTag = generate$6("alloy-premade");
			const premade$1 = (comp) => {
				Object.defineProperty(comp.element.dom, premadeTag, {
					value: comp.uid,
					writable: true
				});
				return wrap$1(premadeTag, comp);
			};
			const isPremade = (element$1) => has$2(element$1.dom, premadeTag);
			const getPremade = (spec) => get$g(spec, premadeTag);
			const makeApi = (f$1) => markAsSketchApi((component, ...rest) => f$1(component.getApis(), component, ...rest), f$1);
			const NoState = { init: () => nu$8({ readState: constant$1("No State required") }) };
			const nu$8 = (spec) => spec;
			const generateFrom$1 = (spec, all$4) => {
				return {
					list: all$4,
					data: map$1(asRaw("component.behaviours", objOf(map$2(all$4, (a) => optionObjOf(a.name(), [required$1("config"), defaulted("state", NoState)]))), spec.behaviours).fold((errInfo) => {
						throw new Error(formatError(errInfo) + "\nComplete spec:\n" + JSON.stringify(spec, null, 2));
					}, identity), (optBlobThunk) => {
						return constant$1(optBlobThunk.map((blob) => ({
							config: blob.config,
							state: blob.state.init(blob.config)
						})));
					})
				};
			};
			const getBehaviours$3 = (bData) => bData.list;
			const getData$2 = (bData) => bData.data;
			const byInnerKey = (data, tuple) => {
				const r$2 = {};
				each(data, (detail, key) => {
					each(detail, (value$5, indexKey) => {
						r$2[indexKey] = get$g(r$2, indexKey).getOr([]).concat([tuple(key, value$5)]);
					});
				});
				return r$2;
			};
			const nu$7 = (s) => ({
				classes: isUndefined(s.classes) ? [] : s.classes,
				attributes: isUndefined(s.attributes) ? {} : s.attributes,
				styles: isUndefined(s.styles) ? {} : s.styles
			});
			const merge = (defnA, mod) => ({
				...defnA,
				attributes: {
					...defnA.attributes,
					...mod.attributes
				},
				styles: {
					...defnA.styles,
					...mod.styles
				},
				classes: defnA.classes.concat(mod.classes)
			});
			const combine$2 = (info, baseMod, behaviours$1, base$1) => {
				const modsByBehaviour = { ...baseMod };
				each$1(behaviours$1, (behaviour) => {
					modsByBehaviour[behaviour.name()] = behaviour.exhibit(info, base$1);
				});
				const byAspect = byInnerKey(modsByBehaviour, (name$4, modification) => ({
					name: name$4,
					modification
				}));
				const combineObjects = (objects) => foldr(objects, (b$1, a) => ({
					...a.modification,
					...b$1
				}), {});
				return nu$7({
					classes: foldr(byAspect.classes, (b$1, a) => a.modification.concat(b$1), []),
					attributes: combineObjects(byAspect.attributes),
					styles: combineObjects(byAspect.styles)
				});
			};
			const sortKeys = (label$1, keyName, array, order) => {
				try {
					const sorted = sort(array, (a, b$1) => {
						const aKey = a[keyName];
						const bKey = b$1[keyName];
						const aIndex = order.indexOf(aKey);
						const bIndex = order.indexOf(bKey);
						if (aIndex === -1) throw new Error("The ordering for " + label$1 + " does not have an entry for " + aKey + ".\nOrder specified: " + JSON.stringify(order, null, 2));
						if (bIndex === -1) throw new Error("The ordering for " + label$1 + " does not have an entry for " + bKey + ".\nOrder specified: " + JSON.stringify(order, null, 2));
						if (aIndex < bIndex) return -1;
						else if (bIndex < aIndex) return 1;
						else return 0;
					});
					return Result.value(sorted);
				} catch (err) {
					return Result.error([err]);
				}
			};
			const uncurried = (handler, purpose) => ({
				handler,
				purpose
			});
			const curried = (handler, purpose) => ({
				cHandler: handler,
				purpose
			});
			const curryArgs = (descHandler, extraArgs) => curried(curry.apply(void 0, [descHandler.handler].concat(extraArgs)), descHandler.purpose);
			const getCurried = (descHandler) => descHandler.cHandler;
			const behaviourTuple = (name$4, handler) => ({
				name: name$4,
				handler
			});
			const nameToHandlers = (behaviours$1, info) => {
				const r$2 = {};
				each$1(behaviours$1, (behaviour) => {
					r$2[behaviour.name()] = behaviour.handlers(info);
				});
				return r$2;
			};
			const groupByEvents = (info, behaviours$1, base$1) => {
				return byInnerKey({
					...base$1,
					...nameToHandlers(behaviours$1, info)
				}, behaviourTuple);
			};
			const combine$1 = (info, eventOrder, behaviours$1, base$1) => {
				return combineGroups(groupByEvents(info, behaviours$1, base$1), eventOrder);
			};
			const assemble = (rawHandler) => {
				const handler = read$2(rawHandler);
				return (component, simulatedEvent, ...rest) => {
					const args = [component, simulatedEvent].concat(rest);
					if (handler.abort.apply(void 0, args)) simulatedEvent.stop();
					else if (handler.can.apply(void 0, args)) handler.run.apply(void 0, args);
				};
			};
			const missingOrderError = (eventName, tuples) => Result.error(["The event (" + eventName + ") has more than one behaviour that listens to it.\nWhen this occurs, you must specify an event ordering for the behaviours in your spec (e.g. [ \"listing\", \"toggling\" ]).\nThe behaviours that can trigger it are: " + JSON.stringify(map$2(tuples, (c) => c.name), null, 2)]);
			const fuse = (tuples, eventOrder, eventName) => {
				const order = eventOrder[eventName];
				if (!order) return missingOrderError(eventName, tuples);
				else return sortKeys("Event: " + eventName, "name", tuples, order).map((sortedTuples) => {
					return fuse$1(map$2(sortedTuples, (tuple) => tuple.handler));
				});
			};
			const combineGroups = (byEventName, eventOrder) => {
				return consolidate(mapToArray(byEventName, (tuples, eventName) => {
					return (tuples.length === 1 ? Result.value(tuples[0].handler) : fuse(tuples, eventOrder, eventName)).map((handler) => {
						return wrap$1(eventName, uncurried(assemble(handler), tuples.length > 1 ? filter$2(eventOrder[eventName], (o) => exists(tuples, (t$1) => t$1.name === o)).join(" > ") : tuples[0].name));
					});
				}), {});
			};
			const baseBehaviour = "alloy.base.behaviour";
			const schema$z = objOf([
				field$1("dom", "dom", required$2(), objOf([
					required$1("tag"),
					defaulted("styles", {}),
					defaulted("classes", []),
					defaulted("attributes", {}),
					option$3("value"),
					option$3("innerHtml")
				])),
				required$1("components"),
				required$1("uid"),
				defaulted("events", {}),
				defaulted("apis", {}),
				field$1("eventOrder", "eventOrder", mergeWith({
					[execute$5()]: [
						"disabling",
						baseBehaviour,
						"toggling",
						"typeaheadevents"
					],
					[focus$4()]: [
						baseBehaviour,
						"focusing",
						"keying"
					],
					[systemInit()]: [
						baseBehaviour,
						"disabling",
						"toggling",
						"representing"
					],
					[input()]: [
						baseBehaviour,
						"representing",
						"streaming",
						"invalidating"
					],
					[detachedFromDom()]: [
						baseBehaviour,
						"representing",
						"item-events",
						"tooltipping"
					],
					[mousedown()]: [
						"focusing",
						baseBehaviour,
						"item-type-events"
					],
					[touchstart()]: [
						"focusing",
						baseBehaviour,
						"item-type-events"
					],
					[mouseover()]: ["item-type-events", "tooltipping"],
					[receive()]: [
						"receiving",
						"reflecting",
						"tooltipping"
					]
				}), anyValue()),
				option$3("domModification")
			]);
			const toInfo = (spec) => asRaw("custom.definition", schema$z, spec);
			const toDefinition = (detail) => ({
				...detail.dom,
				uid: detail.uid,
				domChildren: map$2(detail.components, (comp) => comp.element)
			});
			const toModification = (detail) => detail.domModification.fold(() => nu$7({}), nu$7);
			const toEvents = (info) => info.events;
			const read = (element$1, attr) => {
				const value$5 = get$f(element$1, attr);
				return value$5 === void 0 || value$5 === "" ? [] : value$5.split(" ");
			};
			const add$4 = (element$1, attr, id) => {
				set$9(element$1, attr, read(element$1, attr).concat([id]).join(" "));
				return true;
			};
			const remove$4 = (element$1, attr, id) => {
				const nu$10 = filter$2(read(element$1, attr), (v) => v !== id);
				if (nu$10.length > 0) set$9(element$1, attr, nu$10.join(" "));
				else remove$7(element$1, attr);
				return false;
			};
			const supports = (element$1) => element$1.dom.classList !== void 0;
			const get$8 = (element$1) => read(element$1, "class");
			const add$3 = (element$1, clazz) => add$4(element$1, "class", clazz);
			const remove$3 = (element$1, clazz) => remove$4(element$1, "class", clazz);
			const add$2 = (element$1, clazz) => {
				if (supports(element$1)) element$1.dom.classList.add(clazz);
				else add$3(element$1, clazz);
			};
			const cleanClass = (element$1) => {
				if ((supports(element$1) ? element$1.dom.classList : get$8(element$1)).length === 0) remove$7(element$1, "class");
			};
			const remove$2 = (element$1, clazz) => {
				if (supports(element$1)) element$1.dom.classList.remove(clazz);
				else remove$3(element$1, clazz);
				cleanClass(element$1);
			};
			const has = (element$1, clazz) => supports(element$1) && element$1.dom.classList.contains(clazz);
			const add$1 = (element$1, classes$1) => {
				each$1(classes$1, (x) => {
					add$2(element$1, x);
				});
			};
			const remove$1 = (element$1, classes$1) => {
				each$1(classes$1, (x) => {
					remove$2(element$1, x);
				});
			};
			const hasAll = (element$1, classes$1) => forall(classes$1, (clazz) => has(element$1, clazz));
			const getNative = (element$1) => {
				const classList = element$1.dom.classList;
				const r$2 = new Array(classList.length);
				for (let i = 0; i < classList.length; i++) {
					const item$1 = classList.item(i);
					if (item$1 !== null) r$2[i] = item$1;
				}
				return r$2;
			};
			const get$7 = (element$1) => supports(element$1) ? getNative(element$1) : get$8(element$1);
			const get$6 = (element$1) => element$1.dom.value;
			const set$5 = (element$1, value$5) => {
				if (value$5 === void 0) throw new Error("Value.set was undefined");
				element$1.dom.value = value$5;
			};
			const determineObsoleted = (parent$1, index, oldObsoleted) => {
				return child$2(parent$1, index).map((newObs) => {
					if (oldObsoleted.exists((o) => !eq(o, newObs))) {
						const oldTag = oldObsoleted.map(name$3).getOr("span");
						const marker = SugarElement.fromTag(oldTag);
						before$1(newObs, marker);
						return marker;
					} else return newObs;
				});
			};
			const ensureInDom = (parent$1, child$3, obsoleted) => {
				obsoleted.fold(() => append$2(parent$1, child$3), (obs) => {
					if (!eq(obs, child$3)) {
						before$1(obs, child$3);
						remove$5(obs);
					}
				});
			};
			const patchChildrenWith = (parent$1, nu$10, f$1) => {
				const builtChildren = map$2(nu$10, f$1);
				each$1(children(parent$1).slice(builtChildren.length), remove$5);
				return builtChildren;
			};
			const patchSpecChild = (parent$1, index, spec, build$3) => {
				const oldObsoleted = child$2(parent$1, index);
				const childComp = build$3(spec, oldObsoleted);
				const obsoleted = determineObsoleted(parent$1, index, oldObsoleted);
				ensureInDom(parent$1, childComp.element, obsoleted);
				return childComp;
			};
			const patchSpecChildren = (parent$1, specs, build$3) => patchChildrenWith(parent$1, specs, (spec, index) => patchSpecChild(parent$1, index, spec, build$3));
			const patchDomChildren = (parent$1, nodes) => patchChildrenWith(parent$1, nodes, (node, index) => {
				ensureInDom(parent$1, node, child$2(parent$1, index));
				return node;
			});
			const diffKeyValueSet = (newObj, oldObj) => {
				const newKeys = keys(newObj);
				return {
					toRemove: difference(keys(oldObj), newKeys),
					toSet: bifilter(newObj, (v, k) => {
						return !has$2(oldObj, k) || v !== oldObj[k];
					}).t
				};
			};
			const reconcileToDom = (definition, obsoleted) => {
				const { class: clazz, style, ...existingAttributes } = clone$2(obsoleted);
				const { toSet: attrsToSet, toRemove: attrsToRemove } = diffKeyValueSet(definition.attributes, existingAttributes);
				const updateAttrs = () => {
					each$1(attrsToRemove, (a) => remove$7(obsoleted, a));
					setAll$1(obsoleted, attrsToSet);
				};
				const existingStyles = getAllRaw(obsoleted);
				const { toSet: stylesToSet, toRemove: stylesToRemove } = diffKeyValueSet(definition.styles, existingStyles);
				const updateStyles = () => {
					each$1(stylesToRemove, (s) => remove$6(obsoleted, s));
					setAll(obsoleted, stylesToSet);
				};
				const existingClasses = get$7(obsoleted);
				const classesToRemove = difference(existingClasses, definition.classes);
				const classesToAdd = difference(definition.classes, existingClasses);
				const updateClasses = () => {
					add$1(obsoleted, classesToAdd);
					remove$1(obsoleted, classesToRemove);
				};
				const updateHtml = (html$2) => {
					set$6(obsoleted, html$2);
				};
				const updateChildren = () => {
					const children$1 = definition.domChildren;
					patchDomChildren(obsoleted, children$1);
				};
				const updateValue = () => {
					const valueElement = obsoleted;
					const value$5 = definition.value.getOrUndefined();
					if (value$5 !== get$6(valueElement)) set$5(valueElement, value$5 !== null && value$5 !== void 0 ? value$5 : "");
				};
				updateAttrs();
				updateClasses();
				updateStyles();
				definition.innerHtml.fold(updateChildren, updateHtml);
				updateValue();
				return obsoleted;
			};
			const introduceToDom = (definition) => {
				const subject = SugarElement.fromTag(definition.tag);
				setAll$1(subject, definition.attributes);
				add$1(subject, definition.classes);
				setAll(subject, definition.styles);
				definition.innerHtml.each((html$2) => set$6(subject, html$2));
				const children$1 = definition.domChildren;
				append$1(subject, children$1);
				definition.value.each((value$5) => {
					set$5(subject, value$5);
				});
				return subject;
			};
			const attemptPatch = (definition, obsoleted) => {
				try {
					const e = reconcileToDom(definition, obsoleted);
					return Optional.some(e);
				} catch (err) {
					return Optional.none();
				}
			};
			const hasMixedChildren = (definition) => definition.innerHtml.isSome() && definition.domChildren.length > 0;
			const renderToDom = (definition, optObsoleted) => {
				const canBePatched = (candidate) => name$3(candidate) === definition.tag && !hasMixedChildren(definition) && !isPremade(candidate);
				const elem = optObsoleted.filter(canBePatched).bind((obsoleted) => attemptPatch(definition, obsoleted)).getOrThunk(() => introduceToDom(definition));
				writeOnly(elem, definition.uid);
				return elem;
			};
			const getBehaviours$2 = (spec) => {
				const behaviours$1 = get$g(spec, "behaviours").getOr({});
				return bind$3(keys(behaviours$1), (name$4) => {
					const behaviour = behaviours$1[name$4];
					return isNonNullable(behaviour) ? [behaviour.me] : [];
				});
			};
			const generateFrom = (spec, all$4) => generateFrom$1(spec, all$4);
			const generate$4 = (spec) => {
				return generateFrom(spec, getBehaviours$2(spec));
			};
			const getDomDefinition = (info, bList, bData) => {
				const definition = toDefinition(info);
				const infoModification = toModification(info);
				const baseModification = { "alloy.base.modification": infoModification };
				return merge(definition, bList.length > 0 ? combine$2(bData, baseModification, bList, definition) : infoModification);
			};
			const getEvents = (info, bList, bData) => {
				const baseEvents = { "alloy.base.behaviour": toEvents(info) };
				return combine$1(bData, info.eventOrder, bList, baseEvents).getOrDie();
			};
			const build$2 = (spec, obsoleted) => {
				const getMe = () => me;
				const systemApi = Cell(singleton$1);
				const info = getOrDie(toInfo(spec));
				const bBlob = generate$4(spec);
				const bList = getBehaviours$3(bBlob);
				const bData = getData$2(bBlob);
				const item$1 = renderToDom(getDomDefinition(info, bList, bData), obsoleted);
				const events$10 = getEvents(info, bList, bData);
				const subcomponents = Cell(info.components);
				const connect = (newApi) => {
					systemApi.set(newApi);
				};
				const disconnect = () => {
					systemApi.set(NoContextApi(getMe));
				};
				const syncComponents = () => {
					const subs$1 = bind$3(children(item$1), (child$3) => systemApi.get().getByDom(child$3).fold(() => [], pure$2));
					subcomponents.set(subs$1);
				};
				const config$1 = (behaviour) => {
					const b$1 = bData;
					return (isFunction(b$1[behaviour.name()]) ? b$1[behaviour.name()] : () => {
						throw new Error("Could not find " + behaviour.name() + " in " + JSON.stringify(spec, null, 2));
					})();
				};
				const hasConfigured = (behaviour) => isFunction(bData[behaviour.name()]);
				const getApis = () => info.apis;
				const readState = (behaviourName) => bData[behaviourName]().map((b$1) => b$1.state.readState()).getOr("not enabled");
				const me = {
					uid: spec.uid,
					getSystem: systemApi.get,
					config: config$1,
					hasConfigured,
					spec,
					readState,
					getApis,
					connect,
					disconnect,
					element: item$1,
					syncComponents,
					components: subcomponents.get,
					events: events$10
				};
				return me;
			};
			const buildSubcomponents = (spec, obsoleted) => {
				const components$2 = get$g(spec, "components").getOr([]);
				return obsoleted.fold(() => map$2(components$2, build$1), (obs) => map$2(components$2, (c, i) => {
					return buildOrPatch(c, child$2(obs, i));
				}));
			};
			const buildFromSpec = (userSpec, obsoleted) => {
				const { events: specEvents, ...spec } = make$8(userSpec);
				const components$2 = buildSubcomponents(spec, obsoleted);
				const completeSpec = {
					...spec,
					events: {
						...DefaultEvents,
						...specEvents
					},
					components: components$2
				};
				return Result.value(build$2(completeSpec, obsoleted));
			};
			const text$2 = (textContent) => {
				return external$1({ element: SugarElement.fromText(textContent) });
			};
			const external$1 = (spec) => {
				const extSpec = asRawOrDie$1("external.component", objOfOnly([required$1("element"), option$3("uid")]), spec);
				const systemApi = Cell(NoContextApi());
				const connect = (newApi) => {
					systemApi.set(newApi);
				};
				const disconnect = () => {
					systemApi.set(NoContextApi(() => me));
				};
				const uid = extSpec.uid.getOrThunk(() => generate$5("external"));
				writeOnly(extSpec.element, uid);
				const me = {
					uid,
					getSystem: systemApi.get,
					config: Optional.none,
					hasConfigured: never,
					connect,
					disconnect,
					getApis: () => ({}),
					element: extSpec.element,
					spec,
					readState: constant$1("No state"),
					syncComponents: noop,
					components: constant$1([]),
					events: {}
				};
				return premade$1(me);
			};
			const uids = generate$5;
			const isSketchSpec$1 = (spec) => has$2(spec, "uid");
			const buildOrPatch = (spec, obsoleted) => getPremade(spec).getOrThunk(() => {
				return buildFromSpec(isSketchSpec$1(spec) ? spec : {
					uid: uids(""),
					...spec
				}, obsoleted).getOrDie();
			});
			const build$1 = (spec) => buildOrPatch(spec, Optional.none());
			const premade = premade$1;
			var ClosestOrAncestor = (is$3, ancestor$3, scope, a, isRoot) => {
				if (is$3(scope, a)) return Optional.some(scope);
				else if (isFunction(isRoot) && isRoot(scope)) return Optional.none();
				else return ancestor$3(scope, a, isRoot);
			};
			const ancestor$1 = (scope, predicate, isRoot) => {
				let element$1 = scope.dom;
				const stop$1 = isFunction(isRoot) ? isRoot : never;
				while (element$1.parentNode) {
					element$1 = element$1.parentNode;
					const el = SugarElement.fromDom(element$1);
					if (predicate(el)) return Optional.some(el);
					else if (stop$1(el)) break;
				}
				return Optional.none();
			};
			const closest$3 = (scope, predicate, isRoot) => {
				const is$3 = (s, test) => test(s);
				return ClosestOrAncestor(is$3, ancestor$1, scope, predicate, isRoot);
			};
			const child$1 = (scope, predicate) => {
				const pred = (node) => predicate(SugarElement.fromDom(node));
				return find$5(scope.dom.childNodes, pred).map(SugarElement.fromDom);
			};
			const descendant$1 = (scope, predicate) => {
				const descend = (node) => {
					for (let i = 0; i < node.childNodes.length; i++) {
						const child$3 = SugarElement.fromDom(node.childNodes[i]);
						if (predicate(child$3)) return Optional.some(child$3);
						const res = descend(node.childNodes[i]);
						if (res.isSome()) return res;
					}
					return Optional.none();
				};
				return descend(scope.dom);
			};
			const closest$2 = (scope, predicate, isRoot) => closest$3(scope, predicate, isRoot).isSome();
			const ancestor = (scope, selector, isRoot) => ancestor$1(scope, (e) => is(e, selector), isRoot);
			const child = (scope, selector) => child$1(scope, (e) => is(e, selector));
			const descendant = (scope, selector) => one(selector, scope);
			const closest$1 = (scope, selector, isRoot) => {
				const is$1$1 = (element$1, selector$1) => is(element$1, selector$1);
				return ClosestOrAncestor(is$1$1, ancestor, scope, selector, isRoot);
			};
			const attribute = "aria-controls";
			const find$1 = (queryElem) => {
				return closest$3(queryElem, (elem) => {
					if (!isElement$1(elem)) return false;
					const id = get$f(elem, "id");
					return id !== void 0 && id.indexOf(attribute) > -1;
				}).bind((dep) => {
					const id = get$f(dep, "id");
					return descendant(getRootNode(dep), `[${attribute}="${id}"]`);
				});
			};
			const manager = () => {
				const ariaId = generate$6(attribute);
				const link = (elem) => {
					set$9(elem, attribute, ariaId);
				};
				const unlink = (elem) => {
					remove$7(elem, attribute);
				};
				return {
					id: ariaId,
					link,
					unlink
				};
			};
			const isAriaPartOf = (component, queryElem) => find$1(queryElem).exists((owner$5) => isPartOf$1(component, owner$5));
			const isPartOf$1 = (component, queryElem) => closest$2(queryElem, (el) => eq(el, component.element), never) || isAriaPartOf(component, queryElem);
			const unknown = "unknown";
			var EventConfiguration;
			(function(EventConfiguration$1) {
				EventConfiguration$1[EventConfiguration$1["STOP"] = 0] = "STOP";
				EventConfiguration$1[EventConfiguration$1["NORMAL"] = 1] = "NORMAL";
				EventConfiguration$1[EventConfiguration$1["LOGGING"] = 2] = "LOGGING";
			})(EventConfiguration || (EventConfiguration = {}));
			const eventConfig = Cell({});
			const makeEventLogger = (eventName, initialTarget) => {
				const sequence$1 = [];
				const startTime = (/* @__PURE__ */ new Date()).getTime();
				return {
					logEventCut: (_name, target, purpose) => {
						sequence$1.push({
							outcome: "cut",
							target,
							purpose
						});
					},
					logEventStopped: (_name, target, purpose) => {
						sequence$1.push({
							outcome: "stopped",
							target,
							purpose
						});
					},
					logNoParent: (_name, target, purpose) => {
						sequence$1.push({
							outcome: "no-parent",
							target,
							purpose
						});
					},
					logEventNoHandlers: (_name, target) => {
						sequence$1.push({
							outcome: "no-handlers-left",
							target
						});
					},
					logEventResponse: (_name, target, purpose) => {
						sequence$1.push({
							outcome: "response",
							purpose,
							target
						});
					},
					write: () => {
						const finishTime = (/* @__PURE__ */ new Date()).getTime();
						if (contains$2([
							"mousemove",
							"mouseover",
							"mouseout",
							systemInit()
						], eventName)) return;
						console.log(eventName, {
							event: eventName,
							time: finishTime - startTime,
							target: initialTarget.dom,
							sequence: map$2(sequence$1, (s) => {
								if (!contains$2([
									"cut",
									"stopped",
									"response"
								], s.outcome)) return s.outcome;
								else return "{" + s.purpose + "} " + s.outcome + " at (" + element(s.target) + ")";
							})
						});
					}
				};
			};
			const processEvent = (eventName, initialTarget, f$1) => {
				switch (get$g(eventConfig.get(), eventName).orThunk(() => {
					return findMap(keys(eventConfig.get()), (p) => eventName.indexOf(p) > -1 ? Optional.some(eventConfig.get()[p]) : Optional.none());
				}).getOr(EventConfiguration.NORMAL)) {
					case EventConfiguration.NORMAL: return f$1(noLogger());
					case EventConfiguration.LOGGING: {
						const logger = makeEventLogger(eventName, initialTarget);
						const output$2 = f$1(logger);
						logger.write();
						return output$2;
					}
					case EventConfiguration.STOP: return true;
				}
			};
			const path = ["alloy/data/Fields", "alloy/debugging/Debugging"];
			const getTrace = () => {
				const err = /* @__PURE__ */ new Error();
				if (err.stack !== void 0) return find$5(err.stack.split("\n"), (line) => line.indexOf("alloy") > 0 && !exists(path, (p) => line.indexOf(p) > -1)).getOr(unknown);
				else return unknown;
			};
			const ignoreEvent = {
				logEventCut: noop,
				logEventStopped: noop,
				logNoParent: noop,
				logEventNoHandlers: noop,
				logEventResponse: noop,
				write: noop
			};
			const monitorEvent = (eventName, initialTarget, f$1) => processEvent(eventName, initialTarget, f$1);
			const noLogger = constant$1(ignoreEvent);
			const menuFields = constant$1([required$1("menu"), required$1("selectedMenu")]);
			const itemFields = constant$1([required$1("item"), required$1("selectedItem")]);
			constant$1(objOf(itemFields().concat(menuFields())));
			const itemSchema$3 = constant$1(objOf(itemFields()));
			const _initSize = requiredObjOf("initSize", [required$1("numColumns"), required$1("numRows")]);
			const itemMarkers = () => requiredOf("markers", itemSchema$3());
			const tieredMenuMarkers = () => requiredObjOf("markers", [required$1("backgroundMenu")].concat(menuFields()).concat(itemFields()));
			const markers$1 = (required$3) => requiredObjOf("markers", map$2(required$3, required$1));
			const onPresenceHandler = (label$1, fieldName, presence) => {
				getTrace();
				return field$1(fieldName, fieldName, presence, valueOf((f$1) => Result.value((...args) => {
					return f$1.apply(void 0, args);
				})));
			};
			const onHandler = (fieldName) => onPresenceHandler("onHandler", fieldName, defaulted$1(noop));
			const onKeyboardHandler = (fieldName) => onPresenceHandler("onKeyboardHandler", fieldName, defaulted$1(Optional.none));
			const onStrictHandler = (fieldName) => onPresenceHandler("onHandler", fieldName, required$2());
			const onStrictKeyboardHandler = (fieldName) => onPresenceHandler("onKeyboardHandler", fieldName, required$2());
			const output$1 = (name$4, value$5) => customField(name$4, constant$1(value$5));
			const snapshot = (name$4) => customField(name$4, identity);
			const initSize = constant$1(_initSize);
			const nu$6 = (x, y, bubble, direction, placement$5, boundsRestriction$1, labelPrefix$3, alwaysFit = false) => ({
				x,
				y,
				bubble,
				direction,
				placement: placement$5,
				restriction: boundsRestriction$1,
				label: `${labelPrefix$3}-${placement$5}`,
				alwaysFit
			});
			const adt$a = Adt.generate([
				{ southeast: [] },
				{ southwest: [] },
				{ northeast: [] },
				{ northwest: [] },
				{ south: [] },
				{ north: [] },
				{ east: [] },
				{ west: [] }
			]);
			const cata$2 = (subject, southeast$4, southwest$4, northeast$4, northwest$4, south$4, north$4, east$4, west$4) => subject.fold(southeast$4, southwest$4, northeast$4, northwest$4, south$4, north$4, east$4, west$4);
			const cataVertical = (subject, south$4, middle, north$4) => subject.fold(south$4, south$4, north$4, north$4, south$4, north$4, middle, middle);
			const cataHorizontal = (subject, east$4, middle, west$4) => subject.fold(east$4, west$4, east$4, west$4, middle, middle, east$4, west$4);
			const southeast$3 = adt$a.southeast;
			const southwest$3 = adt$a.southwest;
			const northeast$3 = adt$a.northeast;
			const northwest$3 = adt$a.northwest;
			const south$3 = adt$a.south;
			const north$3 = adt$a.north;
			const east$3 = adt$a.east;
			const west$3 = adt$a.west;
			const cycleBy = (value$5, delta, min$1, max$1) => {
				const r$2 = value$5 + delta;
				if (r$2 > max$1) return min$1;
				else if (r$2 < min$1) return max$1;
				else return r$2;
			};
			const clamp = (value$5, min$1, max$1) => Math.min(Math.max(value$5, min$1), max$1);
			const getRestriction = (anchor$1, restriction) => {
				switch (restriction) {
					case 1: return anchor$1.x;
					case 0: return anchor$1.x + anchor$1.width;
					case 2: return anchor$1.y;
					case 3: return anchor$1.y + anchor$1.height;
				}
			};
			const boundsRestriction = (anchor$1, restrictions) => mapToObject([
				"left",
				"right",
				"top",
				"bottom"
			], (dir) => get$g(restrictions, dir).map((restriction) => getRestriction(anchor$1, restriction)));
			const adjustBounds = (bounds$1$1, restriction, bubbleOffset) => {
				const applyRestriction = (dir, current) => restriction[dir].map((pos) => {
					const isVerticalAxis = dir === "top" || dir === "bottom";
					const offset$1 = isVerticalAxis ? bubbleOffset.top : bubbleOffset.left;
					const newPos = (dir === "left" || dir === "top" ? Math.max : Math.min)(pos, current) + offset$1;
					return isVerticalAxis ? clamp(newPos, bounds$1$1.y, bounds$1$1.bottom) : clamp(newPos, bounds$1$1.x, bounds$1$1.right);
				}).getOr(current);
				const adjustedLeft = applyRestriction("left", bounds$1$1.x);
				const adjustedTop = applyRestriction("top", bounds$1$1.y);
				const adjustedRight = applyRestriction("right", bounds$1$1.right);
				const adjustedBottom = applyRestriction("bottom", bounds$1$1.bottom);
				return bounds(adjustedLeft, adjustedTop, adjustedRight - adjustedLeft, adjustedBottom - adjustedTop);
			};
			const labelPrefix$2 = "layout";
			const eastX$1 = (anchor$1) => anchor$1.x;
			const middleX$1 = (anchor$1, element$1) => anchor$1.x + anchor$1.width / 2 - element$1.width / 2;
			const westX$1 = (anchor$1, element$1) => anchor$1.x + anchor$1.width - element$1.width;
			const northY$2 = (anchor$1, element$1) => anchor$1.y - element$1.height;
			const southY$2 = (anchor$1) => anchor$1.y + anchor$1.height;
			const centreY$1 = (anchor$1, element$1) => anchor$1.y + anchor$1.height / 2 - element$1.height / 2;
			const eastEdgeX$1 = (anchor$1) => anchor$1.x + anchor$1.width;
			const westEdgeX$1 = (anchor$1, element$1) => anchor$1.x - element$1.width;
			const southeast$2 = (anchor$1, element$1, bubbles) => nu$6(eastX$1(anchor$1), southY$2(anchor$1), bubbles.southeast(), southeast$3(), "southeast", boundsRestriction(anchor$1, {
				left: 1,
				top: 3
			}), labelPrefix$2);
			const southwest$2 = (anchor$1, element$1, bubbles) => nu$6(westX$1(anchor$1, element$1), southY$2(anchor$1), bubbles.southwest(), southwest$3(), "southwest", boundsRestriction(anchor$1, {
				right: 0,
				top: 3
			}), labelPrefix$2);
			const northeast$2 = (anchor$1, element$1, bubbles) => nu$6(eastX$1(anchor$1), northY$2(anchor$1, element$1), bubbles.northeast(), northeast$3(), "northeast", boundsRestriction(anchor$1, {
				left: 1,
				bottom: 2
			}), labelPrefix$2);
			const northwest$2 = (anchor$1, element$1, bubbles) => nu$6(westX$1(anchor$1, element$1), northY$2(anchor$1, element$1), bubbles.northwest(), northwest$3(), "northwest", boundsRestriction(anchor$1, {
				right: 0,
				bottom: 2
			}), labelPrefix$2);
			const north$2 = (anchor$1, element$1, bubbles) => nu$6(middleX$1(anchor$1, element$1), northY$2(anchor$1, element$1), bubbles.north(), north$3(), "north", boundsRestriction(anchor$1, { bottom: 2 }), labelPrefix$2);
			const south$2 = (anchor$1, element$1, bubbles) => nu$6(middleX$1(anchor$1, element$1), southY$2(anchor$1), bubbles.south(), south$3(), "south", boundsRestriction(anchor$1, { top: 3 }), labelPrefix$2);
			const east$2 = (anchor$1, element$1, bubbles) => nu$6(eastEdgeX$1(anchor$1), centreY$1(anchor$1, element$1), bubbles.east(), east$3(), "east", boundsRestriction(anchor$1, { left: 0 }), labelPrefix$2);
			const west$2 = (anchor$1, element$1, bubbles) => nu$6(westEdgeX$1(anchor$1, element$1), centreY$1(anchor$1, element$1), bubbles.west(), west$3(), "west", boundsRestriction(anchor$1, { right: 1 }), labelPrefix$2);
			const all$1 = () => [
				southeast$2,
				southwest$2,
				northeast$2,
				northwest$2,
				south$2,
				north$2,
				east$2,
				west$2
			];
			const allRtl$1 = () => [
				southwest$2,
				southeast$2,
				northwest$2,
				northeast$2,
				south$2,
				north$2,
				east$2,
				west$2
			];
			const aboveOrBelow = () => [
				northeast$2,
				northwest$2,
				southeast$2,
				southwest$2,
				north$2,
				south$2
			];
			const aboveOrBelowRtl = () => [
				northwest$2,
				northeast$2,
				southwest$2,
				southeast$2,
				north$2,
				south$2
			];
			const belowOrAbove = () => [
				southeast$2,
				southwest$2,
				northeast$2,
				northwest$2,
				south$2,
				north$2
			];
			const belowOrAboveRtl = () => [
				southwest$2,
				southeast$2,
				northwest$2,
				northeast$2,
				south$2,
				north$2
			];
			const chooseChannels = (channels, message) => message.universal ? channels : filter$2(channels, (ch) => contains$2(message.channels, ch));
			const events$h = (receiveConfig) => derive$2([run$1(receive(), (component, message) => {
				const channelMap = receiveConfig.channels;
				const channels = keys(channelMap);
				const receivingData = message;
				each$1(chooseChannels(channels, receivingData), (ch) => {
					const channelInfo = channelMap[ch];
					const channelSchema = channelInfo.schema;
					const data = asRawOrDie$1("channel[" + ch + "] data\nReceiver: " + element(component.element), channelSchema, receivingData.data);
					channelInfo.onReceive(component, data);
				});
			})]);
			var ActiveReceiving = /* @__PURE__ */ Object.freeze({
				__proto__: null,
				events: events$h
			});
			var ReceivingSchema = [requiredOf("channels", setOf(Result.value, objOfOnly([onStrictHandler("onReceive"), defaulted("schema", anyValue())])))];
			const executeEvent = (bConfig, bState, executor) => runOnExecute$1((component) => {
				executor(component, bConfig, bState);
			});
			const loadEvent = (bConfig, bState, f$1) => runOnInit((component, _simulatedEvent) => {
				f$1(component, bConfig, bState);
			});
			const create$5 = (schema$10, name$4, active$2, apis, extra, state) => {
				return doCreate(objOfOnly(schema$10), optionObjOf(name$4, [optionObjOfOnly("config", schema$10)]), name$4, active$2, apis, extra, state);
			};
			const createModes$1 = (modes, name$4, active$2, apis, extra, state) => {
				return doCreate(modes, optionObjOf(name$4, [optionOf("config", modes)]), name$4, active$2, apis, extra, state);
			};
			const wrapApi = (bName, apiFunction, apiName) => {
				const f$1 = (component, ...rest) => {
					const args = [component].concat(rest);
					return component.config({ name: constant$1(bName) }).fold(() => {
						throw new Error("We could not find any behaviour configuration for: " + bName + ". Using API: " + apiName);
					}, (info) => {
						const rest$1 = Array.prototype.slice.call(args, 1);
						return apiFunction.apply(void 0, [
							component,
							info.config,
							info.state
						].concat(rest$1));
					});
				};
				return markAsBehaviourApi(f$1, apiName, apiFunction);
			};
			const revokeBehaviour = (name$4) => ({
				key: name$4,
				value: void 0
			});
			const doCreate = (configSchema, schemaSchema, name$4, active$2, apis, extra, state) => {
				const getConfig = (info) => hasNonNullableKey(info, name$4) ? info[name$4]() : Optional.none();
				const wrappedApis = map$1(apis, (apiF, apiName) => wrapApi(name$4, apiF, apiName));
				const me = {
					...map$1(extra, (extraF, extraName) => markAsExtraApi(extraF, extraName)),
					...wrappedApis,
					revoke: curry(revokeBehaviour, name$4),
					config: (spec) => {
						return {
							key: name$4,
							value: {
								config: asRawOrDie$1(name$4 + "-config", configSchema, spec),
								me,
								configAsRaw: cached(() => asRawOrDie$1(name$4 + "-config", configSchema, spec)),
								initialConfig: spec,
								state
							}
						};
					},
					schema: constant$1(schemaSchema),
					exhibit: (info, base$1) => {
						return lift2(getConfig(info), get$g(active$2, "exhibit"), (behaviourInfo, exhibitor) => {
							return exhibitor(base$1, behaviourInfo.config, behaviourInfo.state);
						}).getOrThunk(() => nu$7({}));
					},
					name: constant$1(name$4),
					handlers: (info) => {
						return getConfig(info).map((behaviourInfo) => {
							return get$g(active$2, "events").getOr(() => ({}))(behaviourInfo.config, behaviourInfo.state);
						}).getOr({});
					}
				};
				return me;
			};
			const derive$1 = (capabilities) => wrapAll(capabilities);
			const simpleSchema = objOfOnly([
				required$1("fields"),
				required$1("name"),
				defaulted("active", {}),
				defaulted("apis", {}),
				defaulted("state", NoState),
				defaulted("extra", {})
			]);
			const create$4 = (data) => {
				const value$5 = asRawOrDie$1("Creating behaviour: " + data.name, simpleSchema, data);
				return create$5(value$5.fields, value$5.name, value$5.active, value$5.apis, value$5.extra, value$5.state);
			};
			const modeSchema = objOfOnly([
				required$1("branchKey"),
				required$1("branches"),
				required$1("name"),
				defaulted("active", {}),
				defaulted("apis", {}),
				defaulted("state", NoState),
				defaulted("extra", {})
			]);
			const createModes = (data) => {
				const value$5 = asRawOrDie$1("Creating behaviour: " + data.name, modeSchema, data);
				return createModes$1(choose$1(value$5.branchKey, value$5.branches), value$5.name, value$5.active, value$5.apis, value$5.extra, value$5.state);
			};
			const revoke = constant$1(void 0);
			const Receiving = create$4({
				fields: ReceivingSchema,
				name: "receiving",
				active: ActiveReceiving
			});
			const exhibit$6 = (base$1, posConfig) => nu$7({
				classes: [],
				styles: posConfig.useFixed() ? {} : { position: "relative" }
			});
			var ActivePosition = /* @__PURE__ */ Object.freeze({
				__proto__: null,
				exhibit: exhibit$6
			});
			const focus$3 = (element$1) => element$1.dom.focus();
			const blur$1 = (element$1) => element$1.dom.blur();
			const hasFocus = (element$1) => {
				const root = getRootNode(element$1).dom;
				return element$1.dom === root.activeElement;
			};
			const active$1 = (root = getDocument()) => Optional.from(root.dom.activeElement).map(SugarElement.fromDom);
			const search = (element$1) => active$1(getRootNode(element$1)).filter((e) => element$1.dom.contains(e.dom));
			const preserve$1 = (f$1, container) => {
				const dos = getRootNode(container);
				const refocus = active$1(dos).bind((focused) => {
					const hasFocus$1 = (elem) => eq(focused, elem);
					return hasFocus$1(container) ? Optional.some(container) : descendant$1(container, hasFocus$1);
				});
				const result = f$1(container);
				refocus.each((oldFocus) => {
					active$1(dos).filter((newFocus) => eq(newFocus, oldFocus)).fold(() => {
						focus$3(oldFocus);
					}, noop);
				});
				return result;
			};
			const NuPositionCss = (position$3, left$1, top$1, right$1, bottom$1) => {
				const toPx = (num) => num + "px";
				return {
					position: position$3,
					left: left$1.map(toPx),
					top: top$1.map(toPx),
					right: right$1.map(toPx),
					bottom: bottom$1.map(toPx)
				};
			};
			const toOptions = (position$3) => ({
				...position$3,
				position: Optional.some(position$3.position)
			});
			const applyPositionCss = (element$1, position$3) => {
				setOptions(element$1, toOptions(position$3));
			};
			const adt$9 = Adt.generate([
				{ none: [] },
				{ relative: [
					"x",
					"y",
					"width",
					"height"
				] },
				{ fixed: [
					"x",
					"y",
					"width",
					"height"
				] }
			]);
			const positionWithDirection = (posName, decision, x, y, width$1, height$1) => {
				const decisionRect = decision.rect;
				const decisionX = decisionRect.x - x;
				const decisionY = decisionRect.y - y;
				const decisionWidth = decisionRect.width;
				const decisionHeight = decisionRect.height;
				const decisionRight = width$1 - (decisionX + decisionWidth);
				const decisionBottom = height$1 - (decisionY + decisionHeight);
				const left$1 = Optional.some(decisionX);
				const top$1 = Optional.some(decisionY);
				const right$1 = Optional.some(decisionRight);
				const bottom$1 = Optional.some(decisionBottom);
				const none = Optional.none();
				return cata$2(decision.direction, () => NuPositionCss(posName, left$1, top$1, none, none), () => NuPositionCss(posName, none, top$1, right$1, none), () => NuPositionCss(posName, left$1, none, none, bottom$1), () => NuPositionCss(posName, none, none, right$1, bottom$1), () => NuPositionCss(posName, left$1, top$1, none, none), () => NuPositionCss(posName, left$1, none, none, bottom$1), () => NuPositionCss(posName, left$1, top$1, none, none), () => NuPositionCss(posName, none, top$1, right$1, none));
			};
			const reposition = (origin, decision) => origin.fold(() => {
				const decisionRect = decision.rect;
				return NuPositionCss("absolute", Optional.some(decisionRect.x), Optional.some(decisionRect.y), Optional.none(), Optional.none());
			}, (x, y, width$1, height$1) => {
				return positionWithDirection("absolute", decision, x, y, width$1, height$1);
			}, (x, y, width$1, height$1) => {
				return positionWithDirection("fixed", decision, x, y, width$1, height$1);
			});
			const toBox = (origin, element$1) => {
				const rel = curry(find$2, element$1);
				const position$3 = origin.fold(rel, rel, () => {
					const scroll = get$b();
					return find$2(element$1).translate(-scroll.left, -scroll.top);
				});
				const width$1 = getOuter$1(element$1);
				const height$1 = getOuter$2(element$1);
				return bounds(position$3.left, position$3.top, width$1, height$1);
			};
			const viewport = (origin, optBounds) => optBounds.fold(() => origin.fold(win, win, bounds), (bounds$1$1) => origin.fold(constant$1(bounds$1$1), constant$1(bounds$1$1), () => {
				const pos = translate$2(origin, bounds$1$1.x, bounds$1$1.y);
				return bounds(pos.left, pos.top, bounds$1$1.width, bounds$1$1.height);
			}));
			const translate$2 = (origin, x, y) => {
				const pos = SugarPosition(x, y);
				const removeScroll = () => {
					const outerScroll = get$b();
					return pos.translate(-outerScroll.left, -outerScroll.top);
				};
				return origin.fold(constant$1(pos), constant$1(pos), removeScroll);
			};
			const cata$1 = (subject, onNone, onRelative, onFixed) => subject.fold(onNone, onRelative, onFixed);
			adt$9.none;
			const relative$1 = adt$9.relative;
			const fixed$1 = adt$9.fixed;
			const anchor = (anchorBox, origin) => ({
				anchorBox,
				origin
			});
			const box = (anchorBox, origin) => anchor(anchorBox, origin);
			const placementAttribute = "data-alloy-placement";
			const setPlacement$1 = (element$1, placement$5) => {
				set$9(element$1, placementAttribute, placement$5);
			};
			const getPlacement = (element$1) => getOpt(element$1, placementAttribute);
			const reset$2 = (element$1) => remove$7(element$1, placementAttribute);
			const adt$8 = Adt.generate([{ fit: ["reposition"] }, { nofit: [
				"reposition",
				"visibleW",
				"visibleH",
				"isVisible"
			] }]);
			const determinePosition = (box$2, bounds$2) => {
				const { x: boundsX, y: boundsY, right: boundsRight, bottom: boundsBottom } = bounds$2;
				const { x, y, right: right$1, bottom: bottom$1, width: width$1, height: height$1 } = box$2;
				return {
					originInBounds: x >= boundsX && x <= boundsRight && y >= boundsY && y <= boundsBottom,
					sizeInBounds: right$1 <= boundsRight && right$1 >= boundsX && bottom$1 <= boundsBottom && bottom$1 >= boundsY,
					visibleW: Math.min(width$1, x >= boundsX ? boundsRight - x : right$1 - boundsX),
					visibleH: Math.min(height$1, y >= boundsY ? boundsBottom - y : bottom$1 - boundsY)
				};
			};
			const calcReposition = (box$2, bounds$1$1) => {
				const { x: boundsX, y: boundsY, right: boundsRight, bottom: boundsBottom } = bounds$1$1;
				const { x, y, width: width$1, height: height$1 } = box$2;
				const maxX$1 = Math.max(boundsX, boundsRight - width$1);
				const maxY$1 = Math.max(boundsY, boundsBottom - height$1);
				const restrictedX = clamp(x, boundsX, maxX$1);
				const restrictedY = clamp(y, boundsY, maxY$1);
				return bounds(restrictedX, restrictedY, Math.min(restrictedX + width$1, boundsRight) - restrictedX, Math.min(restrictedY + height$1, boundsBottom) - restrictedY);
			};
			const calcMaxSizes = (direction, box$2, bounds$2) => {
				const upAvailable = constant$1(box$2.bottom - bounds$2.y);
				const downAvailable = constant$1(bounds$2.bottom - box$2.y);
				const maxHeight = cataVertical(direction, downAvailable, downAvailable, upAvailable);
				const westAvailable = constant$1(box$2.right - bounds$2.x);
				const eastAvailable = constant$1(bounds$2.right - box$2.x);
				return {
					maxWidth: cataHorizontal(direction, eastAvailable, eastAvailable, westAvailable),
					maxHeight
				};
			};
			const attempt = (candidate, width$1, height$1, bounds$1$1) => {
				const bubble = candidate.bubble;
				const bubbleOffset = bubble.offset;
				const adjustedBounds = adjustBounds(bounds$1$1, candidate.restriction, bubbleOffset);
				const newX = candidate.x + bubbleOffset.left;
				const newY = candidate.y + bubbleOffset.top;
				const box$2 = bounds(newX, newY, width$1, height$1);
				const { originInBounds, sizeInBounds, visibleW, visibleH } = determinePosition(box$2, adjustedBounds);
				const fits = originInBounds && sizeInBounds;
				const fittedBox = fits ? box$2 : calcReposition(box$2, adjustedBounds);
				const isPartlyVisible = fittedBox.width > 0 && fittedBox.height > 0;
				const { maxWidth, maxHeight } = calcMaxSizes(candidate.direction, fittedBox, bounds$1$1);
				const reposition$1 = {
					rect: fittedBox,
					maxHeight,
					maxWidth,
					direction: candidate.direction,
					placement: candidate.placement,
					classes: {
						on: bubble.classesOn,
						off: bubble.classesOff
					},
					layout: candidate.label,
					testY: newY
				};
				return fits || candidate.alwaysFit ? adt$8.fit(reposition$1) : adt$8.nofit(reposition$1, visibleW, visibleH, isPartlyVisible);
			};
			const attempts = (element$1, candidates, anchorBox, elementBox, bubbles, bounds$2) => {
				const panelWidth = elementBox.width;
				const panelHeight = elementBox.height;
				const attemptBestFit = (layout$1, reposition$1, visibleW, visibleH, isVisible$1) => {
					const attemptLayout = attempt(layout$1(anchorBox, elementBox, bubbles, element$1, bounds$2), panelWidth, panelHeight, bounds$2);
					return attemptLayout.fold(constant$1(attemptLayout), (newReposition, newVisibleW, newVisibleH, newIsVisible) => {
						return (isVisible$1 === newIsVisible ? newVisibleH > visibleH || newVisibleW > visibleW : !isVisible$1 && newIsVisible) ? attemptLayout : adt$8.nofit(reposition$1, visibleW, visibleH, isVisible$1);
					});
				};
				return foldl(candidates, (b$1, a) => {
					const bestNext = curry(attemptBestFit, a);
					return b$1.fold(constant$1(b$1), bestNext);
				}, adt$8.nofit({
					rect: anchorBox,
					maxHeight: elementBox.height,
					maxWidth: elementBox.width,
					direction: southeast$3(),
					placement: "southeast",
					classes: {
						on: [],
						off: []
					},
					layout: "none",
					testY: anchorBox.y
				}, -1, -1, false)).fold(identity, identity);
			};
			const singleton = (doRevoke) => {
				const subject = Cell(Optional.none());
				const revoke$1 = () => subject.get().each(doRevoke);
				const clear$1 = () => {
					revoke$1();
					subject.set(Optional.none());
				};
				const isSet = () => subject.get().isSome();
				const get$10 = () => subject.get();
				const set$10 = (s) => {
					revoke$1();
					subject.set(Optional.some(s));
				};
				return {
					clear: clear$1,
					isSet,
					get: get$10,
					set: set$10
				};
			};
			const destroyable = () => singleton((s) => s.destroy());
			const unbindable = () => singleton((s) => s.unbind());
			const value$2 = () => {
				const subject = singleton(noop);
				const on$1 = (f$1) => subject.get().each(f$1);
				return {
					...subject,
					on: on$1
				};
			};
			const filter = always;
			const bind = (element$1, event, handler) => bind$2(element$1, event, filter, handler);
			const capture = (element$1, event, handler) => capture$1(element$1, event, filter, handler);
			const fromRawEvent = fromRawEvent$1;
			const properties = [
				"top",
				"bottom",
				"right",
				"left"
			];
			const timerAttr = "data-alloy-transition-timer";
			const isTransitioning$1 = (element$1, transition) => hasAll(element$1, transition.classes);
			const shouldApplyTransitionCss = (transition, decision, lastPlacement) => {
				return lastPlacement.exists((placer) => {
					const mode = transition.mode;
					return mode === "all" ? true : placer[mode] !== decision[mode];
				});
			};
			const hasChanges = (position$3, intermediate) => {
				const round$2 = (value$5) => parseFloat(value$5).toFixed(3);
				return find$4(intermediate, (value$5, key) => {
					return !equals(position$3[key].map(round$2), value$5.map(round$2));
				}).isSome();
			};
			const getTransitionDuration = (element$1) => {
				const get$10 = (name$4) => {
					return filter$2(get$e(element$1, name$4).split(/\s*,\s*/), isNotEmpty);
				};
				const parse$1 = (value$5) => {
					if (isString(value$5) && /^[\d.]+/.test(value$5)) {
						const num = parseFloat(value$5);
						return endsWith(value$5, "ms") ? num : num * 1e3;
					} else return 0;
				};
				const delay = get$10("transition-delay");
				return foldl(get$10("transition-duration"), (acc, dur, i) => {
					const time = parse$1(delay[i]) + parse$1(dur);
					return Math.max(acc, time);
				}, 0);
			};
			const setupTransitionListeners = (element$1, transition) => {
				const transitionEnd = unbindable();
				const transitionCancel = unbindable();
				let timer;
				const isSourceTransition = (e) => {
					var _a;
					const pseudoElement = (_a = e.raw.pseudoElement) !== null && _a !== void 0 ? _a : "";
					return eq(e.target, element$1) && isEmpty(pseudoElement) && contains$2(properties, e.raw.propertyName);
				};
				const transitionDone = (e) => {
					if (isNullable(e) || isSourceTransition(e)) {
						transitionEnd.clear();
						transitionCancel.clear();
						const type$2 = e === null || e === void 0 ? void 0 : e.raw.type;
						if (isNullable(type$2) || type$2 === transitionend()) {
							clearTimeout(timer);
							remove$7(element$1, timerAttr);
							remove$1(element$1, transition.classes);
						}
					}
				};
				const transitionStart = bind(element$1, transitionstart(), (e) => {
					if (isSourceTransition(e)) {
						transitionStart.unbind();
						transitionEnd.set(bind(element$1, transitionend(), transitionDone));
						transitionCancel.set(bind(element$1, transitioncancel(), transitionDone));
					}
				});
				const duration = getTransitionDuration(element$1);
				requestAnimationFrame(() => {
					timer = setTimeout(transitionDone, duration + 17);
					set$9(element$1, timerAttr, timer);
				});
			};
			const startTransitioning = (element$1, transition) => {
				add$1(element$1, transition.classes);
				getOpt(element$1, timerAttr).each((timerId) => {
					clearTimeout(parseInt(timerId, 10));
					remove$7(element$1, timerAttr);
				});
				setupTransitionListeners(element$1, transition);
			};
			const applyTransitionCss = (element$1, origin, position$3, transition, decision, lastPlacement) => {
				const shouldTransition = shouldApplyTransitionCss(transition, decision, lastPlacement);
				if (shouldTransition || isTransitioning$1(element$1, transition)) {
					set$8(element$1, "position", position$3.position);
					const rect$1 = toBox(origin, element$1);
					const intermediatePosition = reposition(origin, {
						...decision,
						rect: rect$1
					});
					const intermediateCssOptions = mapToObject(properties, (prop) => intermediatePosition[prop]);
					if (hasChanges(position$3, intermediateCssOptions)) {
						setOptions(element$1, intermediateCssOptions);
						if (shouldTransition) startTransitioning(element$1, transition);
						reflow(element$1);
					}
				} else remove$1(element$1, transition.classes);
			};
			const elementSize = (p) => ({
				width: getOuter$1(p),
				height: getOuter$2(p)
			});
			const layout = (anchorBox, element$1, bubbles, options) => {
				remove$6(element$1, "max-height");
				remove$6(element$1, "max-width");
				const elementBox = elementSize(element$1);
				return attempts(element$1, options.preference, anchorBox, elementBox, bubbles, options.bounds);
			};
			const setClasses = (element$1, decision) => {
				const classInfo = decision.classes;
				remove$1(element$1, classInfo.off);
				add$1(element$1, classInfo.on);
			};
			const setHeight = (element$1, decision, options) => {
				const maxHeightFunction = options.maxHeightFunction;
				maxHeightFunction(element$1, decision.maxHeight);
			};
			const setWidth = (element$1, decision, options) => {
				const maxWidthFunction = options.maxWidthFunction;
				maxWidthFunction(element$1, decision.maxWidth);
			};
			const position$2 = (element$1, decision, options) => {
				const positionCss = reposition(options.origin, decision);
				options.transition.each((transition) => {
					applyTransitionCss(element$1, options.origin, positionCss, transition, decision, options.lastPlacement);
				});
				applyPositionCss(element$1, positionCss);
			};
			const setPlacement = (element$1, decision) => {
				setPlacement$1(element$1, decision.placement);
			};
			const setMaxHeight = (element$1, maxHeight) => {
				setMax$1(element$1, Math.floor(maxHeight));
			};
			const anchored = constant$1((element$1, available) => {
				setMaxHeight(element$1, available);
				setAll(element$1, {
					"overflow-x": "hidden",
					"overflow-y": "auto"
				});
			});
			const expandable$1 = constant$1((element$1, available) => {
				setMaxHeight(element$1, available);
			});
			const defaultOr = (options, key, dephault) => options[key] === void 0 ? dephault : options[key];
			const simple = (anchor$1, element$1, bubble, layouts$1, lastPlacement, optBounds, overrideOptions, transition) => {
				const maxHeightFunction = defaultOr(overrideOptions, "maxHeightFunction", anchored());
				const maxWidthFunction = defaultOr(overrideOptions, "maxWidthFunction", noop);
				const anchorBox = anchor$1.anchorBox;
				const origin = anchor$1.origin;
				return go(anchorBox, element$1, bubble, {
					bounds: viewport(origin, optBounds),
					origin,
					preference: layouts$1,
					maxHeightFunction,
					maxWidthFunction,
					lastPlacement,
					transition
				});
			};
			const go = (anchorBox, element$1, bubble, options) => {
				const decision = layout(anchorBox, element$1, bubble, options);
				position$2(element$1, decision, options);
				setPlacement(element$1, decision);
				setClasses(element$1, decision);
				setHeight(element$1, decision, options);
				setWidth(element$1, decision, options);
				return {
					layout: decision.layout,
					placement: decision.placement
				};
			};
			const allAlignments = [
				"valignCentre",
				"alignLeft",
				"alignRight",
				"alignCentre",
				"top",
				"bottom",
				"left",
				"right",
				"inset"
			];
			const nu$5 = (xOffset, yOffset, classes$1, insetModifier = 1) => {
				const insetXOffset = xOffset * insetModifier;
				const insetYOffset = yOffset * insetModifier;
				const getClasses$1 = (prop) => get$g(classes$1, prop).getOr([]);
				const make$9 = (xDelta, yDelta, alignmentsOn) => {
					const alignmentsOff = difference(allAlignments, alignmentsOn);
					return {
						offset: SugarPosition(xDelta, yDelta),
						classesOn: bind$3(alignmentsOn, getClasses$1),
						classesOff: bind$3(alignmentsOff, getClasses$1)
					};
				};
				return {
					southeast: () => make$9(-xOffset, yOffset, ["top", "alignLeft"]),
					southwest: () => make$9(xOffset, yOffset, ["top", "alignRight"]),
					south: () => make$9(-xOffset / 2, yOffset, ["top", "alignCentre"]),
					northeast: () => make$9(-xOffset, -yOffset, ["bottom", "alignLeft"]),
					northwest: () => make$9(xOffset, -yOffset, ["bottom", "alignRight"]),
					north: () => make$9(-xOffset / 2, -yOffset, ["bottom", "alignCentre"]),
					east: () => make$9(xOffset, -yOffset / 2, ["valignCentre", "left"]),
					west: () => make$9(-xOffset, -yOffset / 2, ["valignCentre", "right"]),
					insetNortheast: () => make$9(insetXOffset, insetYOffset, [
						"top",
						"alignLeft",
						"inset"
					]),
					insetNorthwest: () => make$9(-insetXOffset, insetYOffset, [
						"top",
						"alignRight",
						"inset"
					]),
					insetNorth: () => make$9(-insetXOffset / 2, insetYOffset, [
						"top",
						"alignCentre",
						"inset"
					]),
					insetSoutheast: () => make$9(insetXOffset, -insetYOffset, [
						"bottom",
						"alignLeft",
						"inset"
					]),
					insetSouthwest: () => make$9(-insetXOffset, -insetYOffset, [
						"bottom",
						"alignRight",
						"inset"
					]),
					insetSouth: () => make$9(-insetXOffset / 2, -insetYOffset, [
						"bottom",
						"alignCentre",
						"inset"
					]),
					insetEast: () => make$9(-insetXOffset, -insetYOffset / 2, [
						"valignCentre",
						"right",
						"inset"
					]),
					insetWest: () => make$9(insetXOffset, -insetYOffset / 2, [
						"valignCentre",
						"left",
						"inset"
					])
				};
			};
			const fallback = () => nu$5(0, 0, {});
			const nu$4 = identity;
			const onDirection = (isLtr, isRtl) => (element$1) => getDirection(element$1) === "rtl" ? isRtl : isLtr;
			const getDirection = (element$1) => get$e(element$1, "direction") === "rtl" ? "rtl" : "ltr";
			var AttributeValue;
			(function(AttributeValue$1) {
				AttributeValue$1["TopToBottom"] = "toptobottom";
				AttributeValue$1["BottomToTop"] = "bottomtotop";
			})(AttributeValue || (AttributeValue = {}));
			const Attribute = "data-alloy-vertical-dir";
			const isBottomToTopDir = (el) => closest$2(el, (current) => isElement$1(current) && get$f(current, "data-alloy-vertical-dir") === AttributeValue.BottomToTop);
			const schema$y = () => optionObjOf("layouts", [
				required$1("onLtr"),
				required$1("onRtl"),
				option$3("onBottomLtr"),
				option$3("onBottomRtl")
			]);
			const get$5 = (elem, info, defaultLtr, defaultRtl, defaultBottomLtr, defaultBottomRtl, dirElement) => {
				const isBottomToTop = dirElement.map(isBottomToTopDir).getOr(false);
				const customLtr = info.layouts.map((ls) => ls.onLtr(elem));
				const customRtl = info.layouts.map((ls) => ls.onRtl(elem));
				return onDirection(isBottomToTop ? info.layouts.bind((ls) => ls.onBottomLtr.map((f$1) => f$1(elem))).or(customLtr).getOr(defaultBottomLtr) : customLtr.getOr(defaultLtr), isBottomToTop ? info.layouts.bind((ls) => ls.onBottomRtl.map((f$1) => f$1(elem))).or(customRtl).getOr(defaultBottomRtl) : customRtl.getOr(defaultRtl))(elem);
			};
			const placement$4 = (component, anchorInfo, origin) => {
				const hotspot = anchorInfo.hotspot;
				const anchorBox = toBox(origin, hotspot.element);
				const layouts$1 = get$5(component.element, anchorInfo, belowOrAbove(), belowOrAboveRtl(), aboveOrBelow(), aboveOrBelowRtl(), Optional.some(anchorInfo.hotspot.element));
				return Optional.some(nu$4({
					anchorBox,
					bubble: anchorInfo.bubble.getOr(fallback()),
					overrides: anchorInfo.overrides,
					layouts: layouts$1
				}));
			};
			var HotspotAnchor = [
				required$1("hotspot"),
				option$3("bubble"),
				defaulted("overrides", {}),
				schema$y(),
				output$1("placement", placement$4)
			];
			const placement$3 = (component, anchorInfo, origin) => {
				const pos = translate$2(origin, anchorInfo.x, anchorInfo.y);
				const anchorBox = bounds(pos.left, pos.top, anchorInfo.width, anchorInfo.height);
				const layouts$1 = get$5(component.element, anchorInfo, all$1(), allRtl$1(), all$1(), allRtl$1(), Optional.none());
				return Optional.some(nu$4({
					anchorBox,
					bubble: anchorInfo.bubble,
					overrides: anchorInfo.overrides,
					layouts: layouts$1
				}));
			};
			var MakeshiftAnchor = [
				required$1("x"),
				required$1("y"),
				defaulted("height", 0),
				defaulted("width", 0),
				defaulted("bubble", fallback()),
				defaulted("overrides", {}),
				schema$y(),
				output$1("placement", placement$3)
			];
			const adt$7 = Adt.generate([{ screen: ["point"] }, { absolute: [
				"point",
				"scrollLeft",
				"scrollTop"
			] }]);
			const toFixed = (pos) => pos.fold(identity, (point$1, scrollLeft, scrollTop) => point$1.translate(-scrollLeft, -scrollTop));
			const toAbsolute = (pos) => pos.fold(identity, identity);
			const sum = (points) => foldl(points, (b$1, a) => b$1.translate(a.left, a.top), SugarPosition(0, 0));
			const sumAsFixed = (positions) => {
				return sum(map$2(positions, toFixed));
			};
			const sumAsAbsolute = (positions) => {
				return sum(map$2(positions, toAbsolute));
			};
			const screen = adt$7.screen;
			const absolute$1 = adt$7.absolute;
			const getOffset = (component, origin, anchorInfo) => {
				const win$1 = defaultView(anchorInfo.root).dom;
				const hasSameOwner = (frame) => {
					return eq(owner$4(frame), owner$4(component.element));
				};
				return Optional.from(win$1.frameElement).map(SugarElement.fromDom).filter(hasSameOwner).map(absolute$3);
			};
			const getRootPoint = (component, origin, anchorInfo) => {
				const outerScroll = get$b(owner$4(component.element));
				return absolute$1(getOffset(component, origin, anchorInfo).getOr(outerScroll), outerScroll.left, outerScroll.top);
			};
			const getBox = (left$1, top$1, width$1, height$1) => {
				const point$1 = screen(SugarPosition(left$1, top$1));
				return Optional.some(pointed(point$1, width$1, height$1));
			};
			const calcNewAnchor = (optBox, rootPoint, anchorInfo, origin, elem) => optBox.map((box$2) => {
				const points = [rootPoint, box$2.point];
				const topLeft = cata$1(origin, () => sumAsAbsolute(points), () => sumAsAbsolute(points), () => sumAsFixed(points));
				const anchorBox = rect(topLeft.left, topLeft.top, box$2.width, box$2.height);
				const layoutsLtr = anchorInfo.showAbove ? aboveOrBelow() : belowOrAbove();
				const layoutsRtl = anchorInfo.showAbove ? aboveOrBelowRtl() : belowOrAboveRtl();
				const layouts$1 = get$5(elem, anchorInfo, layoutsLtr, layoutsRtl, layoutsLtr, layoutsRtl, Optional.none());
				return nu$4({
					anchorBox,
					bubble: anchorInfo.bubble.getOr(fallback()),
					overrides: anchorInfo.overrides,
					layouts: layouts$1
				});
			});
			const placement$2 = (component, anchorInfo, origin) => {
				const rootPoint = getRootPoint(component, origin, anchorInfo);
				return anchorInfo.node.filter(inBody).bind((target) => {
					const rect$1 = target.dom.getBoundingClientRect();
					return calcNewAnchor(getBox(rect$1.left, rect$1.top, rect$1.width, rect$1.height), rootPoint, anchorInfo, origin, anchorInfo.node.getOr(component.element));
				});
			};
			var NodeAnchor = [
				required$1("node"),
				required$1("root"),
				option$3("bubble"),
				schema$y(),
				defaulted("overrides", {}),
				defaulted("showAbove", false),
				output$1("placement", placement$2)
			];
			const zeroWidth = "";
			const nbsp = "\xA0";
			const create$3 = (start, soffset, finish, foffset) => ({
				start,
				soffset,
				finish,
				foffset
			});
			const SimRange = { create: create$3 };
			const adt$6 = Adt.generate([
				{ before: ["element"] },
				{ on: ["element", "offset"] },
				{ after: ["element"] }
			]);
			const cata = (subject, onBefore, onOn, onAfter) => subject.fold(onBefore, onOn, onAfter);
			const getStart$1 = (situ) => situ.fold(identity, identity, identity);
			const Situ = {
				before: adt$6.before,
				on: adt$6.on,
				after: adt$6.after,
				cata,
				getStart: getStart$1
			};
			const adt$5 = Adt.generate([
				{ domRange: ["rng"] },
				{ relative: ["startSitu", "finishSitu"] },
				{ exact: [
					"start",
					"soffset",
					"finish",
					"foffset"
				] }
			]);
			const exactFromRange = (simRange) => adt$5.exact(simRange.start, simRange.soffset, simRange.finish, simRange.foffset);
			const getStart = (selection) => selection.match({
				domRange: (rng) => SugarElement.fromDom(rng.startContainer),
				relative: (startSitu, _finishSitu) => Situ.getStart(startSitu),
				exact: (start, _soffset, _finish, _foffset) => start
			});
			const domRange = adt$5.domRange;
			const relative = adt$5.relative;
			const exact = adt$5.exact;
			const getWin = (selection) => {
				return defaultView(getStart(selection));
			};
			const SimSelection = {
				domRange,
				relative,
				exact,
				exactFromRange,
				getWin,
				range: SimRange.create
			};
			const setStart = (rng, situ) => {
				situ.fold((e) => {
					rng.setStartBefore(e.dom);
				}, (e, o) => {
					rng.setStart(e.dom, o);
				}, (e) => {
					rng.setStartAfter(e.dom);
				});
			};
			const setFinish = (rng, situ) => {
				situ.fold((e) => {
					rng.setEndBefore(e.dom);
				}, (e, o) => {
					rng.setEnd(e.dom, o);
				}, (e) => {
					rng.setEndAfter(e.dom);
				});
			};
			const relativeToNative = (win$1, startSitu, finishSitu) => {
				const range$1 = win$1.document.createRange();
				setStart(range$1, startSitu);
				setFinish(range$1, finishSitu);
				return range$1;
			};
			const exactToNative = (win$1, start, soffset, finish, foffset) => {
				const rng = win$1.document.createRange();
				rng.setStart(start.dom, soffset);
				rng.setEnd(finish.dom, foffset);
				return rng;
			};
			const toRect = (rect$1) => ({
				left: rect$1.left,
				top: rect$1.top,
				right: rect$1.right,
				bottom: rect$1.bottom,
				width: rect$1.width,
				height: rect$1.height
			});
			const getFirstRect$1 = (rng) => {
				const rects = rng.getClientRects();
				const rect$1 = rects.length > 0 ? rects[0] : rng.getBoundingClientRect();
				return rect$1.width > 0 || rect$1.height > 0 ? Optional.some(rect$1).map(toRect) : Optional.none();
			};
			const getBounds$2 = (rng) => {
				const rect$1 = rng.getBoundingClientRect();
				return rect$1.width > 0 || rect$1.height > 0 ? Optional.some(rect$1).map(toRect) : Optional.none();
			};
			const adt$4 = Adt.generate([{ ltr: [
				"start",
				"soffset",
				"finish",
				"foffset"
			] }, { rtl: [
				"start",
				"soffset",
				"finish",
				"foffset"
			] }]);
			const fromRange = (win$1, type$2, range$1) => type$2(SugarElement.fromDom(range$1.startContainer), range$1.startOffset, SugarElement.fromDom(range$1.endContainer), range$1.endOffset);
			const getRanges = (win$1, selection) => selection.match({
				domRange: (rng) => {
					return {
						ltr: constant$1(rng),
						rtl: Optional.none
					};
				},
				relative: (startSitu, finishSitu) => {
					return {
						ltr: cached(() => relativeToNative(win$1, startSitu, finishSitu)),
						rtl: cached(() => Optional.some(relativeToNative(win$1, finishSitu, startSitu)))
					};
				},
				exact: (start, soffset, finish, foffset) => {
					return {
						ltr: cached(() => exactToNative(win$1, start, soffset, finish, foffset)),
						rtl: cached(() => Optional.some(exactToNative(win$1, finish, foffset, start, soffset)))
					};
				}
			});
			const doDiagnose = (win$1, ranges) => {
				const rng = ranges.ltr();
				if (rng.collapsed) return ranges.rtl().filter((rev) => rev.collapsed === false).map((rev) => adt$4.rtl(SugarElement.fromDom(rev.endContainer), rev.endOffset, SugarElement.fromDom(rev.startContainer), rev.startOffset)).getOrThunk(() => fromRange(win$1, adt$4.ltr, rng));
				else return fromRange(win$1, adt$4.ltr, rng);
			};
			const diagnose = (win$1, selection) => {
				return doDiagnose(win$1, getRanges(win$1, selection));
			};
			const asLtrRange = (win$1, selection) => {
				return diagnose(win$1, selection).match({
					ltr: (start, soffset, finish, foffset) => {
						const rng = win$1.document.createRange();
						rng.setStart(start.dom, soffset);
						rng.setEnd(finish.dom, foffset);
						return rng;
					},
					rtl: (start, soffset, finish, foffset) => {
						const rng = win$1.document.createRange();
						rng.setStart(finish.dom, foffset);
						rng.setEnd(start.dom, soffset);
						return rng;
					}
				});
			};
			adt$4.ltr;
			adt$4.rtl;
			const ancestors = (scope, predicate, isRoot) => filter$2(parents(scope, isRoot), predicate);
			const descendants = (scope, selector) => all$3(selector, scope);
			const makeRange = (start, soffset, finish, foffset) => {
				const rng = owner$4(start).dom.createRange();
				rng.setStart(start.dom, soffset);
				rng.setEnd(finish.dom, foffset);
				return rng;
			};
			const after = (start, soffset, finish, foffset) => {
				const r$2 = makeRange(start, soffset, finish, foffset);
				const same = eq(start, finish) && soffset === foffset;
				return r$2.collapsed && !same;
			};
			const getNativeSelection = (win$1) => Optional.from(win$1.getSelection());
			const readRange = (selection) => {
				if (selection.rangeCount > 0) {
					const firstRng = selection.getRangeAt(0);
					const lastRng = selection.getRangeAt(selection.rangeCount - 1);
					return Optional.some(SimRange.create(SugarElement.fromDom(firstRng.startContainer), firstRng.startOffset, SugarElement.fromDom(lastRng.endContainer), lastRng.endOffset));
				} else return Optional.none();
			};
			const doGetExact = (selection) => {
				if (selection.anchorNode === null || selection.focusNode === null) return readRange(selection);
				else {
					const anchor$1 = SugarElement.fromDom(selection.anchorNode);
					const focus$5 = SugarElement.fromDom(selection.focusNode);
					return after(anchor$1, selection.anchorOffset, focus$5, selection.focusOffset) ? Optional.some(SimRange.create(anchor$1, selection.anchorOffset, focus$5, selection.focusOffset)) : readRange(selection);
				}
			};
			const getExact = (win$1) => getNativeSelection(win$1).filter((sel) => sel.rangeCount > 0).bind(doGetExact);
			const getFirstRect = (win$1, selection) => {
				return getFirstRect$1(asLtrRange(win$1, selection));
			};
			const getBounds$1 = (win$1, selection) => {
				return getBounds$2(asLtrRange(win$1, selection));
			};
			const NodeValue = (is$3, name$4) => {
				const get$10 = (element$1) => {
					if (!is$3(element$1)) throw new Error("Can only get " + name$4 + " value of a " + name$4 + " node");
					return getOption(element$1).getOr("");
				};
				const getOption = (element$1) => is$3(element$1) ? Optional.from(element$1.dom.nodeValue) : Optional.none();
				const set$10 = (element$1, value$5) => {
					if (!is$3(element$1)) throw new Error("Can only set raw " + name$4 + " value of a " + name$4 + " node");
					element$1.dom.nodeValue = value$5;
				};
				return {
					get: get$10,
					getOption,
					set: set$10
				};
			};
			const api = NodeValue(isText, "text");
			const get$4 = (element$1) => api.get(element$1);
			const point = (element$1, offset$1) => ({
				element: element$1,
				offset: offset$1
			});
			const descendOnce$1 = (element$1, offset$1) => {
				const children$1 = children(element$1);
				if (children$1.length === 0) return point(element$1, offset$1);
				else if (offset$1 < children$1.length) return point(children$1[offset$1], 0);
				else {
					const last$2 = children$1[children$1.length - 1];
					return point(last$2, isText(last$2) ? get$4(last$2).length : children(last$2).length);
				}
			};
			const descendOnce = (element$1, offset$1) => isText(element$1) ? point(element$1, offset$1) : descendOnce$1(element$1, offset$1);
			const isSimRange = (detail) => detail.foffset !== void 0;
			const getAnchorSelection = (win$1, anchorInfo) => {
				return anchorInfo.getSelection.getOrThunk(() => () => getExact(win$1))().map((sel) => {
					if (isSimRange(sel)) {
						const modStart = descendOnce(sel.start, sel.soffset);
						const modFinish = descendOnce(sel.finish, sel.foffset);
						return SimSelection.range(modStart.element, modStart.offset, modFinish.element, modFinish.offset);
					} else return sel;
				});
			};
			const placement$1 = (component, anchorInfo, origin) => {
				const win$1 = defaultView(anchorInfo.root).dom;
				const rootPoint = getRootPoint(component, origin, anchorInfo);
				return calcNewAnchor(getAnchorSelection(win$1, anchorInfo).bind((sel) => {
					if (isSimRange(sel)) return getBounds$1(win$1, SimSelection.exactFromRange(sel)).orThunk(() => {
						const zeroWidth$1 = SugarElement.fromText(zeroWidth);
						before$1(sel.start, zeroWidth$1);
						const rect$1 = getFirstRect(win$1, SimSelection.exact(zeroWidth$1, 0, zeroWidth$1, 1));
						remove$5(zeroWidth$1);
						return rect$1;
					}).bind((rawRect) => {
						return getBox(rawRect.left, rawRect.top, rawRect.width, rawRect.height);
					});
					else {
						const selectionRect = map$1(sel, (cell) => cell.dom.getBoundingClientRect());
						const bounds$2 = {
							left: Math.min(selectionRect.firstCell.left, selectionRect.lastCell.left),
							right: Math.max(selectionRect.firstCell.right, selectionRect.lastCell.right),
							top: Math.min(selectionRect.firstCell.top, selectionRect.lastCell.top),
							bottom: Math.max(selectionRect.firstCell.bottom, selectionRect.lastCell.bottom)
						};
						return getBox(bounds$2.left, bounds$2.top, bounds$2.right - bounds$2.left, bounds$2.bottom - bounds$2.top);
					}
				}), rootPoint, anchorInfo, origin, getAnchorSelection(win$1, anchorInfo).bind((sel) => {
					if (isSimRange(sel)) return isElement$1(sel.start) ? Optional.some(sel.start) : parentElement(sel.start);
					else return Optional.some(sel.firstCell);
				}).getOr(component.element));
			};
			var SelectionAnchor = [
				option$3("getSelection"),
				required$1("root"),
				option$3("bubble"),
				schema$y(),
				defaulted("overrides", {}),
				defaulted("showAbove", false),
				output$1("placement", placement$1)
			];
			const labelPrefix$1 = "link-layout";
			const eastX = (anchor$1) => anchor$1.x + anchor$1.width;
			const westX = (anchor$1, element$1) => anchor$1.x - element$1.width;
			const northY$1 = (anchor$1, element$1) => anchor$1.y - element$1.height + anchor$1.height;
			const southY$1 = (anchor$1) => anchor$1.y;
			const southeast$1 = (anchor$1, element$1, bubbles) => nu$6(eastX(anchor$1), southY$1(anchor$1), bubbles.southeast(), southeast$3(), "southeast", boundsRestriction(anchor$1, {
				left: 0,
				top: 2
			}), labelPrefix$1);
			const southwest$1 = (anchor$1, element$1, bubbles) => nu$6(westX(anchor$1, element$1), southY$1(anchor$1), bubbles.southwest(), southwest$3(), "southwest", boundsRestriction(anchor$1, {
				right: 1,
				top: 2
			}), labelPrefix$1);
			const northeast$1 = (anchor$1, element$1, bubbles) => nu$6(eastX(anchor$1), northY$1(anchor$1, element$1), bubbles.northeast(), northeast$3(), "northeast", boundsRestriction(anchor$1, {
				left: 0,
				bottom: 3
			}), labelPrefix$1);
			const northwest$1 = (anchor$1, element$1, bubbles) => nu$6(westX(anchor$1, element$1), northY$1(anchor$1, element$1), bubbles.northwest(), northwest$3(), "northwest", boundsRestriction(anchor$1, {
				right: 1,
				bottom: 3
			}), labelPrefix$1);
			const all = () => [
				southeast$1,
				southwest$1,
				northeast$1,
				northwest$1
			];
			const allRtl = () => [
				southwest$1,
				southeast$1,
				northwest$1,
				northeast$1
			];
			const placement = (component, submenuInfo, origin) => {
				const anchorBox = toBox(origin, submenuInfo.item.element);
				const layouts$1 = get$5(component.element, submenuInfo, all(), allRtl(), all(), allRtl(), Optional.none());
				return Optional.some(nu$4({
					anchorBox,
					bubble: fallback(),
					overrides: submenuInfo.overrides,
					layouts: layouts$1
				}));
			};
			var AnchorSchema = choose$1("type", {
				selection: SelectionAnchor,
				node: NodeAnchor,
				hotspot: HotspotAnchor,
				submenu: [
					required$1("item"),
					schema$y(),
					defaulted("overrides", {}),
					output$1("placement", placement)
				],
				makeshift: MakeshiftAnchor
			});
			const TransitionSchema = [requiredArrayOf("classes", string), defaultedStringEnum("mode", "all", [
				"all",
				"layout",
				"placement"
			])];
			const PositionSchema = [defaulted("useFixed", never), option$3("getBounds")];
			const PlacementSchema = [requiredOf("anchor", AnchorSchema), optionObjOf("transition", TransitionSchema)];
			const getFixedOrigin = () => {
				const html$2 = document.documentElement;
				return fixed$1(0, 0, html$2.clientWidth, html$2.clientHeight);
			};
			const getRelativeOrigin = (component) => {
				const position$3 = absolute$3(component.element);
				const bounds$2 = component.element.dom.getBoundingClientRect();
				return relative$1(position$3.left, position$3.top, bounds$2.width, bounds$2.height);
			};
			const place = (origin, anchoring, optBounds, placee, lastPlace, transition) => {
				return simple(box(anchoring.anchorBox, origin), placee.element, anchoring.bubble, anchoring.layouts, lastPlace, optBounds, anchoring.overrides, transition);
			};
			const position$1 = (component, posConfig, posState, placee, placementSpec) => {
				positionWithinBounds(component, posConfig, posState, placee, placementSpec, Optional.none());
			};
			const positionWithinBounds = (component, posConfig, posState, placee, placementSpec, optWithinBounds) => {
				const placeeDetail = asRawOrDie$1("placement.info", objOf(PlacementSchema), placementSpec);
				const anchorage = placeeDetail.anchor;
				const element$1 = placee.element;
				const placeeState = posState.get(placee.uid);
				preserve$1(() => {
					set$8(element$1, "position", "fixed");
					const oldVisibility = getRaw(element$1, "visibility");
					set$8(element$1, "visibility", "hidden");
					const origin = posConfig.useFixed() ? getFixedOrigin() : getRelativeOrigin(component);
					anchorage.placement(component, anchorage, origin).each((anchoring) => {
						const newState = place(origin, anchoring, optWithinBounds.orThunk(() => posConfig.getBounds.map(apply$1)), placee, placeeState, placeeDetail.transition);
						posState.set(placee.uid, newState);
					});
					oldVisibility.fold(() => {
						remove$6(element$1, "visibility");
					}, (vis) => {
						set$8(element$1, "visibility", vis);
					});
					if (getRaw(element$1, "left").isNone() && getRaw(element$1, "top").isNone() && getRaw(element$1, "right").isNone() && getRaw(element$1, "bottom").isNone() && is$1(getRaw(element$1, "position"), "fixed")) remove$6(element$1, "position");
				}, element$1);
			};
			const getMode = (component, pConfig, _pState) => pConfig.useFixed() ? "fixed" : "absolute";
			const reset$1 = (component, pConfig, posState, placee) => {
				const element$1 = placee.element;
				each$1([
					"position",
					"left",
					"right",
					"top",
					"bottom"
				], (prop) => remove$6(element$1, prop));
				reset$2(element$1);
				posState.clear(placee.uid);
			};
			var PositionApis = /* @__PURE__ */ Object.freeze({
				__proto__: null,
				position: position$1,
				positionWithinBounds,
				getMode,
				reset: reset$1
			});
			const init$g = () => {
				let state = {};
				const set$10 = (id, data) => {
					state[id] = data;
				};
				const get$10 = (id) => get$g(state, id);
				const clear$1 = (id) => {
					if (isNonNullable(id)) delete state[id];
					else state = {};
				};
				return nu$8({
					readState: () => state,
					clear: clear$1,
					set: set$10,
					get: get$10
				});
			};
			const Positioning = create$4({
				fields: PositionSchema,
				name: "positioning",
				active: ActivePosition,
				apis: PositionApis,
				state: /* @__PURE__ */ Object.freeze({
					__proto__: null,
					init: init$g
				})
			});
			const isConnected = (comp) => comp.getSystem().isConnected();
			const fireDetaching = (component) => {
				emit(component, detachedFromDom());
				each$1(component.components(), fireDetaching);
			};
			const fireAttaching = (component) => {
				each$1(component.components(), fireAttaching);
				emit(component, attachedToDom());
			};
			const virtualAttach = (parent$1, child$3) => {
				parent$1.getSystem().addToWorld(child$3);
				if (inBody(parent$1.element)) fireAttaching(child$3);
			};
			const virtualDetach = (comp) => {
				fireDetaching(comp);
				comp.getSystem().removeFromWorld(comp);
			};
			const attach$1 = (parent$1, child$3) => {
				append$2(parent$1.element, child$3.element);
			};
			const detachChildren$1 = (component) => {
				each$1(component.components(), (childComp) => remove$5(childComp.element));
				empty(component.element);
				component.syncComponents();
			};
			const replaceChildren = (component, newSpecs, buildNewChildren) => {
				const subs$1 = component.components();
				detachChildren$1(component);
				const newChildren = buildNewChildren(newSpecs);
				each$1(difference(subs$1, newChildren), (comp) => {
					fireDetaching(comp);
					component.getSystem().removeFromWorld(comp);
				});
				each$1(newChildren, (childComp) => {
					if (!isConnected(childComp)) {
						component.getSystem().addToWorld(childComp);
						attach$1(component, childComp);
						if (inBody(component.element)) fireAttaching(childComp);
					} else attach$1(component, childComp);
				});
				component.syncComponents();
			};
			const virtualReplaceChildren = (component, newSpecs, buildNewChildren) => {
				const subs$1 = component.components();
				const existingComps = bind$3(newSpecs, (spec) => getPremade(spec).toArray());
				each$1(subs$1, (childComp) => {
					if (!contains$2(existingComps, childComp)) virtualDetach(childComp);
				});
				const newChildren = buildNewChildren(newSpecs);
				each$1(difference(subs$1, newChildren), (deletedComp) => {
					if (isConnected(deletedComp)) virtualDetach(deletedComp);
				});
				each$1(newChildren, (childComp) => {
					if (!isConnected(childComp)) virtualAttach(component, childComp);
				});
				component.syncComponents();
			};
			const attach = (parent$1, child$3) => {
				attachWith(parent$1, child$3, append$2);
			};
			const attachWith = (parent$1, child$3, insertion) => {
				parent$1.getSystem().addToWorld(child$3);
				insertion(parent$1.element, child$3.element);
				if (inBody(parent$1.element)) fireAttaching(child$3);
				parent$1.syncComponents();
			};
			const doDetach = (component) => {
				fireDetaching(component);
				remove$5(component.element);
				component.getSystem().removeFromWorld(component);
			};
			const detach = (component) => {
				const parent$1 = parent(component.element).bind((p) => component.getSystem().getByDom(p).toOptional());
				doDetach(component);
				parent$1.each((p) => {
					p.syncComponents();
				});
			};
			const detachChildren = (component) => {
				each$1(component.components(), doDetach);
				empty(component.element);
				component.syncComponents();
			};
			const attachSystem = (element$1, guiSystem) => {
				attachSystemWith(element$1, guiSystem, append$2);
			};
			const attachSystemAfter = (element$1, guiSystem) => {
				attachSystemWith(element$1, guiSystem, after$2);
			};
			const attachSystemWith = (element$1, guiSystem, inserter) => {
				inserter(element$1, guiSystem.element);
				each$1(children(guiSystem.element), (child$3) => {
					guiSystem.getByDom(child$3).each(fireAttaching);
				});
			};
			const detachSystem = (guiSystem) => {
				each$1(children(guiSystem.element), (child$3) => {
					guiSystem.getByDom(child$3).each(fireDetaching);
				});
				remove$5(guiSystem.element);
			};
			const rebuild = (sandbox, sConfig, sState, data) => {
				sState.get().each((_data) => {
					detachChildren(sandbox);
				});
				attach(sConfig.getAttachPoint(sandbox), sandbox);
				const built = sandbox.getSystem().build(data);
				attach(sandbox, built);
				sState.set(built);
				return built;
			};
			const open$1 = (sandbox, sConfig, sState, data) => {
				const newState = rebuild(sandbox, sConfig, sState, data);
				sConfig.onOpen(sandbox, newState);
				return newState;
			};
			const setContent = (sandbox, sConfig, sState, data) => sState.get().map(() => rebuild(sandbox, sConfig, sState, data));
			const openWhileCloaked = (sandbox, sConfig, sState, data, transaction) => {
				cloak(sandbox, sConfig);
				open$1(sandbox, sConfig, sState, data);
				transaction();
				decloak(sandbox, sConfig);
			};
			const close$1 = (sandbox, sConfig, sState) => {
				sState.get().each((data) => {
					detachChildren(sandbox);
					detach(sandbox);
					sConfig.onClose(sandbox, data);
					sState.clear();
				});
			};
			const isOpen$1 = (_sandbox, _sConfig, sState) => sState.isOpen();
			const isPartOf = (sandbox, sConfig, sState, queryElem) => isOpen$1(sandbox, sConfig, sState) && sState.get().exists((data) => sConfig.isPartOf(sandbox, data, queryElem));
			const getState$2 = (_sandbox, _sConfig, sState) => sState.get();
			const store = (sandbox, cssKey, attr, newValue) => {
				getRaw(sandbox.element, cssKey).fold(() => {
					remove$7(sandbox.element, attr);
				}, (v) => {
					set$9(sandbox.element, attr, v);
				});
				set$8(sandbox.element, cssKey, newValue);
			};
			const restore = (sandbox, cssKey, attr) => {
				getOpt(sandbox.element, attr).fold(() => remove$6(sandbox.element, cssKey), (oldValue) => set$8(sandbox.element, cssKey, oldValue));
			};
			const cloak = (sandbox, sConfig, _sState) => {
				const sink = sConfig.getAttachPoint(sandbox);
				set$8(sandbox.element, "position", Positioning.getMode(sink));
				store(sandbox, "visibility", sConfig.cloakVisibilityAttr, "hidden");
			};
			const hasPosition = (element$1) => exists([
				"top",
				"left",
				"right",
				"bottom"
			], (pos) => getRaw(element$1, pos).isSome());
			const decloak = (sandbox, sConfig, _sState) => {
				if (!hasPosition(sandbox.element)) remove$6(sandbox.element, "position");
				restore(sandbox, "visibility", sConfig.cloakVisibilityAttr);
			};
			var SandboxApis = /* @__PURE__ */ Object.freeze({
				__proto__: null,
				cloak,
				decloak,
				open: open$1,
				openWhileCloaked,
				close: close$1,
				isOpen: isOpen$1,
				isPartOf,
				getState: getState$2,
				setContent
			});
			const events$g = (sandboxConfig, sandboxState) => derive$2([run$1(sandboxClose(), (sandbox, _simulatedEvent) => {
				close$1(sandbox, sandboxConfig, sandboxState);
			})]);
			var ActiveSandbox = /* @__PURE__ */ Object.freeze({
				__proto__: null,
				events: events$g
			});
			var SandboxSchema = [
				onHandler("onOpen"),
				onHandler("onClose"),
				required$1("isPartOf"),
				required$1("getAttachPoint"),
				defaulted("cloakVisibilityAttr", "data-precloak-visibility")
			];
			const init$f = () => {
				const contents$1 = value$2();
				return nu$8({
					readState: constant$1("not-implemented"),
					isOpen: contents$1.isSet,
					clear: contents$1.clear,
					set: contents$1.set,
					get: contents$1.get
				});
			};
			const Sandboxing = create$4({
				fields: SandboxSchema,
				name: "sandboxing",
				active: ActiveSandbox,
				apis: SandboxApis,
				state: /* @__PURE__ */ Object.freeze({
					__proto__: null,
					init: init$f
				})
			});
			const dismissPopups = constant$1("dismiss.popups");
			const repositionPopups = constant$1("reposition.popups");
			const mouseReleased = constant$1("mouse.released");
			const schema$x = objOfOnly([defaulted("isExtraPart", never), optionObjOf("fireEventInstead", [defaulted("event", dismissRequested())])]);
			const receivingChannel$1 = (rawSpec) => {
				const detail = asRawOrDie$1("Dismissal", schema$x, rawSpec);
				return { [dismissPopups()]: {
					schema: objOfOnly([required$1("target")]),
					onReceive: (sandbox, data) => {
						if (Sandboxing.isOpen(sandbox)) {
							if (!(Sandboxing.isPartOf(sandbox, data.target) || detail.isExtraPart(sandbox, data.target))) detail.fireEventInstead.fold(() => Sandboxing.close(sandbox), (fe) => emit(sandbox, fe.event));
						}
					}
				} };
			};
			const schema$w = objOfOnly([optionObjOf("fireEventInstead", [defaulted("event", repositionRequested())]), requiredFunction("doReposition")]);
			const receivingChannel = (rawSpec) => {
				const detail = asRawOrDie$1("Reposition", schema$w, rawSpec);
				return { [repositionPopups()]: { onReceive: (sandbox) => {
					if (Sandboxing.isOpen(sandbox)) detail.fireEventInstead.fold(() => detail.doReposition(sandbox), (fe) => emit(sandbox, fe.event));
				} } };
			};
			const onLoad$5 = (component, repConfig, repState) => {
				repConfig.store.manager.onLoad(component, repConfig, repState);
			};
			const onUnload$2 = (component, repConfig, repState) => {
				repConfig.store.manager.onUnload(component, repConfig, repState);
			};
			const setValue$3 = (component, repConfig, repState, data) => {
				repConfig.store.manager.setValue(component, repConfig, repState, data);
			};
			const getValue$3 = (component, repConfig, repState) => repConfig.store.manager.getValue(component, repConfig, repState);
			const getState$1 = (component, repConfig, repState) => repState;
			var RepresentApis = /* @__PURE__ */ Object.freeze({
				__proto__: null,
				onLoad: onLoad$5,
				onUnload: onUnload$2,
				setValue: setValue$3,
				getValue: getValue$3,
				getState: getState$1
			});
			const events$f = (repConfig, repState) => {
				return derive$2(repConfig.resetOnDom ? [runOnAttached((comp, _se) => {
					onLoad$5(comp, repConfig, repState);
				}), runOnDetached((comp, _se) => {
					onUnload$2(comp, repConfig, repState);
				})] : [loadEvent(repConfig, repState, onLoad$5)]);
			};
			var ActiveRepresenting = /* @__PURE__ */ Object.freeze({
				__proto__: null,
				events: events$f
			});
			const memory$1 = () => {
				const data = Cell(null);
				const readState = () => ({
					mode: "memory",
					value: data.get()
				});
				const isNotSet = () => data.get() === null;
				const clear$1 = () => {
					data.set(null);
				};
				return nu$8({
					set: data.set,
					get: data.get,
					isNotSet,
					clear: clear$1,
					readState
				});
			};
			const manual = () => {
				return nu$8({ readState: noop });
			};
			const dataset = () => {
				const dataByValue = Cell({});
				const dataByText = Cell({});
				const readState = () => ({
					mode: "dataset",
					dataByValue: dataByValue.get(),
					dataByText: dataByText.get()
				});
				const clear$1 = () => {
					dataByValue.set({});
					dataByText.set({});
				};
				const lookup$2 = (itemString) => get$g(dataByValue.get(), itemString).orThunk(() => get$g(dataByText.get(), itemString));
				const update = (items) => {
					const currentDataByValue = dataByValue.get();
					const currentDataByText = dataByText.get();
					const newDataByValue = {};
					const newDataByText = {};
					each$1(items, (item$1) => {
						newDataByValue[item$1.value] = item$1;
						get$g(item$1, "meta").each((meta) => {
							get$g(meta, "text").each((text$3) => {
								newDataByText[text$3] = item$1;
							});
						});
					});
					dataByValue.set({
						...currentDataByValue,
						...newDataByValue
					});
					dataByText.set({
						...currentDataByText,
						...newDataByText
					});
				};
				return nu$8({
					readState,
					lookup: lookup$2,
					update,
					clear: clear$1
				});
			};
			const init$e = (spec) => spec.store.manager.state(spec);
			var RepresentState = /* @__PURE__ */ Object.freeze({
				__proto__: null,
				memory: memory$1,
				dataset,
				manual,
				init: init$e
			});
			const setValue$2 = (component, repConfig, repState, data) => {
				const store$1 = repConfig.store;
				repState.update([data]);
				store$1.setValue(component, data);
				repConfig.onSetValue(component, data);
			};
			const getValue$2 = (component, repConfig, repState) => {
				const store$1 = repConfig.store;
				const key = store$1.getDataKey(component);
				return repState.lookup(key).getOrThunk(() => store$1.getFallbackEntry(key));
			};
			const onLoad$4 = (component, repConfig, repState) => {
				repConfig.store.initialValue.each((data) => {
					setValue$2(component, repConfig, repState, data);
				});
			};
			const onUnload$1 = (component, repConfig, repState) => {
				repState.clear();
			};
			var DatasetStore = [
				option$3("initialValue"),
				required$1("getFallbackEntry"),
				required$1("getDataKey"),
				required$1("setValue"),
				output$1("manager", {
					setValue: setValue$2,
					getValue: getValue$2,
					onLoad: onLoad$4,
					onUnload: onUnload$1,
					state: dataset
				})
			];
			const getValue$1 = (component, repConfig, _repState) => repConfig.store.getValue(component);
			const setValue$1 = (component, repConfig, _repState, data) => {
				repConfig.store.setValue(component, data);
				repConfig.onSetValue(component, data);
			};
			const onLoad$3 = (component, repConfig, _repState) => {
				repConfig.store.initialValue.each((data) => {
					repConfig.store.setValue(component, data);
				});
			};
			var ManualStore = [
				required$1("getValue"),
				defaulted("setValue", noop),
				option$3("initialValue"),
				output$1("manager", {
					setValue: setValue$1,
					getValue: getValue$1,
					onLoad: onLoad$3,
					onUnload: noop,
					state: NoState.init
				})
			];
			const setValue = (component, repConfig, repState, data) => {
				repState.set(data);
				repConfig.onSetValue(component, data);
			};
			const getValue = (component, repConfig, repState) => repState.get();
			const onLoad$2 = (component, repConfig, repState) => {
				repConfig.store.initialValue.each((initVal) => {
					if (repState.isNotSet()) repState.set(initVal);
				});
			};
			const onUnload = (component, repConfig, repState) => {
				repState.clear();
			};
			const Representing = create$4({
				fields: [
					defaultedOf("store", { mode: "memory" }, choose$1("mode", {
						memory: [option$3("initialValue"), output$1("manager", {
							setValue,
							getValue,
							onLoad: onLoad$2,
							onUnload,
							state: memory$1
						})],
						manual: ManualStore,
						dataset: DatasetStore
					})),
					onHandler("onSetValue"),
					defaulted("resetOnDom", false)
				],
				name: "representing",
				active: ActiveRepresenting,
				apis: RepresentApis,
				extra: { setValueFrom: (component, source) => {
					const value$5 = Representing.getValue(source);
					Representing.setValue(component, value$5);
				} },
				state: RepresentState
			});
			const field = (name$4, forbidden) => defaultedObjOf(name$4, {}, map$2(forbidden, (f$1) => forbid(f$1.name(), "Cannot configure " + f$1.name() + " for " + name$4)).concat([customField("dump", identity)]));
			const get$3 = (data) => data.dump;
			const augment = (data, original$1) => ({
				...derive$1(original$1),
				...data.dump
			});
			const SketchBehaviours = {
				field,
				augment,
				get: get$3
			};
			const _placeholder = "placeholder";
			const adt$3 = Adt.generate([{ single: ["required", "valueThunk"] }, { multiple: ["required", "valueThunks"] }]);
			const isSubstituted = (spec) => has$2(spec, "uiType");
			const subPlaceholder = (owner$5, detail, compSpec, placeholders) => {
				if (owner$5.exists((o) => o !== compSpec.owner)) return adt$3.single(true, constant$1(compSpec));
				return get$g(placeholders, compSpec.name).fold(() => {
					throw new Error("Unknown placeholder component: " + compSpec.name + "\nKnown: [" + keys(placeholders) + "]\nNamespace: " + owner$5.getOr("none") + "\nSpec: " + JSON.stringify(compSpec, null, 2));
				}, (newSpec) => newSpec.replace());
			};
			const scan = (owner$5, detail, compSpec, placeholders) => {
				if (isSubstituted(compSpec) && compSpec.uiType === _placeholder) return subPlaceholder(owner$5, detail, compSpec, placeholders);
				else return adt$3.single(false, constant$1(compSpec));
			};
			const substitute = (owner$5, detail, compSpec, placeholders) => {
				return scan(owner$5, detail, compSpec, placeholders).fold((req, valueThunk$1) => {
					const value$5 = isSubstituted(compSpec) ? valueThunk$1(detail, compSpec.config, compSpec.validated) : valueThunk$1(detail);
					const substituted = bind$3(get$g(value$5, "components").getOr([]), (c) => substitute(owner$5, detail, c, placeholders));
					return [{
						...value$5,
						components: substituted
					}];
				}, (req, valuesThunk) => {
					if (isSubstituted(compSpec)) {
						const values$1 = valuesThunk(detail, compSpec.config, compSpec.validated);
						return compSpec.validated.preprocess.getOr(identity)(values$1);
					} else return valuesThunk(detail);
				});
			};
			const substituteAll = (owner$5, detail, components$2, placeholders) => bind$3(components$2, (c) => substitute(owner$5, detail, c, placeholders));
			const oneReplace = (label$1, replacements) => {
				let called = false;
				const used = () => called;
				const replace$1 = () => {
					if (called) throw new Error("Trying to use the same placeholder more than once: " + label$1);
					called = true;
					return replacements;
				};
				const required$3 = () => replacements.fold((req, _) => req, (req, _) => req);
				return {
					name: constant$1(label$1),
					required: required$3,
					used,
					replace: replace$1
				};
			};
			const substitutePlaces = (owner$5, detail, components$2, placeholders) => {
				const ps = map$1(placeholders, (ph, name$4) => oneReplace(name$4, ph));
				const outcome = substituteAll(owner$5, detail, components$2, ps);
				each(ps, (p) => {
					if (p.used() === false && p.required()) throw new Error("Placeholder: " + p.name() + " was not found in components list\nNamespace: " + owner$5.getOr("none") + "\nComponents: " + JSON.stringify(detail.components, null, 2));
				});
				return outcome;
			};
			const single$2 = adt$3.single;
			const multiple = adt$3.multiple;
			const placeholder = constant$1(_placeholder);
			const adt$2 = Adt.generate([
				{ required: ["data"] },
				{ external: ["data"] },
				{ optional: ["data"] },
				{ group: ["data"] }
			]);
			const fFactory = defaulted("factory", { sketch: identity });
			const fSchema = defaulted("schema", []);
			const fName = required$1("name");
			const fPname = field$1("pname", "pname", defaultedThunk((typeSpec) => "<alloy." + generate$6(typeSpec.name) + ">"), anyValue());
			const fGroupSchema = customField("schema", () => [option$3("preprocess")]);
			const fDefaults = defaulted("defaults", constant$1({}));
			const fOverrides = defaulted("overrides", constant$1({}));
			const requiredSpec = objOf([
				fFactory,
				fSchema,
				fName,
				fPname,
				fDefaults,
				fOverrides
			]);
			const externalSpec = objOf([
				fFactory,
				fSchema,
				fName,
				fDefaults,
				fOverrides
			]);
			const optionalSpec = objOf([
				fFactory,
				fSchema,
				fName,
				fPname,
				fDefaults,
				fOverrides
			]);
			const groupSpec = objOf([
				fFactory,
				fGroupSchema,
				fName,
				required$1("unit"),
				fPname,
				fDefaults,
				fOverrides
			]);
			const asNamedPart = (part$1) => {
				return part$1.fold(Optional.some, Optional.none, Optional.some, Optional.some);
			};
			const name$2 = (part$1) => {
				const get$10 = (data) => data.name;
				return part$1.fold(get$10, get$10, get$10, get$10);
			};
			const asCommon = (part$1) => {
				return part$1.fold(identity, identity, identity, identity);
			};
			const convert = (adtConstructor, partSchema) => (spec) => {
				return adtConstructor(asRawOrDie$1("Converting part type", partSchema, spec));
			};
			const required = convert(adt$2.required, requiredSpec);
			const external = convert(adt$2.external, externalSpec);
			const optional = convert(adt$2.optional, optionalSpec);
			const group = convert(adt$2.group, groupSpec);
			const original = constant$1("entirety");
			var PartType = /* @__PURE__ */ Object.freeze({
				__proto__: null,
				required,
				external,
				optional,
				group,
				asNamedPart,
				name: name$2,
				asCommon,
				original
			});
			const combine = (detail, data, partSpec, partValidated) => deepMerge(data.defaults(detail, partSpec, partValidated), partSpec, { uid: detail.partUids[data.name] }, data.overrides(detail, partSpec, partValidated));
			const subs = (owner$5, detail, parts$10) => {
				const internals = {};
				const externals = {};
				each$1(parts$10, (part$1) => {
					part$1.fold((data) => {
						internals[data.pname] = single$2(true, (detail$1, partSpec, partValidated) => data.factory.sketch(combine(detail$1, data, partSpec, partValidated)));
					}, (data) => {
						const partSpec = detail.parts[data.name];
						externals[data.name] = constant$1(data.factory.sketch(combine(detail, data, partSpec[original()]), partSpec));
					}, (data) => {
						internals[data.pname] = single$2(false, (detail$1, partSpec, partValidated) => data.factory.sketch(combine(detail$1, data, partSpec, partValidated)));
					}, (data) => {
						internals[data.pname] = multiple(true, (detail$1, _partSpec, _partValidated) => {
							const units$1 = detail$1[data.name];
							return map$2(units$1, (u) => data.factory.sketch(deepMerge(data.defaults(detail$1, u, _partValidated), u, data.overrides(detail$1, u))));
						});
					});
				});
				return {
					internals: constant$1(internals),
					externals: constant$1(externals)
				};
			};
			const generate$3 = (owner$5, parts$10) => {
				const r$2 = {};
				each$1(parts$10, (part$1) => {
					asNamedPart(part$1).each((np) => {
						const g = doGenerateOne(owner$5, np.pname);
						r$2[np.name] = (config$1) => {
							const validated = asRawOrDie$1("Part: " + np.name + " in " + owner$5, objOf(np.schema), config$1);
							return {
								...g,
								config: config$1,
								validated
							};
						};
					});
				});
				return r$2;
			};
			const doGenerateOne = (owner$5, pname) => ({
				uiType: placeholder(),
				owner: owner$5,
				name: pname
			});
			const generateOne$1 = (owner$5, pname, config$1) => ({
				uiType: placeholder(),
				owner: owner$5,
				name: pname,
				config: config$1,
				validated: {}
			});
			const schemas = (parts$10) => bind$3(parts$10, (part$1) => part$1.fold(Optional.none, Optional.some, Optional.none, Optional.none).map((data) => requiredObjOf(data.name, data.schema.concat([snapshot(original())]))).toArray());
			const names = (parts$10) => map$2(parts$10, name$2);
			const substitutes = (owner$5, detail, parts$10) => subs(owner$5, detail, parts$10);
			const components$1 = (owner$5, detail, internals) => substitutePlaces(Optional.some(owner$5), detail, detail.components, internals);
			const getPart = (component, detail, partKey) => {
				const uid = detail.partUids[partKey];
				return component.getSystem().getByUid(uid).toOptional();
			};
			const getPartOrDie = (component, detail, partKey) => getPart(component, detail, partKey).getOrDie("Could not find part: " + partKey);
			const getParts = (component, detail, partKeys) => {
				const r$2 = {};
				const uids$1 = detail.partUids;
				const system = component.getSystem();
				each$1(partKeys, (pk) => {
					r$2[pk] = constant$1(system.getByUid(uids$1[pk]));
				});
				return r$2;
			};
			const getAllParts = (component, detail) => {
				const system = component.getSystem();
				return map$1(detail.partUids, (pUid, _k) => constant$1(system.getByUid(pUid)));
			};
			const getAllPartNames = (detail) => keys(detail.partUids);
			const getPartsOrDie = (component, detail, partKeys) => {
				const r$2 = {};
				const uids$1 = detail.partUids;
				const system = component.getSystem();
				each$1(partKeys, (pk) => {
					r$2[pk] = constant$1(system.getByUid(uids$1[pk]).getOrDie());
				});
				return r$2;
			};
			const defaultUids = (baseUid, partTypes) => {
				return wrapAll(map$2(names(partTypes), (pn) => ({
					key: pn,
					value: baseUid + "-" + pn
				})));
			};
			const defaultUidsSchema = (partTypes) => field$1("partUids", "partUids", mergeWithThunk((spec) => defaultUids(spec.uid, partTypes)), anyValue());
			var AlloyParts = /* @__PURE__ */ Object.freeze({
				__proto__: null,
				generate: generate$3,
				generateOne: generateOne$1,
				schemas,
				names,
				substitutes,
				components: components$1,
				defaultUids,
				defaultUidsSchema,
				getAllParts,
				getAllPartNames,
				getPart,
				getPartOrDie,
				getParts,
				getPartsOrDie
			});
			const base = (partSchemas, partUidsSchemas) => {
				return (partSchemas.length > 0 ? [requiredObjOf("parts", partSchemas)] : []).concat([
					required$1("uid"),
					defaulted("dom", {}),
					defaulted("components", []),
					snapshot("originalSpec"),
					defaulted("debug.sketcher", {})
				]).concat(partUidsSchemas);
			};
			const asRawOrDie = (label$1, schema$10, spec, partSchemas, partUidsSchemas) => {
				const baseS = base(partSchemas, partUidsSchemas);
				return asRawOrDie$1(label$1 + " [SpecSchema]", objOfOnly(baseS.concat(schema$10)), spec);
			};
			const single$1 = (owner$5, schema$10, factory$10, spec) => {
				const specWithUid = supplyUid(spec);
				return factory$10(asRawOrDie(owner$5, schema$10, specWithUid, [], []), specWithUid);
			};
			const composite$1 = (owner$5, schema$10, partTypes, factory$10, spec) => {
				const specWithUid = supplyUid(spec);
				const detail = asRawOrDie(owner$5, schema$10, specWithUid, schemas(partTypes), [defaultUidsSchema(partTypes)]);
				const subs$1 = substitutes(owner$5, detail, partTypes);
				return factory$10(detail, components$1(owner$5, detail, subs$1.internals()), specWithUid, subs$1.externals());
			};
			const hasUid = (spec) => has$2(spec, "uid");
			const supplyUid = (spec) => {
				return hasUid(spec) ? spec : {
					...spec,
					uid: generate$5("uid")
				};
			};
			const isSketchSpec = (spec) => {
				return spec.uid !== void 0;
			};
			const singleSchema = objOfOnly([
				required$1("name"),
				required$1("factory"),
				required$1("configFields"),
				defaulted("apis", {}),
				defaulted("extraApis", {})
			]);
			const compositeSchema = objOfOnly([
				required$1("name"),
				required$1("factory"),
				required$1("configFields"),
				required$1("partFields"),
				defaulted("apis", {}),
				defaulted("extraApis", {})
			]);
			const single = (rawConfig) => {
				const config$1 = asRawOrDie$1("Sketcher for " + rawConfig.name, singleSchema, rawConfig);
				const sketch$3 = (spec) => single$1(config$1.name, config$1.configFields, config$1.factory, spec);
				const apis = map$1(config$1.apis, makeApi);
				const extraApis = map$1(config$1.extraApis, (f$1, k) => markAsExtraApi(f$1, k));
				return {
					name: config$1.name,
					configFields: config$1.configFields,
					sketch: sketch$3,
					...apis,
					...extraApis
				};
			};
			const composite = (rawConfig) => {
				const config$1 = asRawOrDie$1("Sketcher for " + rawConfig.name, compositeSchema, rawConfig);
				const sketch$3 = (spec) => composite$1(config$1.name, config$1.configFields, config$1.partFields, config$1.factory, spec);
				const parts$10 = generate$3(config$1.name, config$1.partFields);
				const apis = map$1(config$1.apis, makeApi);
				const extraApis = map$1(config$1.extraApis, (f$1, k) => markAsExtraApi(f$1, k));
				return {
					name: config$1.name,
					partFields: config$1.partFields,
					configFields: config$1.configFields,
					sketch: sketch$3,
					parts: parts$10,
					...apis,
					...extraApis
				};
			};
			const inside = (target) => isTag("input")(target) && get$f(target, "type") !== "radio" || isTag("textarea")(target);
			const getCurrent = (component, composeConfig, _composeState) => composeConfig.find(component);
			var ComposeApis = /* @__PURE__ */ Object.freeze({
				__proto__: null,
				getCurrent
			});
			const Composing = create$4({
				fields: [required$1("find")],
				name: "composing",
				apis: ComposeApis
			});
			const nativeDisabled = [
				"input",
				"button",
				"textarea",
				"select"
			];
			const onLoad$1 = (component, disableConfig, disableState) => {
				(disableConfig.disabled() ? disable : enable)(component, disableConfig);
			};
			const hasNative = (component, config$1) => config$1.useNative === true && contains$2(nativeDisabled, name$3(component.element));
			const nativeIsDisabled = (component) => has$1(component.element, "disabled");
			const nativeDisable = (component) => {
				set$9(component.element, "disabled", "disabled");
			};
			const nativeEnable = (component) => {
				remove$7(component.element, "disabled");
			};
			const ariaIsDisabled = (component) => get$f(component.element, "aria-disabled") === "true";
			const ariaDisable = (component) => {
				set$9(component.element, "aria-disabled", "true");
			};
			const ariaEnable = (component) => {
				set$9(component.element, "aria-disabled", "false");
			};
			const disable = (component, disableConfig, _disableState) => {
				disableConfig.disableClass.each((disableClass) => {
					add$2(component.element, disableClass);
				});
				(hasNative(component, disableConfig) ? nativeDisable : ariaDisable)(component);
				disableConfig.onDisabled(component);
			};
			const enable = (component, disableConfig, _disableState) => {
				disableConfig.disableClass.each((disableClass) => {
					remove$2(component.element, disableClass);
				});
				(hasNative(component, disableConfig) ? nativeEnable : ariaEnable)(component);
				disableConfig.onEnabled(component);
			};
			const isDisabled = (component, disableConfig) => hasNative(component, disableConfig) ? nativeIsDisabled(component) : ariaIsDisabled(component);
			const set$4 = (component, disableConfig, disableState, disabled) => {
				(disabled ? disable : enable)(component, disableConfig);
			};
			var DisableApis = /* @__PURE__ */ Object.freeze({
				__proto__: null,
				enable,
				disable,
				isDisabled,
				onLoad: onLoad$1,
				set: set$4
			});
			const exhibit$5 = (base$1, disableConfig) => nu$7({ classes: disableConfig.disabled() ? disableConfig.disableClass.toArray() : [] });
			const events$e = (disableConfig, disableState) => derive$2([abort(execute$5(), (component, _simulatedEvent) => isDisabled(component, disableConfig)), loadEvent(disableConfig, disableState, onLoad$1)]);
			var ActiveDisable = /* @__PURE__ */ Object.freeze({
				__proto__: null,
				exhibit: exhibit$5,
				events: events$e
			});
			const Disabling = create$4({
				fields: [
					defaultedFunction("disabled", never),
					defaulted("useNative", true),
					option$3("disableClass"),
					onHandler("onDisabled"),
					onHandler("onEnabled")
				],
				name: "disabling",
				active: ActiveDisable,
				apis: DisableApis
			});
			const dehighlightAllExcept = (component, hConfig, hState, skip) => {
				each$1(descendants(component.element, "." + hConfig.highlightClass), (h) => {
					if (!exists(skip, (skipComp) => eq(skipComp.element, h))) {
						remove$2(h, hConfig.highlightClass);
						component.getSystem().getByDom(h).each((target) => {
							hConfig.onDehighlight(component, target);
							emit(target, dehighlight$1());
						});
					}
				});
			};
			const dehighlightAll = (component, hConfig, hState) => dehighlightAllExcept(component, hConfig, hState, []);
			const dehighlight = (component, hConfig, hState, target) => {
				if (isHighlighted(component, hConfig, hState, target)) {
					remove$2(target.element, hConfig.highlightClass);
					hConfig.onDehighlight(component, target);
					emit(target, dehighlight$1());
				}
			};
			const highlight = (component, hConfig, hState, target) => {
				dehighlightAllExcept(component, hConfig, hState, [target]);
				if (!isHighlighted(component, hConfig, hState, target)) {
					add$2(target.element, hConfig.highlightClass);
					hConfig.onHighlight(component, target);
					emit(target, highlight$1());
				}
			};
			const highlightFirst = (component, hConfig, hState) => {
				getFirst(component, hConfig).each((firstComp) => {
					highlight(component, hConfig, hState, firstComp);
				});
			};
			const highlightLast = (component, hConfig, hState) => {
				getLast(component, hConfig).each((lastComp) => {
					highlight(component, hConfig, hState, lastComp);
				});
			};
			const highlightAt = (component, hConfig, hState, index) => {
				getByIndex(component, hConfig, hState, index).fold((err) => {
					throw err;
				}, (firstComp) => {
					highlight(component, hConfig, hState, firstComp);
				});
			};
			const highlightBy = (component, hConfig, hState, predicate) => {
				find$5(getCandidates(component, hConfig), predicate).each((c) => {
					highlight(component, hConfig, hState, c);
				});
			};
			const isHighlighted = (component, hConfig, hState, queryTarget) => has(queryTarget.element, hConfig.highlightClass);
			const getHighlighted = (component, hConfig, _hState) => descendant(component.element, "." + hConfig.highlightClass).bind((e) => component.getSystem().getByDom(e).toOptional());
			const getByIndex = (component, hConfig, hState, index) => {
				const items = descendants(component.element, "." + hConfig.itemClass);
				return Optional.from(items[index]).fold(() => Result.error(/* @__PURE__ */ new Error("No element found with index " + index)), component.getSystem().getByDom);
			};
			const getFirst = (component, hConfig, _hState) => descendant(component.element, "." + hConfig.itemClass).bind((e) => component.getSystem().getByDom(e).toOptional());
			const getLast = (component, hConfig, _hState) => {
				const items = descendants(component.element, "." + hConfig.itemClass);
				return (items.length > 0 ? Optional.some(items[items.length - 1]) : Optional.none()).bind((c) => component.getSystem().getByDom(c).toOptional());
			};
			const getDelta$2 = (component, hConfig, hState, delta) => {
				const items = descendants(component.element, "." + hConfig.itemClass);
				return findIndex$1(items, (item$1) => has(item$1, hConfig.highlightClass)).bind((selected) => {
					const dest = cycleBy(selected, delta, 0, items.length - 1);
					return component.getSystem().getByDom(items[dest]).toOptional();
				});
			};
			const getPrevious = (component, hConfig, hState) => getDelta$2(component, hConfig, hState, -1);
			const getNext = (component, hConfig, hState) => getDelta$2(component, hConfig, hState, 1);
			const getCandidates = (component, hConfig, _hState) => {
				return cat(map$2(descendants(component.element, "." + hConfig.itemClass), (i) => component.getSystem().getByDom(i).toOptional()));
			};
			var HighlightApis = /* @__PURE__ */ Object.freeze({
				__proto__: null,
				dehighlightAll,
				dehighlight,
				highlight,
				highlightFirst,
				highlightLast,
				highlightAt,
				highlightBy,
				isHighlighted,
				getHighlighted,
				getFirst,
				getLast,
				getPrevious,
				getNext,
				getCandidates
			});
			const Highlighting = create$4({
				fields: [
					required$1("highlightClass"),
					required$1("itemClass"),
					onHandler("onHighlight"),
					onHandler("onDehighlight")
				],
				name: "highlighting",
				apis: HighlightApis
			});
			const BACKSPACE = [8];
			const TAB = [9];
			const ENTER = [13];
			const ESCAPE = [27];
			const SPACE = [32];
			const LEFT = [37];
			const UP = [38];
			const RIGHT = [39];
			const DOWN = [40];
			const cyclePrev = (values$1, index, predicate) => {
				const before = reverse(values$1.slice(0, index));
				const after$1 = reverse(values$1.slice(index + 1));
				return find$5(before.concat(after$1), predicate);
			};
			const tryPrev = (values$1, index, predicate) => {
				return find$5(reverse(values$1.slice(0, index)), predicate);
			};
			const cycleNext = (values$1, index, predicate) => {
				const before = values$1.slice(0, index);
				return find$5(values$1.slice(index + 1).concat(before), predicate);
			};
			const tryNext = (values$1, index, predicate) => {
				return find$5(values$1.slice(index + 1), predicate);
			};
			const inSet = (keys$1) => (event) => {
				const raw = event.raw;
				return contains$2(keys$1, raw.which);
			};
			const and = (preds) => (event) => forall(preds, (pred) => pred(event));
			const isShift = (event) => {
				return event.raw.shiftKey === true;
			};
			const isControl = (event) => {
				return event.raw.ctrlKey === true;
			};
			const isNotShift = not(isShift);
			const rule = (matches, action) => ({
				matches,
				classification: action
			});
			const choose = (transitions, event) => {
				return find$5(transitions, (t$1) => t$1.matches(event)).map((t$1) => t$1.classification);
			};
			const reportFocusShifting = (component, prevFocus, newFocus) => {
				if (!prevFocus.exists((p) => newFocus.exists((n) => eq(n, p)))) emitWith(component, focusShifted(), {
					prevFocus,
					newFocus
				});
			};
			const dom$2 = () => {
				const get$10 = (component) => search(component.element);
				const set$10 = (component, focusee) => {
					const prevFocus = get$10(component);
					component.getSystem().triggerFocus(focusee, component.element);
					reportFocusShifting(component, prevFocus, get$10(component));
				};
				return {
					get: get$10,
					set: set$10
				};
			};
			const highlights = () => {
				const get$10 = (component) => Highlighting.getHighlighted(component).map((item$1) => item$1.element);
				const set$10 = (component, element$1) => {
					const prevFocus = get$10(component);
					component.getSystem().getByDom(element$1).fold(noop, (item$1) => {
						Highlighting.highlight(component, item$1);
					});
					reportFocusShifting(component, prevFocus, get$10(component));
				};
				return {
					get: get$10,
					set: set$10
				};
			};
			var FocusInsideModes;
			(function(FocusInsideModes$1) {
				FocusInsideModes$1["OnFocusMode"] = "onFocus";
				FocusInsideModes$1["OnEnterOrSpaceMode"] = "onEnterOrSpace";
				FocusInsideModes$1["OnApiMode"] = "onApi";
			})(FocusInsideModes || (FocusInsideModes = {}));
			const typical = (infoSchema, stateInit, getKeydownRules$4, getKeyupRules$4, optFocusIn) => {
				const schema$10 = () => infoSchema.concat([
					defaulted("focusManager", dom$2()),
					defaultedOf("focusInside", "onFocus", valueOf((val) => contains$2([
						"onFocus",
						"onEnterOrSpace",
						"onApi"
					], val) ? Result.value(val) : Result.error("Invalid value for focusInside"))),
					output$1("handler", me),
					output$1("state", stateInit),
					output$1("sendFocusIn", optFocusIn)
				]);
				const processKey = (component, simulatedEvent, getRules, keyingConfig, keyingState) => {
					return choose(getRules(component, simulatedEvent, keyingConfig, keyingState), simulatedEvent.event).bind((rule$1) => rule$1(component, simulatedEvent, keyingConfig, keyingState));
				};
				const toEvents$1 = (keyingConfig, keyingState) => {
					const onFocusHandler = keyingConfig.focusInside !== FocusInsideModes.OnFocusMode ? Optional.none() : optFocusIn(keyingConfig).map((focusIn$4) => run$1(focus$4(), (component, simulatedEvent) => {
						focusIn$4(component, keyingConfig, keyingState);
						simulatedEvent.stop();
					}));
					const tryGoInsideComponent = (component, simulatedEvent) => {
						const isEnterOrSpace = inSet(SPACE.concat(ENTER))(simulatedEvent.event);
						if (keyingConfig.focusInside === FocusInsideModes.OnEnterOrSpaceMode && isEnterOrSpace && isSource(component, simulatedEvent)) optFocusIn(keyingConfig).each((focusIn$4) => {
							focusIn$4(component, keyingConfig, keyingState);
							simulatedEvent.stop();
						});
					};
					const keyboardEvents = [run$1(keydown(), (component, simulatedEvent) => {
						processKey(component, simulatedEvent, getKeydownRules$4, keyingConfig, keyingState).fold(() => {
							tryGoInsideComponent(component, simulatedEvent);
						}, (_) => {
							simulatedEvent.stop();
						});
					}), run$1(keyup(), (component, simulatedEvent) => {
						processKey(component, simulatedEvent, getKeyupRules$4, keyingConfig, keyingState).each((_) => {
							simulatedEvent.stop();
						});
					})];
					return derive$2(onFocusHandler.toArray().concat(keyboardEvents));
				};
				const me = {
					schema: schema$10,
					processKey,
					toEvents: toEvents$1
				};
				return me;
			};
			const create$2 = (cyclicField) => {
				const schema$10 = [
					option$3("onEscape"),
					option$3("onEnter"),
					defaulted("selector", "[data-alloy-tabstop=\"true\"]:not(:disabled)"),
					defaulted("firstTabstop", 0),
					defaulted("useTabstopAt", always),
					option$3("visibilitySelector")
				].concat([cyclicField]);
				const isVisible$1 = (tabbingConfig, element$1) => {
					return get$d(tabbingConfig.visibilitySelector.bind((sel) => closest$1(element$1, sel)).getOr(element$1)) > 0;
				};
				const findInitial = (component, tabbingConfig) => {
					const visibles = filter$2(descendants(component.element, tabbingConfig.selector), (elem) => isVisible$1(tabbingConfig, elem));
					return Optional.from(visibles[tabbingConfig.firstTabstop]);
				};
				const findCurrent$2 = (component, tabbingConfig) => tabbingConfig.focusManager.get(component).bind((elem) => closest$1(elem, tabbingConfig.selector));
				const isTabstop = (tabbingConfig, element$1) => isVisible$1(tabbingConfig, element$1) && tabbingConfig.useTabstopAt(element$1);
				const focusIn$4 = (component, tabbingConfig, _tabbingState) => {
					findInitial(component, tabbingConfig).each((target) => {
						tabbingConfig.focusManager.set(component, target);
					});
				};
				const goFromTabstop = (component, tabstops, stopIndex, tabbingConfig, cycle) => cycle(tabstops, stopIndex, (elem) => isTabstop(tabbingConfig, elem)).fold(() => tabbingConfig.cyclic ? Optional.some(true) : Optional.none(), (target) => {
					tabbingConfig.focusManager.set(component, target);
					return Optional.some(true);
				});
				const go$1 = (component, _simulatedEvent, tabbingConfig, cycle) => {
					const tabstops = descendants(component.element, tabbingConfig.selector);
					return findCurrent$2(component, tabbingConfig).bind((tabstop) => {
						return findIndex$1(tabstops, curry(eq, tabstop)).bind((stopIndex) => goFromTabstop(component, tabstops, stopIndex, tabbingConfig, cycle));
					});
				};
				const goBackwards = (component, simulatedEvent, tabbingConfig) => {
					return go$1(component, simulatedEvent, tabbingConfig, tabbingConfig.cyclic ? cyclePrev : tryPrev);
				};
				const goForwards = (component, simulatedEvent, tabbingConfig) => {
					return go$1(component, simulatedEvent, tabbingConfig, tabbingConfig.cyclic ? cycleNext : tryNext);
				};
				const isFirstChild = (elem) => parentNode(elem).bind(firstChild).exists((child$3) => eq(child$3, elem));
				const goFromPseudoTabstop = (component, simulatedEvent, tabbingConfig) => findCurrent$2(component, tabbingConfig).filter((elem) => !tabbingConfig.useTabstopAt(elem)).bind((elem) => (isFirstChild(elem) ? goBackwards : goForwards)(component, simulatedEvent, tabbingConfig));
				const execute$6 = (component, simulatedEvent, tabbingConfig) => tabbingConfig.onEnter.bind((f$1) => f$1(component, simulatedEvent));
				const exit = (component, simulatedEvent, tabbingConfig) => tabbingConfig.onEscape.bind((f$1) => f$1(component, simulatedEvent));
				const getKeydownRules$4 = constant$1([
					rule(and([isShift, inSet(TAB)]), goBackwards),
					rule(inSet(TAB), goForwards),
					rule(and([isNotShift, inSet(ENTER)]), execute$6)
				]);
				const getKeyupRules$4 = constant$1([rule(inSet(ESCAPE), exit), rule(inSet(TAB), goFromPseudoTabstop)]);
				return typical(schema$10, NoState.init, getKeydownRules$4, getKeyupRules$4, () => Optional.some(focusIn$4));
			};
			var AcyclicType = create$2(customField("cyclic", never));
			var CyclicType = create$2(customField("cyclic", always));
			const doDefaultExecute = (component, _simulatedEvent, focused) => {
				dispatch(component, focused, execute$5());
				return Optional.some(true);
			};
			const defaultExecute = (component, simulatedEvent, focused) => {
				return inside(focused) && inSet(SPACE)(simulatedEvent.event) ? Optional.none() : doDefaultExecute(component, simulatedEvent, focused);
			};
			const stopEventForFirefox = (_component, _simulatedEvent) => Optional.some(true);
			const schema$v = [
				defaulted("execute", defaultExecute),
				defaulted("useSpace", false),
				defaulted("useEnter", true),
				defaulted("useControlEnter", false),
				defaulted("useDown", false)
			];
			const execute$4 = (component, simulatedEvent, executeConfig) => executeConfig.execute(component, simulatedEvent, component.element);
			const getKeydownRules$5 = (component, _simulatedEvent, executeConfig, _executeState) => {
				const spaceExec = executeConfig.useSpace && !inside(component.element) ? SPACE : [];
				const enterExec = executeConfig.useEnter ? ENTER : [];
				const downExec = executeConfig.useDown ? DOWN : [];
				return [rule(inSet(spaceExec.concat(enterExec).concat(downExec)), execute$4)].concat(executeConfig.useControlEnter ? [rule(and([isControl, inSet(ENTER)]), execute$4)] : []);
			};
			const getKeyupRules$5 = (component, _simulatedEvent, executeConfig, _executeState) => executeConfig.useSpace && !inside(component.element) ? [rule(inSet(SPACE), stopEventForFirefox)] : [];
			var ExecutionType = typical(schema$v, NoState.init, getKeydownRules$5, getKeyupRules$5, () => Optional.none());
			const flatgrid$1 = () => {
				const dimensions = value$2();
				const setGridSize = (numRows, numColumns) => {
					dimensions.set({
						numRows,
						numColumns
					});
				};
				const getNumRows = () => dimensions.get().map((d) => d.numRows);
				const getNumColumns = () => dimensions.get().map((d) => d.numColumns);
				return nu$8({
					readState: () => dimensions.get().map((d) => ({
						numRows: String(d.numRows),
						numColumns: String(d.numColumns)
					})).getOr({
						numRows: "?",
						numColumns: "?"
					}),
					setGridSize,
					getNumRows,
					getNumColumns
				});
			};
			const init$d = (spec) => spec.state(spec);
			var KeyingState = /* @__PURE__ */ Object.freeze({
				__proto__: null,
				flatgrid: flatgrid$1,
				init: init$d
			});
			const useH = (movement) => (component, simulatedEvent, config$1, state) => {
				return use(movement(component.element), component, simulatedEvent, config$1, state);
			};
			const west$1 = (moveLeft$4, moveRight$4) => {
				return useH(onDirection(moveLeft$4, moveRight$4));
			};
			const east$1 = (moveLeft$4, moveRight$4) => {
				return useH(onDirection(moveRight$4, moveLeft$4));
			};
			const useV = (move$2) => (component, simulatedEvent, config$1, state) => use(move$2, component, simulatedEvent, config$1, state);
			const use = (move$2, component, simulatedEvent, config$1, state) => {
				return config$1.focusManager.get(component).bind((focused) => move$2(component.element, focused, config$1, state)).map((newFocus) => {
					config$1.focusManager.set(component, newFocus);
					return true;
				});
			};
			const north$1 = useV;
			const south$1 = useV;
			const move$1 = useV;
			const isHidden$1 = (dom$3) => dom$3.offsetWidth <= 0 && dom$3.offsetHeight <= 0;
			const isVisible = (element$1) => !isHidden$1(element$1.dom);
			const locate = (candidates, predicate) => findIndex$1(candidates, predicate).map((index) => ({
				index,
				candidates
			}));
			const locateVisible = (container, current, selector) => {
				const predicate = (x) => eq(x, current);
				return locate(filter$2(descendants(container, selector), isVisible), predicate);
			};
			const findIndex = (elements, target) => findIndex$1(elements, (elem) => eq(target, elem));
			const withGrid = (values$1, index, numCols, f$1) => {
				return f$1(Math.floor(index / numCols), index % numCols).bind((address) => {
					const newIndex = address.row * numCols + address.column;
					return newIndex >= 0 && newIndex < values$1.length ? Optional.some(values$1[newIndex]) : Optional.none();
				});
			};
			const cycleHorizontal$1 = (values$1, index, numRows, numCols, delta) => withGrid(values$1, index, numCols, (oldRow, oldColumn) => {
				const newColumn = cycleBy(oldColumn, delta, 0, (oldRow === numRows - 1 ? values$1.length - oldRow * numCols : numCols) - 1);
				return Optional.some({
					row: oldRow,
					column: newColumn
				});
			});
			const cycleVertical$1 = (values$1, index, numRows, numCols, delta) => withGrid(values$1, index, numCols, (oldRow, oldColumn) => {
				const newRow = cycleBy(oldRow, delta, 0, numRows - 1);
				const newCol = clamp(oldColumn, 0, (newRow === numRows - 1 ? values$1.length - newRow * numCols : numCols) - 1);
				return Optional.some({
					row: newRow,
					column: newCol
				});
			});
			const cycleRight$1 = (values$1, index, numRows, numCols) => cycleHorizontal$1(values$1, index, numRows, numCols, 1);
			const cycleLeft$1 = (values$1, index, numRows, numCols) => cycleHorizontal$1(values$1, index, numRows, numCols, -1);
			const cycleUp$1 = (values$1, index, numRows, numCols) => cycleVertical$1(values$1, index, numRows, numCols, -1);
			const cycleDown$1 = (values$1, index, numRows, numCols) => cycleVertical$1(values$1, index, numRows, numCols, 1);
			const schema$u = [
				required$1("selector"),
				defaulted("execute", defaultExecute),
				onKeyboardHandler("onEscape"),
				defaulted("captureTab", false),
				initSize()
			];
			const focusIn$3 = (component, gridConfig, _gridState) => {
				descendant(component.element, gridConfig.selector).each((first$1) => {
					gridConfig.focusManager.set(component, first$1);
				});
			};
			const findCurrent$1 = (component, gridConfig) => gridConfig.focusManager.get(component).bind((elem) => closest$1(elem, gridConfig.selector));
			const execute$3 = (component, simulatedEvent, gridConfig, _gridState) => findCurrent$1(component, gridConfig).bind((focused) => gridConfig.execute(component, simulatedEvent, focused));
			const doMove$2 = (cycle) => (element$1, focused, gridConfig, gridState) => locateVisible(element$1, focused, gridConfig.selector).bind((identified) => cycle(identified.candidates, identified.index, gridState.getNumRows().getOr(gridConfig.initSize.numRows), gridState.getNumColumns().getOr(gridConfig.initSize.numColumns)));
			const handleTab = (_component, _simulatedEvent, gridConfig) => gridConfig.captureTab ? Optional.some(true) : Optional.none();
			const doEscape$1 = (component, simulatedEvent, gridConfig) => gridConfig.onEscape(component, simulatedEvent);
			const moveLeft$3 = doMove$2(cycleLeft$1);
			const moveRight$3 = doMove$2(cycleRight$1);
			const moveNorth$1 = doMove$2(cycleUp$1);
			const moveSouth$1 = doMove$2(cycleDown$1);
			var FlatgridType = typical(schema$u, flatgrid$1, constant$1([
				rule(inSet(LEFT), west$1(moveLeft$3, moveRight$3)),
				rule(inSet(RIGHT), east$1(moveLeft$3, moveRight$3)),
				rule(inSet(UP), north$1(moveNorth$1)),
				rule(inSet(DOWN), south$1(moveSouth$1)),
				rule(and([isShift, inSet(TAB)]), handleTab),
				rule(and([isNotShift, inSet(TAB)]), handleTab),
				rule(inSet(SPACE.concat(ENTER)), execute$3)
			]), constant$1([rule(inSet(ESCAPE), doEscape$1), rule(inSet(SPACE), stopEventForFirefox)]), () => Optional.some(focusIn$3));
			const f = (container, selector, current, delta, getNewIndex) => {
				const isDisabledButton = (candidate) => name$3(candidate) === "button" && get$f(candidate, "disabled") === "disabled";
				const tryNewIndex = (initial, index, candidates) => getNewIndex(initial, index, delta, 0, candidates.length - 1, candidates[index], (newIndex) => isDisabledButton(candidates[newIndex]) ? tryNewIndex(initial, newIndex, candidates) : Optional.from(candidates[newIndex]));
				return locateVisible(container, current, selector).bind((identified) => {
					const index = identified.index;
					const candidates = identified.candidates;
					return tryNewIndex(index, index, candidates);
				});
			};
			const horizontalWithoutCycles = (container, selector, current, delta) => f(container, selector, current, delta, (prevIndex, v, d, min$1, max$1, oldCandidate, onNewIndex) => {
				const newIndex = clamp(v + d, min$1, max$1);
				return newIndex === prevIndex ? Optional.from(oldCandidate) : onNewIndex(newIndex);
			});
			const horizontal = (container, selector, current, delta) => f(container, selector, current, delta, (prevIndex, v, d, min$1, max$1, _oldCandidate, onNewIndex) => {
				const newIndex = cycleBy(v, d, min$1, max$1);
				return newIndex === prevIndex ? Optional.none() : onNewIndex(newIndex);
			});
			const schema$t = [
				required$1("selector"),
				defaulted("getInitial", Optional.none),
				defaulted("execute", defaultExecute),
				onKeyboardHandler("onEscape"),
				defaulted("executeOnMove", false),
				defaulted("allowVertical", true),
				defaulted("allowHorizontal", true),
				defaulted("cycles", true)
			];
			const findCurrent = (component, flowConfig) => flowConfig.focusManager.get(component).bind((elem) => closest$1(elem, flowConfig.selector));
			const execute$2 = (component, simulatedEvent, flowConfig) => findCurrent(component, flowConfig).bind((focused) => flowConfig.execute(component, simulatedEvent, focused));
			const focusIn$2 = (component, flowConfig, _state) => {
				flowConfig.getInitial(component).orThunk(() => descendant(component.element, flowConfig.selector)).each((first$1) => {
					flowConfig.focusManager.set(component, first$1);
				});
			};
			const moveLeft$2 = (element$1, focused, info) => (info.cycles ? horizontal : horizontalWithoutCycles)(element$1, info.selector, focused, -1);
			const moveRight$2 = (element$1, focused, info) => (info.cycles ? horizontal : horizontalWithoutCycles)(element$1, info.selector, focused, 1);
			const doMove$1 = (movement) => (component, simulatedEvent, flowConfig, flowState) => movement(component, simulatedEvent, flowConfig, flowState).bind(() => flowConfig.executeOnMove ? execute$2(component, simulatedEvent, flowConfig) : Optional.some(true));
			const doEscape = (component, simulatedEvent, flowConfig) => flowConfig.onEscape(component, simulatedEvent);
			const getKeydownRules$3 = (_component, _se, flowConfig, _flowState) => {
				const westMovers = [...flowConfig.allowHorizontal ? LEFT : []].concat(flowConfig.allowVertical ? UP : []);
				const eastMovers = [...flowConfig.allowHorizontal ? RIGHT : []].concat(flowConfig.allowVertical ? DOWN : []);
				return [
					rule(inSet(westMovers), doMove$1(west$1(moveLeft$2, moveRight$2))),
					rule(inSet(eastMovers), doMove$1(east$1(moveLeft$2, moveRight$2))),
					rule(inSet(ENTER), execute$2),
					rule(inSet(SPACE), execute$2)
				];
			};
			const getKeyupRules$3 = constant$1([rule(inSet(SPACE), stopEventForFirefox), rule(inSet(ESCAPE), doEscape)]);
			var FlowType = typical(schema$t, NoState.init, getKeydownRules$3, getKeyupRules$3, () => Optional.some(focusIn$2));
			const toCell = (matrix$1, rowIndex, columnIndex) => Optional.from(matrix$1[rowIndex]).bind((row) => Optional.from(row[columnIndex]).map((cell) => ({
				rowIndex,
				columnIndex,
				cell
			})));
			const cycleHorizontal = (matrix$1, rowIndex, startCol, deltaCol) => {
				const colsInRow = matrix$1[rowIndex].length;
				return toCell(matrix$1, rowIndex, cycleBy(startCol, deltaCol, 0, colsInRow - 1));
			};
			const cycleVertical = (matrix$1, colIndex, startRow, deltaRow) => {
				const nextRowIndex = cycleBy(startRow, deltaRow, 0, matrix$1.length - 1);
				const colsInNextRow = matrix$1[nextRowIndex].length;
				return toCell(matrix$1, nextRowIndex, clamp(colIndex, 0, colsInNextRow - 1));
			};
			const moveHorizontal = (matrix$1, rowIndex, startCol, deltaCol) => {
				const colsInRow = matrix$1[rowIndex].length;
				return toCell(matrix$1, rowIndex, clamp(startCol + deltaCol, 0, colsInRow - 1));
			};
			const moveVertical = (matrix$1, colIndex, startRow, deltaRow) => {
				const nextRowIndex = clamp(startRow + deltaRow, 0, matrix$1.length - 1);
				const colsInNextRow = matrix$1[nextRowIndex].length;
				return toCell(matrix$1, nextRowIndex, clamp(colIndex, 0, colsInNextRow - 1));
			};
			const cycleRight = (matrix$1, startRow, startCol) => cycleHorizontal(matrix$1, startRow, startCol, 1);
			const cycleLeft = (matrix$1, startRow, startCol) => cycleHorizontal(matrix$1, startRow, startCol, -1);
			const cycleUp = (matrix$1, startRow, startCol) => cycleVertical(matrix$1, startCol, startRow, -1);
			const cycleDown = (matrix$1, startRow, startCol) => cycleVertical(matrix$1, startCol, startRow, 1);
			const moveLeft$1 = (matrix$1, startRow, startCol) => moveHorizontal(matrix$1, startRow, startCol, -1);
			const moveRight$1 = (matrix$1, startRow, startCol) => moveHorizontal(matrix$1, startRow, startCol, 1);
			const moveUp$1 = (matrix$1, startRow, startCol) => moveVertical(matrix$1, startCol, startRow, -1);
			const moveDown$1 = (matrix$1, startRow, startCol) => moveVertical(matrix$1, startCol, startRow, 1);
			const schema$s = [
				requiredObjOf("selectors", [required$1("row"), required$1("cell")]),
				defaulted("cycles", true),
				defaulted("previousSelector", Optional.none),
				defaulted("execute", defaultExecute)
			];
			const focusIn$1 = (component, matrixConfig, _state) => {
				matrixConfig.previousSelector(component).orThunk(() => {
					const selectors = matrixConfig.selectors;
					return descendant(component.element, selectors.cell);
				}).each((cell) => {
					matrixConfig.focusManager.set(component, cell);
				});
			};
			const execute$1 = (component, simulatedEvent, matrixConfig) => search(component.element).bind((focused) => matrixConfig.execute(component, simulatedEvent, focused));
			const toMatrix = (rows, matrixConfig) => map$2(rows, (row) => descendants(row, matrixConfig.selectors.cell));
			const doMove = (ifCycle, ifMove) => (element$1, focused, matrixConfig) => {
				const move$2 = matrixConfig.cycles ? ifCycle : ifMove;
				return closest$1(focused, matrixConfig.selectors.row).bind((inRow) => {
					return findIndex(descendants(inRow, matrixConfig.selectors.cell), focused).bind((colIndex) => {
						const allRows = descendants(element$1, matrixConfig.selectors.row);
						return findIndex(allRows, inRow).bind((rowIndex) => {
							return move$2(toMatrix(allRows, matrixConfig), rowIndex, colIndex).map((next) => next.cell);
						});
					});
				});
			};
			const moveLeft = doMove(cycleLeft, moveLeft$1);
			const moveRight = doMove(cycleRight, moveRight$1);
			const moveNorth = doMove(cycleUp, moveUp$1);
			const moveSouth = doMove(cycleDown, moveDown$1);
			const getKeydownRules$2 = constant$1([
				rule(inSet(LEFT), west$1(moveLeft, moveRight)),
				rule(inSet(RIGHT), east$1(moveLeft, moveRight)),
				rule(inSet(UP), north$1(moveNorth)),
				rule(inSet(DOWN), south$1(moveSouth)),
				rule(inSet(SPACE.concat(ENTER)), execute$1)
			]);
			const getKeyupRules$2 = constant$1([rule(inSet(SPACE), stopEventForFirefox)]);
			var MatrixType = typical(schema$s, NoState.init, getKeydownRules$2, getKeyupRules$2, () => Optional.some(focusIn$1));
			const schema$r = [
				required$1("selector"),
				defaulted("execute", defaultExecute),
				defaulted("moveOnTab", false)
			];
			const execute = (component, simulatedEvent, menuConfig) => menuConfig.focusManager.get(component).bind((focused) => menuConfig.execute(component, simulatedEvent, focused));
			const focusIn = (component, menuConfig, _state) => {
				descendant(component.element, menuConfig.selector).each((first$1) => {
					menuConfig.focusManager.set(component, first$1);
				});
			};
			const moveUp = (element$1, focused, info) => horizontal(element$1, info.selector, focused, -1);
			const moveDown = (element$1, focused, info) => horizontal(element$1, info.selector, focused, 1);
			const fireShiftTab = (component, simulatedEvent, menuConfig, menuState) => menuConfig.moveOnTab ? move$1(moveUp)(component, simulatedEvent, menuConfig, menuState) : Optional.none();
			const fireTab = (component, simulatedEvent, menuConfig, menuState) => menuConfig.moveOnTab ? move$1(moveDown)(component, simulatedEvent, menuConfig, menuState) : Optional.none();
			const getKeydownRules$1 = constant$1([
				rule(inSet(UP), move$1(moveUp)),
				rule(inSet(DOWN), move$1(moveDown)),
				rule(and([isShift, inSet(TAB)]), fireShiftTab),
				rule(and([isNotShift, inSet(TAB)]), fireTab),
				rule(inSet(ENTER), execute),
				rule(inSet(SPACE), execute)
			]);
			const getKeyupRules$1 = constant$1([rule(inSet(SPACE), stopEventForFirefox)]);
			var MenuType = typical(schema$r, NoState.init, getKeydownRules$1, getKeyupRules$1, () => Optional.some(focusIn));
			const schema$q = [
				onKeyboardHandler("onSpace"),
				onKeyboardHandler("onEnter"),
				onKeyboardHandler("onShiftEnter"),
				onKeyboardHandler("onLeft"),
				onKeyboardHandler("onRight"),
				onKeyboardHandler("onTab"),
				onKeyboardHandler("onShiftTab"),
				onKeyboardHandler("onUp"),
				onKeyboardHandler("onDown"),
				onKeyboardHandler("onEscape"),
				defaulted("stopSpaceKeyup", false),
				option$3("focusIn")
			];
			const getKeydownRules = (component, simulatedEvent, specialInfo) => [
				rule(inSet(SPACE), specialInfo.onSpace),
				rule(and([isNotShift, inSet(ENTER)]), specialInfo.onEnter),
				rule(and([isShift, inSet(ENTER)]), specialInfo.onShiftEnter),
				rule(and([isShift, inSet(TAB)]), specialInfo.onShiftTab),
				rule(and([isNotShift, inSet(TAB)]), specialInfo.onTab),
				rule(inSet(UP), specialInfo.onUp),
				rule(inSet(DOWN), specialInfo.onDown),
				rule(inSet(LEFT), specialInfo.onLeft),
				rule(inSet(RIGHT), specialInfo.onRight),
				rule(inSet(SPACE), specialInfo.onSpace)
			];
			const getKeyupRules = (component, simulatedEvent, specialInfo) => [...specialInfo.stopSpaceKeyup ? [rule(inSet(SPACE), stopEventForFirefox)] : [], rule(inSet(ESCAPE), specialInfo.onEscape)];
			var SpecialType = typical(schema$q, NoState.init, getKeydownRules, getKeyupRules, (specialInfo) => specialInfo.focusIn);
			const acyclic = AcyclicType.schema();
			const cyclic = CyclicType.schema();
			const flow = FlowType.schema();
			const flatgrid = FlatgridType.schema();
			const matrix = MatrixType.schema();
			const execution = ExecutionType.schema();
			const menu = MenuType.schema();
			const special = SpecialType.schema();
			var KeyboardBranches = /* @__PURE__ */ Object.freeze({
				__proto__: null,
				acyclic,
				cyclic,
				flow,
				flatgrid,
				matrix,
				execution,
				menu,
				special
			});
			const isFlatgridState = (keyState) => hasNonNullableKey(keyState, "setGridSize");
			const Keying = createModes({
				branchKey: "mode",
				branches: KeyboardBranches,
				name: "keying",
				active: { events: (keyingConfig, keyingState) => {
					return keyingConfig.handler.toEvents(keyingConfig, keyingState);
				} },
				apis: {
					focusIn: (component, keyConfig, keyState) => {
						keyConfig.sendFocusIn(keyConfig).fold(() => {
							component.getSystem().triggerFocus(component.element, component.element);
						}, (sendFocusIn) => {
							sendFocusIn(component, keyConfig, keyState);
						});
					},
					setGridSize: (component, keyConfig, keyState, numRows, numColumns) => {
						if (!isFlatgridState(keyState)) console.error("Layout does not support setGridSize");
						else keyState.setGridSize(numRows, numColumns);
					}
				},
				state: KeyingState
			});
			const withoutReuse = (parent$1, data) => {
				preserve$1(() => {
					replaceChildren(parent$1, data, () => map$2(data, parent$1.getSystem().build));
				}, parent$1.element);
			};
			const withReuse = (parent$1, data) => {
				preserve$1(() => {
					virtualReplaceChildren(parent$1, data, () => {
						return patchSpecChildren(parent$1.element, data, parent$1.getSystem().buildOrPatch);
					});
				}, parent$1.element);
			};
			const virtualReplace = (component, replacee, replaceeIndex, childSpec) => {
				virtualDetach(replacee);
				virtualAttach(component, patchSpecChild(component.element, replaceeIndex, childSpec, component.getSystem().buildOrPatch));
				component.syncComponents();
			};
			const insert = (component, insertion, childSpec) => {
				attachWith(component, component.getSystem().build(childSpec), insertion);
			};
			const replace = (component, replacee, replaceeIndex, childSpec) => {
				detach(replacee);
				insert(component, (p, c) => appendAt(p, c, replaceeIndex), childSpec);
			};
			const set$3 = (component, replaceConfig, replaceState, data) => {
				return (replaceConfig.reuseDom ? withReuse : withoutReuse)(component, data);
			};
			const append = (component, replaceConfig, replaceState, appendee) => {
				insert(component, append$2, appendee);
			};
			const prepend = (component, replaceConfig, replaceState, prependee) => {
				insert(component, prepend$1, prependee);
			};
			const remove = (component, replaceConfig, replaceState, removee) => {
				find$5(contents(component), (child$3) => eq(removee.element, child$3.element)).each(detach);
			};
			const contents = (component, _replaceConfig) => component.components();
			const replaceAt = (component, replaceConfig, replaceState, replaceeIndex, replacer) => {
				const children$1 = contents(component);
				return Optional.from(children$1[replaceeIndex]).map((replacee) => {
					replacer.fold(() => detach(replacee), (r$2) => {
						(replaceConfig.reuseDom ? virtualReplace : replace)(component, replacee, replaceeIndex, r$2);
					});
					return replacee;
				});
			};
			const replaceBy = (component, replaceConfig, replaceState, replaceePred, replacer) => {
				return findIndex$1(contents(component), replaceePred).bind((replaceeIndex) => replaceAt(component, replaceConfig, replaceState, replaceeIndex, replacer));
			};
			var ReplaceApis = /* @__PURE__ */ Object.freeze({
				__proto__: null,
				append,
				prepend,
				remove,
				replaceAt,
				replaceBy,
				set: set$3,
				contents
			});
			const Replacing = create$4({
				fields: [defaultedBoolean("reuseDom", true)],
				name: "replacing",
				apis: ReplaceApis
			});
			const events$d = (name$4, eventHandlers) => {
				const events$10 = derive$2(eventHandlers);
				return create$4({
					fields: [required$1("enabled")],
					name: name$4,
					active: { events: constant$1(events$10) }
				});
			};
			const config = (name$4, eventHandlers) => {
				return {
					key: name$4,
					value: {
						config: {},
						me: events$d(name$4, eventHandlers),
						configAsRaw: constant$1({}),
						initialConfig: {},
						state: NoState
					}
				};
			};
			const focus$2 = (component, focusConfig) => {
				if (!focusConfig.ignore) {
					focus$3(component.element);
					focusConfig.onFocus(component);
				}
			};
			const blur = (component, focusConfig) => {
				if (!focusConfig.ignore) blur$1(component.element);
			};
			const isFocused = (component) => hasFocus(component.element);
			var FocusApis = /* @__PURE__ */ Object.freeze({
				__proto__: null,
				focus: focus$2,
				blur,
				isFocused
			});
			const exhibit$4 = (base$1, focusConfig) => {
				return nu$7(focusConfig.ignore ? {} : { attributes: { tabindex: "-1" } });
			};
			const events$c = (focusConfig) => derive$2([run$1(focus$4(), (component, simulatedEvent) => {
				focus$2(component, focusConfig);
				simulatedEvent.stop();
			})].concat(focusConfig.stopMousedown ? [run$1(mousedown(), (_, simulatedEvent) => {
				simulatedEvent.event.prevent();
			})] : []));
			var ActiveFocus = /* @__PURE__ */ Object.freeze({
				__proto__: null,
				exhibit: exhibit$4,
				events: events$c
			});
			const Focusing = create$4({
				fields: [
					onHandler("onFocus"),
					defaulted("stopMousedown", false),
					defaulted("ignore", false)
				],
				name: "focusing",
				active: ActiveFocus,
				apis: FocusApis
			});
			const SetupBehaviourCellState = (initialState) => {
				const init$10 = () => {
					const cell = Cell(initialState);
					const get$10 = () => cell.get();
					const set$10 = (newState) => cell.set(newState);
					const clear$1 = () => cell.set(initialState);
					const readState = () => cell.get();
					return {
						get: get$10,
						set: set$10,
						clear: clear$1,
						readState
					};
				};
				return { init: init$10 };
			};
			const updateAriaState = (component, toggleConfig, toggleState) => {
				const ariaInfo = toggleConfig.aria;
				ariaInfo.update(component, ariaInfo, toggleState.get());
			};
			const updateClass = (component, toggleConfig, toggleState) => {
				toggleConfig.toggleClass.each((toggleClass) => {
					if (toggleState.get()) add$2(component.element, toggleClass);
					else remove$2(component.element, toggleClass);
				});
			};
			const set$2 = (component, toggleConfig, toggleState, state) => {
				const initialState = toggleState.get();
				toggleState.set(state);
				updateClass(component, toggleConfig, toggleState);
				updateAriaState(component, toggleConfig, toggleState);
				if (initialState !== state) toggleConfig.onToggled(component, state);
			};
			const toggle$2 = (component, toggleConfig, toggleState) => {
				set$2(component, toggleConfig, toggleState, !toggleState.get());
			};
			const on = (component, toggleConfig, toggleState) => {
				set$2(component, toggleConfig, toggleState, true);
			};
			const off = (component, toggleConfig, toggleState) => {
				set$2(component, toggleConfig, toggleState, false);
			};
			const isOn = (component, toggleConfig, toggleState) => toggleState.get();
			const onLoad = (component, toggleConfig, toggleState) => {
				set$2(component, toggleConfig, toggleState, toggleConfig.selected);
			};
			var ToggleApis = /* @__PURE__ */ Object.freeze({
				__proto__: null,
				onLoad,
				toggle: toggle$2,
				isOn,
				on,
				off,
				set: set$2
			});
			const exhibit$3 = () => nu$7({});
			const events$b = (toggleConfig, toggleState) => {
				const execute$6 = executeEvent(toggleConfig, toggleState, toggle$2);
				const load = loadEvent(toggleConfig, toggleState, onLoad);
				return derive$2(flatten([toggleConfig.toggleOnExecute ? [execute$6] : [], [load]]));
			};
			var ActiveToggle = /* @__PURE__ */ Object.freeze({
				__proto__: null,
				exhibit: exhibit$3,
				events: events$b
			});
			const updatePressed = (component, ariaInfo, status) => {
				set$9(component.element, "aria-pressed", status);
				if (ariaInfo.syncWithExpanded) updateExpanded(component, ariaInfo, status);
			};
			const updateSelected = (component, ariaInfo, status) => {
				set$9(component.element, "aria-selected", status);
			};
			const updateChecked = (component, ariaInfo, status) => {
				set$9(component.element, "aria-checked", status);
			};
			const updateExpanded = (component, ariaInfo, status) => {
				set$9(component.element, "aria-expanded", status);
			};
			const Toggling = create$4({
				fields: [
					defaulted("selected", false),
					option$3("toggleClass"),
					defaulted("toggleOnExecute", true),
					onHandler("onToggled"),
					defaultedOf("aria", { mode: "none" }, choose$1("mode", {
						pressed: [defaulted("syncWithExpanded", false), output$1("update", updatePressed)],
						checked: [output$1("update", updateChecked)],
						expanded: [output$1("update", updateExpanded)],
						selected: [output$1("update", updateSelected)],
						none: [output$1("update", noop)]
					}))
				],
				name: "toggling",
				active: ActiveToggle,
				apis: ToggleApis,
				state: SetupBehaviourCellState(false)
			});
			const pointerEvents = () => {
				const onClick = (component, simulatedEvent) => {
					simulatedEvent.stop();
					emitExecute(component);
				};
				return [
					run$1(click(), onClick),
					run$1(tap(), onClick),
					cutter(touchstart()),
					cutter(mousedown())
				];
			};
			const events$a = (optAction) => {
				const executeHandler = (action) => runOnExecute$1((component, simulatedEvent) => {
					action(component);
					simulatedEvent.stop();
				});
				return derive$2(flatten([optAction.map(executeHandler).toArray(), pointerEvents()]));
			};
			const hoverEvent = "alloy.item-hover";
			const focusEvent = "alloy.item-focus";
			const toggledEvent = "alloy.item-toggled";
			const onHover = (item$1) => {
				if (search(item$1.element).isNone() || Focusing.isFocused(item$1)) {
					if (!Focusing.isFocused(item$1)) Focusing.focus(item$1);
					emitWith(item$1, hoverEvent, { item: item$1 });
				}
			};
			const onFocus$1 = (item$1) => {
				emitWith(item$1, focusEvent, { item: item$1 });
			};
			const onToggled = (item$1, state) => {
				emitWith(item$1, toggledEvent, {
					item: item$1,
					state
				});
			};
			const hover = constant$1(hoverEvent);
			const focus$1 = constant$1(focusEvent);
			const toggled = constant$1(toggledEvent);
			const getItemRole = (detail) => detail.toggling.map((toggling) => toggling.exclusive ? "menuitemradio" : "menuitemcheckbox").getOr("menuitem");
			const getTogglingSpec = (tConfig) => ({
				aria: { mode: "checked" },
				...filter$1(tConfig, (_value, name$4) => name$4 !== "exclusive"),
				onToggled: (component, state) => {
					if (isFunction(tConfig.onToggled)) tConfig.onToggled(component, state);
					onToggled(component, state);
				}
			});
			const builder$2 = (detail) => ({
				dom: detail.dom,
				domModification: {
					...detail.domModification,
					attributes: {
						"role": getItemRole(detail),
						...detail.domModification.attributes,
						"aria-haspopup": detail.hasSubmenu,
						...detail.hasSubmenu ? { "aria-expanded": false } : {}
					}
				},
				behaviours: SketchBehaviours.augment(detail.itemBehaviours, [
					detail.toggling.fold(Toggling.revoke, (tConfig) => Toggling.config(getTogglingSpec(tConfig))),
					Focusing.config({
						ignore: detail.ignoreFocus,
						stopMousedown: detail.ignoreFocus,
						onFocus: (component) => {
							onFocus$1(component);
						}
					}),
					Keying.config({ mode: "execution" }),
					Representing.config({ store: {
						mode: "memory",
						initialValue: detail.data
					} }),
					config("item-type-events", [
						...pointerEvents(),
						run$1(mouseover(), onHover),
						run$1(focusItem(), Focusing.focus)
					])
				]),
				components: detail.components,
				eventOrder: detail.eventOrder
			});
			const schema$p = [
				required$1("data"),
				required$1("components"),
				required$1("dom"),
				defaulted("hasSubmenu", false),
				option$3("toggling"),
				SketchBehaviours.field("itemBehaviours", [
					Toggling,
					Focusing,
					Keying,
					Representing
				]),
				defaulted("ignoreFocus", false),
				defaulted("domModification", {}),
				output$1("builder", builder$2),
				defaulted("eventOrder", {})
			];
			const builder$1 = (detail) => ({
				dom: detail.dom,
				components: detail.components,
				events: derive$2([stopper(focusItem())])
			});
			const schema$o = [
				required$1("dom"),
				required$1("components"),
				output$1("builder", builder$1)
			];
			const owner$2 = constant$1("item-widget");
			const parts$h = constant$1([required({
				name: "widget",
				overrides: (detail) => {
					return { behaviours: derive$1([Representing.config({ store: {
						mode: "manual",
						getValue: (_component) => {
							return detail.data;
						},
						setValue: noop
					} })]) };
				}
			})]);
			const builder = (detail) => {
				const subs$1 = substitutes(owner$2(), detail, parts$h());
				const components$2 = components$1(owner$2(), detail, subs$1.internals());
				const focusWidget = (component) => getPart(component, detail, "widget").map((widget) => {
					Keying.focusIn(widget);
					return widget;
				});
				const onHorizontalArrow = (component, simulatedEvent) => inside(simulatedEvent.event.target) ? Optional.none() : (() => {
					if (detail.autofocus) {
						simulatedEvent.setSource(component.element);
						return Optional.none();
					} else return Optional.none();
				})();
				return {
					dom: detail.dom,
					components: components$2,
					domModification: detail.domModification,
					events: derive$2([
						runOnExecute$1((component, simulatedEvent) => {
							focusWidget(component).each((_widget) => {
								simulatedEvent.stop();
							});
						}),
						run$1(mouseover(), onHover),
						run$1(focusItem(), (component, _simulatedEvent) => {
							if (detail.autofocus) focusWidget(component);
							else Focusing.focus(component);
						})
					]),
					behaviours: SketchBehaviours.augment(detail.widgetBehaviours, [
						Representing.config({ store: {
							mode: "memory",
							initialValue: detail.data
						} }),
						Focusing.config({
							ignore: detail.ignoreFocus,
							onFocus: (component) => {
								onFocus$1(component);
							}
						}),
						Keying.config({
							mode: "special",
							focusIn: detail.autofocus ? (component) => {
								focusWidget(component);
							} : revoke(),
							onLeft: onHorizontalArrow,
							onRight: onHorizontalArrow,
							onEscape: (component, simulatedEvent) => {
								if (!Focusing.isFocused(component) && !detail.autofocus) {
									Focusing.focus(component);
									return Optional.some(true);
								} else if (detail.autofocus) {
									simulatedEvent.setSource(component.element);
									return Optional.none();
								} else return Optional.none();
							}
						})
					])
				};
			};
			const itemSchema$2 = choose$1("type", {
				widget: [
					required$1("uid"),
					required$1("data"),
					required$1("components"),
					required$1("dom"),
					defaulted("autofocus", false),
					defaulted("ignoreFocus", false),
					SketchBehaviours.field("widgetBehaviours", [
						Representing,
						Focusing,
						Keying
					]),
					defaulted("domModification", {}),
					defaultUidsSchema(parts$h()),
					output$1("builder", builder)
				],
				item: schema$p,
				separator: schema$o
			});
			const configureGrid = (detail, movementInfo) => ({
				mode: "flatgrid",
				selector: "." + detail.markers.item,
				initSize: {
					numColumns: movementInfo.initSize.numColumns,
					numRows: movementInfo.initSize.numRows
				},
				focusManager: detail.focusManager
			});
			const configureMatrix = (detail, movementInfo) => ({
				mode: "matrix",
				selectors: {
					row: movementInfo.rowSelector,
					cell: "." + detail.markers.item
				},
				previousSelector: movementInfo.previousSelector,
				focusManager: detail.focusManager
			});
			const configureMenu = (detail, movementInfo) => ({
				mode: "menu",
				selector: "." + detail.markers.item,
				moveOnTab: movementInfo.moveOnTab,
				focusManager: detail.focusManager
			});
			const parts$g = constant$1([group({
				factory: { sketch: (spec) => {
					const itemInfo = asRawOrDie$1("menu.spec item", itemSchema$2, spec);
					return itemInfo.builder(itemInfo);
				} },
				name: "items",
				unit: "item",
				defaults: (detail, u) => {
					return has$2(u, "uid") ? u : {
						...u,
						uid: generate$5("item")
					};
				},
				overrides: (detail, u) => {
					return {
						type: u.type,
						ignoreFocus: detail.fakeFocus,
						domModification: { classes: [detail.markers.item] }
					};
				}
			})]);
			const schema$m = constant$1([
				required$1("value"),
				required$1("items"),
				required$1("dom"),
				required$1("components"),
				defaulted("eventOrder", {}),
				field("menuBehaviours", [
					Highlighting,
					Representing,
					Composing,
					Keying
				]),
				defaultedOf("movement", {
					mode: "menu",
					moveOnTab: true
				}, choose$1("mode", {
					grid: [initSize(), output$1("config", configureGrid)],
					matrix: [
						output$1("config", configureMatrix),
						required$1("rowSelector"),
						defaulted("previousSelector", Optional.none)
					],
					menu: [defaulted("moveOnTab", true), output$1("config", configureMenu)]
				})),
				itemMarkers(),
				defaulted("fakeFocus", false),
				defaulted("focusManager", dom$2()),
				onHandler("onHighlight"),
				onHandler("onDehighlight")
			]);
			const focus = constant$1("alloy.menu-focus");
			const deselectOtherRadioItems = (menu$1, item$1) => {
				each$1(descendants(menu$1.element, "[role=\"menuitemradio\"][aria-checked=\"true\"]"), (ele) => {
					if (!eq(ele, item$1.element)) menu$1.getSystem().getByDom(ele).each((c) => {
						Toggling.off(c);
					});
				});
			};
			const make$7 = (detail, components$2, _spec, _externals) => ({
				uid: detail.uid,
				dom: detail.dom,
				markers: detail.markers,
				behaviours: augment(detail.menuBehaviours, [
					Highlighting.config({
						highlightClass: detail.markers.selectedItem,
						itemClass: detail.markers.item,
						onHighlight: detail.onHighlight,
						onDehighlight: detail.onDehighlight
					}),
					Representing.config({ store: {
						mode: "memory",
						initialValue: detail.value
					} }),
					Composing.config({ find: Optional.some }),
					Keying.config(detail.movement.config(detail, detail.movement))
				]),
				events: derive$2([
					run$1(focus$1(), (menu$1, simulatedEvent) => {
						const event = simulatedEvent.event;
						menu$1.getSystem().getByDom(event.target).each((item$1) => {
							Highlighting.highlight(menu$1, item$1);
							simulatedEvent.stop();
							emitWith(menu$1, focus(), {
								menu: menu$1,
								item: item$1
							});
						});
					}),
					run$1(hover(), (menu$1, simulatedEvent) => {
						const item$1 = simulatedEvent.event.item;
						Highlighting.highlight(menu$1, item$1);
					}),
					run$1(toggled(), (menu$1, simulatedEvent) => {
						const { item: item$1, state } = simulatedEvent.event;
						if (state && get$f(item$1.element, "role") === "menuitemradio") deselectOtherRadioItems(menu$1, item$1);
					})
				]),
				components: components$2,
				eventOrder: detail.eventOrder,
				domModification: { attributes: { role: "menu" } }
			});
			const Menu = composite({
				name: "Menu",
				configFields: schema$m(),
				partFields: parts$g(),
				factory: make$7
			});
			const transpose$1 = (obj) => tupleMap(obj, (v, k) => ({
				k: v,
				v: k
			}));
			const trace = (items, byItem, byMenu, finish) => get$g(byMenu, finish).bind((triggerItem) => get$g(items, triggerItem).bind((triggerMenu) => {
				const rest = trace(items, byItem, byMenu, triggerMenu);
				return Optional.some([triggerMenu].concat(rest));
			})).getOr([]);
			const generate$2 = (menus, expansions) => {
				const items = {};
				each(menus, (menuItems, menu$1) => {
					each$1(menuItems, (item$1) => {
						items[item$1] = menu$1;
					});
				});
				const byItem = expansions;
				const byMenu = transpose$1(expansions);
				const menuPaths = map$1(byMenu, (_triggerItem, submenu) => [submenu].concat(trace(items, byItem, byMenu, submenu)));
				return map$1(items, (menu$1) => get$g(menuPaths, menu$1).getOr([menu$1]));
			};
			const init$c = () => {
				const expansions = Cell({});
				const menus = Cell({});
				const paths = Cell({});
				const primary$1 = value$2();
				const directory = Cell({});
				const clear$1 = () => {
					expansions.set({});
					menus.set({});
					paths.set({});
					primary$1.clear();
				};
				const isClear = () => primary$1.get().isNone();
				const setMenuBuilt = (menuName, built) => {
					menus.set({
						...menus.get(),
						[menuName]: {
							type: "prepared",
							menu: built
						}
					});
				};
				const setContents = (sPrimary, sMenus, sExpansions, dir) => {
					primary$1.set(sPrimary);
					expansions.set(sExpansions);
					menus.set(sMenus);
					directory.set(dir);
					const sPaths = generate$2(dir, sExpansions);
					paths.set(sPaths);
				};
				const getTriggeringItem = (menuValue) => find$4(expansions.get(), (v, _k) => v === menuValue);
				const getTriggerData = (menuValue, getItemByValue, path$2) => getPreparedMenu(menuValue).bind((menu$1) => getTriggeringItem(menuValue).bind((triggeringItemValue) => getItemByValue(triggeringItemValue).map((triggeredItem) => ({
					triggeredMenu: menu$1,
					triggeringItem: triggeredItem,
					triggeringPath: path$2
				}))));
				const getTriggeringPath = (itemValue, getItemByValue) => {
					const extraPath = filter$2(lookupItem(itemValue).toArray(), (menuValue) => getPreparedMenu(menuValue).isSome());
					return get$g(paths.get(), itemValue).bind((path$2) => {
						const revPath = reverse(extraPath.concat(path$2));
						return sequence(bind$3(revPath, (menuValue, menuIndex) => getTriggerData(menuValue, getItemByValue, revPath.slice(0, menuIndex + 1)).fold(() => is$1(primary$1.get(), menuValue) ? [] : [Optional.none()], (data) => [Optional.some(data)])));
					});
				};
				const expand$1 = (itemValue) => get$g(expansions.get(), itemValue).map((menu$1) => {
					const current = get$g(paths.get(), itemValue).getOr([]);
					return [menu$1].concat(current);
				});
				const collapse = (itemValue) => get$g(paths.get(), itemValue).bind((path$2) => path$2.length > 1 ? Optional.some(path$2.slice(1)) : Optional.none());
				const refresh$5 = (itemValue) => get$g(paths.get(), itemValue);
				const getPreparedMenu = (menuValue) => lookupMenu(menuValue).bind(extractPreparedMenu);
				const lookupMenu = (menuValue) => get$g(menus.get(), menuValue);
				const lookupItem = (itemValue) => get$g(expansions.get(), itemValue);
				const otherMenus = (path$2) => {
					return difference(keys(directory.get()), path$2);
				};
				const getPrimary = () => primary$1.get().bind(getPreparedMenu);
				const getMenus$1 = () => menus.get();
				return {
					setMenuBuilt,
					setContents,
					expand: expand$1,
					refresh: refresh$5,
					collapse,
					lookupMenu,
					lookupItem,
					otherMenus,
					getPrimary,
					getMenus: getMenus$1,
					clear: clear$1,
					isClear,
					getTriggeringPath
				};
			};
			const extractPreparedMenu = (prep) => prep.type === "prepared" ? Optional.some(prep.menu) : Optional.none();
			const LayeredState = {
				init: init$c,
				extractPreparedMenu
			};
			const onMenuItemHighlightedEvent = generate$6("tiered-menu-item-highlight");
			const onMenuItemDehighlightedEvent = generate$6("tiered-menu-item-dehighlight");
			var HighlightOnOpen;
			(function(HighlightOnOpen$1) {
				HighlightOnOpen$1[HighlightOnOpen$1["HighlightMenuAndItem"] = 0] = "HighlightMenuAndItem";
				HighlightOnOpen$1[HighlightOnOpen$1["HighlightJustMenu"] = 1] = "HighlightJustMenu";
				HighlightOnOpen$1[HighlightOnOpen$1["HighlightNone"] = 2] = "HighlightNone";
			})(HighlightOnOpen || (HighlightOnOpen = {}));
			const make$6 = (detail, _rawUiSpec) => {
				const submenuParentItems = value$2();
				const buildMenus = (container, primaryName, menus) => map$1(menus, (spec, name$4) => {
					const makeSketch = () => Menu.sketch({
						...spec,
						value: name$4,
						markers: detail.markers,
						fakeFocus: detail.fakeFocus,
						onHighlight: (menuComp, itemComp) => {
							emitWith(menuComp, onMenuItemHighlightedEvent, {
								menuComp,
								itemComp
							});
						},
						onDehighlight: (menuComp, itemComp) => {
							emitWith(menuComp, onMenuItemDehighlightedEvent, {
								menuComp,
								itemComp
							});
						},
						focusManager: detail.fakeFocus ? highlights() : dom$2()
					});
					return name$4 === primaryName ? {
						type: "prepared",
						menu: container.getSystem().build(makeSketch())
					} : {
						type: "notbuilt",
						nbMenu: makeSketch
					};
				});
				const layeredState = LayeredState.init();
				const setup$10 = (container) => {
					const componentMap = buildMenus(container, detail.data.primary, detail.data.menus);
					const directory = toDirectory();
					layeredState.setContents(detail.data.primary, componentMap, detail.data.expansions, directory);
					return layeredState.getPrimary();
				};
				const getItemValue = (item$1) => Representing.getValue(item$1).value;
				const getItemByValue = (_container, menus, itemValue) => findMap(menus, (menu$1) => {
					if (!menu$1.getSystem().isConnected()) return Optional.none();
					return find$5(Highlighting.getCandidates(menu$1), (c) => getItemValue(c) === itemValue);
				});
				const toDirectory = (_container) => map$1(detail.data.menus, (data, _menuName) => bind$3(data.items, (item$1) => item$1.type === "separator" ? [] : [item$1.data.value]));
				const setActiveMenu = Highlighting.highlight;
				const setActiveMenuAndItem = (container, menu$1) => {
					setActiveMenu(container, menu$1);
					Highlighting.getHighlighted(menu$1).orThunk(() => Highlighting.getFirst(menu$1)).each((item$1) => {
						if (detail.fakeFocus) Highlighting.highlight(menu$1, item$1);
						else dispatch(container, item$1.element, focusItem());
					});
				};
				const getMenus$1 = (state, menuValues) => cat(map$2(menuValues, (mv) => state.lookupMenu(mv).bind((prep) => prep.type === "prepared" ? Optional.some(prep.menu) : Optional.none())));
				const closeOthers = (container, state, path$2) => {
					each$1(getMenus$1(state, state.otherMenus(path$2)), (o) => {
						remove$1(o.element, [detail.markers.backgroundMenu]);
						if (!detail.stayInDom) Replacing.remove(container, o);
					});
				};
				const getSubmenuParents = (container) => submenuParentItems.get().getOrThunk(() => {
					const r$2 = {};
					each$1(filter$2(descendants(container.element, `.${detail.markers.item}`), (i) => get$f(i, "aria-haspopup") === "true"), (i) => {
						container.getSystem().getByDom(i).each((itemComp) => {
							const key = getItemValue(itemComp);
							r$2[key] = itemComp;
						});
					});
					submenuParentItems.set(r$2);
					return r$2;
				});
				const updateAriaExpansions = (container, path$2) => {
					each(getSubmenuParents(container), (v, k) => {
						const expanded = contains$2(path$2, k);
						set$9(v.element, "aria-expanded", expanded);
					});
				};
				const updateMenuPath = (container, state, path$2) => Optional.from(path$2[0]).bind((latestMenuName) => state.lookupMenu(latestMenuName).bind((menuPrep) => {
					if (menuPrep.type === "notbuilt") return Optional.none();
					else {
						const activeMenu = menuPrep.menu;
						each$1(getMenus$1(state, path$2.slice(1)), (r$2) => {
							add$2(r$2.element, detail.markers.backgroundMenu);
						});
						if (!inBody(activeMenu.element)) Replacing.append(container, premade(activeMenu));
						remove$1(activeMenu.element, [detail.markers.backgroundMenu]);
						setActiveMenuAndItem(container, activeMenu);
						closeOthers(container, state, path$2);
						return Optional.some(activeMenu);
					}
				}));
				let ExpandHighlightDecision;
				(function(ExpandHighlightDecision$1) {
					ExpandHighlightDecision$1[ExpandHighlightDecision$1["HighlightSubmenu"] = 0] = "HighlightSubmenu";
					ExpandHighlightDecision$1[ExpandHighlightDecision$1["HighlightParent"] = 1] = "HighlightParent";
				})(ExpandHighlightDecision || (ExpandHighlightDecision = {}));
				const buildIfRequired = (container, menuName, menuPrep) => {
					if (menuPrep.type === "notbuilt") {
						const menu$1 = container.getSystem().build(menuPrep.nbMenu());
						layeredState.setMenuBuilt(menuName, menu$1);
						return menu$1;
					} else return menuPrep.menu;
				};
				const expandRight = (container, item$1, decision = ExpandHighlightDecision.HighlightSubmenu) => {
					if (item$1.hasConfigured(Disabling) && Disabling.isDisabled(item$1)) return Optional.some(item$1);
					else {
						const value$5 = getItemValue(item$1);
						return layeredState.expand(value$5).bind((path$2) => {
							updateAriaExpansions(container, path$2);
							return Optional.from(path$2[0]).bind((menuName) => layeredState.lookupMenu(menuName).bind((activeMenuPrep) => {
								const activeMenu = buildIfRequired(container, menuName, activeMenuPrep);
								if (!inBody(activeMenu.element)) Replacing.append(container, premade(activeMenu));
								detail.onOpenSubmenu(container, item$1, activeMenu, reverse(path$2));
								if (decision === ExpandHighlightDecision.HighlightSubmenu) {
									Highlighting.highlightFirst(activeMenu);
									return updateMenuPath(container, layeredState, path$2);
								} else {
									Highlighting.dehighlightAll(activeMenu);
									return Optional.some(item$1);
								}
							}));
						});
					}
				};
				const collapseLeft = (container, item$1) => {
					const value$5 = getItemValue(item$1);
					return layeredState.collapse(value$5).bind((path$2) => {
						updateAriaExpansions(container, path$2);
						return updateMenuPath(container, layeredState, path$2).map((activeMenu) => {
							detail.onCollapseMenu(container, item$1, activeMenu);
							return activeMenu;
						});
					});
				};
				const updateView = (container, item$1) => {
					const value$5 = getItemValue(item$1);
					return layeredState.refresh(value$5).bind((path$2) => {
						updateAriaExpansions(container, path$2);
						return updateMenuPath(container, layeredState, path$2);
					});
				};
				const onRight$3 = (container, item$1) => inside(item$1.element) ? Optional.none() : expandRight(container, item$1, ExpandHighlightDecision.HighlightSubmenu);
				const onLeft$3 = (container, item$1) => inside(item$1.element) ? Optional.none() : collapseLeft(container, item$1);
				const onEscape = (container, item$1) => collapseLeft(container, item$1).orThunk(() => detail.onEscape(container, item$1).map(() => container));
				const keyOnItem = (f$1) => (container, simulatedEvent) => {
					return closest$1(simulatedEvent.getSource(), `.${detail.markers.item}`).bind((target) => container.getSystem().getByDom(target).toOptional().bind((item$1) => f$1(container, item$1).map(always)));
				};
				const events$10 = derive$2([
					run$1(focus(), (tmenu, simulatedEvent) => {
						const item$1 = simulatedEvent.event.item;
						layeredState.lookupItem(getItemValue(item$1)).each(() => {
							const menu$1 = simulatedEvent.event.menu;
							Highlighting.highlight(tmenu, menu$1);
							const value$5 = getItemValue(simulatedEvent.event.item);
							layeredState.refresh(value$5).each((path$2) => closeOthers(tmenu, layeredState, path$2));
						});
					}),
					runOnExecute$1((component, simulatedEvent) => {
						const target = simulatedEvent.event.target;
						component.getSystem().getByDom(target).each((item$1) => {
							if (getItemValue(item$1).indexOf("collapse-item") === 0) collapseLeft(component, item$1);
							expandRight(component, item$1, ExpandHighlightDecision.HighlightSubmenu).fold(() => {
								detail.onExecute(component, item$1);
							}, noop);
						});
					}),
					runOnAttached((container, _simulatedEvent) => {
						setup$10(container).each((primary$1) => {
							Replacing.append(container, premade(primary$1));
							detail.onOpenMenu(container, primary$1);
							if (detail.highlightOnOpen === HighlightOnOpen.HighlightMenuAndItem) setActiveMenuAndItem(container, primary$1);
							else if (detail.highlightOnOpen === HighlightOnOpen.HighlightJustMenu) setActiveMenu(container, primary$1);
						});
					}),
					run$1(onMenuItemHighlightedEvent, (tmenuComp, se) => {
						detail.onHighlightItem(tmenuComp, se.event.menuComp, se.event.itemComp);
					}),
					run$1(onMenuItemDehighlightedEvent, (tmenuComp, se) => {
						detail.onDehighlightItem(tmenuComp, se.event.menuComp, se.event.itemComp);
					}),
					...detail.navigateOnHover ? [run$1(hover(), (tmenu, simulatedEvent) => {
						const item$1 = simulatedEvent.event.item;
						updateView(tmenu, item$1);
						expandRight(tmenu, item$1, ExpandHighlightDecision.HighlightParent);
						detail.onHover(tmenu, item$1);
					})] : []
				]);
				const getActiveItem = (container) => Highlighting.getHighlighted(container).bind(Highlighting.getHighlighted);
				const collapseMenuApi = (container) => {
					getActiveItem(container).each((currentItem) => {
						collapseLeft(container, currentItem);
					});
				};
				const highlightPrimary = (container) => {
					layeredState.getPrimary().each((primary$1) => {
						setActiveMenuAndItem(container, primary$1);
					});
				};
				const extractMenuFromContainer = (container) => Optional.from(container.components()[0]).filter((comp) => get$f(comp.element, "role") === "menu");
				const repositionMenus$1 = (container) => {
					layeredState.getPrimary().bind((primary$1) => getActiveItem(container).bind((currentItem) => {
						const itemValue = getItemValue(currentItem);
						const preparedMenus = cat(map$2(values(layeredState.getMenus()), LayeredState.extractPreparedMenu));
						return layeredState.getTriggeringPath(itemValue, (v) => getItemByValue(container, preparedMenus, v));
					}).map((triggeringPath) => ({
						primary: primary$1,
						triggeringPath
					}))).fold(() => {
						extractMenuFromContainer(container).each((primaryMenu) => {
							detail.onRepositionMenu(container, primaryMenu, []);
						});
					}, ({ primary: primary$1, triggeringPath }) => {
						detail.onRepositionMenu(container, primary$1, triggeringPath);
					});
				};
				const apis = {
					collapseMenu: collapseMenuApi,
					highlightPrimary,
					repositionMenus: repositionMenus$1
				};
				return {
					uid: detail.uid,
					dom: detail.dom,
					markers: detail.markers,
					behaviours: augment(detail.tmenuBehaviours, [
						Keying.config({
							mode: "special",
							onRight: keyOnItem(onRight$3),
							onLeft: keyOnItem(onLeft$3),
							onEscape: keyOnItem(onEscape),
							focusIn: (container, _keyInfo) => {
								layeredState.getPrimary().each((primary$1) => {
									dispatch(container, primary$1.element, focusItem());
								});
							}
						}),
						Highlighting.config({
							highlightClass: detail.markers.selectedMenu,
							itemClass: detail.markers.menu
						}),
						Composing.config({ find: (container) => {
							return Highlighting.getHighlighted(container);
						} }),
						Replacing.config({})
					]),
					eventOrder: detail.eventOrder,
					apis,
					events: events$10
				};
			};
			const collapseItem$1 = constant$1("collapse-item");
			const tieredData = (primary$1, menus, expansions) => ({
				primary: primary$1,
				menus,
				expansions
			});
			const singleData = (name$4, menu$1) => ({
				primary: name$4,
				menus: wrap$1(name$4, menu$1),
				expansions: {}
			});
			const collapseItem = (text$3) => ({
				value: generate$6(collapseItem$1()),
				meta: { text: text$3 }
			});
			const tieredMenu = single({
				name: "TieredMenu",
				configFields: [
					onStrictKeyboardHandler("onExecute"),
					onStrictKeyboardHandler("onEscape"),
					onStrictHandler("onOpenMenu"),
					onStrictHandler("onOpenSubmenu"),
					onHandler("onRepositionMenu"),
					onHandler("onCollapseMenu"),
					defaulted("highlightOnOpen", HighlightOnOpen.HighlightMenuAndItem),
					requiredObjOf("data", [
						required$1("primary"),
						required$1("menus"),
						required$1("expansions")
					]),
					defaulted("fakeFocus", false),
					onHandler("onHighlightItem"),
					onHandler("onDehighlightItem"),
					onHandler("onHover"),
					tieredMenuMarkers(),
					required$1("dom"),
					defaulted("navigateOnHover", true),
					defaulted("stayInDom", false),
					field("tmenuBehaviours", [
						Keying,
						Highlighting,
						Composing,
						Replacing
					]),
					defaulted("eventOrder", {})
				],
				apis: {
					collapseMenu: (apis, tmenu) => {
						apis.collapseMenu(tmenu);
					},
					highlightPrimary: (apis, tmenu) => {
						apis.highlightPrimary(tmenu);
					},
					repositionMenus: (apis, tmenu) => {
						apis.repositionMenus(tmenu);
					}
				},
				factory: make$6,
				extraApis: {
					tieredData,
					singleData,
					collapseItem
				}
			});
			const makeMenu = (detail, menuSandbox, placementSpec, menuSpec, getBounds$4) => {
				const lazySink = () => detail.lazySink(menuSandbox);
				const layouts$1 = menuSpec.type === "horizontal" ? { layouts: {
					onLtr: () => belowOrAbove(),
					onRtl: () => belowOrAboveRtl()
				} } : {};
				const isFirstTierSubmenu = (triggeringPaths) => triggeringPaths.length === 2;
				const getSubmenuLayouts = (triggeringPaths) => isFirstTierSubmenu(triggeringPaths) ? layouts$1 : {};
				return tieredMenu.sketch({
					dom: { tag: "div" },
					data: menuSpec.data,
					markers: menuSpec.menu.markers,
					highlightOnOpen: menuSpec.menu.highlightOnOpen,
					fakeFocus: menuSpec.menu.fakeFocus,
					onEscape: () => {
						Sandboxing.close(menuSandbox);
						detail.onEscape.map((handler) => handler(menuSandbox));
						return Optional.some(true);
					},
					onExecute: () => {
						return Optional.some(true);
					},
					onOpenMenu: (tmenu, menu$1) => {
						Positioning.positionWithinBounds(lazySink().getOrDie(), menu$1, placementSpec, getBounds$4());
					},
					onOpenSubmenu: (tmenu, item$1, submenu, triggeringPaths) => {
						const sink = lazySink().getOrDie();
						Positioning.position(sink, submenu, { anchor: {
							type: "submenu",
							item: item$1,
							...getSubmenuLayouts(triggeringPaths)
						} });
					},
					onRepositionMenu: (tmenu, primaryMenu, submenuTriggers) => {
						const sink = lazySink().getOrDie();
						Positioning.positionWithinBounds(sink, primaryMenu, placementSpec, getBounds$4());
						each$1(submenuTriggers, (st) => {
							const submenuLayouts = getSubmenuLayouts(st.triggeringPath);
							Positioning.position(sink, st.triggeredMenu, { anchor: {
								type: "submenu",
								item: st.triggeringItem,
								...submenuLayouts
							} });
						});
					}
				});
			};
			const factory$o = (detail, spec) => {
				const isPartOfRelated = (sandbox, queryElem) => {
					return detail.getRelated(sandbox).exists((rel) => isPartOf$1(rel, queryElem));
				};
				const setContent$1 = (sandbox, thing) => {
					Sandboxing.setContent(sandbox, thing);
				};
				const showAt = (sandbox, thing, placementSpec) => {
					const getBounds$4 = Optional.none;
					showWithinBounds(sandbox, thing, placementSpec, getBounds$4);
				};
				const showWithinBounds = (sandbox, thing, placementSpec, getBounds$4) => {
					const sink = detail.lazySink(sandbox).getOrDie();
					Sandboxing.openWhileCloaked(sandbox, thing, () => Positioning.positionWithinBounds(sink, sandbox, placementSpec, getBounds$4()));
					Representing.setValue(sandbox, Optional.some({
						mode: "position",
						config: placementSpec,
						getBounds: getBounds$4
					}));
				};
				const showMenuAt = (sandbox, placementSpec, menuSpec) => {
					showMenuWithinBounds(sandbox, placementSpec, menuSpec, Optional.none);
				};
				const showMenuWithinBounds = (sandbox, placementSpec, menuSpec, getBounds$4) => {
					const menu$1 = makeMenu(detail, sandbox, placementSpec, menuSpec, getBounds$4);
					Sandboxing.open(sandbox, menu$1);
					Representing.setValue(sandbox, Optional.some({
						mode: "menu",
						menu: menu$1
					}));
				};
				const hide = (sandbox) => {
					if (Sandboxing.isOpen(sandbox)) {
						Representing.setValue(sandbox, Optional.none());
						Sandboxing.close(sandbox);
					}
				};
				const getContent = (sandbox) => Sandboxing.getState(sandbox);
				const reposition$1 = (sandbox) => {
					if (Sandboxing.isOpen(sandbox)) Representing.getValue(sandbox).each((state) => {
						switch (state.mode) {
							case "menu":
								Sandboxing.getState(sandbox).each(tieredMenu.repositionMenus);
								break;
							case "position":
								const sink = detail.lazySink(sandbox).getOrDie();
								Positioning.positionWithinBounds(sink, sandbox, state.config, state.getBounds());
								break;
						}
					});
				};
				const apis = {
					setContent: setContent$1,
					showAt,
					showWithinBounds,
					showMenuAt,
					showMenuWithinBounds,
					hide,
					getContent,
					reposition: reposition$1,
					isOpen: Sandboxing.isOpen
				};
				return {
					uid: detail.uid,
					dom: detail.dom,
					behaviours: augment(detail.inlineBehaviours, [
						Sandboxing.config({
							isPartOf: (sandbox, data, queryElem) => {
								return isPartOf$1(data, queryElem) || isPartOfRelated(sandbox, queryElem);
							},
							getAttachPoint: (sandbox) => {
								return detail.lazySink(sandbox).getOrDie();
							},
							onOpen: (sandbox) => {
								detail.onShow(sandbox);
							},
							onClose: (sandbox) => {
								detail.onHide(sandbox);
							}
						}),
						Representing.config({ store: {
							mode: "memory",
							initialValue: Optional.none()
						} }),
						Receiving.config({ channels: {
							...receivingChannel$1({
								isExtraPart: spec.isExtraPart,
								...detail.fireDismissalEventInstead.map((fe) => ({ fireEventInstead: { event: fe.event } })).getOr({})
							}),
							...receivingChannel({
								...detail.fireRepositionEventInstead.map((fe) => ({ fireEventInstead: { event: fe.event } })).getOr({}),
								doReposition: reposition$1
							})
						} })
					]),
					eventOrder: detail.eventOrder,
					apis
				};
			};
			const InlineView = single({
				name: "InlineView",
				configFields: [
					required$1("lazySink"),
					onHandler("onShow"),
					onHandler("onHide"),
					optionFunction("onEscape"),
					field("inlineBehaviours", [
						Sandboxing,
						Representing,
						Receiving
					]),
					optionObjOf("fireDismissalEventInstead", [defaulted("event", dismissRequested())]),
					optionObjOf("fireRepositionEventInstead", [defaulted("event", repositionRequested())]),
					defaulted("getRelated", Optional.none),
					defaulted("isExtraPart", never),
					defaulted("eventOrder", Optional.none)
				],
				factory: factory$o,
				apis: {
					showAt: (apis, component, anchor$1, thing) => {
						apis.showAt(component, anchor$1, thing);
					},
					showWithinBounds: (apis, component, anchor$1, thing, bounds$2) => {
						apis.showWithinBounds(component, anchor$1, thing, bounds$2);
					},
					showMenuAt: (apis, component, anchor$1, menuSpec) => {
						apis.showMenuAt(component, anchor$1, menuSpec);
					},
					showMenuWithinBounds: (apis, component, anchor$1, menuSpec, bounds$2) => {
						apis.showMenuWithinBounds(component, anchor$1, menuSpec, bounds$2);
					},
					hide: (apis, component) => {
						apis.hide(component);
					},
					isOpen: (apis, component) => apis.isOpen(component),
					getContent: (apis, component) => apis.getContent(component),
					setContent: (apis, component, thing) => {
						apis.setContent(component, thing);
					},
					reposition: (apis, component) => {
						apis.reposition(component);
					}
				}
			});
			var global$9 = tinymce.util.Tools.resolve("tinymce.util.Delay");
			const factory$n = (detail) => {
				const events$10 = events$a(detail.action);
				const tag = detail.dom.tag;
				const lookupAttr = (attr) => get$g(detail.dom, "attributes").bind((attrs) => get$g(attrs, attr));
				const getModAttributes = () => {
					if (tag === "button") return {
						type: lookupAttr("type").getOr("button"),
						...lookupAttr("role").map((role) => ({ role })).getOr({})
					};
					else return { role: detail.role.getOr(lookupAttr("role").getOr("button")) };
				};
				return {
					uid: detail.uid,
					dom: detail.dom,
					components: detail.components,
					events: events$10,
					behaviours: SketchBehaviours.augment(detail.buttonBehaviours, [Focusing.config({}), Keying.config({
						mode: "execution",
						useSpace: true,
						useEnter: true
					})]),
					domModification: { attributes: getModAttributes() },
					eventOrder: detail.eventOrder
				};
			};
			const Button = single({
				name: "Button",
				factory: factory$n,
				configFields: [
					defaulted("uid", void 0),
					required$1("dom"),
					defaulted("components", []),
					SketchBehaviours.field("buttonBehaviours", [Focusing, Keying]),
					option$3("action"),
					option$3("role"),
					defaulted("eventOrder", {})
				]
			});
			const record = (spec) => {
				const uid = isSketchSpec(spec) && hasNonNullableKey(spec, "uid") ? spec.uid : generate$5("memento");
				const get$10 = (anyInSystem) => anyInSystem.getSystem().getByUid(uid).getOrDie();
				const getOpt$1 = (anyInSystem) => anyInSystem.getSystem().getByUid(uid).toOptional();
				const asSpec = () => ({
					...spec,
					uid
				});
				return {
					get: get$10,
					getOpt: getOpt$1,
					asSpec
				};
			};
			var global$8 = tinymce.util.Tools.resolve("tinymce.util.I18n");
			const rtlTransform = {
				"indent": true,
				"outdent": true,
				"table-insert-column-after": true,
				"table-insert-column-before": true,
				"paste-column-after": true,
				"paste-column-before": true,
				"unordered-list": true,
				"list-bull-circle": true,
				"list-bull-default": true,
				"list-bull-square": true
			};
			const defaultIconName = "temporary-placeholder";
			const defaultIcon = (icons) => () => get$g(icons, defaultIconName).getOr("!not found!");
			const getIconName = (name$4, icons) => {
				const lcName = name$4.toLowerCase();
				if (global$8.isRtl()) {
					const rtlName = ensureTrailing(lcName, "-rtl");
					return has$2(icons, rtlName) ? rtlName : lcName;
				} else return lcName;
			};
			const lookupIcon = (name$4, icons) => get$g(icons, getIconName(name$4, icons));
			const get$2 = (name$4, iconProvider) => {
				const icons = iconProvider();
				return lookupIcon(name$4, icons).getOrThunk(defaultIcon(icons));
			};
			const getOr = (name$4, iconProvider, fallbackIcon) => {
				const icons = iconProvider();
				return lookupIcon(name$4, icons).or(fallbackIcon).getOrThunk(defaultIcon(icons));
			};
			const needsRtlTransform = (iconName) => global$8.isRtl() ? has$2(rtlTransform, iconName) : false;
			const addFocusableBehaviour = () => config("add-focusable", [runOnAttached((comp) => {
				child(comp.element, "svg").each((svg$2) => set$9(svg$2, "focusable", "false"));
			})]);
			const renderIcon$3 = (spec, iconName, icons, fallbackIcon) => {
				var _a, _b;
				const rtlIconClasses = needsRtlTransform(iconName) ? ["tox-icon--flip"] : [];
				const iconHtml = get$g(icons, getIconName(iconName, icons)).or(fallbackIcon).getOrThunk(defaultIcon(icons));
				return {
					dom: {
						tag: spec.tag,
						attributes: (_a = spec.attributes) !== null && _a !== void 0 ? _a : {},
						classes: spec.classes.concat(rtlIconClasses),
						innerHtml: iconHtml
					},
					behaviours: derive$1([...(_b = spec.behaviours) !== null && _b !== void 0 ? _b : [], addFocusableBehaviour()])
				};
			};
			const render$3 = (iconName, spec, iconProvider, fallbackIcon = Optional.none()) => renderIcon$3(spec, iconName, iconProvider(), fallbackIcon);
			const renderFirst = (iconNames, spec, iconProvider) => {
				const icons = iconProvider();
				return renderIcon$3(spec, find$5(iconNames, (name$4) => has$2(icons, getIconName(name$4, icons))).getOr(defaultIconName), icons, Optional.none());
			};
			const notificationIconMap = {
				success: "checkmark",
				error: "warning",
				err: "error",
				warning: "warning",
				warn: "warning",
				info: "info"
			};
			const factory$m = (detail) => {
				const memBannerText = record({
					dom: {
						tag: "p",
						innerHtml: detail.translationProvider(detail.text)
					},
					behaviours: derive$1([Replacing.config({})])
				});
				const renderPercentBar = (percent) => ({ dom: {
					tag: "div",
					classes: ["tox-bar"],
					styles: { width: `${percent}%` }
				} });
				const renderPercentText = (percent) => ({ dom: {
					tag: "div",
					classes: ["tox-text"],
					innerHtml: `${percent}%`
				} });
				const memBannerProgress = record({
					dom: {
						tag: "div",
						classes: detail.progress ? ["tox-progress-bar", "tox-progress-indicator"] : ["tox-progress-bar"]
					},
					components: [{
						dom: {
							tag: "div",
							classes: ["tox-bar-container"]
						},
						components: [renderPercentBar(0)]
					}, renderPercentText(0)],
					behaviours: derive$1([Replacing.config({})])
				});
				const updateProgress = (comp, percent) => {
					if (comp.getSystem().isConnected()) memBannerProgress.getOpt(comp).each((progress) => {
						Replacing.set(progress, [{
							dom: {
								tag: "div",
								classes: ["tox-bar-container"]
							},
							components: [renderPercentBar(percent)]
						}, renderPercentText(percent)]);
					});
				};
				const updateText = (comp, text$3) => {
					if (comp.getSystem().isConnected()) {
						const banner = memBannerText.get(comp);
						Replacing.set(banner, [text$2(text$3)]);
					}
				};
				const apis = {
					updateProgress,
					updateText
				};
				const iconChoices = flatten([
					detail.icon.toArray(),
					detail.level.toArray(),
					detail.level.bind((level) => Optional.from(notificationIconMap[level])).toArray()
				]);
				const memButton = record(Button.sketch({
					dom: {
						tag: "button",
						classes: [
							"tox-notification__dismiss",
							"tox-button",
							"tox-button--naked",
							"tox-button--icon"
						]
					},
					components: [render$3("close", {
						tag: "span",
						classes: ["tox-icon"],
						attributes: { "aria-label": detail.translationProvider("Close") }
					}, detail.iconProvider)],
					action: (comp) => {
						detail.onAction(comp);
					}
				}));
				const components$2 = [renderFirst(iconChoices, {
					tag: "div",
					classes: ["tox-notification__icon"]
				}, detail.iconProvider), {
					dom: {
						tag: "div",
						classes: ["tox-notification__body"]
					},
					components: [memBannerText.asSpec()],
					behaviours: derive$1([Replacing.config({})])
				}];
				return {
					uid: detail.uid,
					dom: {
						tag: "div",
						attributes: { role: "alert" },
						classes: detail.level.map((level) => [
							"tox-notification",
							"tox-notification--in",
							`tox-notification--${level}`
						]).getOr(["tox-notification", "tox-notification--in"])
					},
					behaviours: derive$1([Focusing.config({}), config("notification-events", [run$1(focusin(), (comp) => {
						memButton.getOpt(comp).each(Focusing.focus);
					})])]),
					components: components$2.concat(detail.progress ? [memBannerProgress.asSpec()] : []).concat(!detail.closeButton ? [] : [memButton.asSpec()]),
					apis
				};
			};
			const Notification = single({
				name: "Notification",
				factory: factory$m,
				configFields: [
					option$3("level"),
					required$1("progress"),
					option$3("icon"),
					required$1("onAction"),
					required$1("text"),
					required$1("iconProvider"),
					required$1("translationProvider"),
					defaultedBoolean("closeButton", true)
				],
				apis: {
					updateProgress: (apis, comp, percent) => {
						apis.updateProgress(comp, percent);
					},
					updateText: (apis, comp, text$3) => {
						apis.updateText(comp, text$3);
					}
				}
			});
			var NotificationManagerImpl = (editor, extras, uiMothership) => {
				const sharedBackstage = extras.backstage.shared;
				const getBounds$4 = () => {
					const contentArea = box$1(SugarElement.fromDom(editor.getContentAreaContainer()));
					const win$1 = win();
					const x = clamp(win$1.x, contentArea.x, contentArea.right);
					const y = clamp(win$1.y, contentArea.y, contentArea.bottom);
					const right$1 = Math.max(contentArea.right, win$1.right);
					const bottom$1 = Math.max(contentArea.bottom, win$1.bottom);
					return Optional.some(bounds(x, y, right$1 - x, bottom$1 - y));
				};
				const open$2 = (settings, closeCallback) => {
					const close$3 = () => {
						closeCallback();
						InlineView.hide(notificationWrapper);
					};
					const notification = build$1(Notification.sketch({
						text: settings.text,
						level: contains$2([
							"success",
							"error",
							"warning",
							"warn",
							"info"
						], settings.type) ? settings.type : void 0,
						progress: settings.progressBar === true,
						icon: settings.icon,
						closeButton: settings.closeButton,
						onAction: close$3,
						iconProvider: sharedBackstage.providers.icons,
						translationProvider: sharedBackstage.providers.translate
					}));
					const notificationWrapper = build$1(InlineView.sketch({
						dom: {
							tag: "div",
							classes: ["tox-notifications-container"]
						},
						lazySink: sharedBackstage.getSink,
						fireDismissalEventInstead: {},
						...sharedBackstage.header.isPositionedAtTop() ? {} : { fireRepositionEventInstead: {} }
					}));
					uiMothership.add(notificationWrapper);
					if (isNumber(settings.timeout) && settings.timeout > 0) global$9.setEditorTimeout(editor, () => {
						close$3();
					}, settings.timeout);
					const reposition$1 = () => {
						const notificationSpec = premade(notification);
						const anchorOverrides$1 = { maxHeightFunction: expandable$1() };
						const allNotifications = editor.notificationManager.getNotifications();
						if (allNotifications[0] === thisNotification) {
							const anchor$1 = {
								...sharedBackstage.anchors.banner(),
								overrides: anchorOverrides$1
							};
							InlineView.showWithinBounds(notificationWrapper, notificationSpec, { anchor: anchor$1 }, getBounds$4);
						} else indexOf(allNotifications, thisNotification).each((idx) => {
							const previousNotification = allNotifications[idx - 1].getEl();
							const nodeAnchor = {
								type: "node",
								root: body(),
								node: Optional.some(SugarElement.fromDom(previousNotification)),
								overrides: anchorOverrides$1,
								layouts: {
									onRtl: () => [south$2],
									onLtr: () => [south$2]
								}
							};
							InlineView.showWithinBounds(notificationWrapper, notificationSpec, { anchor: nodeAnchor }, getBounds$4);
						});
					};
					const thisNotification = {
						close: close$3,
						reposition: reposition$1,
						text: (nuText) => {
							Notification.updateText(notification, nuText);
						},
						settings,
						getEl: () => notification.element.dom,
						progressBar: { value: (percent) => {
							Notification.updateProgress(notification, percent);
						} }
					};
					return thisNotification;
				};
				const close$2 = (notification) => {
					notification.close();
				};
				const getArgs = (notification) => {
					return notification.settings;
				};
				return {
					open: open$2,
					close: close$2,
					getArgs
				};
			};
			var global$7 = tinymce.util.Tools.resolve("tinymce.dom.DOMUtils");
			var global$6 = tinymce.util.Tools.resolve("tinymce.EditorManager");
			var global$5 = tinymce.util.Tools.resolve("tinymce.Env");
			var ToolbarMode$1;
			(function(ToolbarMode$2) {
				ToolbarMode$2["default"] = "wrap";
				ToolbarMode$2["floating"] = "floating";
				ToolbarMode$2["sliding"] = "sliding";
				ToolbarMode$2["scrolling"] = "scrolling";
			})(ToolbarMode$1 || (ToolbarMode$1 = {}));
			var ToolbarLocation$1;
			(function(ToolbarLocation$2) {
				ToolbarLocation$2["auto"] = "auto";
				ToolbarLocation$2["top"] = "top";
				ToolbarLocation$2["bottom"] = "bottom";
			})(ToolbarLocation$1 || (ToolbarLocation$1 = {}));
			const option$2 = (name$4) => (editor) => editor.options.get(name$4);
			const wrapOptional = (fn) => (editor) => Optional.from(fn(editor));
			const register$e = (editor) => {
				const isPhone$1 = global$5.deviceType.isPhone();
				const isMobile = global$5.deviceType.isTablet() || isPhone$1;
				const registerOption = editor.options.register;
				const stringOrFalseProcessor = (value$5) => isString(value$5) || value$5 === false;
				const stringOrNumberProcessor = (value$5) => isString(value$5) || isNumber(value$5);
				registerOption("skin", {
					processor: (value$5) => isString(value$5) || value$5 === false,
					default: "oxide"
				});
				registerOption("skin_url", { processor: "string" });
				registerOption("height", {
					processor: stringOrNumberProcessor,
					default: Math.max(editor.getElement().offsetHeight, 400)
				});
				registerOption("width", {
					processor: stringOrNumberProcessor,
					default: global$7.DOM.getStyle(editor.getElement(), "width")
				});
				registerOption("min_height", {
					processor: "number",
					default: 100
				});
				registerOption("min_width", { processor: "number" });
				registerOption("max_height", { processor: "number" });
				registerOption("max_width", { processor: "number" });
				registerOption("style_formats", { processor: "object[]" });
				registerOption("style_formats_merge", {
					processor: "boolean",
					default: false
				});
				registerOption("style_formats_autohide", {
					processor: "boolean",
					default: false
				});
				registerOption("line_height_formats", {
					processor: "string",
					default: "1 1.1 1.2 1.3 1.4 1.5 2"
				});
				registerOption("font_family_formats", {
					processor: "string",
					default: "Andale Mono=andale mono,monospace;Arial=arial,helvetica,sans-serif;Arial Black=arial black,sans-serif;Book Antiqua=book antiqua,palatino,serif;Comic Sans MS=comic sans ms,sans-serif;Courier New=courier new,courier,monospace;Georgia=georgia,palatino,serif;Helvetica=helvetica,arial,sans-serif;Impact=impact,sans-serif;Symbol=symbol;Tahoma=tahoma,arial,helvetica,sans-serif;Terminal=terminal,monaco,monospace;Times New Roman=times new roman,times,serif;Trebuchet MS=trebuchet ms,geneva,sans-serif;Verdana=verdana,geneva,sans-serif;Webdings=webdings;Wingdings=wingdings,zapf dingbats"
				});
				registerOption("font_size_formats", {
					processor: "string",
					default: "8pt 10pt 12pt 14pt 18pt 24pt 36pt"
				});
				registerOption("font_size_input_default_unit", {
					processor: "string",
					default: "pt"
				});
				registerOption("block_formats", {
					processor: "string",
					default: "Paragraph=p;Heading 1=h1;Heading 2=h2;Heading 3=h3;Heading 4=h4;Heading 5=h5;Heading 6=h6;Preformatted=pre"
				});
				registerOption("content_langs", { processor: "object[]" });
				registerOption("removed_menuitems", {
					processor: "string",
					default: ""
				});
				registerOption("menubar", {
					processor: (value$5) => isString(value$5) || isBoolean(value$5),
					default: !isPhone$1
				});
				registerOption("menu", {
					processor: "object",
					default: {}
				});
				registerOption("toolbar", {
					processor: (value$5) => {
						if (isBoolean(value$5) || isString(value$5) || isArray(value$5)) return {
							value: value$5,
							valid: true
						};
						else return {
							valid: false,
							message: "Must be a boolean, string or array."
						};
					},
					default: true
				});
				range$2(9, (num) => {
					registerOption("toolbar" + (num + 1), { processor: "string" });
				});
				registerOption("toolbar_mode", {
					processor: "string",
					default: isMobile ? "scrolling" : "floating"
				});
				registerOption("toolbar_groups", {
					processor: "object",
					default: {}
				});
				registerOption("toolbar_location", {
					processor: "string",
					default: ToolbarLocation$1.auto
				});
				registerOption("toolbar_persist", {
					processor: "boolean",
					default: false
				});
				registerOption("toolbar_sticky", {
					processor: "boolean",
					default: editor.inline
				});
				registerOption("toolbar_sticky_offset", {
					processor: "number",
					default: 0
				});
				registerOption("fixed_toolbar_container", {
					processor: "string",
					default: ""
				});
				registerOption("fixed_toolbar_container_target", { processor: "object" });
				registerOption("ui_mode", {
					processor: "string",
					default: "combined"
				});
				registerOption("file_picker_callback", { processor: "function" });
				registerOption("file_picker_validator_handler", { processor: "function" });
				registerOption("file_picker_types", { processor: "string" });
				registerOption("typeahead_urls", {
					processor: "boolean",
					default: true
				});
				registerOption("anchor_top", {
					processor: stringOrFalseProcessor,
					default: "#top"
				});
				registerOption("anchor_bottom", {
					processor: stringOrFalseProcessor,
					default: "#bottom"
				});
				registerOption("draggable_modal", {
					processor: "boolean",
					default: false
				});
				registerOption("statusbar", {
					processor: "boolean",
					default: true
				});
				registerOption("elementpath", {
					processor: "boolean",
					default: true
				});
				registerOption("branding", {
					processor: "boolean",
					default: true
				});
				registerOption("promotion", {
					processor: "boolean",
					default: true
				});
				registerOption("resize", {
					processor: (value$5) => value$5 === "both" || isBoolean(value$5),
					default: !global$5.deviceType.isTouch()
				});
				registerOption("sidebar_show", { processor: "string" });
				registerOption("help_accessibility", {
					processor: "boolean",
					default: editor.hasPlugin("help")
				});
			};
			const isReadOnly = option$2("readonly");
			const getHeightOption = option$2("height");
			const getWidthOption = option$2("width");
			const getMinWidthOption = wrapOptional(option$2("min_width"));
			const getMinHeightOption = wrapOptional(option$2("min_height"));
			const getMaxWidthOption = wrapOptional(option$2("max_width"));
			const getMaxHeightOption = wrapOptional(option$2("max_height"));
			const getUserStyleFormats = wrapOptional(option$2("style_formats"));
			const shouldMergeStyleFormats = option$2("style_formats_merge");
			const shouldAutoHideStyleFormats = option$2("style_formats_autohide");
			const getContentLanguages = option$2("content_langs");
			const getRemovedMenuItems = option$2("removed_menuitems");
			const getToolbarMode = option$2("toolbar_mode");
			const getToolbarGroups = option$2("toolbar_groups");
			const getToolbarLocation = option$2("toolbar_location");
			const fixedContainerSelector = option$2("fixed_toolbar_container");
			const fixedToolbarContainerTarget = option$2("fixed_toolbar_container_target");
			const isToolbarPersist = option$2("toolbar_persist");
			const getStickyToolbarOffset = option$2("toolbar_sticky_offset");
			const getMenubar = option$2("menubar");
			const getToolbar = option$2("toolbar");
			const getFilePickerCallback = option$2("file_picker_callback");
			const getFilePickerValidatorHandler = option$2("file_picker_validator_handler");
			const getFontSizeInputDefaultUnit = option$2("font_size_input_default_unit");
			const getFilePickerTypes = option$2("file_picker_types");
			const useTypeaheadUrls = option$2("typeahead_urls");
			const getAnchorTop = option$2("anchor_top");
			const getAnchorBottom = option$2("anchor_bottom");
			const isDraggableModal$1 = option$2("draggable_modal");
			const useStatusBar = option$2("statusbar");
			const useElementPath = option$2("elementpath");
			const useBranding = option$2("branding");
			const getResize = option$2("resize");
			const getPasteAsText = option$2("paste_as_text");
			const getSidebarShow = option$2("sidebar_show");
			const promotionEnabled = option$2("promotion");
			const useHelpAccessibility = option$2("help_accessibility");
			const isSkinDisabled = (editor) => editor.options.get("skin") === false;
			const isMenubarEnabled = (editor) => editor.options.get("menubar") !== false;
			const getSkinUrl = (editor) => {
				const skinUrl = editor.options.get("skin_url");
				if (isSkinDisabled(editor)) return skinUrl;
				else if (skinUrl) return editor.documentBaseURI.toAbsolute(skinUrl);
				else {
					const skin = editor.options.get("skin");
					return global$6.baseURL + "/skins/ui/" + skin;
				}
			};
			const getLineHeightFormats = (editor) => editor.options.get("line_height_formats").split(" ");
			const isToolbarEnabled = (editor) => {
				const toolbar = getToolbar(editor);
				const isToolbarString = isString(toolbar);
				const isToolbarObjectArray = isArray(toolbar) && toolbar.length > 0;
				return !isMultipleToolbars(editor) && (isToolbarObjectArray || isToolbarString || toolbar === true);
			};
			const getMultipleToolbarsOption = (editor) => {
				const toolbarArray = filter$2(range$2(9, (num) => editor.options.get("toolbar" + (num + 1))), isString);
				return someIf(toolbarArray.length > 0, toolbarArray);
			};
			const isMultipleToolbars = (editor) => getMultipleToolbarsOption(editor).fold(() => {
				const toolbar = getToolbar(editor);
				return isArrayOf(toolbar, isString) && toolbar.length > 0;
			}, always);
			const isToolbarLocationBottom = (editor) => getToolbarLocation(editor) === ToolbarLocation$1.bottom;
			const fixedContainerTarget = (editor) => {
				var _a;
				if (!editor.inline) return Optional.none();
				const selector = (_a = fixedContainerSelector(editor)) !== null && _a !== void 0 ? _a : "";
				if (selector.length > 0) return descendant(body(), selector);
				const element$1 = fixedToolbarContainerTarget(editor);
				if (isNonNullable(element$1)) return Optional.some(SugarElement.fromDom(element$1));
				return Optional.none();
			};
			const useFixedContainer = (editor) => editor.inline && fixedContainerTarget(editor).isSome();
			const getUiContainer = (editor) => {
				return fixedContainerTarget(editor).getOrThunk(() => getContentContainer(getRootNode(SugarElement.fromDom(editor.getElement()))));
			};
			const isDistractionFree = (editor) => editor.inline && !isMenubarEnabled(editor) && !isToolbarEnabled(editor) && !isMultipleToolbars(editor);
			const isStickyToolbar = (editor) => {
				return (editor.options.get("toolbar_sticky") || editor.inline) && !useFixedContainer(editor) && !isDistractionFree(editor);
			};
			const isSplitUiMode = (editor) => !useFixedContainer(editor) && editor.options.get("ui_mode") === "split";
			const getMenus = (editor) => {
				return map$1(editor.options.get("menu"), (menu$1) => ({
					...menu$1,
					items: menu$1.items
				}));
			};
			var Options = /* @__PURE__ */ Object.freeze({
				__proto__: null,
				get ToolbarMode() {
					return ToolbarMode$1;
				},
				get ToolbarLocation() {
					return ToolbarLocation$1;
				},
				register: register$e,
				getSkinUrl,
				isReadOnly,
				isSkinDisabled,
				getHeightOption,
				getWidthOption,
				getMinWidthOption,
				getMinHeightOption,
				getMaxWidthOption,
				getMaxHeightOption,
				getUserStyleFormats,
				shouldMergeStyleFormats,
				shouldAutoHideStyleFormats,
				getLineHeightFormats,
				getContentLanguages,
				getRemovedMenuItems,
				isMenubarEnabled,
				isMultipleToolbars,
				isToolbarEnabled,
				isToolbarPersist,
				getMultipleToolbarsOption,
				getUiContainer,
				useFixedContainer,
				isSplitUiMode,
				getToolbarMode,
				isDraggableModal: isDraggableModal$1,
				isDistractionFree,
				isStickyToolbar,
				getStickyToolbarOffset,
				getToolbarLocation,
				isToolbarLocationBottom,
				getToolbarGroups,
				getMenus,
				getMenubar,
				getToolbar,
				getFilePickerCallback,
				getFilePickerTypes,
				useTypeaheadUrls,
				getAnchorTop,
				getAnchorBottom,
				getFilePickerValidatorHandler,
				getFontSizeInputDefaultUnit,
				useStatusBar,
				useElementPath,
				promotionEnabled,
				useBranding,
				getResize,
				getPasteAsText,
				getSidebarShow,
				useHelpAccessibility
			});
			const autocompleteSelector = "[data-mce-autocompleter]";
			const detect$1 = (elm) => closest$1(elm, autocompleteSelector);
			const findIn = (elm) => descendant(elm, autocompleteSelector);
			const setup$e = (api$3, editor) => {
				const redirectKeyToItem = (item$1, e) => {
					emitWith(item$1, keydown(), { raw: e });
				};
				const getItem = () => api$3.getMenu().bind(Highlighting.getHighlighted);
				editor.on("keydown", (e) => {
					const keyCode = e.which;
					if (!api$3.isActive()) return;
					if (api$3.isMenuOpen()) {
						if (keyCode === 13) {
							getItem().each(emitExecute);
							e.preventDefault();
						} else if (keyCode === 40) {
							getItem().fold(() => {
								api$3.getMenu().each(Highlighting.highlightFirst);
							}, (item$1) => {
								redirectKeyToItem(item$1, e);
							});
							e.preventDefault();
							e.stopImmediatePropagation();
						} else if (keyCode === 37 || keyCode === 38 || keyCode === 39) getItem().each((item$1) => {
							redirectKeyToItem(item$1, e);
							e.preventDefault();
							e.stopImmediatePropagation();
						});
					} else if (keyCode === 13 || keyCode === 38 || keyCode === 40) api$3.cancelIfNecessary();
				});
				editor.on("NodeChange", (e) => {
					if (api$3.isActive() && !api$3.isProcessingAction() && detect$1(SugarElement.fromDom(e.element)).isNone()) api$3.cancelIfNecessary();
				});
			};
			const AutocompleterEditorEvents = { setup: setup$e };
			var ItemResponse;
			(function(ItemResponse$2) {
				ItemResponse$2[ItemResponse$2["CLOSE_ON_EXECUTE"] = 0] = "CLOSE_ON_EXECUTE";
				ItemResponse$2[ItemResponse$2["BUBBLE_TO_SANDBOX"] = 1] = "BUBBLE_TO_SANDBOX";
			})(ItemResponse || (ItemResponse = {}));
			var ItemResponse$1 = ItemResponse;
			const navClass = "tox-menu-nav__js";
			const selectableClass = "tox-collection__item";
			const colorClass = "tox-swatch";
			const presetClasses = {
				normal: navClass,
				color: colorClass
			};
			const tickedClass = "tox-collection__item--enabled";
			const groupHeadingClass = "tox-collection__group-heading";
			const iconClass = "tox-collection__item-icon";
			const textClass = "tox-collection__item-label";
			const accessoryClass = "tox-collection__item-accessory";
			const caretClass = "tox-collection__item-caret";
			const checkmarkClass = "tox-collection__item-checkmark";
			const activeClass = "tox-collection__item--active";
			const containerClass = "tox-collection__item-container";
			const containerColumnClass = "tox-collection__item-container--column";
			const containerRowClass = "tox-collection__item-container--row";
			const containerAlignRightClass = "tox-collection__item-container--align-right";
			const containerAlignLeftClass = "tox-collection__item-container--align-left";
			const containerValignTopClass = "tox-collection__item-container--valign-top";
			const containerValignMiddleClass = "tox-collection__item-container--valign-middle";
			const containerValignBottomClass = "tox-collection__item-container--valign-bottom";
			const classForPreset = (presets) => get$g(presetClasses, presets).getOr(navClass);
			const forMenu = (presets) => {
				if (presets === "color") return "tox-swatches";
				else return "tox-menu";
			};
			const classes = (presets) => ({
				backgroundMenu: "tox-background-menu",
				selectedMenu: "tox-selected-menu",
				selectedItem: "tox-collection__item--active",
				hasIcons: "tox-menu--has-icons",
				menu: forMenu(presets),
				tieredMenu: "tox-tiered-menu"
			});
			const markers = (presets) => {
				const menuClasses = classes(presets);
				return {
					backgroundMenu: menuClasses.backgroundMenu,
					selectedMenu: menuClasses.selectedMenu,
					menu: menuClasses.menu,
					selectedItem: menuClasses.selectedItem,
					item: classForPreset(presets)
				};
			};
			const dom$1 = (hasIcons, columns, presets) => {
				const menuClasses = classes(presets);
				return {
					tag: "div",
					classes: flatten([[menuClasses.menu, `tox-menu-${columns}-column`], hasIcons ? [menuClasses.hasIcons] : []])
				};
			};
			const components = [Menu.parts.items({})];
			const part = (hasIcons, columns, presets) => {
				return {
					dom: {
						tag: "div",
						classes: flatten([[classes(presets).tieredMenu]])
					},
					markers: markers(presets)
				};
			};
			const schema$l = constant$1([
				option$3("data"),
				defaulted("inputAttributes", {}),
				defaulted("inputStyles", {}),
				defaulted("tag", "input"),
				defaulted("inputClasses", []),
				onHandler("onSetValue"),
				defaulted("styles", {}),
				defaulted("eventOrder", {}),
				field("inputBehaviours", [Representing, Focusing]),
				defaulted("selectOnFocus", true)
			]);
			const focusBehaviours = (detail) => derive$1([Focusing.config({ onFocus: !detail.selectOnFocus ? noop : (component) => {
				const input$1 = component.element;
				const value$5 = get$6(input$1);
				input$1.dom.setSelectionRange(0, value$5.length);
			} })]);
			const behaviours = (detail) => ({
				...focusBehaviours(detail),
				...augment(detail.inputBehaviours, [Representing.config({
					store: {
						mode: "manual",
						...detail.data.map((data) => ({ initialValue: data })).getOr({}),
						getValue: (input$1) => {
							return get$6(input$1.element);
						},
						setValue: (input$1, data) => {
							if (get$6(input$1.element) !== data) set$5(input$1.element, data);
						}
					},
					onSetValue: detail.onSetValue
				})])
			});
			const dom = (detail) => ({
				tag: detail.tag,
				attributes: {
					type: "text",
					...detail.inputAttributes
				},
				styles: detail.inputStyles,
				classes: detail.inputClasses
			});
			const factory$l = (detail, _spec) => ({
				uid: detail.uid,
				dom: dom(detail),
				components: [],
				behaviours: behaviours(detail),
				eventOrder: detail.eventOrder
			});
			const Input = single({
				name: "Input",
				configFields: schema$l(),
				factory: factory$l
			});
			const refetchTriggerEvent = generate$6("refetch-trigger-event");
			const redirectMenuItemInteractionEvent = generate$6("redirect-menu-item-interaction");
			const menuSearcherClass = "tox-menu__searcher";
			const findWithinSandbox = (sandboxComp) => {
				return descendant(sandboxComp.element, `.${menuSearcherClass}`).bind((inputElem) => sandboxComp.getSystem().getByDom(inputElem).toOptional());
			};
			const findWithinMenu = findWithinSandbox;
			const restoreState = (inputComp, searcherState) => {
				Representing.setValue(inputComp, searcherState.fetchPattern);
				inputComp.element.dom.selectionStart = searcherState.selectionStart;
				inputComp.element.dom.selectionEnd = searcherState.selectionEnd;
			};
			const saveState = (inputComp) => {
				return {
					fetchPattern: Representing.getValue(inputComp),
					selectionStart: inputComp.element.dom.selectionStart,
					selectionEnd: inputComp.element.dom.selectionEnd
				};
			};
			const setActiveDescendant = (inputComp, active$2) => {
				getOpt(active$2.element, "id").each((id) => set$9(inputComp.element, "aria-activedescendant", id));
			};
			const renderMenuSearcher = (spec) => {
				const handleByBrowser = (comp, se) => {
					se.cut();
					return Optional.none();
				};
				const handleByHighlightedItem = (comp, se) => {
					emitWith(comp, redirectMenuItemInteractionEvent, {
						interactionEvent: se.event,
						eventType: se.event.raw.type
					});
					return Optional.some(true);
				};
				const customSearcherEventsName = "searcher-events";
				return {
					dom: {
						tag: "div",
						classes: [selectableClass]
					},
					components: [Input.sketch({
						inputClasses: [menuSearcherClass, "tox-textfield"],
						inputAttributes: {
							...spec.placeholder.map((placeholder$1) => ({ placeholder: spec.i18n(placeholder$1) })).getOr({}),
							"type": "search",
							"aria-autocomplete": "list"
						},
						inputBehaviours: derive$1([config(customSearcherEventsName, [run$1(input(), (inputComp) => {
							emit(inputComp, refetchTriggerEvent);
						}), run$1(keydown(), (inputComp, se) => {
							if (se.event.raw.key === "Escape") se.stop();
						})]), Keying.config({
							mode: "special",
							onLeft: handleByBrowser,
							onRight: handleByBrowser,
							onSpace: handleByBrowser,
							onEnter: handleByHighlightedItem,
							onEscape: handleByHighlightedItem,
							onUp: handleByHighlightedItem,
							onDown: handleByHighlightedItem
						})]),
						eventOrder: { keydown: [customSearcherEventsName, Keying.name()] }
					})]
				};
			};
			const searchResultsClass = "tox-collection--results__js";
			const augmentWithAria = (item$1) => {
				var _a;
				if (item$1.dom) return {
					...item$1,
					dom: {
						...item$1.dom,
						attributes: {
							...(_a = item$1.dom.attributes) !== null && _a !== void 0 ? _a : {},
							"id": generate$6("aria-item-search-result-id"),
							"aria-selected": "false"
						}
					}
				};
				else return item$1;
			};
			const chunk = (rowDom, numColumns) => (items) => {
				return map$2(chunk$1(items, numColumns), (c) => ({
					dom: rowDom,
					components: c
				}));
			};
			const forSwatch = (columns) => ({
				dom: {
					tag: "div",
					classes: ["tox-menu", "tox-swatches-menu"]
				},
				components: [{
					dom: {
						tag: "div",
						classes: ["tox-swatches"]
					},
					components: [Menu.parts.items({ preprocess: columns !== "auto" ? chunk({
						tag: "div",
						classes: ["tox-swatches__row"]
					}, columns) : identity })]
				}]
			});
			const forToolbar = (columns) => ({
				dom: {
					tag: "div",
					classes: [
						"tox-menu",
						"tox-collection",
						"tox-collection--toolbar",
						"tox-collection--toolbar-lg"
					]
				},
				components: [Menu.parts.items({ preprocess: chunk({
					tag: "div",
					classes: ["tox-collection__group"]
				}, columns) })]
			});
			const preprocessCollection = (items, isSeparator$3) => {
				const allSplits = [];
				let currentSplit = [];
				each$1(items, (item$1, i) => {
					if (isSeparator$3(item$1, i)) {
						if (currentSplit.length > 0) allSplits.push(currentSplit);
						currentSplit = [];
						if (has$2(item$1.dom, "innerHtml") || item$1.components && item$1.components.length > 0) currentSplit.push(item$1);
					} else currentSplit.push(item$1);
				});
				if (currentSplit.length > 0) allSplits.push(currentSplit);
				return map$2(allSplits, (s) => ({
					dom: {
						tag: "div",
						classes: ["tox-collection__group"]
					},
					components: s
				}));
			};
			const insertItemsPlaceholder = (columns, initItems, onItem) => {
				return Menu.parts.items({ preprocess: (rawItems) => {
					const enrichedItems = map$2(rawItems, onItem);
					if (columns !== "auto" && columns > 1) return chunk({
						tag: "div",
						classes: ["tox-collection__group"]
					}, columns)(enrichedItems);
					else return preprocessCollection(enrichedItems, (_item, i) => initItems[i].type === "separator");
				} });
			};
			const forCollection = (columns, initItems, _hasIcons = true) => ({
				dom: {
					tag: "div",
					classes: ["tox-menu", "tox-collection"].concat(columns === 1 ? ["tox-collection--list"] : ["tox-collection--grid"])
				},
				components: [insertItemsPlaceholder(columns, initItems, identity)]
			});
			const forCollectionWithSearchResults = (columns, initItems, _hasIcons = true) => {
				const ariaControlsSearchResults = generate$6("aria-controls-search-results");
				return {
					dom: {
						tag: "div",
						classes: [
							"tox-menu",
							"tox-collection",
							searchResultsClass
						].concat(columns === 1 ? ["tox-collection--list"] : ["tox-collection--grid"]),
						attributes: { id: ariaControlsSearchResults }
					},
					components: [insertItemsPlaceholder(columns, initItems, augmentWithAria)]
				};
			};
			const forCollectionWithSearchField = (columns, initItems, searchField) => {
				const ariaControlsSearchResults = generate$6("aria-controls-search-results");
				return {
					dom: {
						tag: "div",
						classes: ["tox-menu", "tox-collection"].concat(columns === 1 ? ["tox-collection--list"] : ["tox-collection--grid"])
					},
					components: [renderMenuSearcher({
						i18n: global$8.translate,
						placeholder: searchField.placeholder
					}), {
						dom: {
							tag: "div",
							classes: [...columns === 1 ? ["tox-collection--list"] : ["tox-collection--grid"], searchResultsClass],
							attributes: { id: ariaControlsSearchResults }
						},
						components: [insertItemsPlaceholder(columns, initItems, augmentWithAria)]
					}]
				};
			};
			const forHorizontalCollection = (initItems, _hasIcons = true) => ({
				dom: {
					tag: "div",
					classes: ["tox-collection", "tox-collection--horizontal"]
				},
				components: [Menu.parts.items({ preprocess: (items) => preprocessCollection(items, (_item, i) => initItems[i].type === "separator") })]
			});
			const menuHasIcons = (xs) => exists(xs, (item$1) => "icon" in item$1 && item$1.icon !== void 0);
			const handleError = (error$2) => {
				console.error(formatError(error$2));
				console.log(error$2);
				return Optional.none();
			};
			const createHorizontalPartialMenuWithAlloyItems = (value$5, _hasIcons, items, _columns, _menuLayout) => {
				const structure = forHorizontalCollection(items);
				return {
					value: value$5,
					dom: structure.dom,
					components: structure.components,
					items
				};
			};
			const createPartialMenuWithAlloyItems = (value$5, hasIcons, items, columns, menuLayout) => {
				const getNormalStructure = () => {
					if (menuLayout.menuType !== "searchable") return forCollection(columns, items);
					else return menuLayout.searchMode.searchMode === "search-with-field" ? forCollectionWithSearchField(columns, items, menuLayout.searchMode) : forCollectionWithSearchResults(columns, items);
				};
				if (menuLayout.menuType === "color") {
					const structure = forSwatch(columns);
					return {
						value: value$5,
						dom: structure.dom,
						components: structure.components,
						items
					};
				} else if (menuLayout.menuType === "normal" && columns === "auto") {
					const structure = forCollection(columns, items);
					return {
						value: value$5,
						dom: structure.dom,
						components: structure.components,
						items
					};
				} else if (menuLayout.menuType === "normal" || menuLayout.menuType === "searchable") {
					const structure = getNormalStructure();
					return {
						value: value$5,
						dom: structure.dom,
						components: structure.components,
						items
					};
				} else if (menuLayout.menuType === "listpreview" && columns !== "auto") {
					const structure = forToolbar(columns);
					return {
						value: value$5,
						dom: structure.dom,
						components: structure.components,
						items
					};
				} else return {
					value: value$5,
					dom: dom$1(hasIcons, columns, menuLayout.menuType),
					components,
					items
				};
			};
			const type = requiredString("type");
			const name$1 = requiredString("name");
			const label = requiredString("label");
			const text$1 = requiredString("text");
			const title = requiredString("title");
			const icon = requiredString("icon");
			const value$1 = requiredString("value");
			const fetch$1 = requiredFunction("fetch");
			const getSubmenuItems = requiredFunction("getSubmenuItems");
			const onAction = requiredFunction("onAction");
			const onItemAction = requiredFunction("onItemAction");
			const onSetup = defaultedFunction("onSetup", () => noop);
			const optionalName = optionString("name");
			const optionalText = optionString("text");
			const optionalIcon = optionString("icon");
			const optionalTooltip = optionString("tooltip");
			const optionalLabel = optionString("label");
			const optionalShortcut = optionString("shortcut");
			const optionalSelect = optionFunction("select");
			const active = defaultedBoolean("active", false);
			const borderless = defaultedBoolean("borderless", false);
			const enabled = defaultedBoolean("enabled", true);
			const primary = defaultedBoolean("primary", false);
			const defaultedColumns = (num) => defaulted("columns", num);
			const defaultedMeta = defaulted("meta", {});
			const defaultedOnAction = defaultedFunction("onAction", noop);
			const defaultedType = (type$2) => defaultedString("type", type$2);
			const generatedName = (namePrefix) => field$1("name", "name", defaultedThunk(() => generate$6(`${namePrefix}-name`)), string);
			const generatedValue = (valuePrefix) => field$1("value", "value", defaultedThunk(() => generate$6(`${valuePrefix}-value`)), anyValue());
			const separatorMenuItemSchema = objOf([type, optionalText]);
			const createSeparatorMenuItem = (spec) => asRaw("separatormenuitem", separatorMenuItemSchema, spec);
			const autocompleterItemSchema = objOf([
				defaultedType("autocompleteitem"),
				active,
				enabled,
				defaultedMeta,
				value$1,
				optionalText,
				optionalIcon
			]);
			const createSeparatorItem = (spec) => asRaw("Autocompleter.Separator", separatorMenuItemSchema, spec);
			const createAutocompleterItem = (spec) => asRaw("Autocompleter.Item", autocompleterItemSchema, spec);
			const baseToolbarButtonFields = [
				enabled,
				optionalTooltip,
				optionalIcon,
				optionalText,
				onSetup
			];
			const toolbarButtonSchema = objOf([type, onAction].concat(baseToolbarButtonFields));
			const createToolbarButton = (spec) => asRaw("toolbarbutton", toolbarButtonSchema, spec);
			const baseToolbarToggleButtonFields = [active].concat(baseToolbarButtonFields);
			const toggleButtonSchema = objOf(baseToolbarToggleButtonFields.concat([type, onAction]));
			const createToggleButton = (spec) => asRaw("ToggleButton", toggleButtonSchema, spec);
			const contextBarFields = [
				defaultedFunction("predicate", never),
				defaultedStringEnum("scope", "node", ["node", "editor"]),
				defaultedStringEnum("position", "selection", [
					"node",
					"selection",
					"line"
				])
			];
			const contextButtonFields = baseToolbarButtonFields.concat([
				defaultedType("contextformbutton"),
				primary,
				onAction,
				customField("original", identity)
			]);
			const contextToggleButtonFields = baseToolbarToggleButtonFields.concat([
				defaultedType("contextformbutton"),
				primary,
				onAction,
				customField("original", identity)
			]);
			const launchButtonFields = baseToolbarButtonFields.concat([defaultedType("contextformbutton")]);
			const launchToggleButtonFields = baseToolbarToggleButtonFields.concat([defaultedType("contextformtogglebutton")]);
			const toggleOrNormal = choose$1("type", {
				contextformbutton: contextButtonFields,
				contextformtogglebutton: contextToggleButtonFields
			});
			const contextFormSchema = objOf([
				defaultedType("contextform"),
				defaultedFunction("initValue", constant$1("")),
				optionalLabel,
				requiredArrayOf("commands", toggleOrNormal),
				optionOf("launch", choose$1("type", {
					contextformbutton: launchButtonFields,
					contextformtogglebutton: launchToggleButtonFields
				}))
			].concat(contextBarFields));
			const createContextForm = (spec) => asRaw("ContextForm", contextFormSchema, spec);
			const contextToolbarSchema = objOf([defaultedType("contexttoolbar"), requiredString("items")].concat(contextBarFields));
			const createContextToolbar = (spec) => asRaw("ContextToolbar", contextToolbarSchema, spec);
			const cardImageSchema = objOf([
				type,
				requiredString("src"),
				optionString("alt"),
				defaultedArrayOf("classes", [], string)
			]);
			const cardTextSchema = objOf([
				type,
				text$1,
				optionalName,
				defaultedArrayOf("classes", ["tox-collection__item-label"], string)
			]);
			const itemSchema$1 = valueThunk(() => choose$2("type", {
				cardimage: cardImageSchema,
				cardtext: cardTextSchema,
				cardcontainer: cardContainerSchema
			}));
			const cardContainerSchema = objOf([
				type,
				defaultedString("direction", "horizontal"),
				defaultedString("align", "left"),
				defaultedString("valign", "middle"),
				requiredArrayOf("items", itemSchema$1)
			]);
			const commonMenuItemFields = [
				enabled,
				optionalText,
				optionalShortcut,
				generatedValue("menuitem"),
				defaultedMeta
			];
			const cardMenuItemSchema = objOf([
				type,
				optionalLabel,
				requiredArrayOf("items", itemSchema$1),
				onSetup,
				defaultedOnAction
			].concat(commonMenuItemFields));
			const createCardMenuItem = (spec) => asRaw("cardmenuitem", cardMenuItemSchema, spec);
			const choiceMenuItemSchema = objOf([
				type,
				active,
				optionalIcon
			].concat(commonMenuItemFields));
			const createChoiceMenuItem = (spec) => asRaw("choicemenuitem", choiceMenuItemSchema, spec);
			const baseFields = [
				type,
				requiredString("fancytype"),
				defaultedOnAction
			];
			const fancyMenuItemSchema = choose$1("fancytype", {
				inserttable: [defaulted("initData", {})].concat(baseFields),
				colorswatch: [optionFunction("select"), defaultedObjOf("initData", {}, [
					defaultedBoolean("allowCustomColors", true),
					defaultedString("storageKey", "default"),
					optionArrayOf("colors", anyValue())
				])].concat(baseFields)
			});
			const createFancyMenuItem = (spec) => asRaw("fancymenuitem", fancyMenuItemSchema, spec);
			const menuItemSchema = objOf([
				type,
				onSetup,
				defaultedOnAction,
				optionalIcon
			].concat(commonMenuItemFields));
			const createMenuItem = (spec) => asRaw("menuitem", menuItemSchema, spec);
			const nestedMenuItemSchema = objOf([
				type,
				getSubmenuItems,
				onSetup,
				optionalIcon
			].concat(commonMenuItemFields));
			const createNestedMenuItem = (spec) => asRaw("nestedmenuitem", nestedMenuItemSchema, spec);
			const toggleMenuItemSchema = objOf([
				type,
				optionalIcon,
				active,
				onSetup,
				onAction
			].concat(commonMenuItemFields));
			const createToggleMenuItem = (spec) => asRaw("togglemenuitem", toggleMenuItemSchema, spec);
			const detectSize = (comp, margin, selectorClass) => {
				const descendants$1 = descendants(comp.element, "." + selectorClass);
				if (descendants$1.length > 0) {
					const columnLength = findIndex$1(descendants$1, (c) => {
						const thisTop = c.dom.getBoundingClientRect().top;
						const cTop = descendants$1[0].dom.getBoundingClientRect().top;
						return Math.abs(thisTop - cTop) > margin;
					}).getOr(descendants$1.length);
					return Optional.some({
						numColumns: columnLength,
						numRows: Math.ceil(descendants$1.length / columnLength)
					});
				} else return Optional.none();
			};
			const namedEvents = (name$4, handlers$1) => derive$1([config(name$4, handlers$1)]);
			const unnamedEvents = (handlers$1) => namedEvents(generate$6("unnamed-events"), handlers$1);
			const SimpleBehaviours = {
				namedEvents,
				unnamedEvents
			};
			const ExclusivityChannel = generate$6("tooltip.exclusive");
			const ShowTooltipEvent = generate$6("tooltip.show");
			const HideTooltipEvent = generate$6("tooltip.hide");
			const hideAllExclusive = (component, _tConfig, _tState) => {
				component.getSystem().broadcastOn([ExclusivityChannel], {});
			};
			const setComponents = (component, tConfig, tState, specs) => {
				tState.getTooltip().each((tooltip) => {
					if (tooltip.getSystem().isConnected()) Replacing.set(tooltip, specs);
				});
			};
			var TooltippingApis = /* @__PURE__ */ Object.freeze({
				__proto__: null,
				hideAllExclusive,
				setComponents
			});
			const events$9 = (tooltipConfig, state) => {
				const hide = (comp) => {
					state.getTooltip().each((p) => {
						detach(p);
						tooltipConfig.onHide(comp, p);
						state.clearTooltip();
					});
					state.clearTimer();
				};
				const show$1 = (comp) => {
					if (!state.isShowing()) {
						hideAllExclusive(comp);
						const sink = tooltipConfig.lazySink(comp).getOrDie();
						const popup = comp.getSystem().build({
							dom: tooltipConfig.tooltipDom,
							components: tooltipConfig.tooltipComponents,
							events: derive$2(tooltipConfig.mode === "normal" ? [run$1(mouseover(), (_) => {
								emit(comp, ShowTooltipEvent);
							}), run$1(mouseout(), (_) => {
								emit(comp, HideTooltipEvent);
							})] : []),
							behaviours: derive$1([Replacing.config({})])
						});
						state.setTooltip(popup);
						attach(sink, popup);
						tooltipConfig.onShow(comp, popup);
						Positioning.position(sink, popup, { anchor: tooltipConfig.anchor(comp) });
					}
				};
				return derive$2(flatten([[
					run$1(ShowTooltipEvent, (comp) => {
						state.resetTimer(() => {
							show$1(comp);
						}, tooltipConfig.delay);
					}),
					run$1(HideTooltipEvent, (comp) => {
						state.resetTimer(() => {
							hide(comp);
						}, tooltipConfig.delay);
					}),
					run$1(receive(), (comp, message) => {
						const receivingData = message;
						if (!receivingData.universal) {
							if (contains$2(receivingData.channels, ExclusivityChannel)) hide(comp);
						}
					}),
					runOnDetached((comp) => {
						hide(comp);
					})
				], tooltipConfig.mode === "normal" ? [
					run$1(focusin(), (comp) => {
						emit(comp, ShowTooltipEvent);
					}),
					run$1(postBlur(), (comp) => {
						emit(comp, HideTooltipEvent);
					}),
					run$1(mouseover(), (comp) => {
						emit(comp, ShowTooltipEvent);
					}),
					run$1(mouseout(), (comp) => {
						emit(comp, HideTooltipEvent);
					})
				] : [run$1(highlight$1(), (comp, _se) => {
					emit(comp, ShowTooltipEvent);
				}), run$1(dehighlight$1(), (comp) => {
					emit(comp, HideTooltipEvent);
				})]]));
			};
			var ActiveTooltipping = /* @__PURE__ */ Object.freeze({
				__proto__: null,
				events: events$9
			});
			var TooltippingSchema = [
				required$1("lazySink"),
				required$1("tooltipDom"),
				defaulted("exclusive", true),
				defaulted("tooltipComponents", []),
				defaulted("delay", 300),
				defaultedStringEnum("mode", "normal", ["normal", "follow-highlight"]),
				defaulted("anchor", (comp) => ({
					type: "hotspot",
					hotspot: comp,
					layouts: {
						onLtr: constant$1([
							south$2,
							north$2,
							southeast$2,
							northeast$2,
							southwest$2,
							northwest$2
						]),
						onRtl: constant$1([
							south$2,
							north$2,
							southeast$2,
							northeast$2,
							southwest$2,
							northwest$2
						])
					}
				})),
				onHandler("onHide"),
				onHandler("onShow")
			];
			const init$b = () => {
				const timer = value$2();
				const popup = value$2();
				const clearTimer = () => {
					timer.on(clearTimeout);
				};
				const resetTimer = (f$1, delay) => {
					clearTimer();
					timer.set(setTimeout(f$1, delay));
				};
				const readState = constant$1("not-implemented");
				return nu$8({
					getTooltip: popup.get,
					isShowing: popup.isSet,
					setTooltip: popup.set,
					clearTooltip: popup.clear,
					clearTimer,
					resetTimer,
					readState
				});
			};
			const Tooltipping = create$4({
				fields: TooltippingSchema,
				name: "tooltipping",
				active: ActiveTooltipping,
				state: /* @__PURE__ */ Object.freeze({
					__proto__: null,
					init: init$b
				}),
				apis: TooltippingApis
			});
			const escape$1 = (text$3) => text$3.replace(/[.*+?^${}()|[\]\\]/g, "\\$&");
			const ReadOnlyChannel = "silver.readonly";
			const ReadOnlyDataSchema = objOf([requiredBoolean("readonly")]);
			const broadcastReadonly = (uiRefs, readonly) => {
				const target = uiRefs.mainUi.outerContainer.element;
				const motherships = [uiRefs.mainUi.mothership, ...uiRefs.uiMotherships];
				if (readonly) each$1(motherships, (m) => {
					m.broadcastOn([dismissPopups()], { target });
				});
				each$1(motherships, (m) => {
					m.broadcastOn([ReadOnlyChannel], { readonly });
				});
			};
			const setupReadonlyModeSwitch = (editor, uiRefs) => {
				editor.on("init", () => {
					if (editor.mode.isReadOnly()) broadcastReadonly(uiRefs, true);
				});
				editor.on("SwitchMode", () => broadcastReadonly(uiRefs, editor.mode.isReadOnly()));
				if (isReadOnly(editor)) editor.mode.set("readonly");
			};
			const receivingConfig = () => Receiving.config({ channels: { [ReadOnlyChannel]: {
				schema: ReadOnlyDataSchema,
				onReceive: (comp, data) => {
					Disabling.set(comp, data.readonly);
				}
			} } });
			const item = (disabled) => Disabling.config({
				disabled,
				disableClass: "tox-collection__item--state-disabled"
			});
			const button = (disabled) => Disabling.config({ disabled });
			const splitButton = (disabled) => Disabling.config({
				disabled,
				disableClass: "tox-tbtn--disabled"
			});
			const toolbarButton = (disabled) => Disabling.config({
				disabled,
				disableClass: "tox-tbtn--disabled",
				useNative: false
			});
			const DisablingConfigs = {
				item,
				button,
				splitButton,
				toolbarButton
			};
			const runWithApi = (info, comp) => {
				const api$3 = info.getApi(comp);
				return (f$1) => {
					f$1(api$3);
				};
			};
			const onControlAttached = (info, editorOffCell) => runOnAttached((comp) => {
				runWithApi(info, comp)((api$3) => {
					const onDestroy = info.onSetup(api$3);
					if (isFunction(onDestroy)) editorOffCell.set(onDestroy);
				});
			});
			const onControlDetached = (getApi$1, editorOffCell) => runOnDetached((comp) => runWithApi(getApi$1, comp)(editorOffCell.get()));
			const onMenuItemExecute = (info, itemResponse) => runOnExecute$1((comp, simulatedEvent) => {
				runWithApi(info, comp)(info.onAction);
				if (!info.triggersSubmenu && itemResponse === ItemResponse$1.CLOSE_ON_EXECUTE) {
					if (comp.getSystem().isConnected()) emit(comp, sandboxClose());
					simulatedEvent.stop();
				}
			});
			const menuItemEventOrder = { [execute$5()]: [
				"disabling",
				"alloy.base.behaviour",
				"toggling",
				"item-events"
			] };
			const componentRenderPipeline = cat;
			const renderCommonItem = (spec, structure, itemResponse, providersBackstage) => {
				const editorOffCell = Cell(noop);
				return {
					type: "item",
					dom: structure.dom,
					components: componentRenderPipeline(structure.optComponents),
					data: spec.data,
					eventOrder: menuItemEventOrder,
					hasSubmenu: spec.triggersSubmenu,
					itemBehaviours: derive$1([
						config("item-events", [
							onMenuItemExecute(spec, itemResponse),
							onControlAttached(spec, editorOffCell),
							onControlDetached(spec, editorOffCell)
						]),
						DisablingConfigs.item(() => !spec.enabled || providersBackstage.isDisabled()),
						receivingConfig(),
						Replacing.config({})
					].concat(spec.itemBehaviours))
				};
			};
			const buildData = (source) => ({
				value: source.value,
				meta: {
					text: source.text.getOr(""),
					...source.meta
				}
			});
			const convertText = (source) => {
				const isMac = global$5.os.isMacOS() || global$5.os.isiOS();
				const replace$1 = isMac ? {
					alt: "",
					ctrl: "",
					shift: "",
					meta: "",
					access: ""
				} : {
					meta: "Ctrl",
					access: "Shift+Alt"
				};
				const updated = map$2(source.split("+"), (segment) => {
					const search$1 = segment.toLowerCase().trim();
					return has$2(replace$1, search$1) ? replace$1[search$1] : segment;
				});
				return isMac ? updated.join("") : updated.join("+");
			};
			const renderIcon$2 = (name$4, icons, classes$1 = [iconClass]) => render$3(name$4, {
				tag: "div",
				classes: classes$1
			}, icons);
			const renderText = (text$3) => ({
				dom: {
					tag: "div",
					classes: [textClass]
				},
				components: [text$2(global$8.translate(text$3))]
			});
			const renderHtml = (html$2, classes$1) => ({ dom: {
				tag: "div",
				classes: classes$1,
				innerHtml: html$2
			} });
			const renderStyledText = (style, text$3) => ({
				dom: {
					tag: "div",
					classes: [textClass]
				},
				components: [{
					dom: {
						tag: style.tag,
						styles: style.styles
					},
					components: [text$2(global$8.translate(text$3))]
				}]
			});
			const renderShortcut = (shortcut) => ({
				dom: {
					tag: "div",
					classes: [accessoryClass]
				},
				components: [text$2(convertText(shortcut))]
			});
			const renderCheckmark = (icons) => renderIcon$2("checkmark", icons, [checkmarkClass]);
			const renderSubmenuCaret = (icons) => renderIcon$2("chevron-right", icons, [caretClass]);
			const renderDownwardsCaret = (icons) => renderIcon$2("chevron-down", icons, [caretClass]);
			const renderContainer = (container, components$2) => {
				const directionClass = container.direction === "vertical" ? containerColumnClass : containerRowClass;
				const alignClass = container.align === "left" ? containerAlignLeftClass : containerAlignRightClass;
				const getValignClass = () => {
					switch (container.valign) {
						case "top": return containerValignTopClass;
						case "middle": return containerValignMiddleClass;
						case "bottom": return containerValignBottomClass;
					}
				};
				return {
					dom: {
						tag: "div",
						classes: [
							containerClass,
							directionClass,
							alignClass,
							getValignClass()
						]
					},
					components: components$2
				};
			};
			const renderImage = (src, classes$1, alt) => ({ dom: {
				tag: "img",
				classes: classes$1,
				attributes: {
					src,
					alt: alt.getOr("")
				}
			} });
			const renderColorStructure = (item$1, providerBackstage, fallbackIcon) => {
				const colorPickerCommand = "custom";
				const removeColorCommand = "remove";
				const itemText = item$1.ariaLabel;
				const itemValue = item$1.value;
				const iconSvg = item$1.iconContent.map((name$4) => getOr(name$4, providerBackstage.icons, fallbackIcon));
				const getDom = () => {
					const common = colorClass;
					const icon$1 = iconSvg.getOr("");
					const baseDom = {
						tag: "div",
						attributes: itemText.map((text$3) => ({ title: providerBackstage.translate(text$3) })).getOr({}),
						classes: [common]
					};
					if (itemValue === colorPickerCommand) return {
						...baseDom,
						tag: "button",
						classes: [...baseDom.classes, "tox-swatches__picker-btn"],
						innerHtml: icon$1
					};
					else if (itemValue === removeColorCommand) return {
						...baseDom,
						classes: [...baseDom.classes, "tox-swatch--remove"],
						innerHtml: icon$1
					};
					else if (isNonNullable(itemValue)) return {
						...baseDom,
						attributes: {
							...baseDom.attributes,
							"data-mce-color": itemValue
						},
						styles: { "background-color": itemValue },
						innerHtml: icon$1
					};
					else return baseDom;
				};
				return {
					dom: getDom(),
					optComponents: []
				};
			};
			const renderItemDomStructure = (ariaLabel) => {
				const domTitle = ariaLabel.map((label$1) => ({ attributes: {
					title: global$8.translate(label$1),
					id: generate$6("menu-item")
				} })).getOr({});
				return {
					tag: "div",
					classes: [navClass, selectableClass],
					...domTitle
				};
			};
			const renderNormalItemStructure = (info, providersBackstage, renderIcons, fallbackIcon) => {
				const iconSpec = {
					tag: "div",
					classes: [iconClass]
				};
				const renderIcon$4 = (iconName) => render$3(iconName, iconSpec, providersBackstage.icons, fallbackIcon);
				const renderEmptyIcon = () => Optional.some({ dom: iconSpec });
				const leftIcon = renderIcons ? info.iconContent.map(renderIcon$4).orThunk(renderEmptyIcon) : Optional.none();
				const checkmark = info.checkMark;
				const textRender = Optional.from(info.meta).fold(() => renderText, (meta) => has$2(meta, "style") ? curry(renderStyledText, meta.style) : renderText);
				const content = info.htmlContent.fold(() => info.textContent.map(textRender), (html$2) => Optional.some(renderHtml(html$2, [textClass])));
				return {
					dom: renderItemDomStructure(info.ariaLabel),
					optComponents: [
						leftIcon,
						content,
						info.shortcutContent.map(renderShortcut),
						checkmark,
						info.caret
					]
				};
			};
			const renderItemStructure = (info, providersBackstage, renderIcons, fallbackIcon = Optional.none()) => {
				if (info.presets === "color") return renderColorStructure(info, providersBackstage, fallbackIcon);
				else return renderNormalItemStructure(info, providersBackstage, renderIcons, fallbackIcon);
			};
			const tooltipBehaviour = (meta, sharedBackstage) => get$g(meta, "tooltipWorker").map((tooltipWorker) => [Tooltipping.config({
				lazySink: sharedBackstage.getSink,
				tooltipDom: {
					tag: "div",
					classes: ["tox-tooltip-worker-container"]
				},
				tooltipComponents: [],
				anchor: (comp) => ({
					type: "submenu",
					item: comp,
					overrides: { maxHeightFunction: expandable$1 }
				}),
				mode: "follow-highlight",
				onShow: (component, _tooltip) => {
					tooltipWorker((elm) => {
						Tooltipping.setComponents(component, [external$1({ element: SugarElement.fromDom(elm) })]);
					});
				}
			})]).getOr([]);
			const encodeText = (text$3) => global$7.DOM.encode(text$3);
			const replaceText = (text$3, matchText) => {
				const encoded = encodeText(global$8.translate(text$3));
				if (matchText.length > 0) {
					const escapedMatchRegex = new RegExp(escape$1(matchText), "gi");
					return encoded.replace(escapedMatchRegex, (match) => `<span class="tox-autocompleter-highlight">${match}</span>`);
				} else return encoded;
			};
			const renderAutocompleteItem = (spec, matchText, useText, presets, onItemValueHandler, itemResponse, sharedBackstage, renderIcons = true) => {
				const structure = renderItemStructure({
					presets,
					textContent: Optional.none(),
					htmlContent: useText ? spec.text.map((text$3) => replaceText(text$3, matchText)) : Optional.none(),
					ariaLabel: spec.text,
					iconContent: spec.icon,
					shortcutContent: Optional.none(),
					checkMark: Optional.none(),
					caret: Optional.none(),
					value: spec.value
				}, sharedBackstage.providers, renderIcons, spec.icon);
				return renderCommonItem({
					data: buildData(spec),
					enabled: spec.enabled,
					getApi: constant$1({}),
					onAction: (_api) => onItemValueHandler(spec.value, spec.meta),
					onSetup: constant$1(noop),
					triggersSubmenu: false,
					itemBehaviours: tooltipBehaviour(spec.meta, sharedBackstage)
				}, structure, itemResponse, sharedBackstage.providers);
			};
			const render$2 = (items, extras) => map$2(items, (item$1) => {
				switch (item$1.type) {
					case "cardcontainer": return renderContainer(item$1, render$2(item$1.items, extras));
					case "cardimage": return renderImage(item$1.src, item$1.classes, item$1.alt);
					case "cardtext":
						const matchText = item$1.name.exists((name$4) => contains$2(extras.cardText.highlightOn, name$4)) ? Optional.from(extras.cardText.matchText).getOr("") : "";
						return renderHtml(replaceText(item$1.text, matchText), item$1.classes);
				}
			});
			const renderCardMenuItem = (spec, itemResponse, sharedBackstage, extras) => {
				const getApi$1 = (component) => ({
					isEnabled: () => !Disabling.isDisabled(component),
					setEnabled: (state) => {
						Disabling.set(component, !state);
						each$1(descendants(component.element, "*"), (elm) => {
							component.getSystem().getByDom(elm).each((comp) => {
								if (comp.hasConfigured(Disabling)) Disabling.set(comp, !state);
							});
						});
					}
				});
				const structure = {
					dom: renderItemDomStructure(spec.label),
					optComponents: [Optional.some({
						dom: {
							tag: "div",
							classes: [containerClass, containerRowClass]
						},
						components: render$2(spec.items, extras)
					})]
				};
				return renderCommonItem({
					data: buildData({
						text: Optional.none(),
						...spec
					}),
					enabled: spec.enabled,
					getApi: getApi$1,
					onAction: spec.onAction,
					onSetup: spec.onSetup,
					triggersSubmenu: false,
					itemBehaviours: Optional.from(extras.itemBehaviours).getOr([])
				}, structure, itemResponse, sharedBackstage.providers);
			};
			const renderChoiceItem = (spec, useText, presets, onItemValueHandler, isSelected, itemResponse, providersBackstage, renderIcons = true) => {
				const getApi$1 = (component) => ({
					setActive: (state) => {
						Toggling.set(component, state);
					},
					isActive: () => Toggling.isOn(component),
					isEnabled: () => !Disabling.isDisabled(component),
					setEnabled: (state) => Disabling.set(component, !state)
				});
				const structure = renderItemStructure({
					presets,
					textContent: useText ? spec.text : Optional.none(),
					htmlContent: Optional.none(),
					ariaLabel: spec.text,
					iconContent: spec.icon,
					shortcutContent: useText ? spec.shortcut : Optional.none(),
					checkMark: useText ? Optional.some(renderCheckmark(providersBackstage.icons)) : Optional.none(),
					caret: Optional.none(),
					value: spec.value
				}, providersBackstage, renderIcons);
				return deepMerge(renderCommonItem({
					data: buildData(spec),
					enabled: spec.enabled,
					getApi: getApi$1,
					onAction: (_api) => onItemValueHandler(spec.value),
					onSetup: (api$3) => {
						api$3.setActive(isSelected);
						return noop;
					},
					triggersSubmenu: false,
					itemBehaviours: []
				}, structure, itemResponse, providersBackstage), { toggling: {
					toggleClass: tickedClass,
					toggleOnExecute: false,
					selected: spec.active,
					exclusive: true
				} });
			};
			const parts$f = generate$3(owner$2(), parts$h());
			const hexColour = (value$5) => ({ value: normalizeHex(value$5) });
			const shorthandRegex = /^#?([a-f\d])([a-f\d])([a-f\d])$/i;
			const longformRegex = /^#?([a-f\d]{2})([a-f\d]{2})([a-f\d]{2})$/i;
			const isHexString = (hex) => shorthandRegex.test(hex) || longformRegex.test(hex);
			const normalizeHex = (hex) => removeLeading(hex, "#").toUpperCase();
			const fromString$1 = (hex) => isHexString(hex) ? Optional.some({ value: normalizeHex(hex) }) : Optional.none();
			const getLongForm = (hex) => {
				return { value: hex.value.replace(shorthandRegex, (m, r$2, g, b$1) => r$2 + r$2 + g + g + b$1 + b$1) };
			};
			const extractValues = (hex) => {
				const longForm = getLongForm(hex);
				const splitForm = longformRegex.exec(longForm.value);
				return splitForm === null ? [
					"FFFFFF",
					"FF",
					"FF",
					"FF"
				] : splitForm;
			};
			const toHex = (component) => {
				const hex = component.toString(16);
				return (hex.length === 1 ? "0" + hex : hex).toUpperCase();
			};
			const fromRgba = (rgbaColour$1) => {
				return hexColour(toHex(rgbaColour$1.red) + toHex(rgbaColour$1.green) + toHex(rgbaColour$1.blue));
			};
			const min = Math.min;
			const max = Math.max;
			const round$1 = Math.round;
			const rgbRegex = /^\s*rgb\s*\(\s*(\d+)\s*,\s*(\d+)\s*,\s*(\d+)\s*\)\s*$/i;
			const rgbaRegex = /^\s*rgba\s*\(\s*(\d+)\s*,\s*(\d+)\s*,\s*(\d+)\s*,\s*(\d?(?:\.\d+)?)\s*\)\s*$/i;
			const rgbaColour = (red$1, green, blue, alpha) => ({
				red: red$1,
				green,
				blue,
				alpha
			});
			const isRgbaComponent = (value$5) => {
				const num = parseInt(value$5, 10);
				return num.toString() === value$5 && num >= 0 && num <= 255;
			};
			const fromHsv = (hsv) => {
				let r$2;
				let g;
				let b$1;
				const hue = (hsv.hue || 0) % 360;
				let saturation = hsv.saturation / 100;
				let brightness = hsv.value / 100;
				saturation = max(0, min(saturation, 1));
				brightness = max(0, min(brightness, 1));
				if (saturation === 0) {
					r$2 = g = b$1 = round$1(255 * brightness);
					return rgbaColour(r$2, g, b$1, 1);
				}
				const side = hue / 60;
				const chroma = brightness * saturation;
				const x = chroma * (1 - Math.abs(side % 2 - 1));
				const match = brightness - chroma;
				switch (Math.floor(side)) {
					case 0:
						r$2 = chroma;
						g = x;
						b$1 = 0;
						break;
					case 1:
						r$2 = x;
						g = chroma;
						b$1 = 0;
						break;
					case 2:
						r$2 = 0;
						g = chroma;
						b$1 = x;
						break;
					case 3:
						r$2 = 0;
						g = x;
						b$1 = chroma;
						break;
					case 4:
						r$2 = x;
						g = 0;
						b$1 = chroma;
						break;
					case 5:
						r$2 = chroma;
						g = 0;
						b$1 = x;
						break;
					default: r$2 = g = b$1 = 0;
				}
				r$2 = round$1(255 * (r$2 + match));
				g = round$1(255 * (g + match));
				b$1 = round$1(255 * (b$1 + match));
				return rgbaColour(r$2, g, b$1, 1);
			};
			const fromHex = (hexColour$1) => {
				const result = extractValues(hexColour$1);
				return rgbaColour(parseInt(result[1], 16), parseInt(result[2], 16), parseInt(result[3], 16), 1);
			};
			const fromStringValues = (red$1, green, blue, alpha) => {
				return rgbaColour(parseInt(red$1, 10), parseInt(green, 10), parseInt(blue, 10), parseFloat(alpha));
			};
			const fromString = (rgbaString) => {
				if (rgbaString === "transparent") return Optional.some(rgbaColour(0, 0, 0, 0));
				const rgbMatch = rgbRegex.exec(rgbaString);
				if (rgbMatch !== null) return Optional.some(fromStringValues(rgbMatch[1], rgbMatch[2], rgbMatch[3], "1"));
				const rgbaMatch = rgbaRegex.exec(rgbaString);
				if (rgbaMatch !== null) return Optional.some(fromStringValues(rgbaMatch[1], rgbaMatch[2], rgbaMatch[3], rgbaMatch[4]));
				return Optional.none();
			};
			const toString = (rgba) => `rgba(${rgba.red},${rgba.green},${rgba.blue},${rgba.alpha})`;
			const red = rgbaColour(255, 0, 0, 1);
			const fireSkinLoaded$1 = (editor) => {
				editor.dispatch("SkinLoaded");
			};
			const fireSkinLoadError$1 = (editor, error$2) => {
				editor.dispatch("SkinLoadError", error$2);
			};
			const fireResizeEditor = (editor) => {
				editor.dispatch("ResizeEditor");
			};
			const fireResizeContent = (editor, e) => {
				editor.dispatch("ResizeContent", e);
			};
			const fireScrollContent = (editor, e) => {
				editor.dispatch("ScrollContent", e);
			};
			const fireTextColorChange = (editor, data) => {
				editor.dispatch("TextColorChange", data);
			};
			const fireAfterProgressState = (editor, state) => {
				editor.dispatch("AfterProgressState", { state });
			};
			const fireResolveName = (editor, node) => editor.dispatch("ResolveName", {
				name: node.nodeName.toLowerCase(),
				target: node
			});
			const fireToggleToolbarDrawer = (editor, state) => {
				editor.dispatch("ToggleToolbarDrawer", { state });
			};
			const composeUnbinders = (f$1, g) => () => {
				f$1();
				g();
			};
			const onSetupEditableToggle = (editor) => onSetupEvent(editor, "NodeChange", (api$3) => {
				api$3.setEnabled(editor.selection.isEditable());
			});
			const onSetupFormatToggle = (editor, name$4) => (api$3) => {
				const boundFormatChangeCallback = unbindable();
				const init$10 = () => {
					api$3.setActive(editor.formatter.match(name$4));
					const binding = editor.formatter.formatChanged(name$4, api$3.setActive);
					boundFormatChangeCallback.set(binding);
				};
				editor.initialized ? init$10() : editor.once("init", init$10);
				return () => {
					editor.off("init", init$10);
					boundFormatChangeCallback.clear();
				};
			};
			const onSetupStateToggle = (editor, name$4) => (api$3) => {
				const unbindEditableToogle = onSetupEditableToggle(editor)(api$3);
				const unbindFormatToggle = onSetupFormatToggle(editor, name$4)(api$3);
				return () => {
					unbindEditableToogle();
					unbindFormatToggle();
				};
			};
			const onSetupEvent = (editor, event, f$1) => (api$3) => {
				const handleEvent = () => f$1(api$3);
				const init$10 = () => {
					f$1(api$3);
					editor.on(event, handleEvent);
				};
				editor.initialized ? init$10() : editor.once("init", init$10);
				return () => {
					editor.off("init", init$10);
					editor.off(event, handleEvent);
				};
			};
			const onActionToggleFormat$1 = (editor) => (rawItem) => () => {
				editor.undoManager.transact(() => {
					editor.focus();
					editor.execCommand("mceToggleFormat", false, rawItem.format);
				});
			};
			const onActionExecCommand = (editor, command) => () => editor.execCommand(command);
			var global$4 = tinymce.util.Tools.resolve("tinymce.util.LocalStorage");
			const cacheStorage = {};
			const ColorCache = (storageId, max$1 = 10) => {
				const storageString = global$4.getItem(storageId);
				const localstorage = isString(storageString) ? JSON.parse(storageString) : [];
				const prune = (list) => {
					return max$1 - list.length < 0 ? list.slice(0, max$1) : list;
				};
				const cache = prune(localstorage);
				const add$5 = (key) => {
					indexOf(cache, key).each(remove$8);
					cache.unshift(key);
					if (cache.length > max$1) cache.pop();
					global$4.setItem(storageId, JSON.stringify(cache));
				};
				const remove$8 = (idx) => {
					cache.splice(idx, 1);
				};
				const state = () => cache.slice(0);
				return {
					add: add$5,
					state
				};
			};
			const getCacheForId = (id) => get$g(cacheStorage, id).getOrThunk(() => {
				const storageId = `tinymce-custom-colors-${id}`;
				if (isNullable(global$4.getItem(storageId))) {
					const legacyDefault = global$4.getItem("tinymce-custom-colors");
					global$4.setItem(storageId, isNonNullable(legacyDefault) ? legacyDefault : "[]");
				}
				const storage = ColorCache(storageId, 10);
				cacheStorage[id] = storage;
				return storage;
			});
			const getCurrentColors = (id) => map$2(getCacheForId(id).state(), (color) => ({
				type: "choiceitem",
				text: color,
				icon: "checkmark",
				value: color
			}));
			const addColor = (id, color) => {
				getCacheForId(id).add(color);
			};
			const hsvColour = (hue, saturation, value$5) => ({
				hue,
				saturation,
				value: value$5
			});
			const fromRgb = (rgbaColour$1) => {
				let h = 0;
				let s = 0;
				let v = 0;
				const r$2 = rgbaColour$1.red / 255;
				const g = rgbaColour$1.green / 255;
				const b$1 = rgbaColour$1.blue / 255;
				const minRGB = Math.min(r$2, Math.min(g, b$1));
				const maxRGB = Math.max(r$2, Math.max(g, b$1));
				if (minRGB === maxRGB) {
					v = minRGB;
					return hsvColour(0, 0, v * 100);
				}
				const d = r$2 === minRGB ? g - b$1 : b$1 === minRGB ? r$2 - g : b$1 - r$2;
				h = r$2 === minRGB ? 3 : b$1 === minRGB ? 1 : 5;
				h = 60 * (h - d / (maxRGB - minRGB));
				s = (maxRGB - minRGB) / maxRGB;
				v = maxRGB;
				return hsvColour(Math.round(h), Math.round(s * 100), Math.round(v * 100));
			};
			const hexToHsv = (hex) => fromRgb(fromHex(hex));
			const hsvToHex = (hsv) => fromRgba(fromHsv(hsv));
			const anyToHex = (color) => fromString$1(color).orThunk(() => fromString(color).map(fromRgba)).getOrThunk(() => {
				const canvas = document.createElement("canvas");
				canvas.height = 1;
				canvas.width = 1;
				const canvasContext = canvas.getContext("2d");
				canvasContext.clearRect(0, 0, canvas.width, canvas.height);
				canvasContext.fillStyle = "#FFFFFF";
				canvasContext.fillStyle = color;
				canvasContext.fillRect(0, 0, 1, 1);
				const rgba = canvasContext.getImageData(0, 0, 1, 1).data;
				const r$2 = rgba[0];
				const g = rgba[1];
				const b$1 = rgba[2];
				const a = rgba[3];
				return fromRgba(rgbaColour(r$2, g, b$1, a));
			});
			const foregroundId = "forecolor";
			const backgroundId = "hilitecolor";
			const fallbackCols = 5;
			const mapColors = (colorMap) => {
				const colors = [];
				for (let i = 0; i < colorMap.length; i += 2) colors.push({
					text: colorMap[i + 1],
					value: "#" + anyToHex(colorMap[i]).value,
					icon: "checkmark",
					type: "choiceitem"
				});
				return colors;
			};
			const option$1 = (name$4) => (editor) => editor.options.get(name$4);
			const fallbackColor = "#000000";
			const register$d = (editor) => {
				const registerOption = editor.options.register;
				const colorProcessor = (value$5) => {
					if (isArrayOf(value$5, isString)) return {
						value: mapColors(value$5),
						valid: true
					};
					else return {
						valid: false,
						message: "Must be an array of strings."
					};
				};
				const colorColsProcessor = (value$5) => {
					if (isNumber(value$5) && value$5 > 0) return {
						value: value$5,
						valid: true
					};
					else return {
						valid: false,
						message: "Must be a positive number."
					};
				};
				registerOption("color_map", {
					processor: colorProcessor,
					default: [
						"#BFEDD2",
						"Light Green",
						"#FBEEB8",
						"Light Yellow",
						"#F8CAC6",
						"Light Red",
						"#ECCAFA",
						"Light Purple",
						"#C2E0F4",
						"Light Blue",
						"#2DC26B",
						"Green",
						"#F1C40F",
						"Yellow",
						"#E03E2D",
						"Red",
						"#B96AD9",
						"Purple",
						"#3598DB",
						"Blue",
						"#169179",
						"Dark Turquoise",
						"#E67E23",
						"Orange",
						"#BA372A",
						"Dark Red",
						"#843FA1",
						"Dark Purple",
						"#236FA1",
						"Dark Blue",
						"#ECF0F1",
						"Light Gray",
						"#CED4D9",
						"Medium Gray",
						"#95A5A6",
						"Gray",
						"#7E8C8D",
						"Dark Gray",
						"#34495E",
						"Navy Blue",
						"#000000",
						"Black",
						"#ffffff",
						"White"
					]
				});
				registerOption("color_map_background", { processor: colorProcessor });
				registerOption("color_map_foreground", { processor: colorProcessor });
				registerOption("color_cols", {
					processor: colorColsProcessor,
					default: calcCols(editor)
				});
				registerOption("color_cols_foreground", {
					processor: colorColsProcessor,
					default: defaultCols(editor, foregroundId)
				});
				registerOption("color_cols_background", {
					processor: colorColsProcessor,
					default: defaultCols(editor, backgroundId)
				});
				registerOption("custom_colors", {
					processor: "boolean",
					default: true
				});
				registerOption("color_default_foreground", {
					processor: "string",
					default: fallbackColor
				});
				registerOption("color_default_background", {
					processor: "string",
					default: fallbackColor
				});
			};
			const getColors$2 = (editor, id) => {
				if (id === foregroundId && editor.options.isSet("color_map_foreground")) return option$1("color_map_foreground")(editor);
				else if (id === backgroundId && editor.options.isSet("color_map_background")) return option$1("color_map_background")(editor);
				else return option$1("color_map")(editor);
			};
			const calcCols = (editor, id = "default") => Math.max(fallbackCols, Math.ceil(Math.sqrt(getColors$2(editor, id).length)));
			const defaultCols = (editor, id) => {
				const defaultCols$1 = option$1("color_cols")(editor);
				const calculatedCols = calcCols(editor, id);
				if (defaultCols$1 === calcCols(editor)) return calculatedCols;
				else return defaultCols$1;
			};
			const getColorCols$1 = (editor, id = "default") => {
				const getCols = () => {
					if (id === foregroundId) return option$1("color_cols_foreground")(editor);
					else if (id === backgroundId) return option$1("color_cols_background")(editor);
					else return option$1("color_cols")(editor);
				};
				return Math.round(getCols());
			};
			const hasCustomColors$1 = option$1("custom_colors");
			const getDefaultForegroundColor = option$1("color_default_foreground");
			const getDefaultBackgroundColor = option$1("color_default_background");
			const defaultBackgroundColor = "rgba(0, 0, 0, 0)";
			const isValidBackgroundColor = (value$5) => fromString(value$5).exists((c) => c.alpha !== 0);
			const getClosestCssBackgroundColorValue = (scope) => {
				return closest$4(scope, (node) => {
					if (isElement$1(node)) {
						const color = get$e(node, "background-color");
						return someIf(isValidBackgroundColor(color), color);
					} else return Optional.none();
				}).getOr(defaultBackgroundColor);
			};
			const getCurrentColor = (editor, format) => {
				const node = SugarElement.fromDom(editor.selection.getStart());
				return fromString(format === "hilitecolor" ? getClosestCssBackgroundColorValue(node) : get$e(node, "color")).map((rgba) => "#" + fromRgba(rgba).value);
			};
			const applyFormat = (editor, format, value$5) => {
				editor.undoManager.transact(() => {
					editor.focus();
					editor.formatter.apply(format, { value: value$5 });
					editor.nodeChanged();
				});
			};
			const removeFormat = (editor, format) => {
				editor.undoManager.transact(() => {
					editor.focus();
					editor.formatter.remove(format, { value: null }, void 0, true);
					editor.nodeChanged();
				});
			};
			const registerCommands = (editor) => {
				editor.addCommand("mceApplyTextcolor", (format, value$5) => {
					applyFormat(editor, format, value$5);
				});
				editor.addCommand("mceRemoveTextcolor", (format) => {
					removeFormat(editor, format);
				});
			};
			const getAdditionalColors = (hasCustom) => {
				const type$2 = "choiceitem";
				const remove$8 = {
					type: type$2,
					text: "Remove color",
					icon: "color-swatch-remove-color",
					value: "remove"
				};
				return hasCustom ? [remove$8, {
					type: type$2,
					text: "Custom color",
					icon: "color-picker",
					value: "custom"
				}] : [remove$8];
			};
			const applyColor = (editor, format, value$5, onChoice) => {
				if (value$5 === "custom") colorPickerDialog(editor)((colorOpt) => {
					colorOpt.each((color) => {
						addColor(format, color);
						editor.execCommand("mceApplyTextcolor", format, color);
						onChoice(color);
					});
				}, getCurrentColor(editor, format).getOr(fallbackColor));
				else if (value$5 === "remove") {
					onChoice("");
					editor.execCommand("mceRemoveTextcolor", format);
				} else {
					onChoice(value$5);
					editor.execCommand("mceApplyTextcolor", format, value$5);
				}
			};
			const getColors$1 = (colors, id, hasCustom) => colors.concat(getCurrentColors(id).concat(getAdditionalColors(hasCustom)));
			const getFetch$1 = (colors, id, hasCustom) => (callback) => {
				callback(getColors$1(colors, id, hasCustom));
			};
			const setIconColor = (splitButtonApi, name$4, newColor) => {
				const id = name$4 === "forecolor" ? "tox-icon-text-color__color" : "tox-icon-highlight-bg-color__color";
				splitButtonApi.setIconFill(id, newColor);
			};
			const select$1 = (editor, format) => (value$5) => {
				return is$1(getCurrentColor(editor, format), value$5.toUpperCase());
			};
			const registerTextColorButton = (editor, name$4, format, tooltip, lastColor) => {
				editor.ui.registry.addSplitButton(name$4, {
					tooltip,
					presets: "color",
					icon: name$4 === "forecolor" ? "text-color" : "highlight-bg-color",
					select: select$1(editor, format),
					columns: getColorCols$1(editor, format),
					fetch: getFetch$1(getColors$2(editor, format), format, hasCustomColors$1(editor)),
					onAction: (_splitButtonApi) => {
						applyColor(editor, format, lastColor.get(), noop);
					},
					onItemAction: (_splitButtonApi, value$5) => {
						applyColor(editor, format, value$5, (newColor) => {
							lastColor.set(newColor);
							fireTextColorChange(editor, {
								name: name$4,
								color: newColor
							});
						});
					},
					onSetup: (splitButtonApi) => {
						setIconColor(splitButtonApi, name$4, lastColor.get());
						const handler = (e) => {
							if (e.name === name$4) setIconColor(splitButtonApi, e.name, e.color);
						};
						editor.on("TextColorChange", handler);
						return composeUnbinders(onSetupEditableToggle(editor)(splitButtonApi), () => {
							editor.off("TextColorChange", handler);
						});
					}
				});
			};
			const registerTextColorMenuItem = (editor, name$4, format, text$3, lastColor) => {
				editor.ui.registry.addNestedMenuItem(name$4, {
					text: text$3,
					icon: name$4 === "forecolor" ? "text-color" : "highlight-bg-color",
					onSetup: (api$3) => {
						setIconColor(api$3, name$4, lastColor.get());
						return onSetupEditableToggle(editor)(api$3);
					},
					getSubmenuItems: () => [{
						type: "fancymenuitem",
						fancytype: "colorswatch",
						select: select$1(editor, format),
						initData: { storageKey: format },
						onAction: (data) => {
							applyColor(editor, format, data.value, (newColor) => {
								lastColor.set(newColor);
								fireTextColorChange(editor, {
									name: name$4,
									color: newColor
								});
							});
						}
					}]
				});
			};
			const colorPickerDialog = (editor) => (callback, value$5) => {
				let isValid = false;
				const onSubmit = (api$3) => {
					const hex = api$3.getData().colorpicker;
					if (isValid) {
						callback(Optional.from(hex));
						api$3.close();
					} else editor.windowManager.alert(editor.translate(["Invalid hex color code: {0}", hex]));
				};
				const onAction$1 = (_api, details) => {
					if (details.name === "hex-valid") isValid = details.value;
				};
				const initialData = { colorpicker: value$5 };
				editor.windowManager.open({
					title: "Color Picker",
					size: "normal",
					body: {
						type: "panel",
						items: [{
							type: "colorpicker",
							name: "colorpicker",
							label: "Color"
						}]
					},
					buttons: [{
						type: "cancel",
						name: "cancel",
						text: "Cancel"
					}, {
						type: "submit",
						name: "save",
						text: "Save",
						primary: true
					}],
					initialData,
					onAction: onAction$1,
					onSubmit,
					onClose: noop,
					onCancel: () => {
						callback(Optional.none());
					}
				});
			};
			const register$c = (editor) => {
				registerCommands(editor);
				const fallbackColorForeground = getDefaultForegroundColor(editor);
				const fallbackColorBackground = getDefaultBackgroundColor(editor);
				const lastForeColor = Cell(fallbackColorForeground);
				const lastBackColor = Cell(fallbackColorBackground);
				registerTextColorButton(editor, "forecolor", "forecolor", "Text color", lastForeColor);
				registerTextColorButton(editor, "backcolor", "hilitecolor", "Background color", lastBackColor);
				registerTextColorMenuItem(editor, "forecolor", "forecolor", "Text color", lastForeColor);
				registerTextColorMenuItem(editor, "backcolor", "hilitecolor", "Background color", lastBackColor);
			};
			const createPartialChoiceMenu = (value$5, items, onItemValueHandler, columns, presets, itemResponse, select$2, providersBackstage) => {
				return createPartialMenuWithAlloyItems(value$5, menuHasIcons(items), createChoiceItems(items, onItemValueHandler, columns, presets !== "color" ? "normal" : "color", itemResponse, select$2, providersBackstage), columns, { menuType: presets });
			};
			const createChoiceItems = (items, onItemValueHandler, columns, itemPresets, itemResponse, select$2, providersBackstage) => cat(map$2(items, (item$1) => {
				if (item$1.type === "choiceitem") return createChoiceMenuItem(item$1).fold(handleError, (d) => Optional.some(renderChoiceItem(d, columns === 1, itemPresets, onItemValueHandler, select$2(d.value), itemResponse, providersBackstage, menuHasIcons(items))));
				else return Optional.none();
			}));
			const deriveMenuMovement = (columns, presets) => {
				const menuMarkers = markers(presets);
				if (columns === 1) return {
					mode: "menu",
					moveOnTab: true
				};
				else if (columns === "auto") return {
					mode: "grid",
					selector: "." + menuMarkers.item,
					initSize: {
						numColumns: 1,
						numRows: 1
					}
				};
				else return {
					mode: "matrix",
					rowSelector: "." + (presets === "color" ? "tox-swatches__row" : "tox-collection__group"),
					previousSelector: (menu$1) => {
						return presets === "color" ? descendant(menu$1.element, "[aria-checked=true]") : Optional.none();
					}
				};
			};
			const deriveCollectionMovement = (columns, presets) => {
				if (columns === 1) return {
					mode: "menu",
					moveOnTab: false,
					selector: ".tox-collection__item"
				};
				else if (columns === "auto") return {
					mode: "flatgrid",
					selector: ".tox-collection__item",
					initSize: {
						numColumns: 1,
						numRows: 1
					}
				};
				else return {
					mode: "matrix",
					selectors: {
						row: presets === "color" ? ".tox-swatches__row" : ".tox-collection__group",
						cell: presets === "color" ? `.${colorClass}` : `.${selectableClass}`
					}
				};
			};
			const renderColorSwatchItem = (spec, backstage) => {
				const items = getColorItems(spec, backstage);
				const columns = backstage.colorinput.getColorCols(spec.initData.storageKey);
				const presets = "color";
				const widgetSpec = {
					...createPartialChoiceMenu(generate$6("menu-value"), items, (value$5) => {
						spec.onAction({ value: value$5 });
					}, columns, presets, ItemResponse$1.CLOSE_ON_EXECUTE, spec.select.getOr(never), backstage.shared.providers),
					markers: markers(presets),
					movement: deriveMenuMovement(columns, presets)
				};
				return {
					type: "widget",
					data: { value: generate$6("widget-id") },
					dom: {
						tag: "div",
						classes: ["tox-fancymenuitem"]
					},
					autofocus: true,
					components: [parts$f.widget(Menu.sketch(widgetSpec))]
				};
			};
			const getColorItems = (spec, backstage) => {
				const useCustomColors = spec.initData.allowCustomColors && backstage.colorinput.hasCustomColors();
				return spec.initData.colors.fold(() => getColors$1(backstage.colorinput.getColors(spec.initData.storageKey), spec.initData.storageKey, useCustomColors), (colors) => colors.concat(getAdditionalColors(useCustomColors)));
			};
			const cellOverEvent = generate$6("cell-over");
			const cellExecuteEvent = generate$6("cell-execute");
			const makeAnnouncementText = (backstage) => (row, col) => backstage.shared.providers.translate(`${col} columns, ${row} rows`);
			const makeCell = (row, col, label$1) => {
				const emitCellOver = (c) => emitWith(c, cellOverEvent, {
					row,
					col
				});
				const emitExecute$1 = (c) => emitWith(c, cellExecuteEvent, {
					row,
					col
				});
				const onClick = (c, se) => {
					se.stop();
					emitExecute$1(c);
				};
				return build$1({
					dom: {
						tag: "div",
						attributes: {
							role: "button",
							["aria-label"]: label$1
						}
					},
					behaviours: derive$1([
						config("insert-table-picker-cell", [
							run$1(mouseover(), Focusing.focus),
							run$1(execute$5(), emitExecute$1),
							run$1(click(), onClick),
							run$1(tap(), onClick)
						]),
						Toggling.config({
							toggleClass: "tox-insert-table-picker__selected",
							toggleOnExecute: false
						}),
						Focusing.config({ onFocus: emitCellOver })
					])
				});
			};
			const makeCells = (getCellLabel, numRows, numCols) => {
				const cells = [];
				for (let i = 0; i < numRows; i++) {
					const row = [];
					for (let j = 0; j < numCols; j++) {
						const label$1 = getCellLabel(i + 1, j + 1);
						row.push(makeCell(i, j, label$1));
					}
					cells.push(row);
				}
				return cells;
			};
			const selectCells = (cells, selectedRow, selectedColumn, numRows, numColumns) => {
				for (let i = 0; i < numRows; i++) for (let j = 0; j < numColumns; j++) Toggling.set(cells[i][j], i <= selectedRow && j <= selectedColumn);
			};
			const makeComponents = (cells) => bind$3(cells, (cellRow) => map$2(cellRow, premade));
			const makeLabelText = (row, col) => text$2(`${col}x${row}`);
			const renderInsertTableMenuItem = (spec, backstage) => {
				const numRows = 10;
				const numColumns = 10;
				const cells = makeCells(makeAnnouncementText(backstage), numRows, numColumns);
				const emptyLabelText = makeLabelText(0, 0);
				const memLabel = record({
					dom: {
						tag: "span",
						classes: ["tox-insert-table-picker__label"]
					},
					components: [emptyLabelText],
					behaviours: derive$1([Replacing.config({})])
				});
				return {
					type: "widget",
					data: { value: generate$6("widget-id") },
					dom: {
						tag: "div",
						classes: ["tox-fancymenuitem"]
					},
					autofocus: true,
					components: [parts$f.widget({
						dom: {
							tag: "div",
							classes: ["tox-insert-table-picker"]
						},
						components: makeComponents(cells).concat(memLabel.asSpec()),
						behaviours: derive$1([config("insert-table-picker", [
							runOnAttached((c) => {
								Replacing.set(memLabel.get(c), [emptyLabelText]);
							}),
							runWithTarget(cellOverEvent, (c, t$1, e) => {
								const { row, col } = e.event;
								selectCells(cells, row, col, numRows, numColumns);
								Replacing.set(memLabel.get(c), [makeLabelText(row + 1, col + 1)]);
							}),
							runWithTarget(cellExecuteEvent, (c, _, e) => {
								const { row, col } = e.event;
								spec.onAction({
									numRows: row + 1,
									numColumns: col + 1
								});
								emit(c, sandboxClose());
							})
						]), Keying.config({
							initSize: {
								numRows,
								numColumns
							},
							mode: "flatgrid",
							selector: "[role=\"button\"]"
						})])
					})]
				};
			};
			const fancyMenuItems = {
				inserttable: renderInsertTableMenuItem,
				colorswatch: renderColorSwatchItem
			};
			const renderFancyMenuItem = (spec, backstage) => get$g(fancyMenuItems, spec.fancytype).map((render$4) => render$4(spec, backstage));
			const renderNestedItem = (spec, itemResponse, providersBackstage, renderIcons = true, downwardsCaret = false) => {
				const caret = downwardsCaret ? renderDownwardsCaret(providersBackstage.icons) : renderSubmenuCaret(providersBackstage.icons);
				const getApi$1 = (component) => ({
					isEnabled: () => !Disabling.isDisabled(component),
					setEnabled: (state) => Disabling.set(component, !state),
					setIconFill: (id, value$5) => {
						descendant(component.element, `svg path[class="${id}"], rect[class="${id}"]`).each((underlinePath) => {
							set$9(underlinePath, "fill", value$5);
						});
					}
				});
				const structure = renderItemStructure({
					presets: "normal",
					iconContent: spec.icon,
					textContent: spec.text,
					htmlContent: Optional.none(),
					ariaLabel: spec.text,
					caret: Optional.some(caret),
					checkMark: Optional.none(),
					shortcutContent: spec.shortcut
				}, providersBackstage, renderIcons);
				return renderCommonItem({
					data: buildData(spec),
					getApi: getApi$1,
					enabled: spec.enabled,
					onAction: noop,
					onSetup: spec.onSetup,
					triggersSubmenu: true,
					itemBehaviours: []
				}, structure, itemResponse, providersBackstage);
			};
			const renderNormalItem = (spec, itemResponse, providersBackstage, renderIcons = true) => {
				const getApi$1 = (component) => ({
					isEnabled: () => !Disabling.isDisabled(component),
					setEnabled: (state) => Disabling.set(component, !state)
				});
				const structure = renderItemStructure({
					presets: "normal",
					iconContent: spec.icon,
					textContent: spec.text,
					htmlContent: Optional.none(),
					ariaLabel: spec.text,
					caret: Optional.none(),
					checkMark: Optional.none(),
					shortcutContent: spec.shortcut
				}, providersBackstage, renderIcons);
				return renderCommonItem({
					data: buildData(spec),
					getApi: getApi$1,
					enabled: spec.enabled,
					onAction: spec.onAction,
					onSetup: spec.onSetup,
					triggersSubmenu: false,
					itemBehaviours: []
				}, structure, itemResponse, providersBackstage);
			};
			const renderSeparatorItem = (spec) => ({
				type: "separator",
				dom: {
					tag: "div",
					classes: [selectableClass, groupHeadingClass]
				},
				components: spec.text.map(text$2).toArray()
			});
			const renderToggleMenuItem = (spec, itemResponse, providersBackstage, renderIcons = true) => {
				const getApi$1 = (component) => ({
					setActive: (state) => {
						Toggling.set(component, state);
					},
					isActive: () => Toggling.isOn(component),
					isEnabled: () => !Disabling.isDisabled(component),
					setEnabled: (state) => Disabling.set(component, !state)
				});
				const structure = renderItemStructure({
					iconContent: spec.icon,
					textContent: spec.text,
					htmlContent: Optional.none(),
					ariaLabel: spec.text,
					checkMark: Optional.some(renderCheckmark(providersBackstage.icons)),
					caret: Optional.none(),
					shortcutContent: spec.shortcut,
					presets: "normal",
					meta: spec.meta
				}, providersBackstage, renderIcons);
				return deepMerge(renderCommonItem({
					data: buildData(spec),
					enabled: spec.enabled,
					getApi: getApi$1,
					onAction: spec.onAction,
					onSetup: spec.onSetup,
					triggersSubmenu: false,
					itemBehaviours: []
				}, structure, itemResponse, providersBackstage), { toggling: {
					toggleClass: tickedClass,
					toggleOnExecute: false,
					selected: spec.active
				} });
			};
			const autocomplete = renderAutocompleteItem;
			const separator$3 = renderSeparatorItem;
			const normal = renderNormalItem;
			const nested = renderNestedItem;
			const toggle$1 = renderToggleMenuItem;
			const fancy = renderFancyMenuItem;
			const card = renderCardMenuItem;
			const getCoupled = (component, coupleConfig, coupleState, name$4) => coupleState.getOrCreate(component, coupleConfig, name$4);
			const getExistingCoupled = (component, coupleConfig, coupleState, name$4) => coupleState.getExisting(component, coupleConfig, name$4);
			var CouplingApis = /* @__PURE__ */ Object.freeze({
				__proto__: null,
				getCoupled,
				getExistingCoupled
			});
			var CouplingSchema = [requiredOf("others", setOf(Result.value, anyValue()))];
			const init$a = () => {
				const coupled = {};
				const lookupCoupled = (coupleConfig, coupledName) => {
					if (keys(coupleConfig.others).length === 0) throw new Error("Cannot find any known coupled components");
					else return get$g(coupled, coupledName);
				};
				const getOrCreate = (component, coupleConfig, name$4) => {
					return lookupCoupled(coupleConfig, name$4).getOrThunk(() => {
						const spec = get$g(coupleConfig.others, name$4).getOrDie("No information found for coupled component: " + name$4)(component);
						const built = component.getSystem().build(spec);
						coupled[name$4] = built;
						return built;
					});
				};
				const getExisting = (component, coupleConfig, name$4) => {
					return lookupCoupled(coupleConfig, name$4).orThunk(() => {
						get$g(coupleConfig.others, name$4).getOrDie("No information found for coupled component: " + name$4);
						return Optional.none();
					});
				};
				return nu$8({
					readState: constant$1({}),
					getExisting,
					getOrCreate
				});
			};
			const Coupling = create$4({
				fields: CouplingSchema,
				name: "coupling",
				apis: CouplingApis,
				state: /* @__PURE__ */ Object.freeze({
					__proto__: null,
					init: init$a
				})
			});
			const nu$3 = (baseFn) => {
				let data = Optional.none();
				let callbacks = [];
				const map$3 = (f$1) => nu$3((nCallback) => {
					get$10((data$1) => {
						nCallback(f$1(data$1));
					});
				});
				const get$10 = (nCallback) => {
					if (isReady()) call(nCallback);
					else callbacks.push(nCallback);
				};
				const set$10 = (x) => {
					if (!isReady()) {
						data = Optional.some(x);
						run$2(callbacks);
						callbacks = [];
					}
				};
				const isReady = () => data.isSome();
				const run$2 = (cbs) => {
					each$1(cbs, call);
				};
				const call = (cb) => {
					data.each((x) => {
						setTimeout(() => {
							cb(x);
						}, 0);
					});
				};
				baseFn(set$10);
				return {
					get: get$10,
					map: map$3,
					isReady
				};
			};
			const pure$1 = (a) => nu$3((callback) => {
				callback(a);
			});
			const LazyValue = {
				nu: nu$3,
				pure: pure$1
			};
			const errorReporter = (err) => {
				setTimeout(() => {
					throw err;
				}, 0);
			};
			const make$5 = (run$2) => {
				const get$10 = (callback) => {
					run$2().then(callback, errorReporter);
				};
				const map$3 = (fab) => {
					return make$5(() => run$2().then(fab));
				};
				const bind$4 = (aFutureB) => {
					return make$5(() => run$2().then((v) => aFutureB(v).toPromise()));
				};
				const anonBind = (futureB) => {
					return make$5(() => run$2().then(() => futureB.toPromise()));
				};
				const toLazy = () => {
					return LazyValue.nu(get$10);
				};
				const toCached = () => {
					let cache = null;
					return make$5(() => {
						if (cache === null) cache = run$2();
						return cache;
					});
				};
				return {
					map: map$3,
					bind: bind$4,
					anonBind,
					toLazy,
					toCached,
					toPromise: run$2,
					get: get$10
				};
			};
			const nu$2 = (baseFn) => {
				return make$5(() => new Promise(baseFn));
			};
			const pure = (a) => {
				return make$5(() => Promise.resolve(a));
			};
			const Future = {
				nu: nu$2,
				pure
			};
			const suffix = constant$1("sink");
			const partType$1 = constant$1(optional({
				name: suffix(),
				overrides: constant$1({
					dom: { tag: "div" },
					behaviours: derive$1([Positioning.config({ useFixed: always })]),
					events: derive$2([
						cutter(keydown()),
						cutter(mousedown()),
						cutter(click())
					])
				})
			}));
			const getAnchor = (detail, component) => {
				const hotspot = detail.getHotspot(component).getOr(component);
				const type$2 = "hotspot";
				const overrides = detail.getAnchorOverrides();
				return detail.layouts.fold(() => ({
					type: type$2,
					hotspot,
					overrides
				}), (layouts$1) => ({
					type: type$2,
					hotspot,
					overrides,
					layouts: layouts$1
				}));
			};
			const fetch$2 = (detail, mapFetch, component) => {
				const fetcher = detail.fetch;
				return fetcher(component).map(mapFetch);
			};
			const openF = (detail, mapFetch, anchor$1, component, sandbox, externals, highlightOnOpen) => {
				const futureData = fetch$2(detail, mapFetch, component);
				const getLazySink = getSink(component, detail);
				return futureData.map((tdata) => tdata.bind((data) => Optional.from(tieredMenu.sketch({
					...externals.menu(),
					uid: generate$5(""),
					data,
					highlightOnOpen,
					onOpenMenu: (tmenu, menu$1) => {
						const sink = getLazySink().getOrDie();
						Positioning.position(sink, menu$1, { anchor: anchor$1 });
						Sandboxing.decloak(sandbox);
					},
					onOpenSubmenu: (tmenu, item$1, submenu) => {
						const sink = getLazySink().getOrDie();
						Positioning.position(sink, submenu, { anchor: {
							type: "submenu",
							item: item$1
						} });
						Sandboxing.decloak(sandbox);
					},
					onRepositionMenu: (tmenu, primaryMenu, submenuTriggers) => {
						const sink = getLazySink().getOrDie();
						Positioning.position(sink, primaryMenu, { anchor: anchor$1 });
						each$1(submenuTriggers, (st) => {
							Positioning.position(sink, st.triggeredMenu, { anchor: {
								type: "submenu",
								item: st.triggeringItem
							} });
						});
					},
					onEscape: () => {
						Focusing.focus(component);
						Sandboxing.close(sandbox);
						return Optional.some(true);
					}
				}))));
			};
			const open = (detail, mapFetch, hotspot, sandbox, externals, onOpenSync, highlightOnOpen) => {
				return openF(detail, mapFetch, getAnchor(detail, hotspot), hotspot, sandbox, externals, highlightOnOpen).map((tdata) => {
					tdata.fold(() => {
						if (Sandboxing.isOpen(sandbox)) Sandboxing.close(sandbox);
					}, (data) => {
						Sandboxing.cloak(sandbox);
						Sandboxing.open(sandbox, data);
						onOpenSync(sandbox);
					});
					return sandbox;
				});
			};
			const close = (detail, mapFetch, component, sandbox, _externals, _onOpenSync, _highlightOnOpen) => {
				Sandboxing.close(sandbox);
				return Future.pure(sandbox);
			};
			const togglePopup = (detail, mapFetch, hotspot, externals, onOpenSync, highlightOnOpen) => {
				const sandbox = Coupling.getCoupled(hotspot, "sandbox");
				return (Sandboxing.isOpen(sandbox) ? close : open)(detail, mapFetch, hotspot, sandbox, externals, onOpenSync, highlightOnOpen);
			};
			const matchWidth = (hotspot, container, useMinWidth) => {
				const menu$1 = Composing.getCurrent(container).getOr(container);
				const buttonWidth = get$c(hotspot.element);
				if (useMinWidth) set$8(menu$1.element, "min-width", buttonWidth + "px");
				else set$7(menu$1.element, buttonWidth);
			};
			const getSink = (anyInSystem, sinkDetail) => anyInSystem.getSystem().getByUid(sinkDetail.uid + "-" + suffix()).map((internalSink) => () => Result.value(internalSink)).getOrThunk(() => sinkDetail.lazySink.fold(() => () => Result.error(/* @__PURE__ */ new Error("No internal sink is specified, nor could an external sink be found")), (lazySinkFn) => () => lazySinkFn(anyInSystem)));
			const doRepositionMenus = (sandbox) => {
				Sandboxing.getState(sandbox).each((tmenu) => {
					tieredMenu.repositionMenus(tmenu);
				});
			};
			const makeSandbox$1 = (detail, hotspot, extras) => {
				const ariaControls = manager();
				const onOpen = (component, menu$1) => {
					const anchor$1 = getAnchor(detail, hotspot);
					ariaControls.link(hotspot.element);
					if (detail.matchWidth) matchWidth(anchor$1.hotspot, menu$1, detail.useMinWidth);
					detail.onOpen(anchor$1, component, menu$1);
					if (extras !== void 0 && extras.onOpen !== void 0) extras.onOpen(component, menu$1);
				};
				const onClose = (component, menu$1) => {
					ariaControls.unlink(hotspot.element);
					if (extras !== void 0 && extras.onClose !== void 0) extras.onClose(component, menu$1);
				};
				const lazySink = getSink(hotspot, detail);
				return {
					dom: {
						tag: "div",
						classes: detail.sandboxClasses,
						attributes: {
							id: ariaControls.id,
							role: "listbox"
						}
					},
					behaviours: SketchBehaviours.augment(detail.sandboxBehaviours, [
						Representing.config({ store: {
							mode: "memory",
							initialValue: hotspot
						} }),
						Sandboxing.config({
							onOpen,
							onClose,
							isPartOf: (container, data, queryElem) => {
								return isPartOf$1(data, queryElem) || isPartOf$1(hotspot, queryElem);
							},
							getAttachPoint: () => {
								return lazySink().getOrDie();
							}
						}),
						Composing.config({ find: (sandbox) => {
							return Sandboxing.getState(sandbox).bind((menu$1) => Composing.getCurrent(menu$1));
						} }),
						Receiving.config({ channels: {
							...receivingChannel$1({ isExtraPart: never }),
							...receivingChannel({ doReposition: doRepositionMenus })
						} })
					])
				};
			};
			const repositionMenus = (comp) => {
				doRepositionMenus(Coupling.getCoupled(comp, "sandbox"));
			};
			const sandboxFields = () => [defaulted("sandboxClasses", []), SketchBehaviours.field("sandboxBehaviours", [
				Composing,
				Receiving,
				Sandboxing,
				Representing
			])];
			const schema$k = constant$1([
				required$1("dom"),
				required$1("fetch"),
				onHandler("onOpen"),
				onKeyboardHandler("onExecute"),
				defaulted("getHotspot", Optional.some),
				defaulted("getAnchorOverrides", constant$1({})),
				schema$y(),
				field("dropdownBehaviours", [
					Toggling,
					Coupling,
					Keying,
					Focusing
				]),
				required$1("toggleClass"),
				defaulted("eventOrder", {}),
				option$3("lazySink"),
				defaulted("matchWidth", false),
				defaulted("useMinWidth", false),
				option$3("role")
			].concat(sandboxFields()));
			const parts$e = constant$1([external({
				schema: [tieredMenuMarkers(), defaulted("fakeFocus", false)],
				name: "menu",
				defaults: (detail) => {
					return { onExecute: detail.onExecute };
				}
			}), partType$1()]);
			const factory$k = (detail, components$2, _spec, externals) => {
				const lookupAttr = (attr) => get$g(detail.dom, "attributes").bind((attrs) => get$g(attrs, attr));
				const switchToMenu = (sandbox) => {
					Sandboxing.getState(sandbox).each((tmenu) => {
						tieredMenu.highlightPrimary(tmenu);
					});
				};
				const togglePopup$1 = (dropdownComp, onOpenSync, highlightOnOpen) => {
					return togglePopup(detail, identity, dropdownComp, externals, onOpenSync, highlightOnOpen);
				};
				const action = (component) => {
					togglePopup$1(component, switchToMenu, HighlightOnOpen.HighlightMenuAndItem).get(noop);
				};
				const apis = {
					expand: (comp) => {
						if (!Toggling.isOn(comp)) togglePopup$1(comp, noop, HighlightOnOpen.HighlightNone).get(noop);
					},
					open: (comp) => {
						if (!Toggling.isOn(comp)) togglePopup$1(comp, noop, HighlightOnOpen.HighlightMenuAndItem).get(noop);
					},
					refetch: (comp) => {
						return Coupling.getExistingCoupled(comp, "sandbox").fold(() => {
							return togglePopup$1(comp, noop, HighlightOnOpen.HighlightMenuAndItem).map(noop);
						}, (sandboxComp) => {
							return open(detail, identity, comp, sandboxComp, externals, noop, HighlightOnOpen.HighlightMenuAndItem).map(noop);
						});
					},
					isOpen: Toggling.isOn,
					close: (comp) => {
						if (Toggling.isOn(comp)) togglePopup$1(comp, noop, HighlightOnOpen.HighlightMenuAndItem).get(noop);
					},
					repositionMenus: (comp) => {
						if (Toggling.isOn(comp)) repositionMenus(comp);
					}
				};
				const triggerExecute = (comp, _se) => {
					emitExecute(comp);
					return Optional.some(true);
				};
				return {
					uid: detail.uid,
					dom: detail.dom,
					components: components$2,
					behaviours: augment(detail.dropdownBehaviours, [
						Toggling.config({
							toggleClass: detail.toggleClass,
							aria: { mode: "expanded" }
						}),
						Coupling.config({ others: { sandbox: (hotspot) => {
							return makeSandbox$1(detail, hotspot, {
								onOpen: () => Toggling.on(hotspot),
								onClose: () => Toggling.off(hotspot)
							});
						} } }),
						Keying.config({
							mode: "special",
							onSpace: triggerExecute,
							onEnter: triggerExecute,
							onDown: (comp, _se) => {
								if (Dropdown.isOpen(comp)) switchToMenu(Coupling.getCoupled(comp, "sandbox"));
								else Dropdown.open(comp);
								return Optional.some(true);
							},
							onEscape: (comp, _se) => {
								if (Dropdown.isOpen(comp)) {
									Dropdown.close(comp);
									return Optional.some(true);
								} else return Optional.none();
							}
						}),
						Focusing.config({})
					]),
					events: events$a(Optional.some(action)),
					eventOrder: {
						...detail.eventOrder,
						[execute$5()]: [
							"disabling",
							"toggling",
							"alloy.base.behaviour"
						]
					},
					apis,
					domModification: { attributes: {
						"aria-haspopup": "true",
						...detail.role.fold(() => ({}), (role) => ({ role })),
						...detail.dom.tag === "button" ? { type: lookupAttr("type").getOr("button") } : {}
					} }
				};
			};
			const Dropdown = composite({
				name: "Dropdown",
				configFields: schema$k(),
				partFields: parts$e(),
				factory: factory$k,
				apis: {
					open: (apis, comp) => apis.open(comp),
					refetch: (apis, comp) => apis.refetch(comp),
					expand: (apis, comp) => apis.expand(comp),
					close: (apis, comp) => apis.close(comp),
					isOpen: (apis, comp) => apis.isOpen(comp),
					repositionMenus: (apis, comp) => apis.repositionMenus(comp)
				}
			});
			const identifyMenuLayout = (searchMode) => {
				switch (searchMode.searchMode) {
					case "no-search": return { menuType: "normal" };
					default: return {
						menuType: "searchable",
						searchMode
					};
				}
			};
			const handleRefetchTrigger = (originalSandboxComp) => {
				const dropdown = Representing.getValue(originalSandboxComp);
				const optSearcherState = findWithinSandbox(originalSandboxComp).map(saveState);
				Dropdown.refetch(dropdown).get(() => {
					const newSandboxComp = Coupling.getCoupled(dropdown, "sandbox");
					optSearcherState.each((searcherState) => findWithinSandbox(newSandboxComp).each((inputComp) => restoreState(inputComp, searcherState)));
				});
			};
			const handleRedirectToMenuItem = (sandboxComp, se) => {
				getActiveMenuItemFrom(sandboxComp).each((activeItem) => {
					retargetAndDispatchWith(sandboxComp, activeItem.element, se.event.eventType, se.event.interactionEvent);
				});
			};
			const getActiveMenuItemFrom = (sandboxComp) => {
				return Sandboxing.getState(sandboxComp).bind(Highlighting.getHighlighted).bind(Highlighting.getHighlighted);
			};
			const getSearchResults = (activeMenuComp) => {
				return has(activeMenuComp.element, searchResultsClass) ? Optional.some(activeMenuComp.element) : descendant(activeMenuComp.element, "." + searchResultsClass);
			};
			const updateAriaOnHighlight = (tmenuComp, menuComp, itemComp) => {
				findWithinMenu(tmenuComp).each((inputComp) => {
					setActiveDescendant(inputComp, itemComp);
					getSearchResults(menuComp).each((resultsElem) => {
						getOpt(resultsElem, "id").each((controlledId) => set$9(inputComp.element, "aria-controls", controlledId));
					});
				});
				set$9(itemComp.element, "aria-selected", "true");
			};
			const updateAriaOnDehighlight = (tmenuComp, menuComp, itemComp) => {
				set$9(itemComp.element, "aria-selected", "false");
			};
			const focusSearchField = (tmenuComp) => {
				findWithinMenu(tmenuComp).each((searcherComp) => Focusing.focus(searcherComp));
			};
			const getSearchPattern = (dropdownComp) => {
				return Coupling.getExistingCoupled(dropdownComp, "sandbox").bind(findWithinSandbox).map(saveState).map((state) => state.fetchPattern).getOr("");
			};
			var FocusMode;
			(function(FocusMode$1) {
				FocusMode$1[FocusMode$1["ContentFocus"] = 0] = "ContentFocus";
				FocusMode$1[FocusMode$1["UiFocus"] = 1] = "UiFocus";
			})(FocusMode || (FocusMode = {}));
			const createMenuItemFromBridge = (item$1, itemResponse, backstage, menuHasIcons$1, isHorizontalMenu) => {
				const providersBackstage = backstage.shared.providers;
				const parseForHorizontalMenu = (menuitem) => !isHorizontalMenu ? menuitem : {
					...menuitem,
					shortcut: Optional.none(),
					icon: menuitem.text.isSome() ? Optional.none() : menuitem.icon
				};
				switch (item$1.type) {
					case "menuitem": return createMenuItem(item$1).fold(handleError, (d) => Optional.some(normal(parseForHorizontalMenu(d), itemResponse, providersBackstage, menuHasIcons$1)));
					case "nestedmenuitem": return createNestedMenuItem(item$1).fold(handleError, (d) => Optional.some(nested(parseForHorizontalMenu(d), itemResponse, providersBackstage, menuHasIcons$1, isHorizontalMenu)));
					case "togglemenuitem": return createToggleMenuItem(item$1).fold(handleError, (d) => Optional.some(toggle$1(parseForHorizontalMenu(d), itemResponse, providersBackstage, menuHasIcons$1)));
					case "separator": return createSeparatorMenuItem(item$1).fold(handleError, (d) => Optional.some(separator$3(d)));
					case "fancymenuitem": return createFancyMenuItem(item$1).fold(handleError, (d) => fancy(d, backstage));
					default:
						console.error("Unknown item in general menu", item$1);
						return Optional.none();
				}
			};
			const createAutocompleteItems = (items, matchText, onItemValueHandler, columns, itemResponse, sharedBackstage, highlightOn) => {
				const renderText$1 = columns === 1;
				const renderIcons = !renderText$1 || menuHasIcons(items);
				return cat(map$2(items, (item$1) => {
					switch (item$1.type) {
						case "separator": return createSeparatorItem(item$1).fold(handleError, (d) => Optional.some(separator$3(d)));
						case "cardmenuitem": return createCardMenuItem(item$1).fold(handleError, (d) => Optional.some(card({
							...d,
							onAction: (api$3) => {
								d.onAction(api$3);
								onItemValueHandler(d.value, d.meta);
							}
						}, itemResponse, sharedBackstage, {
							itemBehaviours: tooltipBehaviour(d.meta, sharedBackstage),
							cardText: {
								matchText,
								highlightOn
							}
						})));
						case "autocompleteitem":
						default: return createAutocompleterItem(item$1).fold(handleError, (d) => Optional.some(autocomplete(d, matchText, renderText$1, "normal", onItemValueHandler, itemResponse, sharedBackstage, renderIcons)));
					}
				}));
			};
			const createPartialMenu = (value$5, items, itemResponse, backstage, isHorizontalMenu, searchMode) => {
				const hasIcons = menuHasIcons(items);
				const alloyItems = cat(map$2(items, (item$1) => {
					const itemHasIcon = (i) => isHorizontalMenu ? !has$2(i, "text") : hasIcons;
					const createItem = (i) => createMenuItemFromBridge(i, itemResponse, backstage, itemHasIcon(i), isHorizontalMenu);
					if (item$1.type === "nestedmenuitem" && item$1.getSubmenuItems().length <= 0) return createItem({
						...item$1,
						enabled: false
					});
					else return createItem(item$1);
				}));
				const menuLayout = identifyMenuLayout(searchMode);
				return (isHorizontalMenu ? createHorizontalPartialMenuWithAlloyItems : createPartialMenuWithAlloyItems)(value$5, hasIcons, alloyItems, 1, menuLayout);
			};
			const createTieredDataFrom = (partialMenu) => tieredMenu.singleData(partialMenu.value, partialMenu);
			const createInlineMenuFrom = (partialMenu, columns, focusMode, presets) => {
				const movement = deriveMenuMovement(columns, presets);
				const menuMarkers = markers(presets);
				return {
					data: createTieredDataFrom({
						...partialMenu,
						movement,
						menuBehaviours: SimpleBehaviours.unnamedEvents(columns !== "auto" ? [] : [runOnAttached((comp, _se) => {
							detectSize(comp, 4, menuMarkers.item).each(({ numColumns, numRows }) => {
								Keying.setGridSize(comp, numRows, numColumns);
							});
						})])
					}),
					menu: {
						markers: markers(presets),
						fakeFocus: focusMode === FocusMode.ContentFocus
					}
				};
			};
			const getAutocompleterRange = (dom$3, initRange) => {
				return detect$1(SugarElement.fromDom(initRange.startContainer)).map((elm) => {
					const range$1 = dom$3.createRng();
					range$1.selectNode(elm.dom);
					return range$1;
				});
			};
			const register$b = (editor, sharedBackstage) => {
				const processingAction = Cell(false);
				const activeState = Cell(false);
				const autocompleter = build$1(InlineView.sketch({
					dom: {
						tag: "div",
						classes: ["tox-autocompleter"]
					},
					components: [],
					fireDismissalEventInstead: {},
					inlineBehaviours: derive$1([config("dismissAutocompleter", [run$1(dismissRequested(), () => cancelIfNecessary())])]),
					lazySink: sharedBackstage.getSink
				}));
				const isMenuOpen = () => InlineView.isOpen(autocompleter);
				const isActive = activeState.get;
				const hideIfNecessary = () => {
					if (isMenuOpen()) InlineView.hide(autocompleter);
				};
				const getMenu = () => InlineView.getContent(autocompleter).bind((tmenu) => {
					return get$h(tmenu.components(), 0);
				});
				const cancelIfNecessary = () => editor.execCommand("mceAutocompleterClose");
				const getCombinedItems = (matches) => {
					const columns = findMap(matches, (m) => Optional.from(m.columns)).getOr(1);
					return bind$3(matches, (match) => {
						const choices = match.items;
						return createAutocompleteItems(choices, match.matchText, (itemValue, itemMeta) => {
							const nr = editor.selection.getRng();
							getAutocompleterRange(editor.dom, nr).each((range$1) => {
								const autocompleterApi = {
									hide: () => cancelIfNecessary(),
									reload: (fetchOptions) => {
										hideIfNecessary();
										editor.execCommand("mceAutocompleterReload", false, { fetchOptions });
									}
								};
								processingAction.set(true);
								match.onAction(autocompleterApi, range$1, itemValue, itemMeta);
								processingAction.set(false);
							});
						}, columns, ItemResponse$1.BUBBLE_TO_SANDBOX, sharedBackstage, match.highlightOn);
					});
				};
				const display = (lookupData, items) => {
					findIn(SugarElement.fromDom(editor.getBody())).each((element$1) => {
						const columns = findMap(lookupData, (ld) => Optional.from(ld.columns)).getOr(1);
						InlineView.showMenuAt(autocompleter, { anchor: {
							type: "node",
							root: SugarElement.fromDom(editor.getBody()),
							node: Optional.from(element$1)
						} }, createInlineMenuFrom(createPartialMenuWithAlloyItems("autocompleter-value", true, items, columns, { menuType: "normal" }), columns, FocusMode.ContentFocus, "normal"));
					});
					getMenu().each(Highlighting.highlightFirst);
				};
				const updateDisplay = (lookupData) => {
					const combinedItems = getCombinedItems(lookupData);
					if (combinedItems.length > 0) display(lookupData, combinedItems);
					else hideIfNecessary();
				};
				editor.on("AutocompleterStart", ({ lookupData }) => {
					activeState.set(true);
					processingAction.set(false);
					updateDisplay(lookupData);
				});
				editor.on("AutocompleterUpdate", ({ lookupData }) => updateDisplay(lookupData));
				editor.on("AutocompleterEnd", () => {
					hideIfNecessary();
					activeState.set(false);
					processingAction.set(false);
				});
				const autocompleterUiApi = {
					cancelIfNecessary,
					isMenuOpen,
					isActive,
					isProcessingAction: processingAction.get,
					getMenu
				};
				AutocompleterEditorEvents.setup(autocompleterUiApi, editor);
			};
			const Autocompleter = { register: register$b };
			const nonScrollingOverflows = [
				"visible",
				"hidden",
				"clip"
			];
			const isScrollingOverflowValue = (value$5) => trim$1(value$5).length > 0 && !contains$2(nonScrollingOverflows, value$5);
			const isScroller = (elem) => {
				if (isHTMLElement(elem)) {
					const overflowX = get$e(elem, "overflow-x");
					const overflowY = get$e(elem, "overflow-y");
					return isScrollingOverflowValue(overflowX) || isScrollingOverflowValue(overflowY);
				} else return false;
			};
			const detect = (popupSinkElem) => {
				const ancestorsScrollers = ancestors(popupSinkElem, isScroller);
				const scrollers = ancestorsScrollers.length === 0 ? getShadowRoot(popupSinkElem).map(getShadowHost).map((x) => ancestors(x, isScroller)).getOr([]) : ancestorsScrollers;
				return head(scrollers).map((element$1) => ({
					element: element$1,
					others: scrollers.slice(1)
				}));
			};
			const detectWhenSplitUiMode = (editor, popupSinkElem) => isSplitUiMode(editor) ? detect(popupSinkElem) : Optional.none();
			const getBoundsFrom = (sc) => {
				const scrollableBoxes = [...map$2(sc.others, box$1), win()];
				return constrainByMany(box$1(sc.element), scrollableBoxes);
			};
			const closest = (scope, selector, isRoot) => closest$1(scope, selector, isRoot).isSome();
			const DelayedFunction = (fun, delay) => {
				let ref = null;
				const schedule = (...args) => {
					ref = setTimeout(() => {
						fun.apply(null, args);
						ref = null;
					}, delay);
				};
				const cancel = () => {
					if (ref !== null) {
						clearTimeout(ref);
						ref = null;
					}
				};
				return {
					cancel,
					schedule
				};
			};
			const SIGNIFICANT_MOVE = 5;
			const LONGPRESS_DELAY = 400;
			const getTouch = (event) => {
				const raw = event.raw;
				if (raw.touches === void 0 || raw.touches.length !== 1) return Optional.none();
				return Optional.some(raw.touches[0]);
			};
			const isFarEnough = (touch$1, data) => {
				const distX = Math.abs(touch$1.clientX - data.x);
				const distY = Math.abs(touch$1.clientY - data.y);
				return distX > SIGNIFICANT_MOVE || distY > SIGNIFICANT_MOVE;
			};
			const monitor = (settings) => {
				const startData = value$2();
				const longpressFired = Cell(false);
				const longpress$1 = DelayedFunction((event) => {
					settings.triggerEvent(longpress(), event);
					longpressFired.set(true);
				}, LONGPRESS_DELAY);
				const handleTouchstart = (event) => {
					getTouch(event).each((touch$1) => {
						longpress$1.cancel();
						const data = {
							x: touch$1.clientX,
							y: touch$1.clientY,
							target: event.target
						};
						longpress$1.schedule(event);
						longpressFired.set(false);
						startData.set(data);
					});
					return Optional.none();
				};
				const handleTouchmove = (event) => {
					longpress$1.cancel();
					getTouch(event).each((touch$1) => {
						startData.on((data) => {
							if (isFarEnough(touch$1, data)) startData.clear();
						});
					});
					return Optional.none();
				};
				const handleTouchend = (event) => {
					longpress$1.cancel();
					const isSame = (data) => eq(data.target, event.target);
					return startData.get().filter(isSame).map((_data) => {
						if (longpressFired.get()) {
							event.prevent();
							return false;
						} else return settings.triggerEvent(tap(), event);
					});
				};
				const handlers$1 = wrapAll([
					{
						key: touchstart(),
						value: handleTouchstart
					},
					{
						key: touchmove(),
						value: handleTouchmove
					},
					{
						key: touchend(),
						value: handleTouchend
					}
				]);
				const fireIfReady = (event, type$2) => get$g(handlers$1, type$2).bind((handler) => handler(event));
				return { fireIfReady };
			};
			const isDangerous = (event) => {
				return event.raw.which === BACKSPACE[0] && !contains$2(["input", "textarea"], name$3(event.target)) && !closest(event.target, "[contenteditable=\"true\"]");
			};
			const setup$d = (container, rawSettings) => {
				const settings = {
					stopBackspace: true,
					...rawSettings
				};
				const pointerEvents$1 = [
					"touchstart",
					"touchmove",
					"touchend",
					"touchcancel",
					"gesturestart",
					"mousedown",
					"mouseup",
					"mouseover",
					"mousemove",
					"mouseout",
					"click"
				];
				const tapEvent = monitor(settings);
				const simpleEvents = map$2(pointerEvents$1.concat([
					"selectstart",
					"input",
					"contextmenu",
					"change",
					"transitionend",
					"transitioncancel",
					"drag",
					"dragstart",
					"dragend",
					"dragenter",
					"dragleave",
					"dragover",
					"drop",
					"keyup"
				]), (type$2) => bind(container, type$2, (event) => {
					tapEvent.fireIfReady(event, type$2).each((tapStopped) => {
						if (tapStopped) event.kill();
					});
					if (settings.triggerEvent(type$2, event)) event.kill();
				}));
				const pasteTimeout = value$2();
				const onPaste = bind(container, "paste", (event) => {
					tapEvent.fireIfReady(event, "paste").each((tapStopped) => {
						if (tapStopped) event.kill();
					});
					if (settings.triggerEvent("paste", event)) event.kill();
					pasteTimeout.set(setTimeout(() => {
						settings.triggerEvent(postPaste(), event);
					}, 0));
				});
				const onKeydown = bind(container, "keydown", (event) => {
					if (settings.triggerEvent("keydown", event)) event.kill();
					else if (settings.stopBackspace && isDangerous(event)) event.prevent();
				});
				const onFocusIn = bind(container, "focusin", (event) => {
					if (settings.triggerEvent("focusin", event)) event.kill();
				});
				const focusoutTimeout = value$2();
				const onFocusOut = bind(container, "focusout", (event) => {
					if (settings.triggerEvent("focusout", event)) event.kill();
					focusoutTimeout.set(setTimeout(() => {
						settings.triggerEvent(postBlur(), event);
					}, 0));
				});
				const unbind$1 = () => {
					each$1(simpleEvents, (e) => {
						e.unbind();
					});
					onKeydown.unbind();
					onFocusIn.unbind();
					onFocusOut.unbind();
					onPaste.unbind();
					pasteTimeout.on(clearTimeout);
					focusoutTimeout.on(clearTimeout);
				};
				return { unbind: unbind$1 };
			};
			const derive = (rawEvent, rawTarget) => {
				return Cell(get$g(rawEvent, "target").getOr(rawTarget));
			};
			const fromSource = (event, source) => {
				const stopper$1 = Cell(false);
				const cutter$1 = Cell(false);
				const stop$1 = () => {
					stopper$1.set(true);
				};
				const cut = () => {
					cutter$1.set(true);
				};
				return {
					stop: stop$1,
					cut,
					isStopped: stopper$1.get,
					isCut: cutter$1.get,
					event,
					setSource: source.set,
					getSource: source.get
				};
			};
			const fromExternal = (event) => {
				const stopper$1 = Cell(false);
				const stop$1 = () => {
					stopper$1.set(true);
				};
				return {
					stop: stop$1,
					cut: noop,
					isStopped: stopper$1.get,
					isCut: never,
					event,
					setSource: die("Cannot set source of a broadcasted event"),
					getSource: die("Cannot get source of a broadcasted event")
				};
			};
			const adt$1 = Adt.generate([
				{ stopped: [] },
				{ resume: ["element"] },
				{ complete: [] }
			]);
			const doTriggerHandler = (lookup$2, eventType, rawEvent, target, source, logger) => {
				const handler = lookup$2(eventType, target);
				const simulatedEvent = fromSource(rawEvent, source);
				return handler.fold(() => {
					logger.logEventNoHandlers(eventType, target);
					return adt$1.complete();
				}, (handlerInfo) => {
					const descHandler = handlerInfo.descHandler;
					getCurried(descHandler)(simulatedEvent);
					if (simulatedEvent.isStopped()) {
						logger.logEventStopped(eventType, handlerInfo.element, descHandler.purpose);
						return adt$1.stopped();
					} else if (simulatedEvent.isCut()) {
						logger.logEventCut(eventType, handlerInfo.element, descHandler.purpose);
						return adt$1.complete();
					} else return parent(handlerInfo.element).fold(() => {
						logger.logNoParent(eventType, handlerInfo.element, descHandler.purpose);
						return adt$1.complete();
					}, (parent$1) => {
						logger.logEventResponse(eventType, handlerInfo.element, descHandler.purpose);
						return adt$1.resume(parent$1);
					});
				});
			};
			const doTriggerOnUntilStopped = (lookup$2, eventType, rawEvent, rawTarget, source, logger) => doTriggerHandler(lookup$2, eventType, rawEvent, rawTarget, source, logger).fold(always, (parent$1) => doTriggerOnUntilStopped(lookup$2, eventType, rawEvent, parent$1, source, logger), never);
			const triggerHandler = (lookup$2, eventType, rawEvent, target, logger) => {
				return doTriggerHandler(lookup$2, eventType, rawEvent, target, derive(rawEvent, target), logger);
			};
			const broadcast = (listeners, rawEvent, _logger) => {
				const simulatedEvent = fromExternal(rawEvent);
				each$1(listeners, (listener) => {
					const descHandler = listener.descHandler;
					getCurried(descHandler)(simulatedEvent);
				});
				return simulatedEvent.isStopped();
			};
			const triggerUntilStopped = (lookup$2, eventType, rawEvent, logger) => triggerOnUntilStopped(lookup$2, eventType, rawEvent, rawEvent.target, logger);
			const triggerOnUntilStopped = (lookup$2, eventType, rawEvent, rawTarget, logger) => {
				return doTriggerOnUntilStopped(lookup$2, eventType, rawEvent, rawTarget, derive(rawEvent, rawTarget), logger);
			};
			const eventHandler = (element$1, descHandler) => ({
				element: element$1,
				descHandler
			});
			const broadcastHandler = (id, handler) => ({
				id,
				descHandler: handler
			});
			const EventRegistry = () => {
				const registry = {};
				const registerId = (extraArgs, id, events$10) => {
					each(events$10, (v, k) => {
						const handlers$1 = registry[k] !== void 0 ? registry[k] : {};
						handlers$1[id] = curryArgs(v, extraArgs);
						registry[k] = handlers$1;
					});
				};
				const findHandler = (handlers$1, elem) => read$1(elem).bind((id) => get$g(handlers$1, id)).map((descHandler) => eventHandler(elem, descHandler));
				const filterByType = (type$2) => get$g(registry, type$2).map((handlers$1) => mapToArray(handlers$1, (f$1, id) => broadcastHandler(id, f$1))).getOr([]);
				const find$6 = (isAboveRoot, type$2, target) => get$g(registry, type$2).bind((handlers$1) => closest$4(target, (elem) => findHandler(handlers$1, elem), isAboveRoot));
				const unregisterId = (id) => {
					each(registry, (handlersById, _eventName) => {
						if (has$2(handlersById, id)) delete handlersById[id];
					});
				};
				return {
					registerId,
					unregisterId,
					filterByType,
					find: find$6
				};
			};
			const Registry = () => {
				const events$10 = EventRegistry();
				const components$2 = {};
				const readOrTag = (component) => {
					const elem = component.element;
					return read$1(elem).getOrThunk(() => write("uid-", component.element));
				};
				const failOnDuplicate = (component, tagId) => {
					const conflict = components$2[tagId];
					if (conflict === component) unregister(component);
					else throw new Error("The tagId \"" + tagId + "\" is already used by: " + element(conflict.element) + "\nCannot use it for: " + element(component.element) + "\nThe conflicting element is" + (inBody(conflict.element) ? " " : " not ") + "already in the DOM");
				};
				const register$10 = (component) => {
					const tagId = readOrTag(component);
					if (hasNonNullableKey(components$2, tagId)) failOnDuplicate(component, tagId);
					const extraArgs = [component];
					events$10.registerId(extraArgs, tagId, component.events);
					components$2[tagId] = component;
				};
				const unregister = (component) => {
					read$1(component.element).each((tagId) => {
						delete components$2[tagId];
						events$10.unregisterId(tagId);
					});
				};
				const filter$3 = (type$2) => events$10.filterByType(type$2);
				const find$6 = (isAboveRoot, type$2, target) => events$10.find(isAboveRoot, type$2, target);
				const getById = (id) => get$g(components$2, id);
				return {
					find: find$6,
					filter: filter$3,
					register: register$10,
					unregister,
					getById
				};
			};
			const factory$j = (detail) => {
				const { attributes, ...domWithoutAttributes } = detail.dom;
				return {
					uid: detail.uid,
					dom: {
						tag: "div",
						attributes: {
							role: "presentation",
							...attributes
						},
						...domWithoutAttributes
					},
					components: detail.components,
					behaviours: get$3(detail.containerBehaviours),
					events: detail.events,
					domModification: detail.domModification,
					eventOrder: detail.eventOrder
				};
			};
			const Container = single({
				name: "Container",
				factory: factory$j,
				configFields: [
					defaulted("components", []),
					field("containerBehaviours", []),
					defaulted("events", {}),
					defaulted("domModification", {}),
					defaulted("eventOrder", {})
				]
			});
			const takeover = (root) => {
				const isAboveRoot = (el) => parent(root.element).fold(always, (parent$1) => eq(el, parent$1));
				const registry = Registry();
				const lookup$2 = (eventName, target) => registry.find(isAboveRoot, eventName, target);
				const domEvents = setup$d(root.element, { triggerEvent: (eventName, event) => {
					return monitorEvent(eventName, event.target, (logger) => triggerUntilStopped(lookup$2, eventName, event, logger));
				} });
				const systemApi = {
					debugInfo: constant$1("real"),
					triggerEvent: (eventName, target, data) => {
						monitorEvent(eventName, target, (logger) => triggerOnUntilStopped(lookup$2, eventName, data, target, logger));
					},
					triggerFocus: (target, originator) => {
						read$1(target).fold(() => {
							focus$3(target);
						}, (_alloyId) => {
							monitorEvent(focus$4(), target, (logger) => {
								triggerHandler(lookup$2, focus$4(), {
									originator,
									kill: noop,
									prevent: noop,
									target
								}, target, logger);
								return false;
							});
						});
					},
					triggerEscape: (comp, simulatedEvent) => {
						systemApi.triggerEvent("keydown", comp.element, simulatedEvent.event);
					},
					getByUid: (uid) => {
						return getByUid(uid);
					},
					getByDom: (elem) => {
						return getByDom(elem);
					},
					build: build$1,
					buildOrPatch,
					addToGui: (c) => {
						add$5(c);
					},
					removeFromGui: (c) => {
						remove$8(c);
					},
					addToWorld: (c) => {
						addToWorld(c);
					},
					removeFromWorld: (c) => {
						removeFromWorld(c);
					},
					broadcast: (message) => {
						broadcast$1(message);
					},
					broadcastOn: (channels, message) => {
						broadcastOn(channels, message);
					},
					broadcastEvent: (eventName, event) => {
						broadcastEvent(eventName, event);
					},
					isConnected: always
				};
				const addToWorld = (component) => {
					component.connect(systemApi);
					if (!isText(component.element)) {
						registry.register(component);
						each$1(component.components(), addToWorld);
						systemApi.triggerEvent(systemInit(), component.element, { target: component.element });
					}
				};
				const removeFromWorld = (component) => {
					if (!isText(component.element)) {
						each$1(component.components(), removeFromWorld);
						registry.unregister(component);
					}
					component.disconnect();
				};
				const add$5 = (component) => {
					attach(root, component);
				};
				const remove$8 = (component) => {
					detach(component);
				};
				const destroy = () => {
					domEvents.unbind();
					remove$5(root.element);
				};
				const broadcastData = (data) => {
					each$1(registry.filter(receive()), (receiver) => {
						const descHandler = receiver.descHandler;
						getCurried(descHandler)(data);
					});
				};
				const broadcast$1 = (message) => {
					broadcastData({
						universal: true,
						data: message
					});
				};
				const broadcastOn = (channels, message) => {
					broadcastData({
						universal: false,
						channels,
						data: message
					});
				};
				const broadcastEvent = (eventName, event) => {
					return broadcast(registry.filter(eventName), event);
				};
				const getByUid = (uid) => registry.getById(uid).fold(() => Result.error(/* @__PURE__ */ new Error("Could not find component with uid: \"" + uid + "\" in system.")), Result.value);
				const getByDom = (elem) => {
					return getByUid(read$1(elem).getOr("not found"));
				};
				addToWorld(root);
				return {
					root,
					element: root.element,
					destroy,
					add: add$5,
					remove: remove$8,
					getByUid,
					getByDom,
					addToWorld,
					removeFromWorld,
					broadcast: broadcast$1,
					broadcastOn,
					broadcastEvent
				};
			};
			const renderBar = (spec, backstage) => ({
				dom: {
					tag: "div",
					classes: ["tox-bar", "tox-form__controls-h-stack"]
				},
				components: map$2(spec.items, backstage.interpreter)
			});
			const schema$j = constant$1([defaulted("prefix", "form-field"), field("fieldBehaviours", [Composing, Representing])]);
			const parts$d = constant$1([
				optional({
					schema: [required$1("dom")],
					name: "label"
				}),
				optional({
					factory: { sketch: (spec) => {
						return {
							uid: spec.uid,
							dom: {
								tag: "span",
								styles: { display: "none" },
								attributes: { "aria-hidden": "true" },
								innerHtml: spec.text
							}
						};
					} },
					schema: [required$1("text")],
					name: "aria-descriptor"
				}),
				required({
					factory: { sketch: (spec) => {
						const excludeFactory = exclude(spec, ["factory"]);
						return spec.factory.sketch(excludeFactory);
					} },
					schema: [required$1("factory")],
					name: "field"
				})
			]);
			const factory$i = (detail, components$2, _spec, _externals) => {
				const behaviours$1 = augment(detail.fieldBehaviours, [Composing.config({ find: (container) => {
					return getPart(container, detail, "field");
				} }), Representing.config({ store: {
					mode: "manual",
					getValue: (field$3) => {
						return Composing.getCurrent(field$3).bind(Representing.getValue);
					},
					setValue: (field$3, value$5) => {
						Composing.getCurrent(field$3).each((current) => {
							Representing.setValue(current, value$5);
						});
					}
				} })]);
				const events$10 = derive$2([runOnAttached((component, _simulatedEvent) => {
					const ps = getParts(component, detail, [
						"label",
						"field",
						"aria-descriptor"
					]);
					ps.field().each((field$3) => {
						const id = generate$6(detail.prefix);
						ps.label().each((label$1) => {
							set$9(label$1.element, "for", id);
							set$9(field$3.element, "id", id);
						});
						ps["aria-descriptor"]().each((descriptor) => {
							const descriptorId = generate$6(detail.prefix);
							set$9(descriptor.element, "id", descriptorId);
							set$9(field$3.element, "aria-describedby", descriptorId);
						});
					});
				})]);
				return {
					uid: detail.uid,
					dom: detail.dom,
					components: components$2,
					behaviours: behaviours$1,
					events: events$10,
					apis: {
						getField: (container) => getPart(container, detail, "field"),
						getLabel: (container) => getPart(container, detail, "label")
					}
				};
			};
			const FormField = composite({
				name: "FormField",
				configFields: schema$j(),
				partFields: parts$d(),
				factory: factory$i,
				apis: {
					getField: (apis, comp) => apis.getField(comp),
					getLabel: (apis, comp) => apis.getLabel(comp)
				}
			});
			const exhibit$2 = (base$1, tabConfig) => nu$7({ attributes: wrapAll([{
				key: tabConfig.tabAttr,
				value: "true"
			}]) });
			var ActiveTabstopping = /* @__PURE__ */ Object.freeze({
				__proto__: null,
				exhibit: exhibit$2
			});
			const Tabstopping = create$4({
				fields: [defaulted("tabAttr", "data-alloy-tabstop")],
				name: "tabstopping",
				active: ActiveTabstopping
			});
			var global$3 = tinymce.util.Tools.resolve("tinymce.html.Entities");
			const renderFormFieldWith = (pLabel, pField, extraClasses, extraBehaviours) => {
				const spec = renderFormFieldSpecWith(pLabel, pField, extraClasses, extraBehaviours);
				return FormField.sketch(spec);
			};
			const renderFormField = (pLabel, pField) => renderFormFieldWith(pLabel, pField, [], []);
			const renderFormFieldSpecWith = (pLabel, pField, extraClasses, extraBehaviours) => ({
				dom: renderFormFieldDomWith(extraClasses),
				components: pLabel.toArray().concat([pField]),
				fieldBehaviours: derive$1(extraBehaviours)
			});
			const renderFormFieldDom = () => renderFormFieldDomWith([]);
			const renderFormFieldDomWith = (extraClasses) => ({
				tag: "div",
				classes: ["tox-form__group"].concat(extraClasses)
			});
			const renderLabel$3 = (label$1, providersBackstage) => FormField.parts.label({
				dom: {
					tag: "label",
					classes: ["tox-label"]
				},
				components: [text$2(providersBackstage.translate(label$1))]
			});
			const formChangeEvent = generate$6("form-component-change");
			const formCloseEvent = generate$6("form-close");
			const formCancelEvent = generate$6("form-cancel");
			const formActionEvent = generate$6("form-action");
			const formSubmitEvent = generate$6("form-submit");
			const formBlockEvent = generate$6("form-block");
			const formUnblockEvent = generate$6("form-unblock");
			const formTabChangeEvent = generate$6("form-tabchange");
			const formResizeEvent = generate$6("form-resize");
			const renderCollection = (spec, providersBackstage, initialData) => {
				const pLabel = spec.label.map((label$1) => renderLabel$3(label$1, providersBackstage));
				const runOnItem = (f$1) => (comp, se) => {
					closest$1(se.event.target, "[data-collection-item-value]").each((target) => {
						f$1(comp, se, target, get$f(target, "data-collection-item-value"));
					});
				};
				const setContents = (comp, items) => {
					const htmlLines = map$2(items, (item$1) => {
						const itemText = global$8.translate(item$1.text);
						const textContent = spec.columns === 1 ? `<div class="tox-collection__item-label">${itemText}</div>` : "";
						const iconContent = `<div class="tox-collection__item-icon">${item$1.icon}</div>`;
						const mapItemName = {
							"_": " ",
							" - ": " ",
							"-": " "
						};
						const ariaLabel = itemText.replace(/\_| \- |\-/g, (match) => mapItemName[match]);
						return `<div class="tox-collection__item${providersBackstage.isDisabled() ? " tox-collection__item--state-disabled" : ""}" tabindex="-1" data-collection-item-value="${global$3.encodeAllRaw(item$1.value)}" title="${ariaLabel}" aria-label="${ariaLabel}">${iconContent}${textContent}</div>`;
					});
					const html$2 = map$2(spec.columns !== "auto" && spec.columns > 1 ? chunk$1(htmlLines, spec.columns) : [htmlLines], (ch) => `<div class="tox-collection__group">${ch.join("")}</div>`);
					set$6(comp.element, html$2.join(""));
				};
				const onClick = runOnItem((comp, se, tgt, itemValue) => {
					se.stop();
					if (!providersBackstage.isDisabled()) emitWith(comp, formActionEvent, {
						name: spec.name,
						value: itemValue
					});
				});
				const collectionEvents = [
					run$1(mouseover(), runOnItem((comp, se, tgt) => {
						focus$3(tgt);
					})),
					run$1(click(), onClick),
					run$1(tap(), onClick),
					run$1(focusin(), runOnItem((comp, se, tgt) => {
						descendant(comp.element, "." + activeClass).each((currentActive) => {
							remove$2(currentActive, activeClass);
						});
						add$2(tgt, activeClass);
					})),
					run$1(focusout(), runOnItem((comp) => {
						descendant(comp.element, "." + activeClass).each((currentActive) => {
							remove$2(currentActive, activeClass);
						});
					})),
					runOnExecute$1(runOnItem((comp, se, tgt, itemValue) => {
						emitWith(comp, formActionEvent, {
							name: spec.name,
							value: itemValue
						});
					}))
				];
				const iterCollectionItems = (comp, applyAttributes) => map$2(descendants(comp.element, ".tox-collection__item"), applyAttributes);
				return renderFormFieldWith(pLabel, FormField.parts.field({
					dom: {
						tag: "div",
						classes: ["tox-collection"].concat(spec.columns !== 1 ? ["tox-collection--grid"] : ["tox-collection--list"])
					},
					components: [],
					factory: { sketch: identity },
					behaviours: derive$1([
						Disabling.config({
							disabled: providersBackstage.isDisabled,
							onDisabled: (comp) => {
								iterCollectionItems(comp, (childElm) => {
									add$2(childElm, "tox-collection__item--state-disabled");
									set$9(childElm, "aria-disabled", true);
								});
							},
							onEnabled: (comp) => {
								iterCollectionItems(comp, (childElm) => {
									remove$2(childElm, "tox-collection__item--state-disabled");
									remove$7(childElm, "aria-disabled");
								});
							}
						}),
						receivingConfig(),
						Replacing.config({}),
						Representing.config({
							store: {
								mode: "memory",
								initialValue: initialData.getOr([])
							},
							onSetValue: (comp, items) => {
								setContents(comp, items);
								if (spec.columns === "auto") detectSize(comp, 5, "tox-collection__item").each(({ numRows, numColumns }) => {
									Keying.setGridSize(comp, numRows, numColumns);
								});
								emit(comp, formResizeEvent);
							}
						}),
						Tabstopping.config({}),
						Keying.config(deriveCollectionMovement(spec.columns, "normal")),
						config("collection-events", collectionEvents)
					]),
					eventOrder: { [execute$5()]: [
						"disabling",
						"alloy.base.behaviour",
						"collection-events"
					] }
				}), ["tox-form__group--collection"], []);
			};
			const ariaElements = ["input", "textarea"];
			const isAriaElement = (elem) => {
				return contains$2(ariaElements, name$3(elem));
			};
			const markValid = (component, invalidConfig) => {
				remove$2(invalidConfig.getRoot(component).getOr(component.element), invalidConfig.invalidClass);
				invalidConfig.notify.each((notifyInfo) => {
					if (isAriaElement(component.element)) set$9(component.element, "aria-invalid", false);
					notifyInfo.getContainer(component).each((container) => {
						set$6(container, notifyInfo.validHtml);
					});
					notifyInfo.onValid(component);
				});
			};
			const markInvalid = (component, invalidConfig, invalidState, text$3) => {
				add$2(invalidConfig.getRoot(component).getOr(component.element), invalidConfig.invalidClass);
				invalidConfig.notify.each((notifyInfo) => {
					if (isAriaElement(component.element)) set$9(component.element, "aria-invalid", true);
					notifyInfo.getContainer(component).each((container) => {
						set$6(container, text$3);
					});
					notifyInfo.onInvalid(component, text$3);
				});
			};
			const query = (component, invalidConfig, _invalidState) => invalidConfig.validator.fold(() => Future.pure(Result.value(true)), (validatorInfo) => validatorInfo.validate(component));
			const run = (component, invalidConfig, invalidState) => {
				invalidConfig.notify.each((notifyInfo) => {
					notifyInfo.onValidate(component);
				});
				return query(component, invalidConfig).map((valid) => {
					if (component.getSystem().isConnected()) return valid.fold((err) => {
						markInvalid(component, invalidConfig, invalidState, err);
						return Result.error(err);
					}, (v) => {
						markValid(component, invalidConfig);
						return Result.value(v);
					});
					else return Result.error("No longer in system");
				});
			};
			const isInvalid = (component, invalidConfig) => {
				return has(invalidConfig.getRoot(component).getOr(component.element), invalidConfig.invalidClass);
			};
			var InvalidateApis = /* @__PURE__ */ Object.freeze({
				__proto__: null,
				markValid,
				markInvalid,
				query,
				run,
				isInvalid
			});
			const events$8 = (invalidConfig, invalidState) => invalidConfig.validator.map((validatorInfo) => derive$2([run$1(validatorInfo.onEvent, (component) => {
				run(component, invalidConfig, invalidState).get(identity);
			})].concat(validatorInfo.validateOnLoad ? [runOnAttached((component) => {
				run(component, invalidConfig, invalidState).get(noop);
			})] : []))).getOr({});
			var ActiveInvalidate = /* @__PURE__ */ Object.freeze({
				__proto__: null,
				events: events$8
			});
			const Invalidating = create$4({
				fields: [
					required$1("invalidClass"),
					defaulted("getRoot", Optional.none),
					optionObjOf("notify", [
						defaulted("aria", "alert"),
						defaulted("getContainer", Optional.none),
						defaulted("validHtml", ""),
						onHandler("onValid"),
						onHandler("onInvalid"),
						onHandler("onValidate")
					]),
					optionObjOf("validator", [
						required$1("validate"),
						defaulted("onEvent", "input"),
						defaulted("validateOnLoad", true)
					])
				],
				name: "invalidating",
				active: ActiveInvalidate,
				apis: InvalidateApis,
				extra: { validation: (validator) => {
					return (component) => {
						const v = Representing.getValue(component);
						return Future.pure(validator(v));
					};
				} }
			});
			const exhibit$1 = () => nu$7({
				styles: {
					"-webkit-user-select": "none",
					"user-select": "none",
					"-ms-user-select": "none",
					"-moz-user-select": "-moz-none"
				},
				attributes: { unselectable: "on" }
			});
			const events$7 = () => derive$2([abort(selectstart(), always)]);
			const Unselecting = create$4({
				fields: [],
				name: "unselecting",
				active: /* @__PURE__ */ Object.freeze({
					__proto__: null,
					events: events$7,
					exhibit: exhibit$1
				})
			});
			const renderPanelButton = (spec, sharedBackstage) => Dropdown.sketch({
				dom: spec.dom,
				components: spec.components,
				toggleClass: "mce-active",
				dropdownBehaviours: derive$1([
					DisablingConfigs.button(sharedBackstage.providers.isDisabled),
					receivingConfig(),
					Unselecting.config({}),
					Tabstopping.config({})
				]),
				layouts: spec.layouts,
				sandboxClasses: ["tox-dialog__popups"],
				lazySink: sharedBackstage.getSink,
				fetch: (comp) => Future.nu((callback) => spec.fetch(callback)).map((items) => Optional.from(createTieredDataFrom(deepMerge(createPartialChoiceMenu(generate$6("menu-value"), items, (value$5) => {
					spec.onItemAction(comp, value$5);
				}, spec.columns, spec.presets, ItemResponse$1.CLOSE_ON_EXECUTE, never, sharedBackstage.providers), { movement: deriveMenuMovement(spec.columns, spec.presets) })))),
				parts: { menu: part(false, 1, spec.presets) }
			});
			const colorInputChangeEvent = generate$6("color-input-change");
			const colorSwatchChangeEvent = generate$6("color-swatch-change");
			const colorPickerCancelEvent = generate$6("color-picker-cancel");
			const renderColorInput = (spec, sharedBackstage, colorInputBackstage, initialData) => {
				const pField = FormField.parts.field({
					factory: Input,
					inputClasses: ["tox-textfield"],
					data: initialData,
					onSetValue: (c) => Invalidating.run(c).get(noop),
					inputBehaviours: derive$1([
						Disabling.config({ disabled: sharedBackstage.providers.isDisabled }),
						receivingConfig(),
						Tabstopping.config({}),
						Invalidating.config({
							invalidClass: "tox-textbox-field-invalid",
							getRoot: (comp) => parentElement(comp.element),
							notify: { onValid: (comp) => {
								emitWith(comp, colorInputChangeEvent, { color: Representing.getValue(comp) });
							} },
							validator: {
								validateOnLoad: false,
								validate: (input$1) => {
									const inputValue = Representing.getValue(input$1);
									if (inputValue.length === 0) return Future.pure(Result.value(true));
									else {
										const span = SugarElement.fromTag("span");
										set$8(span, "background-color", inputValue);
										const res = getRaw(span, "background-color").fold(() => Result.error("blah"), (_) => Result.value(inputValue));
										return Future.pure(res);
									}
								}
							}
						})
					]),
					selectOnFocus: false
				});
				const pLabel = spec.label.map((label$1) => renderLabel$3(label$1, sharedBackstage.providers));
				const emitSwatchChange = (colorBit, value$5) => {
					emitWith(colorBit, colorSwatchChangeEvent, { value: value$5 });
				};
				const onItemAction$1 = (comp, value$5) => {
					memColorButton.getOpt(comp).each((colorBit) => {
						if (value$5 === "custom") colorInputBackstage.colorPicker((valueOpt) => {
							valueOpt.fold(() => emit(colorBit, colorPickerCancelEvent), (value$6) => {
								emitSwatchChange(colorBit, value$6);
								addColor(spec.storageKey, value$6);
							});
						}, "#ffffff");
						else if (value$5 === "remove") emitSwatchChange(colorBit, "");
						else emitSwatchChange(colorBit, value$5);
					});
				};
				const memColorButton = record(renderPanelButton({
					dom: {
						tag: "span",
						attributes: { "aria-label": sharedBackstage.providers.translate("Color swatch") }
					},
					layouts: {
						onRtl: () => [
							southwest$2,
							southeast$2,
							south$2
						],
						onLtr: () => [
							southeast$2,
							southwest$2,
							south$2
						]
					},
					components: [],
					fetch: getFetch$1(colorInputBackstage.getColors(spec.storageKey), spec.storageKey, colorInputBackstage.hasCustomColors()),
					columns: colorInputBackstage.getColorCols(spec.storageKey),
					presets: "color",
					onItemAction: onItemAction$1
				}, sharedBackstage));
				return FormField.sketch({
					dom: {
						tag: "div",
						classes: ["tox-form__group"]
					},
					components: pLabel.toArray().concat([{
						dom: {
							tag: "div",
							classes: ["tox-color-input"]
						},
						components: [pField, memColorButton.asSpec()]
					}]),
					fieldBehaviours: derive$1([config("form-field-events", [
						run$1(colorInputChangeEvent, (comp, se) => {
							memColorButton.getOpt(comp).each((colorButton) => {
								set$8(colorButton.element, "background-color", se.event.color);
							});
							emitWith(comp, formChangeEvent, { name: spec.name });
						}),
						run$1(colorSwatchChangeEvent, (comp, se) => {
							FormField.getField(comp).each((field$3) => {
								Representing.setValue(field$3, se.event.value);
								Composing.getCurrent(comp).each(Focusing.focus);
							});
						}),
						run$1(colorPickerCancelEvent, (comp, _se) => {
							FormField.getField(comp).each((_field) => {
								Composing.getCurrent(comp).each(Focusing.focus);
							});
						})
					])])
				});
			};
			const labelPart = optional({
				schema: [required$1("dom")],
				name: "label"
			});
			const edgePart = (name$4) => optional({
				name: "" + name$4 + "-edge",
				overrides: (detail) => {
					return detail.model.manager.edgeActions[name$4].fold(() => ({}), (a) => ({ events: derive$2([
						runActionExtra(touchstart(), (comp, se, d) => a(comp, d), [detail]),
						runActionExtra(mousedown(), (comp, se, d) => a(comp, d), [detail]),
						runActionExtra(mousemove(), (comp, se, det) => {
							if (det.mouseIsDown.get()) a(comp, det);
						}, [detail])
					]) }));
				}
			});
			const tlEdgePart = edgePart("top-left");
			const tedgePart = edgePart("top");
			const trEdgePart = edgePart("top-right");
			const redgePart = edgePart("right");
			const brEdgePart = edgePart("bottom-right");
			const bedgePart = edgePart("bottom");
			const blEdgePart = edgePart("bottom-left");
			var SliderParts = [
				labelPart,
				edgePart("left"),
				redgePart,
				tedgePart,
				bedgePart,
				tlEdgePart,
				trEdgePart,
				blEdgePart,
				brEdgePart,
				required({
					name: "thumb",
					defaults: constant$1({ dom: { styles: { position: "absolute" } } }),
					overrides: (detail) => {
						return { events: derive$2([
							redirectToPart(touchstart(), detail, "spectrum"),
							redirectToPart(touchmove(), detail, "spectrum"),
							redirectToPart(touchend(), detail, "spectrum"),
							redirectToPart(mousedown(), detail, "spectrum"),
							redirectToPart(mousemove(), detail, "spectrum"),
							redirectToPart(mouseup(), detail, "spectrum")
						]) };
					}
				}),
				required({
					schema: [customField("mouseIsDown", () => Cell(false))],
					name: "spectrum",
					overrides: (detail) => {
						const model = detail.model.manager;
						const setValueFrom$3 = (component, simulatedEvent) => model.getValueFromEvent(simulatedEvent).map((value$5) => model.setValueFrom(component, detail, value$5));
						return {
							behaviours: derive$1([Keying.config({
								mode: "special",
								onLeft: (spectrum) => model.onLeft(spectrum, detail),
								onRight: (spectrum) => model.onRight(spectrum, detail),
								onUp: (spectrum) => model.onUp(spectrum, detail),
								onDown: (spectrum) => model.onDown(spectrum, detail)
							}), Focusing.config({})]),
							events: derive$2([
								run$1(touchstart(), setValueFrom$3),
								run$1(touchmove(), setValueFrom$3),
								run$1(mousedown(), setValueFrom$3),
								run$1(mousemove(), (spectrum, se) => {
									if (detail.mouseIsDown.get()) setValueFrom$3(spectrum, se);
								})
							])
						};
					}
				})
			];
			const sliderChangeEvent = constant$1("slider.change.value");
			const isTouchEvent$2 = (evt) => evt.type.indexOf("touch") !== -1;
			const getEventSource = (simulatedEvent) => {
				const evt = simulatedEvent.event.raw;
				if (isTouchEvent$2(evt)) {
					const touchEvent = evt;
					return touchEvent.touches !== void 0 && touchEvent.touches.length === 1 ? Optional.some(touchEvent.touches[0]).map((t$1) => SugarPosition(t$1.clientX, t$1.clientY)) : Optional.none();
				} else {
					const mouseEvent = evt;
					return mouseEvent.clientX !== void 0 ? Optional.some(mouseEvent).map((me) => SugarPosition(me.clientX, me.clientY)) : Optional.none();
				}
			};
			const t = "top", r = "right", b = "bottom", l = "left";
			const minX = (detail) => detail.model.minX;
			const minY = (detail) => detail.model.minY;
			const min1X = (detail) => detail.model.minX - 1;
			const min1Y = (detail) => detail.model.minY - 1;
			const maxX = (detail) => detail.model.maxX;
			const maxY = (detail) => detail.model.maxY;
			const max1X = (detail) => detail.model.maxX + 1;
			const max1Y = (detail) => detail.model.maxY + 1;
			const range = (detail, max$1, min$1) => max$1(detail) - min$1(detail);
			const xRange = (detail) => range(detail, maxX, minX);
			const yRange = (detail) => range(detail, maxY, minY);
			const halfX = (detail) => xRange(detail) / 2;
			const halfY = (detail) => yRange(detail) / 2;
			const step = (detail) => detail.stepSize;
			const snap = (detail) => detail.snapToGrid;
			const snapStart = (detail) => detail.snapStart;
			const rounded = (detail) => detail.rounded;
			const hasEdge = (detail, edgeName) => detail[edgeName + "-edge"] !== void 0;
			const hasLEdge = (detail) => hasEdge(detail, l);
			const hasREdge = (detail) => hasEdge(detail, r);
			const hasTEdge = (detail) => hasEdge(detail, t);
			const hasBEdge = (detail) => hasEdge(detail, b);
			const currentValue = (detail) => detail.model.value.get();
			const xyValue = (x, y) => ({
				x,
				y
			});
			const fireSliderChange$3 = (component, value$5) => {
				emitWith(component, sliderChangeEvent(), { value: value$5 });
			};
			const setToTLEdgeXY = (edge$1, detail) => {
				fireSliderChange$3(edge$1, xyValue(min1X(detail), min1Y(detail)));
			};
			const setToTEdge = (edge$1, detail) => {
				fireSliderChange$3(edge$1, min1Y(detail));
			};
			const setToTEdgeXY = (edge$1, detail) => {
				fireSliderChange$3(edge$1, xyValue(halfX(detail), min1Y(detail)));
			};
			const setToTREdgeXY = (edge$1, detail) => {
				fireSliderChange$3(edge$1, xyValue(max1X(detail), min1Y(detail)));
			};
			const setToREdge = (edge$1, detail) => {
				fireSliderChange$3(edge$1, max1X(detail));
			};
			const setToREdgeXY = (edge$1, detail) => {
				fireSliderChange$3(edge$1, xyValue(max1X(detail), halfY(detail)));
			};
			const setToBREdgeXY = (edge$1, detail) => {
				fireSliderChange$3(edge$1, xyValue(max1X(detail), max1Y(detail)));
			};
			const setToBEdge = (edge$1, detail) => {
				fireSliderChange$3(edge$1, max1Y(detail));
			};
			const setToBEdgeXY = (edge$1, detail) => {
				fireSliderChange$3(edge$1, xyValue(halfX(detail), max1Y(detail)));
			};
			const setToBLEdgeXY = (edge$1, detail) => {
				fireSliderChange$3(edge$1, xyValue(min1X(detail), max1Y(detail)));
			};
			const setToLEdge = (edge$1, detail) => {
				fireSliderChange$3(edge$1, min1X(detail));
			};
			const setToLEdgeXY = (edge$1, detail) => {
				fireSliderChange$3(edge$1, xyValue(min1X(detail), halfY(detail)));
			};
			const reduceBy = (value$5, min$1, max$1, step$1) => {
				if (value$5 < min$1) return value$5;
				else if (value$5 > max$1) return max$1;
				else if (value$5 === min$1) return min$1 - 1;
				else return Math.max(min$1, value$5 - step$1);
			};
			const increaseBy = (value$5, min$1, max$1, step$1) => {
				if (value$5 > max$1) return value$5;
				else if (value$5 < min$1) return min$1;
				else if (value$5 === max$1) return max$1 + 1;
				else return Math.min(max$1, value$5 + step$1);
			};
			const capValue = (value$5, min$1, max$1) => Math.max(min$1, Math.min(max$1, value$5));
			const snapValueOf = (value$5, min$1, max$1, step$1, snapStart$1) => snapStart$1.fold(() => {
				const initValue = value$5 - min$1;
				return capValue(min$1 + Math.round(initValue / step$1) * step$1, min$1 - 1, max$1 + 1);
			}, (start) => {
				const remainder = (value$5 - start) % step$1;
				const adjustment = Math.round(remainder / step$1);
				const rawSteps = Math.floor((value$5 - start) / step$1);
				const maxSteps = Math.floor((max$1 - start) / step$1);
				const r$2 = start + Math.min(maxSteps, rawSteps + adjustment) * step$1;
				return Math.max(start, r$2);
			});
			const findOffsetOf = (value$5, min$1, max$1) => Math.min(max$1, Math.max(value$5, min$1)) - min$1;
			const findValueOf = (args) => {
				const { min: min$1, max: max$1, range: range$1, value: value$5, step: step$1, snap: snap$1, snapStart: snapStart$1, rounded: rounded$1, hasMinEdge, hasMaxEdge, minBound, maxBound, screenRange } = args;
				const capMin = hasMinEdge ? min$1 - 1 : min$1;
				const capMax = hasMaxEdge ? max$1 + 1 : max$1;
				if (value$5 < minBound) return capMin;
				else if (value$5 > maxBound) return capMax;
				else {
					const newValue = capValue(findOffsetOf(value$5, minBound, maxBound) / screenRange * range$1 + min$1, capMin, capMax);
					if (snap$1 && newValue >= min$1 && newValue <= max$1) return snapValueOf(newValue, min$1, max$1, step$1, snapStart$1);
					else if (rounded$1) return Math.round(newValue);
					else return newValue;
				}
			};
			const findOffsetOfValue$2 = (args) => {
				const { min: min$1, max: max$1, range: range$1, value: value$5, hasMinEdge, hasMaxEdge, maxBound, maxOffset, centerMinEdge, centerMaxEdge } = args;
				if (value$5 < min$1) return hasMinEdge ? 0 : centerMinEdge;
				else if (value$5 > max$1) return hasMaxEdge ? maxBound : centerMaxEdge;
				else return (value$5 - min$1) / range$1 * maxOffset;
			};
			const top = "top", right = "right", bottom = "bottom", left = "left", width = "width", height = "height";
			const getBounds = (component) => component.element.dom.getBoundingClientRect();
			const getBoundsProperty = (bounds$2, property) => bounds$2[property];
			const getMinXBounds = (component) => {
				return getBoundsProperty(getBounds(component), left);
			};
			const getMaxXBounds = (component) => {
				return getBoundsProperty(getBounds(component), right);
			};
			const getMinYBounds = (component) => {
				return getBoundsProperty(getBounds(component), top);
			};
			const getMaxYBounds = (component) => {
				return getBoundsProperty(getBounds(component), bottom);
			};
			const getXScreenRange = (component) => {
				return getBoundsProperty(getBounds(component), width);
			};
			const getYScreenRange = (component) => {
				return getBoundsProperty(getBounds(component), height);
			};
			const getCenterOffsetOf = (componentMinEdge, componentMaxEdge, spectrumMinEdge) => (componentMinEdge + componentMaxEdge) / 2 - spectrumMinEdge;
			const getXCenterOffSetOf = (component, spectrum) => {
				const componentBounds = getBounds(component);
				const spectrumBounds = getBounds(spectrum);
				return getCenterOffsetOf(getBoundsProperty(componentBounds, left), getBoundsProperty(componentBounds, right), getBoundsProperty(spectrumBounds, left));
			};
			const getYCenterOffSetOf = (component, spectrum) => {
				const componentBounds = getBounds(component);
				const spectrumBounds = getBounds(spectrum);
				return getCenterOffsetOf(getBoundsProperty(componentBounds, top), getBoundsProperty(componentBounds, bottom), getBoundsProperty(spectrumBounds, top));
			};
			const fireSliderChange$2 = (spectrum, value$5) => {
				emitWith(spectrum, sliderChangeEvent(), { value: value$5 });
			};
			const findValueOfOffset$1 = (spectrum, detail, left$1) => {
				return findValueOf({
					min: minX(detail),
					max: maxX(detail),
					range: xRange(detail),
					value: left$1,
					step: step(detail),
					snap: snap(detail),
					snapStart: snapStart(detail),
					rounded: rounded(detail),
					hasMinEdge: hasLEdge(detail),
					hasMaxEdge: hasREdge(detail),
					minBound: getMinXBounds(spectrum),
					maxBound: getMaxXBounds(spectrum),
					screenRange: getXScreenRange(spectrum)
				});
			};
			const setValueFrom$2 = (spectrum, detail, value$5) => {
				const xValue = findValueOfOffset$1(spectrum, detail, value$5);
				fireSliderChange$2(spectrum, xValue);
				return xValue;
			};
			const setToMin$2 = (spectrum, detail) => {
				fireSliderChange$2(spectrum, minX(detail));
			};
			const setToMax$2 = (spectrum, detail) => {
				fireSliderChange$2(spectrum, maxX(detail));
			};
			const moveBy$2 = (direction, spectrum, detail) => {
				const xValue = (direction > 0 ? increaseBy : reduceBy)(currentValue(detail), minX(detail), maxX(detail), step(detail));
				fireSliderChange$2(spectrum, xValue);
				return Optional.some(xValue);
			};
			const handleMovement$2 = (direction) => (spectrum, detail) => moveBy$2(direction, spectrum, detail).map(always);
			const getValueFromEvent$2 = (simulatedEvent) => {
				return getEventSource(simulatedEvent).map((p) => p.left);
			};
			const findOffsetOfValue$1 = (spectrum, detail, value$5, minEdge, maxEdge) => {
				const minOffset = 0;
				const maxOffset = getXScreenRange(spectrum);
				const centerMinEdge = minEdge.bind((edge$1) => Optional.some(getXCenterOffSetOf(edge$1, spectrum))).getOr(minOffset);
				const centerMaxEdge = maxEdge.bind((edge$1) => Optional.some(getXCenterOffSetOf(edge$1, spectrum))).getOr(maxOffset);
				return findOffsetOfValue$2({
					min: minX(detail),
					max: maxX(detail),
					range: xRange(detail),
					value: value$5,
					hasMinEdge: hasLEdge(detail),
					hasMaxEdge: hasREdge(detail),
					minBound: getMinXBounds(spectrum),
					minOffset,
					maxBound: getMaxXBounds(spectrum),
					maxOffset,
					centerMinEdge,
					centerMaxEdge
				});
			};
			const findPositionOfValue$1 = (slider, spectrum, value$5, minEdge, maxEdge, detail) => {
				const offset$1 = findOffsetOfValue$1(spectrum, detail, value$5, minEdge, maxEdge);
				return getMinXBounds(spectrum) - getMinXBounds(slider) + offset$1;
			};
			const setPositionFromValue$2 = (slider, thumb, detail, edges) => {
				const value$5 = currentValue(detail);
				const pos = findPositionOfValue$1(slider, edges.getSpectrum(slider), value$5, edges.getLeftEdge(slider), edges.getRightEdge(slider), detail);
				const thumbRadius = get$c(thumb.element) / 2;
				set$8(thumb.element, "left", pos - thumbRadius + "px");
			};
			const onLeft$2 = handleMovement$2(-1);
			const onRight$2 = handleMovement$2(1);
			const onUp$2 = Optional.none;
			const onDown$2 = Optional.none;
			const edgeActions$2 = {
				"top-left": Optional.none(),
				"top": Optional.none(),
				"top-right": Optional.none(),
				"right": Optional.some(setToREdge),
				"bottom-right": Optional.none(),
				"bottom": Optional.none(),
				"bottom-left": Optional.none(),
				"left": Optional.some(setToLEdge)
			};
			var HorizontalModel = /* @__PURE__ */ Object.freeze({
				__proto__: null,
				setValueFrom: setValueFrom$2,
				setToMin: setToMin$2,
				setToMax: setToMax$2,
				findValueOfOffset: findValueOfOffset$1,
				getValueFromEvent: getValueFromEvent$2,
				findPositionOfValue: findPositionOfValue$1,
				setPositionFromValue: setPositionFromValue$2,
				onLeft: onLeft$2,
				onRight: onRight$2,
				onUp: onUp$2,
				onDown: onDown$2,
				edgeActions: edgeActions$2
			});
			const fireSliderChange$1 = (spectrum, value$5) => {
				emitWith(spectrum, sliderChangeEvent(), { value: value$5 });
			};
			const findValueOfOffset = (spectrum, detail, top$1) => {
				return findValueOf({
					min: minY(detail),
					max: maxY(detail),
					range: yRange(detail),
					value: top$1,
					step: step(detail),
					snap: snap(detail),
					snapStart: snapStart(detail),
					rounded: rounded(detail),
					hasMinEdge: hasTEdge(detail),
					hasMaxEdge: hasBEdge(detail),
					minBound: getMinYBounds(spectrum),
					maxBound: getMaxYBounds(spectrum),
					screenRange: getYScreenRange(spectrum)
				});
			};
			const setValueFrom$1 = (spectrum, detail, value$5) => {
				const yValue = findValueOfOffset(spectrum, detail, value$5);
				fireSliderChange$1(spectrum, yValue);
				return yValue;
			};
			const setToMin$1 = (spectrum, detail) => {
				fireSliderChange$1(spectrum, minY(detail));
			};
			const setToMax$1 = (spectrum, detail) => {
				fireSliderChange$1(spectrum, maxY(detail));
			};
			const moveBy$1 = (direction, spectrum, detail) => {
				const yValue = (direction > 0 ? increaseBy : reduceBy)(currentValue(detail), minY(detail), maxY(detail), step(detail));
				fireSliderChange$1(spectrum, yValue);
				return Optional.some(yValue);
			};
			const handleMovement$1 = (direction) => (spectrum, detail) => moveBy$1(direction, spectrum, detail).map(always);
			const getValueFromEvent$1 = (simulatedEvent) => {
				return getEventSource(simulatedEvent).map((p) => {
					return p.top;
				});
			};
			const findOffsetOfValue = (spectrum, detail, value$5, minEdge, maxEdge) => {
				const minOffset = 0;
				const maxOffset = getYScreenRange(spectrum);
				const centerMinEdge = minEdge.bind((edge$1) => Optional.some(getYCenterOffSetOf(edge$1, spectrum))).getOr(minOffset);
				const centerMaxEdge = maxEdge.bind((edge$1) => Optional.some(getYCenterOffSetOf(edge$1, spectrum))).getOr(maxOffset);
				return findOffsetOfValue$2({
					min: minY(detail),
					max: maxY(detail),
					range: yRange(detail),
					value: value$5,
					hasMinEdge: hasTEdge(detail),
					hasMaxEdge: hasBEdge(detail),
					minBound: getMinYBounds(spectrum),
					minOffset,
					maxBound: getMaxYBounds(spectrum),
					maxOffset,
					centerMinEdge,
					centerMaxEdge
				});
			};
			const findPositionOfValue = (slider, spectrum, value$5, minEdge, maxEdge, detail) => {
				const offset$1 = findOffsetOfValue(spectrum, detail, value$5, minEdge, maxEdge);
				return getMinYBounds(spectrum) - getMinYBounds(slider) + offset$1;
			};
			const setPositionFromValue$1 = (slider, thumb, detail, edges) => {
				const value$5 = currentValue(detail);
				const pos = findPositionOfValue(slider, edges.getSpectrum(slider), value$5, edges.getTopEdge(slider), edges.getBottomEdge(slider), detail);
				const thumbRadius = get$d(thumb.element) / 2;
				set$8(thumb.element, "top", pos - thumbRadius + "px");
			};
			const onLeft$1 = Optional.none;
			const onRight$1 = Optional.none;
			const onUp$1 = handleMovement$1(-1);
			const onDown$1 = handleMovement$1(1);
			const edgeActions$1 = {
				"top-left": Optional.none(),
				"top": Optional.some(setToTEdge),
				"top-right": Optional.none(),
				"right": Optional.none(),
				"bottom-right": Optional.none(),
				"bottom": Optional.some(setToBEdge),
				"bottom-left": Optional.none(),
				"left": Optional.none()
			};
			var VerticalModel = /* @__PURE__ */ Object.freeze({
				__proto__: null,
				setValueFrom: setValueFrom$1,
				setToMin: setToMin$1,
				setToMax: setToMax$1,
				findValueOfOffset,
				getValueFromEvent: getValueFromEvent$1,
				findPositionOfValue,
				setPositionFromValue: setPositionFromValue$1,
				onLeft: onLeft$1,
				onRight: onRight$1,
				onUp: onUp$1,
				onDown: onDown$1,
				edgeActions: edgeActions$1
			});
			const fireSliderChange = (spectrum, value$5) => {
				emitWith(spectrum, sliderChangeEvent(), { value: value$5 });
			};
			const sliderValue = (x, y) => ({
				x,
				y
			});
			const setValueFrom = (spectrum, detail, value$5) => {
				const val = sliderValue(findValueOfOffset$1(spectrum, detail, value$5.left), findValueOfOffset(spectrum, detail, value$5.top));
				fireSliderChange(spectrum, val);
				return val;
			};
			const moveBy = (direction, isVerticalMovement, spectrum, detail) => {
				const f$1 = direction > 0 ? increaseBy : reduceBy;
				const xValue = isVerticalMovement ? currentValue(detail).x : f$1(currentValue(detail).x, minX(detail), maxX(detail), step(detail));
				fireSliderChange(spectrum, sliderValue(xValue, !isVerticalMovement ? currentValue(detail).y : f$1(currentValue(detail).y, minY(detail), maxY(detail), step(detail))));
				return Optional.some(xValue);
			};
			const handleMovement = (direction, isVerticalMovement) => (spectrum, detail) => moveBy(direction, isVerticalMovement, spectrum, detail).map(always);
			const setToMin = (spectrum, detail) => {
				fireSliderChange(spectrum, sliderValue(minX(detail), minY(detail)));
			};
			const setToMax = (spectrum, detail) => {
				fireSliderChange(spectrum, sliderValue(maxX(detail), maxY(detail)));
			};
			const getValueFromEvent = (simulatedEvent) => getEventSource(simulatedEvent);
			const setPositionFromValue = (slider, thumb, detail, edges) => {
				const value$5 = currentValue(detail);
				const xPos = findPositionOfValue$1(slider, edges.getSpectrum(slider), value$5.x, edges.getLeftEdge(slider), edges.getRightEdge(slider), detail);
				const yPos = findPositionOfValue(slider, edges.getSpectrum(slider), value$5.y, edges.getTopEdge(slider), edges.getBottomEdge(slider), detail);
				const thumbXRadius = get$c(thumb.element) / 2;
				const thumbYRadius = get$d(thumb.element) / 2;
				set$8(thumb.element, "left", xPos - thumbXRadius + "px");
				set$8(thumb.element, "top", yPos - thumbYRadius + "px");
			};
			const onLeft = handleMovement(-1, false);
			const onRight = handleMovement(1, false);
			const onUp = handleMovement(-1, true);
			const onDown = handleMovement(1, true);
			const edgeActions = {
				"top-left": Optional.some(setToTLEdgeXY),
				"top": Optional.some(setToTEdgeXY),
				"top-right": Optional.some(setToTREdgeXY),
				"right": Optional.some(setToREdgeXY),
				"bottom-right": Optional.some(setToBREdgeXY),
				"bottom": Optional.some(setToBEdgeXY),
				"bottom-left": Optional.some(setToBLEdgeXY),
				"left": Optional.some(setToLEdgeXY)
			};
			var TwoDModel = /* @__PURE__ */ Object.freeze({
				__proto__: null,
				setValueFrom,
				setToMin,
				setToMax,
				getValueFromEvent,
				setPositionFromValue,
				onLeft,
				onRight,
				onUp,
				onDown,
				edgeActions
			});
			const SliderSchema = [
				defaulted("stepSize", 1),
				defaulted("onChange", noop),
				defaulted("onChoose", noop),
				defaulted("onInit", noop),
				defaulted("onDragStart", noop),
				defaulted("onDragEnd", noop),
				defaulted("snapToGrid", false),
				defaulted("rounded", true),
				option$3("snapStart"),
				requiredOf("model", choose$1("mode", {
					x: [
						defaulted("minX", 0),
						defaulted("maxX", 100),
						customField("value", (spec) => Cell(spec.mode.minX)),
						required$1("getInitialValue"),
						output$1("manager", HorizontalModel)
					],
					y: [
						defaulted("minY", 0),
						defaulted("maxY", 100),
						customField("value", (spec) => Cell(spec.mode.minY)),
						required$1("getInitialValue"),
						output$1("manager", VerticalModel)
					],
					xy: [
						defaulted("minX", 0),
						defaulted("maxX", 100),
						defaulted("minY", 0),
						defaulted("maxY", 100),
						customField("value", (spec) => Cell({
							x: spec.mode.minX,
							y: spec.mode.minY
						})),
						required$1("getInitialValue"),
						output$1("manager", TwoDModel)
					]
				})),
				field("sliderBehaviours", [Keying, Representing]),
				customField("mouseIsDown", () => Cell(false))
			];
			const sketch$2 = (detail, components$2, _spec, _externals) => {
				const getThumb = (component) => getPartOrDie(component, detail, "thumb");
				const getSpectrum = (component) => getPartOrDie(component, detail, "spectrum");
				const getLeftEdge = (component) => getPart(component, detail, "left-edge");
				const getRightEdge = (component) => getPart(component, detail, "right-edge");
				const getTopEdge = (component) => getPart(component, detail, "top-edge");
				const getBottomEdge = (component) => getPart(component, detail, "bottom-edge");
				const modelDetail = detail.model;
				const model = modelDetail.manager;
				const refresh$5 = (slider, thumb) => {
					model.setPositionFromValue(slider, thumb, detail, {
						getLeftEdge,
						getRightEdge,
						getTopEdge,
						getBottomEdge,
						getSpectrum
					});
				};
				const setValue$4 = (slider, newValue) => {
					modelDetail.value.set(newValue);
					refresh$5(slider, getThumb(slider));
				};
				const changeValue = (slider, newValue) => {
					setValue$4(slider, newValue);
					const thumb = getThumb(slider);
					detail.onChange(slider, thumb, newValue);
					return Optional.some(true);
				};
				const resetToMin = (slider) => {
					model.setToMin(slider, detail);
				};
				const resetToMax = (slider) => {
					model.setToMax(slider, detail);
				};
				const choose$3 = (slider) => {
					const fireOnChoose = () => {
						getPart(slider, detail, "thumb").each((thumb) => {
							const value$5 = modelDetail.value.get();
							detail.onChoose(slider, thumb, value$5);
						});
					};
					const wasDown = detail.mouseIsDown.get();
					detail.mouseIsDown.set(false);
					if (wasDown) fireOnChoose();
				};
				const onDragStart = (slider, simulatedEvent) => {
					simulatedEvent.stop();
					detail.mouseIsDown.set(true);
					detail.onDragStart(slider, getThumb(slider));
				};
				const onDragEnd = (slider, simulatedEvent) => {
					simulatedEvent.stop();
					detail.onDragEnd(slider, getThumb(slider));
					choose$3(slider);
				};
				return {
					uid: detail.uid,
					dom: detail.dom,
					components: components$2,
					behaviours: augment(detail.sliderBehaviours, [
						Keying.config({
							mode: "special",
							focusIn: (slider) => {
								return getPart(slider, detail, "spectrum").map(Keying.focusIn).map(always);
							}
						}),
						Representing.config({ store: {
							mode: "manual",
							getValue: (_) => {
								return modelDetail.value.get();
							},
							setValue: setValue$4
						} }),
						Receiving.config({ channels: { [mouseReleased()]: { onReceive: choose$3 } } })
					]),
					events: derive$2([
						run$1(sliderChangeEvent(), (slider, simulatedEvent) => {
							changeValue(slider, simulatedEvent.event.value);
						}),
						runOnAttached((slider, _simulatedEvent) => {
							const getInitial = modelDetail.getInitialValue();
							modelDetail.value.set(getInitial);
							const thumb = getThumb(slider);
							refresh$5(slider, thumb);
							const spectrum = getSpectrum(slider);
							detail.onInit(slider, thumb, spectrum, modelDetail.value.get());
						}),
						run$1(touchstart(), onDragStart),
						run$1(touchend(), onDragEnd),
						run$1(mousedown(), onDragStart),
						run$1(mouseup(), onDragEnd)
					]),
					apis: {
						resetToMin,
						resetToMax,
						setValue: setValue$4,
						refresh: refresh$5
					},
					domModification: { styles: { position: "relative" } }
				};
			};
			const Slider = composite({
				name: "Slider",
				configFields: SliderSchema,
				partFields: SliderParts,
				factory: sketch$2,
				apis: {
					setValue: (apis, slider, value$5) => {
						apis.setValue(slider, value$5);
					},
					resetToMin: (apis, slider) => {
						apis.resetToMin(slider);
					},
					resetToMax: (apis, slider) => {
						apis.resetToMax(slider);
					},
					refresh: (apis, slider) => {
						apis.refresh(slider);
					}
				}
			});
			const fieldsUpdate = generate$6("rgb-hex-update");
			const sliderUpdate = generate$6("slider-update");
			const paletteUpdate = generate$6("palette-update");
			const sliderFactory = (translate$3, getClass) => {
				const spectrum = Slider.parts.spectrum({ dom: {
					tag: "div",
					classes: [getClass("hue-slider-spectrum")],
					attributes: { role: "presentation" }
				} });
				const thumb = Slider.parts.thumb({ dom: {
					tag: "div",
					classes: [getClass("hue-slider-thumb")],
					attributes: { role: "presentation" }
				} });
				return Slider.sketch({
					dom: {
						tag: "div",
						classes: [getClass("hue-slider")],
						attributes: { role: "presentation" }
					},
					rounded: false,
					model: {
						mode: "y",
						getInitialValue: constant$1(0)
					},
					components: [spectrum, thumb],
					sliderBehaviours: derive$1([Focusing.config({})]),
					onChange: (slider, _thumb, value$5) => {
						emitWith(slider, sliderUpdate, { value: value$5 });
					}
				});
			};
			const owner$1 = "form";
			const schema$i = [field("formBehaviours", [Representing])];
			const getPartName$1 = (name$4) => "<alloy.field." + name$4 + ">";
			const sketch$1 = (fSpec) => {
				const parts$10 = (() => {
					const record$1 = [];
					const field$3 = (name$4, config$1) => {
						record$1.push(name$4);
						return generateOne$1(owner$1, getPartName$1(name$4), config$1);
					};
					return {
						field: field$3,
						record: constant$1(record$1)
					};
				})();
				const spec = fSpec(parts$10);
				return composite$1(owner$1, schema$i, map$2(parts$10.record(), (n) => required({
					name: n,
					pname: getPartName$1(n)
				})), make$4, spec);
			};
			const toResult = (o, e) => o.fold(() => Result.error(e), Result.value);
			const make$4 = (detail, components$2) => ({
				uid: detail.uid,
				dom: detail.dom,
				components: components$2,
				behaviours: augment(detail.formBehaviours, [Representing.config({ store: {
					mode: "manual",
					getValue: (form) => {
						return map$1(getAllParts(form, detail), (resPThunk, pName) => resPThunk().bind((v) => {
							return toResult(Composing.getCurrent(v), /* @__PURE__ */ new Error(`Cannot find a current component to extract the value from for form part '${pName}': ` + element(v.element)));
						}).map(Representing.getValue));
					},
					setValue: (form, values$1) => {
						each(values$1, (newValue, key) => {
							getPart(form, detail, key).each((wrapper) => {
								Composing.getCurrent(wrapper).each((field$3) => {
									Representing.setValue(field$3, newValue);
								});
							});
						});
					}
				} })]),
				apis: { getField: (form, key) => {
					return getPart(form, detail, key).bind(Composing.getCurrent);
				} }
			});
			const Form = {
				getField: makeApi((apis, component, key) => apis.getField(component, key)),
				sketch: sketch$1
			};
			const validInput = generate$6("valid-input");
			const invalidInput = generate$6("invalid-input");
			const validatingInput = generate$6("validating-input");
			const translatePrefix = "colorcustom.rgb.";
			const rgbFormFactory = (translate$3, getClass, onValidHexx, onInvalidHexx) => {
				const invalidation = (label$1, isValid) => Invalidating.config({
					invalidClass: getClass("invalid"),
					notify: {
						onValidate: (comp) => {
							emitWith(comp, validatingInput, { type: label$1 });
						},
						onValid: (comp) => {
							emitWith(comp, validInput, {
								type: label$1,
								value: Representing.getValue(comp)
							});
						},
						onInvalid: (comp) => {
							emitWith(comp, invalidInput, {
								type: label$1,
								value: Representing.getValue(comp)
							});
						}
					},
					validator: {
						validate: (comp) => {
							const res = isValid(Representing.getValue(comp)) ? Result.value(true) : Result.error(translate$3("aria.input.invalid"));
							return Future.pure(res);
						},
						validateOnLoad: false
					}
				});
				const renderTextField$1 = (isValid, name$4, label$1, description, data) => {
					const helptext = translate$3(translatePrefix + "range");
					const comps = [FormField.parts.label({
						dom: {
							tag: "label",
							attributes: { "aria-label": description }
						},
						components: [text$2(label$1)]
					}), FormField.parts.field({
						data,
						factory: Input,
						inputAttributes: {
							type: "text",
							...name$4 === "hex" ? { "aria-live": "polite" } : {}
						},
						inputClasses: [getClass("textfield")],
						inputBehaviours: derive$1([invalidation(name$4, isValid), Tabstopping.config({})]),
						onSetValue: (input$1) => {
							if (Invalidating.isInvalid(input$1)) Invalidating.run(input$1).get(noop);
						}
					})];
					const concats = name$4 !== "hex" ? [FormField.parts["aria-descriptor"]({ text: helptext })] : [];
					return {
						dom: {
							tag: "div",
							attributes: { role: "presentation" }
						},
						components: comps.concat(concats)
					};
				};
				const copyRgbToHex = (form, rgba) => {
					const hex = fromRgba(rgba);
					Form.getField(form, "hex").each((hexField) => {
						if (!Focusing.isFocused(hexField)) Representing.setValue(form, { hex: hex.value });
					});
					return hex;
				};
				const copyRgbToForm = (form, rgb) => {
					const red$1 = rgb.red;
					const green = rgb.green;
					const blue = rgb.blue;
					Representing.setValue(form, {
						red: red$1,
						green,
						blue
					});
				};
				const memPreview = record({ dom: {
					tag: "div",
					classes: [getClass("rgba-preview")],
					styles: { "background-color": "white" },
					attributes: { role: "presentation" }
				} });
				const updatePreview = (anyInSystem, hex) => {
					memPreview.getOpt(anyInSystem).each((preview) => {
						set$8(preview.element, "background-color", "#" + hex.value);
					});
				};
				const factory$10 = () => {
					const state = {
						red: Cell(Optional.some(255)),
						green: Cell(Optional.some(255)),
						blue: Cell(Optional.some(255)),
						hex: Cell(Optional.some("ffffff"))
					};
					const copyHexToRgb = (form, hex) => {
						const rgb = fromHex(hex);
						copyRgbToForm(form, rgb);
						setValueRgb(rgb);
					};
					const get$10 = (prop) => state[prop].get();
					const set$10 = (prop, value$5) => {
						state[prop].set(value$5);
					};
					const getValueRgb = () => get$10("red").bind((red$1) => get$10("green").bind((green) => get$10("blue").map((blue) => rgbaColour(red$1, green, blue, 1))));
					const setValueRgb = (rgb) => {
						const red$1 = rgb.red;
						const green = rgb.green;
						const blue = rgb.blue;
						set$10("red", Optional.some(red$1));
						set$10("green", Optional.some(green));
						set$10("blue", Optional.some(blue));
					};
					const onInvalidInput = (form, simulatedEvent) => {
						const data = simulatedEvent.event;
						if (data.type !== "hex") set$10(data.type, Optional.none());
						else onInvalidHexx(form);
					};
					const onValidHex = (form, value$5) => {
						onValidHexx(form);
						const hex = hexColour(value$5);
						set$10("hex", Optional.some(hex.value));
						const rgb = fromHex(hex);
						copyRgbToForm(form, rgb);
						setValueRgb(rgb);
						emitWith(form, fieldsUpdate, { hex });
						updatePreview(form, hex);
					};
					const onValidRgb = (form, prop, value$5) => {
						const val = parseInt(value$5, 10);
						set$10(prop, Optional.some(val));
						getValueRgb().each((rgb) => {
							const hex = copyRgbToHex(form, rgb);
							emitWith(form, fieldsUpdate, { hex });
							updatePreview(form, hex);
						});
					};
					const isHexInputEvent = (data) => data.type === "hex";
					const onValidInput = (form, simulatedEvent) => {
						const data = simulatedEvent.event;
						if (isHexInputEvent(data)) onValidHex(form, data.value);
						else onValidRgb(form, data.type, data.value);
					};
					const formPartStrings = (key) => ({
						label: translate$3(translatePrefix + key + ".label"),
						description: translate$3(translatePrefix + key + ".description")
					});
					const redStrings = formPartStrings("red");
					const greenStrings = formPartStrings("green");
					const blueStrings = formPartStrings("blue");
					const hexStrings = formPartStrings("hex");
					return deepMerge(Form.sketch((parts$10) => ({
						dom: {
							tag: "form",
							classes: [getClass("rgb-form")],
							attributes: { "aria-label": translate$3("aria.color.picker") }
						},
						components: [
							parts$10.field("red", FormField.sketch(renderTextField$1(isRgbaComponent, "red", redStrings.label, redStrings.description, 255))),
							parts$10.field("green", FormField.sketch(renderTextField$1(isRgbaComponent, "green", greenStrings.label, greenStrings.description, 255))),
							parts$10.field("blue", FormField.sketch(renderTextField$1(isRgbaComponent, "blue", blueStrings.label, blueStrings.description, 255))),
							parts$10.field("hex", FormField.sketch(renderTextField$1(isHexString, "hex", hexStrings.label, hexStrings.description, "ffffff"))),
							memPreview.asSpec()
						],
						formBehaviours: derive$1([Invalidating.config({ invalidClass: getClass("form-invalid") }), config("rgb-form-events", [
							run$1(validInput, onValidInput),
							run$1(invalidInput, onInvalidInput),
							run$1(validatingInput, onInvalidInput)
						])])
					})), { apis: { updateHex: (form, hex) => {
						Representing.setValue(form, { hex: hex.value });
						copyHexToRgb(form, hex);
						updatePreview(form, hex);
					} } });
				};
				return single({
					factory: factory$10,
					name: "RgbForm",
					configFields: [],
					apis: { updateHex: (apis, form, hex) => {
						apis.updateHex(form, hex);
					} },
					extraApis: {}
				});
			};
			const paletteFactory = (_translate, getClass) => {
				const spectrumPart = Slider.parts.spectrum({ dom: {
					tag: "canvas",
					attributes: { role: "presentation" },
					classes: [getClass("sv-palette-spectrum")]
				} });
				const thumbPart = Slider.parts.thumb({ dom: {
					tag: "div",
					attributes: { role: "presentation" },
					classes: [getClass("sv-palette-thumb")],
					innerHtml: `<div class=${getClass("sv-palette-inner-thumb")} role="presentation"></div>`
				} });
				const setColour = (canvas, rgba) => {
					const { width: width$1, height: height$1 } = canvas;
					const ctx = canvas.getContext("2d");
					if (ctx === null) return;
					ctx.fillStyle = rgba;
					ctx.fillRect(0, 0, width$1, height$1);
					const grdWhite = ctx.createLinearGradient(0, 0, width$1, 0);
					grdWhite.addColorStop(0, "rgba(255,255,255,1)");
					grdWhite.addColorStop(1, "rgba(255,255,255,0)");
					ctx.fillStyle = grdWhite;
					ctx.fillRect(0, 0, width$1, height$1);
					const grdBlack = ctx.createLinearGradient(0, 0, 0, height$1);
					grdBlack.addColorStop(0, "rgba(0,0,0,0)");
					grdBlack.addColorStop(1, "rgba(0,0,0,1)");
					ctx.fillStyle = grdBlack;
					ctx.fillRect(0, 0, width$1, height$1);
				};
				const setPaletteHue = (slider, hue) => {
					const canvas = slider.components()[0].element.dom;
					setColour(canvas, toString(fromHsv(hsvColour(hue, 100, 100))));
				};
				const setPaletteThumb = (slider, hex) => {
					const hsv = fromRgb(fromHex(hex));
					Slider.setValue(slider, {
						x: hsv.saturation,
						y: 100 - hsv.value
					});
				};
				const factory$10 = (_detail) => {
					const getInitialValue = constant$1({
						x: 0,
						y: 0
					});
					const onChange = (slider, _thumb, value$5) => {
						emitWith(slider, paletteUpdate, { value: value$5 });
					};
					const onInit = (_slider, _thumb, spectrum, _value) => {
						setColour(spectrum.element.dom, toString(red));
					};
					const sliderBehaviours = derive$1([Composing.config({ find: Optional.some }), Focusing.config({})]);
					return Slider.sketch({
						dom: {
							tag: "div",
							attributes: { role: "presentation" },
							classes: [getClass("sv-palette")]
						},
						model: {
							mode: "xy",
							getInitialValue
						},
						rounded: false,
						components: [spectrumPart, thumbPart],
						onChange,
						onInit,
						sliderBehaviours
					});
				};
				return single({
					factory: factory$10,
					name: "SaturationBrightnessPalette",
					configFields: [],
					apis: {
						setHue: (_apis, slider, hue) => {
							setPaletteHue(slider, hue);
						},
						setThumb: (_apis, slider, hex) => {
							setPaletteThumb(slider, hex);
						}
					},
					extraApis: {}
				});
			};
			const makeFactory = (translate$3, getClass) => {
				const factory$10 = (detail) => {
					const rgbForm = rgbFormFactory(translate$3, getClass, detail.onValidHex, detail.onInvalidHex);
					const sbPalette = paletteFactory(translate$3, getClass);
					const hueSliderToDegrees = (hue) => (100 - hue) / 100 * 360;
					const hueDegreesToSlider = (hue) => 100 - hue / 360 * 100;
					const state = {
						paletteRgba: Cell(red),
						paletteHue: Cell(0)
					};
					const memSlider = record(sliderFactory(translate$3, getClass));
					const memPalette = record(sbPalette.sketch({}));
					const memRgb = record(rgbForm.sketch({}));
					const updatePalette = (anyInSystem, _hex, hue) => {
						memPalette.getOpt(anyInSystem).each((palette) => {
							sbPalette.setHue(palette, hue);
						});
					};
					const updateFields = (anyInSystem, hex) => {
						memRgb.getOpt(anyInSystem).each((form) => {
							rgbForm.updateHex(form, hex);
						});
					};
					const updateSlider = (anyInSystem, _hex, hue) => {
						memSlider.getOpt(anyInSystem).each((slider) => {
							Slider.setValue(slider, hueDegreesToSlider(hue));
						});
					};
					const updatePaletteThumb = (anyInSystem, hex) => {
						memPalette.getOpt(anyInSystem).each((palette) => {
							sbPalette.setThumb(palette, hex);
						});
					};
					const updateState = (hex, hue) => {
						const rgba = fromHex(hex);
						state.paletteRgba.set(rgba);
						state.paletteHue.set(hue);
					};
					const runUpdates = (anyInSystem, hex, hue, updates) => {
						updateState(hex, hue);
						each$1(updates, (update) => {
							update(anyInSystem, hex, hue);
						});
					};
					const onPaletteUpdate = () => {
						const updates = [updateFields];
						return (form, simulatedEvent) => {
							const value$5 = simulatedEvent.event.value;
							const oldHue = state.paletteHue.get();
							runUpdates(form, hsvToHex(hsvColour(oldHue, value$5.x, 100 - value$5.y)), oldHue, updates);
						};
					};
					const onSliderUpdate = () => {
						const updates = [updatePalette, updateFields];
						return (form, simulatedEvent) => {
							const hue = hueSliderToDegrees(simulatedEvent.event.value);
							const oldHsv = fromRgb(state.paletteRgba.get());
							runUpdates(form, hsvToHex(hsvColour(hue, oldHsv.saturation, oldHsv.value)), hue, updates);
						};
					};
					const onFieldsUpdate = () => {
						const updates = [
							updatePalette,
							updateSlider,
							updatePaletteThumb
						];
						return (form, simulatedEvent) => {
							const hex = simulatedEvent.event.hex;
							runUpdates(form, hex, hexToHsv(hex).hue, updates);
						};
					};
					return {
						uid: detail.uid,
						dom: detail.dom,
						components: [
							memPalette.asSpec(),
							memSlider.asSpec(),
							memRgb.asSpec()
						],
						behaviours: derive$1([
							config("colour-picker-events", [
								run$1(fieldsUpdate, onFieldsUpdate()),
								run$1(paletteUpdate, onPaletteUpdate()),
								run$1(sliderUpdate, onSliderUpdate())
							]),
							Composing.config({ find: (comp) => memRgb.getOpt(comp) }),
							Keying.config({ mode: "acyclic" })
						])
					};
				};
				return single({
					name: "ColourPicker",
					configFields: [
						required$1("dom"),
						defaulted("onValidHex", noop),
						defaulted("onInvalidHex", noop)
					],
					factory: factory$10
				});
			};
			const self = () => Composing.config({ find: Optional.some });
			const memento$1 = (mem) => Composing.config({ find: mem.getOpt });
			const childAt = (index) => Composing.config({ find: (comp) => child$2(comp.element, index).bind((element$1) => comp.getSystem().getByDom(element$1).toOptional()) });
			const ComposingConfigs = {
				self,
				memento: memento$1,
				childAt
			};
			const processors = objOf([defaulted("preprocess", identity), defaulted("postprocess", identity)]);
			const memento = (mem, rawProcessors) => {
				const ps = asRawOrDie$1("RepresentingConfigs.memento processors", processors, rawProcessors);
				return Representing.config({ store: {
					mode: "manual",
					getValue: (comp) => {
						const other = mem.get(comp);
						const rawValue = Representing.getValue(other);
						return ps.postprocess(rawValue);
					},
					setValue: (comp, rawValue) => {
						const newValue = ps.preprocess(rawValue);
						const other = mem.get(comp);
						Representing.setValue(other, newValue);
					}
				} });
			};
			const withComp = (optInitialValue, getter, setter) => Representing.config({ store: {
				mode: "manual",
				...optInitialValue.map((initialValue) => ({ initialValue })).getOr({}),
				getValue: getter,
				setValue: setter
			} });
			const withElement = (initialValue, getter, setter) => withComp(initialValue, (c) => getter(c.element), (c, v) => setter(c.element, v));
			const domHtml = (optInitialValue) => withElement(optInitialValue, get$9, set$6);
			const memory = (initialValue) => Representing.config({ store: {
				mode: "memory",
				initialValue
			} });
			const english = {
				"colorcustom.rgb.red.label": "R",
				"colorcustom.rgb.red.description": "Red component",
				"colorcustom.rgb.green.label": "G",
				"colorcustom.rgb.green.description": "Green component",
				"colorcustom.rgb.blue.label": "B",
				"colorcustom.rgb.blue.description": "Blue component",
				"colorcustom.rgb.hex.label": "#",
				"colorcustom.rgb.hex.description": "Hex color code",
				"colorcustom.rgb.range": "Range 0 to 255",
				"aria.color.picker": "Color Picker",
				"aria.input.invalid": "Invalid input"
			};
			const translate$1 = (providerBackstage) => (key) => {
				return providerBackstage.translate(english[key]);
			};
			const renderColorPicker = (_spec, providerBackstage, initialData) => {
				const getClass = (key) => "tox-" + key;
				const colourPickerFactory = makeFactory(translate$1(providerBackstage), getClass);
				const onValidHex = (form) => {
					emitWith(form, formActionEvent, {
						name: "hex-valid",
						value: true
					});
				};
				const onInvalidHex = (form) => {
					emitWith(form, formActionEvent, {
						name: "hex-valid",
						value: false
					});
				};
				const memPicker = record(colourPickerFactory.sketch({
					dom: {
						tag: "div",
						classes: [getClass("color-picker-container")],
						attributes: { role: "presentation" }
					},
					onValidHex,
					onInvalidHex
				}));
				return {
					dom: { tag: "div" },
					components: [memPicker.asSpec()],
					behaviours: derive$1([withComp(initialData, (comp) => {
						const picker = memPicker.get(comp);
						return Composing.getCurrent(picker).bind((rgbForm) => {
							return Representing.getValue(rgbForm).hex;
						}).map((hex) => "#" + removeLeading(hex, "#")).getOr("");
					}, (comp, newValue) => {
						const valOpt = Optional.from(/^#([a-fA-F0-9]{3}(?:[a-fA-F0-9]{3})?)/.exec(newValue)).bind((matches) => get$h(matches, 1));
						const picker = memPicker.get(comp);
						Composing.getCurrent(picker).fold(() => {
							console.log("Can not find form");
						}, (rgbForm) => {
							Representing.setValue(rgbForm, { hex: valOpt.getOr("") });
							Form.getField(rgbForm, "hex").each((hexField) => {
								emit(hexField, input());
							});
						});
					}), ComposingConfigs.self()])
				};
			};
			var global$2 = tinymce.util.Tools.resolve("tinymce.Resource");
			const isOldCustomEditor = (spec) => has$2(spec, "init");
			const renderCustomEditor = (spec) => {
				const editorApi = value$2();
				const memReplaced = record({ dom: { tag: spec.tag } });
				const initialValue = value$2();
				return {
					dom: {
						tag: "div",
						classes: ["tox-custom-editor"]
					},
					behaviours: derive$1([
						config("custom-editor-events", [runOnAttached((component) => {
							memReplaced.getOpt(component).each((ta) => {
								(isOldCustomEditor(spec) ? spec.init(ta.element.dom) : global$2.load(spec.scriptId, spec.scriptUrl).then((init$10) => init$10(ta.element.dom, spec.settings))).then((ea) => {
									initialValue.on((cvalue) => {
										ea.setValue(cvalue);
									});
									initialValue.clear();
									editorApi.set(ea);
								});
							});
						})]),
						withComp(Optional.none(), () => editorApi.get().fold(() => initialValue.get().getOr(""), (ed) => ed.getValue()), (component, value$5) => {
							editorApi.get().fold(() => initialValue.set(value$5), (ed) => ed.setValue(value$5));
						}),
						ComposingConfigs.self()
					]),
					components: [memReplaced.asSpec()]
				};
			};
			var global$1 = tinymce.util.Tools.resolve("tinymce.util.Tools");
			const filterByExtension = (files, providersBackstage) => {
				const allowedImageFileTypes = global$1.explode(providersBackstage.getOption("images_file_types"));
				const isFileInAllowedTypes = (file) => exists(allowedImageFileTypes, (type$2) => endsWith(file.name.toLowerCase(), `.${type$2.toLowerCase()}`));
				return filter$2(from(files), isFileInAllowedTypes);
			};
			const renderDropZone = (spec, providersBackstage, initialData) => {
				const stopper$1 = (_, se) => {
					se.stop();
				};
				const sequence$1 = (actions) => (comp, se) => {
					each$1(actions, (a) => {
						a(comp, se);
					});
				};
				const onDrop = (comp, se) => {
					var _a;
					if (!Disabling.isDisabled(comp)) {
						const transferEvent = se.event.raw;
						handleFiles(comp, (_a = transferEvent.dataTransfer) === null || _a === void 0 ? void 0 : _a.files);
					}
				};
				const onSelect = (component, simulatedEvent) => {
					const input$1 = simulatedEvent.event.raw.target;
					handleFiles(component, input$1.files);
				};
				const handleFiles = (component, files) => {
					if (files) {
						Representing.setValue(component, filterByExtension(files, providersBackstage));
						emitWith(component, formChangeEvent, { name: spec.name });
					}
				};
				const memInput = record({
					dom: {
						tag: "input",
						attributes: {
							type: "file",
							accept: "image/*"
						},
						styles: { display: "none" }
					},
					behaviours: derive$1([config("input-file-events", [cutter(click()), cutter(tap())])])
				});
				const renderField = (s) => ({
					uid: s.uid,
					dom: {
						tag: "div",
						classes: ["tox-dropzone-container"]
					},
					behaviours: derive$1([
						memory(initialData.getOr([])),
						ComposingConfigs.self(),
						Disabling.config({}),
						Toggling.config({
							toggleClass: "dragenter",
							toggleOnExecute: false
						}),
						config("dropzone-events", [
							run$1("dragenter", sequence$1([stopper$1, Toggling.toggle])),
							run$1("dragleave", sequence$1([stopper$1, Toggling.toggle])),
							run$1("dragover", stopper$1),
							run$1("drop", sequence$1([stopper$1, onDrop])),
							run$1(change(), onSelect)
						])
					]),
					components: [{
						dom: {
							tag: "div",
							classes: ["tox-dropzone"],
							styles: {}
						},
						components: [{
							dom: { tag: "p" },
							components: [text$2(providersBackstage.translate("Drop an image here"))]
						}, Button.sketch({
							dom: {
								tag: "button",
								styles: { position: "relative" },
								classes: ["tox-button", "tox-button--secondary"]
							},
							components: [text$2(providersBackstage.translate("Browse for an image")), memInput.asSpec()],
							action: (comp) => {
								memInput.get(comp).element.dom.click();
							},
							buttonBehaviours: derive$1([
								Tabstopping.config({}),
								DisablingConfigs.button(providersBackstage.isDisabled),
								receivingConfig()
							])
						})]
					}]
				});
				return renderFormFieldWith(spec.label.map((label$1) => renderLabel$3(label$1, providersBackstage)), FormField.parts.field({ factory: { sketch: renderField } }), ["tox-form__group--stretched"], []);
			};
			const renderGrid = (spec, backstage) => ({
				dom: {
					tag: "div",
					classes: ["tox-form__grid", `tox-form__grid--${spec.columns}col`]
				},
				components: map$2(spec.items, backstage.interpreter)
			});
			const adaptable = (fn, rate) => {
				let timer = null;
				let args = null;
				const cancel = () => {
					if (!isNull(timer)) {
						clearTimeout(timer);
						timer = null;
						args = null;
					}
				};
				const throttle$1 = (...newArgs) => {
					args = newArgs;
					if (isNull(timer)) timer = setTimeout(() => {
						const tempArgs = args;
						timer = null;
						args = null;
						fn.apply(null, tempArgs);
					}, rate);
				};
				return {
					cancel,
					throttle: throttle$1
				};
			};
			const first = (fn, rate) => {
				let timer = null;
				const cancel = () => {
					if (!isNull(timer)) {
						clearTimeout(timer);
						timer = null;
					}
				};
				const throttle$1 = (...args) => {
					if (isNull(timer)) timer = setTimeout(() => {
						timer = null;
						fn.apply(null, args);
					}, rate);
				};
				return {
					cancel,
					throttle: throttle$1
				};
			};
			const last = (fn, rate) => {
				let timer = null;
				const cancel = () => {
					if (!isNull(timer)) {
						clearTimeout(timer);
						timer = null;
					}
				};
				const throttle$1 = (...args) => {
					cancel();
					timer = setTimeout(() => {
						timer = null;
						fn.apply(null, args);
					}, rate);
				};
				return {
					cancel,
					throttle: throttle$1
				};
			};
			const beforeObject = generate$6("alloy-fake-before-tabstop");
			const afterObject = generate$6("alloy-fake-after-tabstop");
			const craftWithClasses = (classes$1) => {
				return {
					dom: {
						tag: "div",
						styles: {
							width: "1px",
							height: "1px",
							outline: "none"
						},
						attributes: { tabindex: "0" },
						classes: classes$1
					},
					behaviours: derive$1([Focusing.config({ ignore: true }), Tabstopping.config({})])
				};
			};
			const craft = (containerClasses, spec) => {
				return {
					dom: {
						tag: "div",
						classes: ["tox-navobj", ...containerClasses.getOr([])]
					},
					components: [
						craftWithClasses([beforeObject]),
						spec,
						craftWithClasses([afterObject])
					],
					behaviours: derive$1([ComposingConfigs.childAt(1)])
				};
			};
			const triggerTab = (placeholder$1, shiftKey) => {
				emitWith(placeholder$1, keydown(), { raw: {
					which: 9,
					shiftKey
				} });
			};
			const onFocus = (container, targetComp) => {
				const target = targetComp.element;
				if (has(target, beforeObject)) triggerTab(container, true);
				else if (has(target, afterObject)) triggerTab(container, false);
			};
			const isPseudoStop = (element$1) => {
				return closest(element$1, ["." + beforeObject, "." + afterObject].join(","), never);
			};
			const dialogChannel = generate$6("update-dialog");
			const titleChannel = generate$6("update-title");
			const bodyChannel = generate$6("update-body");
			const footerChannel = generate$6("update-footer");
			const bodySendMessageChannel = generate$6("body-send-message");
			const dialogFocusShiftedChannel = generate$6("dialog-focus-shifted");
			const browser = detect$2().browser;
			const isSafari = browser.isSafari();
			const isFirefox = browser.isFirefox();
			const isSafariOrFirefox = isSafari || isFirefox;
			const isChromium = browser.isChromium();
			const isElementScrollAtBottom = ({ scrollTop, scrollHeight, clientHeight }) => Math.ceil(scrollTop) + clientHeight >= scrollHeight;
			const scrollToY = (win$1, y) => win$1.scrollTo(0, y === "bottom" ? 99999999 : y);
			const getScrollingElement = (doc, html$2) => {
				const body$1 = doc.body;
				return Optional.from(!/^<!DOCTYPE (html|HTML)/.test(html$2) && (!isChromium && !isSafari || isNonNullable(body$1) && (body$1.scrollTop !== 0 || Math.abs(body$1.scrollHeight - body$1.clientHeight) > 1)) ? body$1 : doc.documentElement);
			};
			const writeValue = (iframeElement, html$2, fallbackFn) => {
				const iframe$1 = iframeElement.dom;
				Optional.from(iframe$1.contentDocument).fold(fallbackFn, (doc) => {
					let lastScrollTop = 0;
					const isScrollAtBottom = getScrollingElement(doc, html$2).map((el) => {
						lastScrollTop = el.scrollTop;
						return el;
					}).forall(isElementScrollAtBottom);
					const scrollAfterWrite = () => {
						const win$1 = iframe$1.contentWindow;
						if (isNonNullable(win$1)) {
							if (isScrollAtBottom) scrollToY(win$1, "bottom");
							else if (!isScrollAtBottom && isSafariOrFirefox && lastScrollTop !== 0) scrollToY(win$1, lastScrollTop);
						}
					};
					if (isSafari) iframe$1.addEventListener("load", scrollAfterWrite, { once: true });
					doc.open();
					doc.write(html$2);
					doc.close();
					if (!isSafari) scrollAfterWrite();
				});
			};
			const writeValueThrottler = someIf(isSafariOrFirefox, isSafari ? 500 : 200).map((interval) => adaptable(writeValue, interval));
			const getDynamicSource = (initialData, stream) => {
				const cachedValue = Cell(initialData.getOr(""));
				return {
					getValue: (_frameComponent) => cachedValue.get(),
					setValue: (frameComponent, html$2) => {
						if (cachedValue.get() !== html$2) {
							const iframeElement = frameComponent.element;
							const setSrcdocValue = () => set$9(iframeElement, "srcdoc", html$2);
							if (stream) writeValueThrottler.fold(constant$1(writeValue), (throttler) => throttler.throttle)(iframeElement, html$2, setSrcdocValue);
							else setSrcdocValue();
						}
						cachedValue.set(html$2);
					}
				};
			};
			const renderIFrame = (spec, providersBackstage, initialData) => {
				const baseClass = "tox-dialog__iframe";
				const opaqueClass = spec.transparent ? [] : [`${baseClass}--opaque`];
				const containerBorderedClass = spec.border ? [`tox-navobj-bordered`] : [];
				const attributes = {
					...spec.label.map((title$1) => ({ title: title$1 })).getOr({}),
					...initialData.map((html$2) => ({ srcdoc: html$2 })).getOr({}),
					...spec.sandboxed ? { sandbox: "allow-scripts allow-same-origin" } : {}
				};
				const sourcing = getDynamicSource(initialData, spec.streamContent);
				const pLabel = spec.label.map((label$1) => renderLabel$3(label$1, providersBackstage));
				const factory$10 = (newSpec) => craft(Optional.from(containerBorderedClass), {
					uid: newSpec.uid,
					dom: {
						tag: "iframe",
						attributes,
						classes: [baseClass, ...opaqueClass]
					},
					behaviours: derive$1([
						Tabstopping.config({}),
						Focusing.config({}),
						withComp(initialData, sourcing.getValue, sourcing.setValue),
						Receiving.config({ channels: { [dialogFocusShiftedChannel]: { onReceive: (comp, message) => {
							message.newFocus.each((newFocus) => {
								parentElement(comp.element).each((parent$1) => {
									(eq(comp.element, newFocus) ? add$2 : remove$2)(parent$1, "tox-navobj-bordered-focus");
								});
							});
						} } } })
					])
				});
				return renderFormFieldWith(pLabel, FormField.parts.field({ factory: { sketch: factory$10 } }), ["tox-form__group--stretched"], []);
			};
			const image = (image$1) => new Promise((resolve$1, reject) => {
				const loaded = () => {
					destroy();
					resolve$1(image$1);
				};
				const listeners = [bind(image$1, "load", loaded), bind(image$1, "error", () => {
					destroy();
					reject("Unable to load data from image: " + image$1.dom.src);
				})];
				const destroy = () => each$1(listeners, (l$1) => l$1.unbind());
				if (image$1.dom.complete) loaded();
			});
			const calculateImagePosition = (panelWidth, panelHeight, imageWidth, imageHeight, zoom) => {
				const width$1 = imageWidth * zoom;
				const height$1 = imageHeight * zoom;
				const left$1 = Math.max(0, panelWidth / 2 - width$1 / 2);
				const top$1 = Math.max(0, panelHeight / 2 - height$1 / 2);
				return {
					left: left$1.toString() + "px",
					top: top$1.toString() + "px",
					width: width$1.toString() + "px",
					height: height$1.toString() + "px"
				};
			};
			const zoomToFit = (panel, width$1, height$1) => {
				const panelW = get$c(panel);
				const panelH = get$d(panel);
				return Math.min(panelW / width$1, panelH / height$1, 1);
			};
			const renderImagePreview = (spec, initialData) => {
				const cachedData = Cell(initialData.getOr({ url: "" }));
				const memImage = record({ dom: {
					tag: "img",
					classes: ["tox-imagepreview__image"],
					attributes: initialData.map((data) => ({ src: data.url })).getOr({})
				} });
				const memContainer = record({
					dom: {
						tag: "div",
						classes: ["tox-imagepreview__container"],
						attributes: { role: "presentation" }
					},
					components: [memImage.asSpec()]
				});
				const setValue$4 = (frameComponent, data) => {
					const translatedData = { url: data.url };
					data.zoom.each((z) => translatedData.zoom = z);
					data.cachedWidth.each((z) => translatedData.cachedWidth = z);
					data.cachedHeight.each((z) => translatedData.cachedHeight = z);
					cachedData.set(translatedData);
					const applyFramePositioning = () => {
						const { cachedWidth, cachedHeight, zoom } = translatedData;
						if (!isUndefined(cachedWidth) && !isUndefined(cachedHeight)) {
							if (isUndefined(zoom)) translatedData.zoom = zoomToFit(frameComponent.element, cachedWidth, cachedHeight);
							const position$3 = calculateImagePosition(get$c(frameComponent.element), get$d(frameComponent.element), cachedWidth, cachedHeight, translatedData.zoom);
							memContainer.getOpt(frameComponent).each((container) => {
								setAll(container.element, position$3);
							});
						}
					};
					memImage.getOpt(frameComponent).each((imageComponent) => {
						const img = imageComponent.element;
						if (data.url !== get$f(img, "src")) {
							set$9(img, "src", data.url);
							remove$2(frameComponent.element, "tox-imagepreview__loaded");
						}
						applyFramePositioning();
						image(img).then((img$1) => {
							if (frameComponent.getSystem().isConnected()) {
								add$2(frameComponent.element, "tox-imagepreview__loaded");
								translatedData.cachedWidth = img$1.dom.naturalWidth;
								translatedData.cachedHeight = img$1.dom.naturalHeight;
								applyFramePositioning();
							}
						});
					});
				};
				const styles = {};
				spec.height.each((h) => styles.height = h);
				const fakeValidatedData = initialData.map((d) => ({
					url: d.url,
					zoom: Optional.from(d.zoom),
					cachedWidth: Optional.from(d.cachedWidth),
					cachedHeight: Optional.from(d.cachedHeight)
				}));
				return {
					dom: {
						tag: "div",
						classes: ["tox-imagepreview"],
						styles,
						attributes: { role: "presentation" }
					},
					components: [memContainer.asSpec()],
					behaviours: derive$1([ComposingConfigs.self(), withComp(fakeValidatedData, () => cachedData.get(), setValue$4)])
				};
			};
			const renderLabel$2 = (spec, backstageShared) => {
				const baseClass = "tox-label";
				const centerClass = spec.align === "center" ? [`${baseClass}--center`] : [];
				const endClass = spec.align === "end" ? [`${baseClass}--end`] : [];
				return {
					dom: {
						tag: "div",
						classes: ["tox-form__group"]
					},
					components: [{
						dom: {
							tag: "label",
							classes: [
								baseClass,
								...centerClass,
								...endClass
							]
						},
						components: [text$2(backstageShared.providers.translate(spec.label))]
					}, ...map$2(spec.items, backstageShared.interpreter)],
					behaviours: derive$1([
						ComposingConfigs.self(),
						Replacing.config({}),
						domHtml(Optional.none()),
						Keying.config({ mode: "acyclic" })
					])
				};
			};
			const internalToolbarButtonExecute = generate$6("toolbar.button.execute");
			const onToolbarButtonExecute = (info) => runOnExecute$1((comp, _simulatedEvent) => {
				runWithApi(info, comp)((itemApi) => {
					emitWith(comp, internalToolbarButtonExecute, { buttonApi: itemApi });
					info.onAction(itemApi);
				});
			});
			const commonButtonDisplayEvent = generate$6("common-button-display-events");
			const toolbarButtonEventOrder = {
				[execute$5()]: [
					"disabling",
					"alloy.base.behaviour",
					"toggling",
					"toolbar-button-events"
				],
				[attachedToDom()]: ["toolbar-button-events", commonButtonDisplayEvent],
				[mousedown()]: [
					"focusing",
					"alloy.base.behaviour",
					commonButtonDisplayEvent
				]
			};
			const forceInitialSize = (comp) => set$8(comp.element, "width", get$e(comp.element, "width"));
			const renderIcon$1 = (iconName, iconsProvider, behaviours$1) => render$3(iconName, {
				tag: "span",
				classes: ["tox-icon", "tox-tbtn__icon-wrap"],
				behaviours: behaviours$1
			}, iconsProvider);
			const renderIconFromPack$1 = (iconName, iconsProvider) => renderIcon$1(iconName, iconsProvider, []);
			const renderReplaceableIconFromPack = (iconName, iconsProvider) => renderIcon$1(iconName, iconsProvider, [Replacing.config({})]);
			const renderLabel$1 = (text$3, prefix$2, providersBackstage) => ({
				dom: {
					tag: "span",
					classes: [`${prefix$2}__select-label`]
				},
				components: [text$2(providersBackstage.translate(text$3))],
				behaviours: derive$1([Replacing.config({})])
			});
			const updateMenuText = generate$6("update-menu-text");
			const updateMenuIcon = generate$6("update-menu-icon");
			const renderCommonDropdown = (spec, prefix$2, sharedBackstage) => {
				const editorOffCell = Cell(noop);
				const optMemDisplayText = spec.text.map((text$3) => record(renderLabel$1(text$3, prefix$2, sharedBackstage.providers)));
				const optMemDisplayIcon = spec.icon.map((iconName) => record(renderReplaceableIconFromPack(iconName, sharedBackstage.providers.icons)));
				const onLeftOrRightInMenu = (comp, se) => {
					const dropdown = Representing.getValue(comp);
					Focusing.focus(dropdown);
					emitWith(dropdown, "keydown", { raw: se.event.raw });
					Dropdown.close(dropdown);
					return Optional.some(true);
				};
				const role = spec.role.fold(() => ({}), (role$1) => ({ role: role$1 }));
				const tooltipAttributes = spec.tooltip.fold(() => ({}), (tooltip) => {
					const translatedTooltip = sharedBackstage.providers.translate(tooltip);
					return {
						"title": translatedTooltip,
						"aria-label": translatedTooltip
					};
				});
				const iconSpec = render$3("chevron-down", {
					tag: "div",
					classes: [`${prefix$2}__select-chevron`]
				}, sharedBackstage.providers.icons);
				const fixWidthBehaviourName = generate$6("common-button-display-events");
				return record(Dropdown.sketch({
					...spec.uid ? { uid: spec.uid } : {},
					...role,
					dom: {
						tag: "button",
						classes: [prefix$2, `${prefix$2}--select`].concat(map$2(spec.classes, (c) => `${prefix$2}--${c}`)),
						attributes: { ...tooltipAttributes }
					},
					components: componentRenderPipeline([
						optMemDisplayIcon.map((mem) => mem.asSpec()),
						optMemDisplayText.map((mem) => mem.asSpec()),
						Optional.some(iconSpec)
					]),
					matchWidth: true,
					useMinWidth: true,
					onOpen: (anchor$1, dropdownComp, tmenuComp) => {
						if (spec.searchable) focusSearchField(tmenuComp);
					},
					dropdownBehaviours: derive$1([
						...spec.dropdownBehaviours,
						DisablingConfigs.button(() => spec.disabled || sharedBackstage.providers.isDisabled()),
						receivingConfig(),
						Unselecting.config({}),
						Replacing.config({}),
						config("dropdown-events", [onControlAttached(spec, editorOffCell), onControlDetached(spec, editorOffCell)]),
						config(fixWidthBehaviourName, [runOnAttached((comp, _se) => forceInitialSize(comp))]),
						config("menubutton-update-display-text", [run$1(updateMenuText, (comp, se) => {
							optMemDisplayText.bind((mem) => mem.getOpt(comp)).each((displayText) => {
								Replacing.set(displayText, [text$2(sharedBackstage.providers.translate(se.event.text))]);
							});
						}), run$1(updateMenuIcon, (comp, se) => {
							optMemDisplayIcon.bind((mem) => mem.getOpt(comp)).each((displayIcon) => {
								Replacing.set(displayIcon, [renderReplaceableIconFromPack(se.event.icon, sharedBackstage.providers.icons)]);
							});
						})])
					]),
					eventOrder: deepMerge(toolbarButtonEventOrder, {
						mousedown: [
							"focusing",
							"alloy.base.behaviour",
							"item-type-events",
							"normal-dropdown-events"
						],
						[attachedToDom()]: [
							"toolbar-button-events",
							"dropdown-events",
							fixWidthBehaviourName
						]
					}),
					sandboxBehaviours: derive$1([Keying.config({
						mode: "special",
						onLeft: onLeftOrRightInMenu,
						onRight: onLeftOrRightInMenu
					}), config("dropdown-sandbox-events", [run$1(refetchTriggerEvent, (originalSandboxComp, se) => {
						handleRefetchTrigger(originalSandboxComp);
						se.stop();
					}), run$1(redirectMenuItemInteractionEvent, (sandboxComp, se) => {
						handleRedirectToMenuItem(sandboxComp, se);
						se.stop();
					})])]),
					lazySink: sharedBackstage.getSink,
					toggleClass: `${prefix$2}--active`,
					parts: { menu: {
						...part(false, spec.columns, spec.presets),
						fakeFocus: spec.searchable,
						onHighlightItem: updateAriaOnHighlight,
						onCollapseMenu: (tmenuComp, itemCompCausingCollapse, nowActiveMenuComp) => {
							Highlighting.getHighlighted(nowActiveMenuComp).each((itemComp) => {
								updateAriaOnHighlight(tmenuComp, nowActiveMenuComp, itemComp);
							});
						},
						onDehighlightItem: updateAriaOnDehighlight
					} },
					getAnchorOverrides: () => {
						return { maxHeightFunction: (element$1, available) => {
							anchored()(element$1, available - 10);
						} };
					},
					fetch: (comp) => Future.nu(curry(spec.fetch, comp))
				})).asSpec();
			};
			const isMenuItemReference = (item$1) => isString(item$1);
			const isSeparator$2 = (item$1) => item$1.type === "separator";
			const isExpandingMenuItem = (item$1) => has$2(item$1, "getSubmenuItems");
			const separator$2 = { type: "separator" };
			const unwrapReferences = (items, menuItems) => {
				const realItems = foldl(items, (acc, item$1) => {
					if (isMenuItemReference(item$1)) if (item$1 === "") return acc;
					else if (item$1 === "|") return acc.length > 0 && !isSeparator$2(acc[acc.length - 1]) ? acc.concat([separator$2]) : acc;
					else if (has$2(menuItems, item$1.toLowerCase())) return acc.concat([menuItems[item$1.toLowerCase()]]);
					else return acc;
					else return acc.concat([item$1]);
				}, []);
				if (realItems.length > 0 && isSeparator$2(realItems[realItems.length - 1])) realItems.pop();
				return realItems;
			};
			const getFromExpandingItem = (item$1, menuItems) => {
				const rest = expand(item$1.getSubmenuItems(), menuItems);
				return {
					item: item$1,
					menus: deepMerge(rest.menus, { [item$1.value]: rest.items }),
					expansions: deepMerge(rest.expansions, { [item$1.value]: item$1.value })
				};
			};
			const generateValueIfRequired = (item$1) => {
				return deepMerge({ value: get$g(item$1, "value").getOrThunk(() => generate$6("generated-menu-item")) }, item$1);
			};
			const expand = (items, menuItems) => {
				return foldr(unwrapReferences(isString(items) ? items.split(" ") : items, menuItems), (acc, item$1) => {
					if (isExpandingMenuItem(item$1)) {
						const newData = getFromExpandingItem(generateValueIfRequired(item$1), menuItems);
						return {
							menus: deepMerge(acc.menus, newData.menus),
							items: [newData.item, ...acc.items],
							expansions: deepMerge(acc.expansions, newData.expansions)
						};
					} else return {
						...acc,
						items: [item$1, ...acc.items]
					};
				}, {
					menus: {},
					expansions: {},
					items: []
				});
			};
			const getSearchModeForField = (settings) => {
				return settings.search.fold(() => ({ searchMode: "no-search" }), (searchSettings) => ({
					searchMode: "search-with-field",
					placeholder: searchSettings.placeholder
				}));
			};
			const getSearchModeForResults = (settings) => {
				return settings.search.fold(() => ({ searchMode: "no-search" }), (_) => ({ searchMode: "search-with-results" }));
			};
			const build = (items, itemResponse, backstage, settings) => {
				const primary$1 = generate$6("primary-menu");
				const data = expand(items, backstage.shared.providers.menuItems());
				if (data.items.length === 0) return Optional.none();
				const mainMenuSearchMode = getSearchModeForField(settings);
				const mainMenu = createPartialMenu(primary$1, data.items, itemResponse, backstage, settings.isHorizontalMenu, mainMenuSearchMode);
				const submenuSearchMode = getSearchModeForResults(settings);
				const menus = deepMerge(map$1(data.menus, (menuItems, menuName) => createPartialMenu(menuName, menuItems, itemResponse, backstage, false, submenuSearchMode)), wrap$1(primary$1, mainMenu));
				return Optional.from(tieredMenu.tieredData(primary$1, menus, data.expansions));
			};
			const isSingleListItem = (item$1) => !has$2(item$1, "items");
			const dataAttribute = "data-value";
			const fetchItems = (dropdownComp, name$4, items, selectedValue) => map$2(items, (item$1) => {
				if (!isSingleListItem(item$1)) return {
					type: "nestedmenuitem",
					text: item$1.text,
					getSubmenuItems: () => fetchItems(dropdownComp, name$4, item$1.items, selectedValue)
				};
				else return {
					type: "togglemenuitem",
					text: item$1.text,
					value: item$1.value,
					active: item$1.value === selectedValue,
					onAction: () => {
						Representing.setValue(dropdownComp, item$1.value);
						emitWith(dropdownComp, formChangeEvent, { name: name$4 });
						Focusing.focus(dropdownComp);
					}
				};
			});
			const findItemByValue = (items, value$5) => findMap(items, (item$1) => {
				if (!isSingleListItem(item$1)) return findItemByValue(item$1.items, value$5);
				else return someIf(item$1.value === value$5, item$1);
			});
			const renderListBox = (spec, backstage, initialData) => {
				const providersBackstage = backstage.shared.providers;
				const initialItem = initialData.bind((value$5) => findItemByValue(spec.items, value$5)).orThunk(() => head(spec.items).filter(isSingleListItem));
				const pLabel = spec.label.map((label$1) => renderLabel$3(label$1, providersBackstage));
				const listBoxWrap = {
					dom: {
						tag: "div",
						classes: ["tox-listboxfield"]
					},
					components: [FormField.parts.field({
						dom: {},
						factory: { sketch: (sketchSpec) => renderCommonDropdown({
							uid: sketchSpec.uid,
							text: initialItem.map((item$1) => item$1.text),
							icon: Optional.none(),
							tooltip: spec.label,
							role: Optional.none(),
							fetch: (comp, callback) => {
								callback(build(fetchItems(comp, spec.name, spec.items, Representing.getValue(comp)), ItemResponse$1.CLOSE_ON_EXECUTE, backstage, {
									isHorizontalMenu: false,
									search: Optional.none()
								}));
							},
							onSetup: constant$1(noop),
							getApi: constant$1({}),
							columns: 1,
							presets: "normal",
							classes: [],
							dropdownBehaviours: [Tabstopping.config({}), withComp(initialItem.map((item$1) => item$1.value), (comp) => get$f(comp.element, dataAttribute), (comp, data) => {
								findItemByValue(spec.items, data).each((item$1) => {
									set$9(comp.element, dataAttribute, item$1.value);
									emitWith(comp, updateMenuText, { text: item$1.text });
								});
							})]
						}, "tox-listbox", backstage.shared) }
					})]
				};
				return FormField.sketch({
					dom: {
						tag: "div",
						classes: ["tox-form__group"]
					},
					components: flatten([pLabel.toArray(), [listBoxWrap]]),
					fieldBehaviours: derive$1([Disabling.config({
						disabled: constant$1(!spec.enabled),
						onDisabled: (comp) => {
							FormField.getField(comp).each(Disabling.disable);
						},
						onEnabled: (comp) => {
							FormField.getField(comp).each(Disabling.enable);
						}
					})])
				});
			};
			const renderPanel = (spec, backstage) => ({
				dom: {
					tag: "div",
					classes: spec.classes
				},
				components: map$2(spec.items, backstage.shared.interpreter)
			});
			const factory$h = (detail, _spec) => {
				const options = map$2(detail.options, (option$4) => ({ dom: {
					tag: "option",
					value: option$4.value,
					innerHtml: option$4.text
				} }));
				const initialValues = detail.data.map((v) => wrap$1("initialValue", v)).getOr({});
				return {
					uid: detail.uid,
					dom: {
						tag: "select",
						classes: detail.selectClasses,
						attributes: detail.selectAttributes
					},
					components: options,
					behaviours: augment(detail.selectBehaviours, [Focusing.config({}), Representing.config({ store: {
						mode: "manual",
						getValue: (select$2) => {
							return get$6(select$2.element);
						},
						setValue: (select$2, newValue) => {
							const firstOption = head(detail.options);
							if (find$5(detail.options, (opt) => opt.value === newValue).isSome()) set$5(select$2.element, newValue);
							else if (select$2.element.dom.selectedIndex === -1 && newValue === "") firstOption.each((value$5) => set$5(select$2.element, value$5.value));
						},
						...initialValues
					} })])
				};
			};
			const HtmlSelect = single({
				name: "HtmlSelect",
				configFields: [
					required$1("options"),
					field("selectBehaviours", [Focusing, Representing]),
					defaulted("selectClasses", []),
					defaulted("selectAttributes", {}),
					option$3("data")
				],
				factory: factory$h
			});
			const renderSelectBox = (spec, providersBackstage, initialData) => {
				const translatedOptions = map$2(spec.items, (item$1) => ({
					text: providersBackstage.translate(item$1.text),
					value: item$1.value
				}));
				const pLabel = spec.label.map((label$1) => renderLabel$3(label$1, providersBackstage));
				const pField = FormField.parts.field({
					dom: {},
					...initialData.map((data) => ({ data })).getOr({}),
					selectAttributes: { size: spec.size },
					options: translatedOptions,
					factory: HtmlSelect,
					selectBehaviours: derive$1([
						Disabling.config({ disabled: () => !spec.enabled || providersBackstage.isDisabled() }),
						Tabstopping.config({}),
						config("selectbox-change", [run$1(change(), (component, _) => {
							emitWith(component, formChangeEvent, { name: spec.name });
						})])
					])
				});
				const chevron = spec.size > 1 ? Optional.none() : Optional.some(render$3("chevron-down", {
					tag: "div",
					classes: ["tox-selectfield__icon-js"]
				}, providersBackstage.icons));
				const selectWrap = {
					dom: {
						tag: "div",
						classes: ["tox-selectfield"]
					},
					components: flatten([[pField], chevron.toArray()])
				};
				return FormField.sketch({
					dom: {
						tag: "div",
						classes: ["tox-form__group"]
					},
					components: flatten([pLabel.toArray(), [selectWrap]]),
					fieldBehaviours: derive$1([Disabling.config({
						disabled: () => !spec.enabled || providersBackstage.isDisabled(),
						onDisabled: (comp) => {
							FormField.getField(comp).each(Disabling.disable);
						},
						onEnabled: (comp) => {
							FormField.getField(comp).each(Disabling.enable);
						}
					}), receivingConfig()])
				});
			};
			const schema$h = constant$1([
				defaulted("field1Name", "field1"),
				defaulted("field2Name", "field2"),
				onStrictHandler("onLockedChange"),
				markers$1(["lockClass"]),
				defaulted("locked", false),
				SketchBehaviours.field("coupledFieldBehaviours", [Composing, Representing])
			]);
			const getField = (comp, detail, partName) => getPart(comp, detail, partName).bind(Composing.getCurrent);
			const coupledPart = (selfName, otherName) => required({
				factory: FormField,
				name: selfName,
				overrides: (detail) => {
					return { fieldBehaviours: derive$1([config("coupled-input-behaviour", [run$1(input(), (me) => {
						getField(me, detail, otherName).each((other) => {
							getPart(me, detail, "lock").each((lock) => {
								if (Toggling.isOn(lock)) detail.onLockedChange(me, other, lock);
							});
						});
					})])]) };
				}
			});
			const parts$c = constant$1([
				coupledPart("field1", "field2"),
				coupledPart("field2", "field1"),
				required({
					factory: Button,
					schema: [required$1("dom")],
					name: "lock",
					overrides: (detail) => {
						return { buttonBehaviours: derive$1([Toggling.config({
							selected: detail.locked,
							toggleClass: detail.markers.lockClass,
							aria: { mode: "pressed" }
						})]) };
					}
				})
			]);
			const factory$g = (detail, components$2, _spec, _externals) => ({
				uid: detail.uid,
				dom: detail.dom,
				components: components$2,
				behaviours: SketchBehaviours.augment(detail.coupledFieldBehaviours, [Composing.config({ find: Optional.some }), Representing.config({ store: {
					mode: "manual",
					getValue: (comp) => {
						const parts$10 = getPartsOrDie(comp, detail, ["field1", "field2"]);
						return {
							[detail.field1Name]: Representing.getValue(parts$10.field1()),
							[detail.field2Name]: Representing.getValue(parts$10.field2())
						};
					},
					setValue: (comp, value$5) => {
						const parts$10 = getPartsOrDie(comp, detail, ["field1", "field2"]);
						if (hasNonNullableKey(value$5, detail.field1Name)) Representing.setValue(parts$10.field1(), value$5[detail.field1Name]);
						if (hasNonNullableKey(value$5, detail.field2Name)) Representing.setValue(parts$10.field2(), value$5[detail.field2Name]);
					}
				} })]),
				apis: {
					getField1: (component) => getPart(component, detail, "field1"),
					getField2: (component) => getPart(component, detail, "field2"),
					getLock: (component) => getPart(component, detail, "lock")
				}
			});
			const FormCoupledInputs = composite({
				name: "FormCoupledInputs",
				configFields: schema$h(),
				partFields: parts$c(),
				factory: factory$g,
				apis: {
					getField1: (apis, component) => apis.getField1(component),
					getField2: (apis, component) => apis.getField2(component),
					getLock: (apis, component) => apis.getLock(component)
				}
			});
			const formatSize = (size) => {
				const unitDec = {
					"": 0,
					"px": 0,
					"pt": 1,
					"mm": 1,
					"pc": 2,
					"ex": 2,
					"em": 2,
					"ch": 2,
					"rem": 2,
					"cm": 3,
					"in": 4,
					"%": 4
				};
				const maxDecimal = (unit) => unit in unitDec ? unitDec[unit] : 1;
				let numText = size.value.toFixed(maxDecimal(size.unit));
				if (numText.indexOf(".") !== -1) numText = numText.replace(/\.?0*$/, "");
				return numText + size.unit;
			};
			const parseSize = (sizeText) => {
				const match = /^\s*(\d+(?:\.\d+)?)\s*(|cm|mm|in|px|pt|pc|em|ex|ch|rem|vw|vh|vmin|vmax|%)\s*$/.exec(sizeText);
				if (match !== null) {
					const value$5 = parseFloat(match[1]);
					const unit = match[2];
					return Result.value({
						value: value$5,
						unit
					});
				} else return Result.error(sizeText);
			};
			const convertUnit = (size, unit) => {
				const inInch = {
					"": 96,
					"px": 96,
					"pt": 72,
					"cm": 2.54,
					"pc": 12,
					"mm": 25.4,
					"in": 1
				};
				const supported$1 = (u) => has$2(inInch, u);
				if (size.unit === unit) return Optional.some(size.value);
				else if (supported$1(size.unit) && supported$1(unit)) if (inInch[size.unit] === inInch[unit]) return Optional.some(size.value);
				else return Optional.some(size.value / inInch[size.unit] * inInch[unit]);
				else return Optional.none();
			};
			const noSizeConversion = (_input) => Optional.none();
			const ratioSizeConversion = (scale, unit) => (size) => convertUnit(size, unit).map((value$5) => ({
				value: value$5 * scale,
				unit
			}));
			const makeRatioConverter = (currentFieldText, otherFieldText) => {
				return lift2(parseSize(currentFieldText).toOptional(), parseSize(otherFieldText).toOptional(), (cSize, oSize) => convertUnit(cSize, oSize.unit).map((val) => oSize.value / val).map((r$2) => ratioSizeConversion(r$2, oSize.unit)).getOr(noSizeConversion)).getOr(noSizeConversion);
			};
			const renderSizeInput = (spec, providersBackstage) => {
				let converter = noSizeConversion;
				const ratioEvent = generate$6("ratio-event");
				const makeIcon = (iconName) => render$3(iconName, {
					tag: "span",
					classes: ["tox-icon", "tox-lock-icon__" + iconName]
				}, providersBackstage.icons);
				const pLock = FormCoupledInputs.parts.lock({
					dom: {
						tag: "button",
						classes: [
							"tox-lock",
							"tox-button",
							"tox-button--naked",
							"tox-button--icon"
						],
						attributes: { title: providersBackstage.translate(spec.label.getOr("Constrain proportions")) }
					},
					components: [makeIcon("lock"), makeIcon("unlock")],
					buttonBehaviours: derive$1([
						Disabling.config({ disabled: () => !spec.enabled || providersBackstage.isDisabled() }),
						receivingConfig(),
						Tabstopping.config({})
					])
				});
				const formGroup = (components$2) => ({
					dom: {
						tag: "div",
						classes: ["tox-form__group"]
					},
					components: components$2
				});
				const getFieldPart = (isField1) => FormField.parts.field({
					factory: Input,
					inputClasses: ["tox-textfield"],
					inputBehaviours: derive$1([
						Disabling.config({ disabled: () => !spec.enabled || providersBackstage.isDisabled() }),
						receivingConfig(),
						Tabstopping.config({}),
						config("size-input-events", [run$1(focusin(), (component, _simulatedEvent) => {
							emitWith(component, ratioEvent, { isField1 });
						}), run$1(change(), (component, _simulatedEvent) => {
							emitWith(component, formChangeEvent, { name: spec.name });
						})])
					]),
					selectOnFocus: false
				});
				const getLabel = (label$1) => ({
					dom: {
						tag: "label",
						classes: ["tox-label"]
					},
					components: [text$2(providersBackstage.translate(label$1))]
				});
				const widthField = FormCoupledInputs.parts.field1(formGroup([FormField.parts.label(getLabel("Width")), getFieldPart(true)]));
				const heightField = FormCoupledInputs.parts.field2(formGroup([FormField.parts.label(getLabel("Height")), getFieldPart(false)]));
				return FormCoupledInputs.sketch({
					dom: {
						tag: "div",
						classes: ["tox-form__group"]
					},
					components: [{
						dom: {
							tag: "div",
							classes: ["tox-form__controls-h-stack"]
						},
						components: [
							widthField,
							heightField,
							formGroup([getLabel(nbsp), pLock])
						]
					}],
					field1Name: "width",
					field2Name: "height",
					locked: true,
					markers: { lockClass: "tox-locked" },
					onLockedChange: (current, other, _lock) => {
						parseSize(Representing.getValue(current)).each((size) => {
							converter(size).each((newSize) => {
								Representing.setValue(other, formatSize(newSize));
							});
						});
					},
					coupledFieldBehaviours: derive$1([
						Disabling.config({
							disabled: () => !spec.enabled || providersBackstage.isDisabled(),
							onDisabled: (comp) => {
								FormCoupledInputs.getField1(comp).bind(FormField.getField).each(Disabling.disable);
								FormCoupledInputs.getField2(comp).bind(FormField.getField).each(Disabling.disable);
								FormCoupledInputs.getLock(comp).each(Disabling.disable);
							},
							onEnabled: (comp) => {
								FormCoupledInputs.getField1(comp).bind(FormField.getField).each(Disabling.enable);
								FormCoupledInputs.getField2(comp).bind(FormField.getField).each(Disabling.enable);
								FormCoupledInputs.getLock(comp).each(Disabling.enable);
							}
						}),
						receivingConfig(),
						config("size-input-events2", [run$1(ratioEvent, (component, simulatedEvent) => {
							const isField1 = simulatedEvent.event.isField1;
							const optCurrent = isField1 ? FormCoupledInputs.getField1(component) : FormCoupledInputs.getField2(component);
							const optOther = isField1 ? FormCoupledInputs.getField2(component) : FormCoupledInputs.getField1(component);
							converter = makeRatioConverter(optCurrent.map(Representing.getValue).getOr(""), optOther.map(Representing.getValue).getOr(""));
						})])
					])
				});
			};
			const renderSlider = (spec, providerBackstage, initialData) => {
				const labelPart$1 = Slider.parts.label({
					dom: {
						tag: "label",
						classes: ["tox-label"]
					},
					components: [text$2(providerBackstage.translate(spec.label))]
				});
				const spectrum = Slider.parts.spectrum({ dom: {
					tag: "div",
					classes: ["tox-slider__rail"],
					attributes: { role: "presentation" }
				} });
				const thumb = Slider.parts.thumb({ dom: {
					tag: "div",
					classes: ["tox-slider__handle"],
					attributes: { role: "presentation" }
				} });
				return Slider.sketch({
					dom: {
						tag: "div",
						classes: ["tox-slider"],
						attributes: { role: "presentation" }
					},
					model: {
						mode: "x",
						minX: spec.min,
						maxX: spec.max,
						getInitialValue: constant$1(initialData.getOrThunk(() => (Math.abs(spec.max) - Math.abs(spec.min)) / 2))
					},
					components: [
						labelPart$1,
						spectrum,
						thumb
					],
					sliderBehaviours: derive$1([ComposingConfigs.self(), Focusing.config({})]),
					onChoose: (component, thumb$1, value$5) => {
						emitWith(component, formChangeEvent, {
							name: spec.name,
							value: value$5
						});
					}
				});
			};
			const renderTable = (spec, providersBackstage) => {
				const renderTh = (text$3) => ({ dom: {
					tag: "th",
					innerHtml: providersBackstage.translate(text$3)
				} });
				const renderHeader$1 = (header) => ({
					dom: { tag: "thead" },
					components: [{
						dom: { tag: "tr" },
						components: map$2(header, renderTh)
					}]
				});
				const renderTd = (text$3) => ({ dom: {
					tag: "td",
					innerHtml: providersBackstage.translate(text$3)
				} });
				const renderTr = (row) => ({
					dom: { tag: "tr" },
					components: map$2(row, renderTd)
				});
				const renderRows = (rows) => ({
					dom: { tag: "tbody" },
					components: map$2(rows, renderTr)
				});
				return {
					dom: {
						tag: "table",
						classes: ["tox-dialog__table"]
					},
					components: [renderHeader$1(spec.header), renderRows(spec.cells)],
					behaviours: derive$1([Tabstopping.config({}), Focusing.config({})])
				};
			};
			const renderTextField = (spec, providersBackstage) => {
				const pLabel = spec.label.map((label$1) => renderLabel$3(label$1, providersBackstage));
				const baseInputBehaviours = [
					Disabling.config({ disabled: () => spec.disabled || providersBackstage.isDisabled() }),
					receivingConfig(),
					Keying.config({
						mode: "execution",
						useEnter: spec.multiline !== true,
						useControlEnter: spec.multiline === true,
						execute: (comp) => {
							emit(comp, formSubmitEvent);
							return Optional.some(true);
						}
					}),
					config("textfield-change", [run$1(input(), (component, _) => {
						emitWith(component, formChangeEvent, { name: spec.name });
					}), run$1(postPaste(), (component, _) => {
						emitWith(component, formChangeEvent, { name: spec.name });
					})]),
					Tabstopping.config({})
				];
				const validatingBehaviours = spec.validation.map((vl) => Invalidating.config({
					getRoot: (input$1) => {
						return parentElement(input$1.element);
					},
					invalidClass: "tox-invalid",
					validator: {
						validate: (input$1) => {
							const v = Representing.getValue(input$1);
							const result = vl.validator(v);
							return Future.pure(result === true ? Result.value(v) : Result.error(result));
						},
						validateOnLoad: vl.validateOnLoad
					}
				})).toArray();
				const placeholder$1 = spec.placeholder.fold(constant$1({}), (p) => ({ placeholder: providersBackstage.translate(p) }));
				const inputMode = spec.inputMode.fold(constant$1({}), (mode) => ({ inputmode: mode }));
				const inputAttributes = {
					...placeholder$1,
					...inputMode
				};
				const pField = FormField.parts.field({
					tag: spec.multiline === true ? "textarea" : "input",
					...spec.data.map((data) => ({ data })).getOr({}),
					inputAttributes,
					inputClasses: [spec.classname],
					inputBehaviours: derive$1(flatten([baseInputBehaviours, validatingBehaviours])),
					selectOnFocus: false,
					factory: Input
				});
				return renderFormFieldWith(pLabel, spec.multiline ? {
					dom: {
						tag: "div",
						classes: ["tox-textarea-wrap"]
					},
					components: [pField]
				} : pField, (spec.flex ? ["tox-form__group--stretched"] : []).concat(spec.maximized ? ["tox-form-group--maximize"] : []), [Disabling.config({
					disabled: () => spec.disabled || providersBackstage.isDisabled(),
					onDisabled: (comp) => {
						FormField.getField(comp).each(Disabling.disable);
					},
					onEnabled: (comp) => {
						FormField.getField(comp).each(Disabling.enable);
					}
				}), receivingConfig()]);
			};
			const renderInput = (spec, providersBackstage, initialData) => renderTextField({
				name: spec.name,
				multiline: false,
				label: spec.label,
				inputMode: spec.inputMode,
				placeholder: spec.placeholder,
				flex: false,
				disabled: !spec.enabled,
				classname: "tox-textfield",
				validation: Optional.none(),
				maximized: spec.maximized,
				data: initialData
			}, providersBackstage);
			const renderTextarea = (spec, providersBackstage, initialData) => renderTextField({
				name: spec.name,
				multiline: true,
				label: spec.label,
				inputMode: Optional.none(),
				placeholder: spec.placeholder,
				flex: true,
				disabled: !spec.enabled,
				classname: "tox-textarea",
				validation: Optional.none(),
				maximized: spec.maximized,
				data: initialData
			}, providersBackstage);
			const getAnimationRoot = (component, slideConfig) => slideConfig.getAnimationRoot.fold(() => component.element, (get$10) => get$10(component));
			const getDimensionProperty = (slideConfig) => slideConfig.dimension.property;
			const getDimension = (slideConfig, elem) => slideConfig.dimension.getDimension(elem);
			const disableTransitions = (component, slideConfig) => {
				remove$1(getAnimationRoot(component, slideConfig), [slideConfig.shrinkingClass, slideConfig.growingClass]);
			};
			const setShrunk = (component, slideConfig) => {
				remove$2(component.element, slideConfig.openClass);
				add$2(component.element, slideConfig.closedClass);
				set$8(component.element, getDimensionProperty(slideConfig), "0px");
				reflow(component.element);
			};
			const setGrown = (component, slideConfig) => {
				remove$2(component.element, slideConfig.closedClass);
				add$2(component.element, slideConfig.openClass);
				remove$6(component.element, getDimensionProperty(slideConfig));
			};
			const doImmediateShrink = (component, slideConfig, slideState, _calculatedSize) => {
				slideState.setCollapsed();
				set$8(component.element, getDimensionProperty(slideConfig), getDimension(slideConfig, component.element));
				disableTransitions(component, slideConfig);
				setShrunk(component, slideConfig);
				slideConfig.onStartShrink(component);
				slideConfig.onShrunk(component);
			};
			const doStartShrink = (component, slideConfig, slideState, calculatedSize) => {
				const size = calculatedSize.getOrThunk(() => getDimension(slideConfig, component.element));
				slideState.setCollapsed();
				set$8(component.element, getDimensionProperty(slideConfig), size);
				reflow(component.element);
				const root = getAnimationRoot(component, slideConfig);
				remove$2(root, slideConfig.growingClass);
				add$2(root, slideConfig.shrinkingClass);
				setShrunk(component, slideConfig);
				slideConfig.onStartShrink(component);
			};
			const doStartSmartShrink = (component, slideConfig, slideState) => {
				const size = getDimension(slideConfig, component.element);
				(size === "0px" ? doImmediateShrink : doStartShrink)(component, slideConfig, slideState, Optional.some(size));
			};
			const doStartGrow = (component, slideConfig, slideState) => {
				const root = getAnimationRoot(component, slideConfig);
				const wasShrinking = has(root, slideConfig.shrinkingClass);
				const beforeSize = getDimension(slideConfig, component.element);
				setGrown(component, slideConfig);
				const fullSize = getDimension(slideConfig, component.element);
				const startPartialGrow = () => {
					set$8(component.element, getDimensionProperty(slideConfig), beforeSize);
					reflow(component.element);
				};
				const startCompleteGrow = () => {
					setShrunk(component, slideConfig);
				};
				(wasShrinking ? startPartialGrow : startCompleteGrow)();
				remove$2(root, slideConfig.shrinkingClass);
				add$2(root, slideConfig.growingClass);
				setGrown(component, slideConfig);
				set$8(component.element, getDimensionProperty(slideConfig), fullSize);
				slideState.setExpanded();
				slideConfig.onStartGrow(component);
			};
			const refresh$4 = (component, slideConfig, slideState) => {
				if (slideState.isExpanded()) {
					remove$6(component.element, getDimensionProperty(slideConfig));
					const fullSize = getDimension(slideConfig, component.element);
					set$8(component.element, getDimensionProperty(slideConfig), fullSize);
				}
			};
			const grow = (component, slideConfig, slideState) => {
				if (!slideState.isExpanded()) doStartGrow(component, slideConfig, slideState);
			};
			const shrink = (component, slideConfig, slideState) => {
				if (slideState.isExpanded()) doStartSmartShrink(component, slideConfig, slideState);
			};
			const immediateShrink = (component, slideConfig, slideState) => {
				if (slideState.isExpanded()) doImmediateShrink(component, slideConfig, slideState);
			};
			const hasGrown = (component, slideConfig, slideState) => slideState.isExpanded();
			const hasShrunk = (component, slideConfig, slideState) => slideState.isCollapsed();
			const isGrowing = (component, slideConfig, _slideState) => {
				return has(getAnimationRoot(component, slideConfig), slideConfig.growingClass) === true;
			};
			const isShrinking = (component, slideConfig, _slideState) => {
				return has(getAnimationRoot(component, slideConfig), slideConfig.shrinkingClass) === true;
			};
			const isTransitioning = (component, slideConfig, slideState) => isGrowing(component, slideConfig) || isShrinking(component, slideConfig);
			const toggleGrow = (component, slideConfig, slideState) => {
				(slideState.isExpanded() ? doStartSmartShrink : doStartGrow)(component, slideConfig, slideState);
			};
			const immediateGrow = (component, slideConfig, slideState) => {
				if (!slideState.isExpanded()) {
					setGrown(component, slideConfig);
					set$8(component.element, getDimensionProperty(slideConfig), getDimension(slideConfig, component.element));
					disableTransitions(component, slideConfig);
					slideState.setExpanded();
					slideConfig.onStartGrow(component);
					slideConfig.onGrown(component);
				}
			};
			var SlidingApis = /* @__PURE__ */ Object.freeze({
				__proto__: null,
				refresh: refresh$4,
				grow,
				shrink,
				immediateShrink,
				hasGrown,
				hasShrunk,
				isGrowing,
				isShrinking,
				isTransitioning,
				toggleGrow,
				disableTransitions,
				immediateGrow
			});
			const exhibit = (base$1, slideConfig, _slideState) => {
				return slideConfig.expanded ? nu$7({
					classes: [slideConfig.openClass],
					styles: {}
				}) : nu$7({
					classes: [slideConfig.closedClass],
					styles: wrap$1(slideConfig.dimension.property, "0px")
				});
			};
			const events$6 = (slideConfig, slideState) => derive$2([runOnSource(transitionend(), (component, simulatedEvent) => {
				if (simulatedEvent.event.raw.propertyName === slideConfig.dimension.property) {
					disableTransitions(component, slideConfig);
					if (slideState.isExpanded()) remove$6(component.element, slideConfig.dimension.property);
					(slideState.isExpanded() ? slideConfig.onGrown : slideConfig.onShrunk)(component);
				}
			})]);
			var ActiveSliding = /* @__PURE__ */ Object.freeze({
				__proto__: null,
				exhibit,
				events: events$6
			});
			var SlidingSchema = [
				required$1("closedClass"),
				required$1("openClass"),
				required$1("shrinkingClass"),
				required$1("growingClass"),
				option$3("getAnimationRoot"),
				onHandler("onShrunk"),
				onHandler("onStartShrink"),
				onHandler("onGrown"),
				onHandler("onStartGrow"),
				defaulted("expanded", false),
				requiredOf("dimension", choose$1("property", {
					width: [output$1("property", "width"), output$1("getDimension", (elem) => get$c(elem) + "px")],
					height: [output$1("property", "height"), output$1("getDimension", (elem) => get$d(elem) + "px")]
				}))
			];
			const init$9 = (spec) => {
				const state = Cell(spec.expanded);
				const readState = () => "expanded: " + state.get();
				return nu$8({
					isExpanded: () => state.get() === true,
					isCollapsed: () => state.get() === false,
					setCollapsed: curry(state.set, false),
					setExpanded: curry(state.set, true),
					readState
				});
			};
			const Sliding = create$4({
				fields: SlidingSchema,
				name: "sliding",
				active: ActiveSliding,
				apis: SlidingApis,
				state: /* @__PURE__ */ Object.freeze({
					__proto__: null,
					init: init$9
				})
			});
			const getMenuButtonApi = (component) => ({
				isEnabled: () => !Disabling.isDisabled(component),
				setEnabled: (state) => Disabling.set(component, !state),
				setActive: (state) => {
					const elm = component.element;
					if (state) {
						add$2(elm, "tox-tbtn--enabled");
						set$9(elm, "aria-pressed", true);
					} else {
						remove$2(elm, "tox-tbtn--enabled");
						remove$7(elm, "aria-pressed");
					}
				},
				isActive: () => has(component.element, "tox-tbtn--enabled"),
				setText: (text$3) => {
					emitWith(component, updateMenuText, { text: text$3 });
				},
				setIcon: (icon$1) => emitWith(component, updateMenuIcon, { icon: icon$1 })
			});
			const renderMenuButton = (spec, prefix$2, backstage, role, tabstopping = true) => {
				return renderCommonDropdown({
					text: spec.text,
					icon: spec.icon,
					tooltip: spec.tooltip,
					searchable: spec.search.isSome(),
					role,
					fetch: (dropdownComp, callback) => {
						const fetchContext = { pattern: spec.search.isSome() ? getSearchPattern(dropdownComp) : "" };
						spec.fetch((items) => {
							callback(build(items, ItemResponse$1.CLOSE_ON_EXECUTE, backstage, {
								isHorizontalMenu: false,
								search: spec.search
							}));
						}, fetchContext, getMenuButtonApi(dropdownComp));
					},
					onSetup: spec.onSetup,
					getApi: getMenuButtonApi,
					columns: 1,
					presets: "normal",
					classes: [],
					dropdownBehaviours: [...tabstopping ? [Tabstopping.config({})] : []]
				}, prefix$2, backstage.shared);
			};
			const getFetch = (items, getButton, backstage) => {
				const getMenuItemAction = (item$1) => (api$3) => {
					const newValue = !api$3.isActive();
					api$3.setActive(newValue);
					item$1.storage.set(newValue);
					backstage.shared.getSink().each((sink) => {
						getButton().getOpt(sink).each((orig) => {
							focus$3(orig.element);
							emitWith(orig, formActionEvent, {
								name: item$1.name,
								value: item$1.storage.get()
							});
						});
					});
				};
				const getMenuItemSetup = (item$1) => (api$3) => {
					api$3.setActive(item$1.storage.get());
				};
				return (success) => {
					success(map$2(items, (item$1) => {
						const text$3 = item$1.text.fold(() => ({}), (text$4) => ({ text: text$4 }));
						return {
							type: item$1.type,
							active: false,
							...text$3,
							onAction: getMenuItemAction(item$1),
							onSetup: getMenuItemSetup(item$1)
						};
					}));
				};
			};
			const renderLabel = (text$3) => ({
				dom: {
					tag: "span",
					classes: ["tox-tree__label"],
					attributes: {
						"title": text$3,
						"aria-label": text$3
					}
				},
				components: [text$2(text$3)]
			});
			const leafLabelEventsId = generate$6("leaf-label-event-id");
			const renderLeafLabel = ({ leaf: leaf$1, onLeafAction, visible, treeId, selectedId, backstage }) => {
				const internalMenuButton = leaf$1.menu.map((btn) => renderMenuButton(btn, "tox-mbtn", backstage, Optional.none(), visible));
				const components$2 = [renderLabel(leaf$1.title)];
				internalMenuButton.each((btn) => components$2.push(btn));
				return Button.sketch({
					dom: {
						tag: "div",
						classes: ["tox-tree--leaf__label", "tox-trbtn"].concat(visible ? ["tox-tree--leaf__label--visible"] : [])
					},
					components: components$2,
					role: "treeitem",
					action: (button$1) => {
						onLeafAction(leaf$1.id);
						button$1.getSystem().broadcastOn([`update-active-item-${treeId}`], { value: leaf$1.id });
					},
					eventOrder: { [keydown()]: [leafLabelEventsId, "keying"] },
					buttonBehaviours: derive$1([
						...visible ? [Tabstopping.config({})] : [],
						Toggling.config({
							toggleClass: "tox-trbtn--enabled",
							toggleOnExecute: false,
							aria: { mode: "selected" }
						}),
						Receiving.config({ channels: { [`update-active-item-${treeId}`]: { onReceive: (comp, message) => {
							(message.value === leaf$1.id ? Toggling.on : Toggling.off)(comp);
						} } } }),
						config(leafLabelEventsId, [runOnAttached((comp, _se) => {
							selectedId.each((id) => {
								(id === leaf$1.id ? Toggling.on : Toggling.off)(comp);
							});
						}), run$1(keydown(), (comp, se) => {
							const isLeftArrowKey = se.event.raw.code === "ArrowLeft";
							const isRightArrowKey = se.event.raw.code === "ArrowRight";
							if (isLeftArrowKey) {
								ancestor(comp.element, ".tox-tree--directory").each((dirElement) => {
									comp.getSystem().getByDom(dirElement).each((dirComp) => {
										child(dirElement, ".tox-tree--directory__label").each((dirLabelElement) => {
											dirComp.getSystem().getByDom(dirLabelElement).each(Focusing.focus);
										});
									});
								});
								se.stop();
							} else if (isRightArrowKey) se.stop();
						})])
					])
				});
			};
			const renderIcon = (iconName, iconsProvider, behaviours$1) => render$3(iconName, {
				tag: "span",
				classes: ["tox-tree__icon-wrap", "tox-icon"],
				behaviours: behaviours$1
			}, iconsProvider);
			const renderIconFromPack = (iconName, iconsProvider) => renderIcon(iconName, iconsProvider, []);
			const directoryLabelEventsId = generate$6("directory-label-event-id");
			const renderDirectoryLabel = ({ directory, visible, noChildren, backstage }) => {
				const internalMenuButton = directory.menu.map((btn) => renderMenuButton(btn, "tox-mbtn", backstage, Optional.none()));
				const components$2 = [{
					dom: {
						tag: "div",
						classes: ["tox-chevron"]
					},
					components: [renderIconFromPack("chevron-right", backstage.shared.providers.icons)]
				}, renderLabel(directory.title)];
				internalMenuButton.each((btn) => {
					components$2.push(btn);
				});
				const toggleExpandChildren = (button$1) => {
					ancestor(button$1.element, ".tox-tree--directory").each((directoryEle) => {
						button$1.getSystem().getByDom(directoryEle).each((directoryComp) => {
							const willExpand = !Toggling.isOn(directoryComp);
							Toggling.toggle(directoryComp);
							emitWith(button$1, "expand-tree-node", {
								expanded: willExpand,
								node: directory.id
							});
						});
					});
				};
				return Button.sketch({
					dom: {
						tag: "div",
						classes: ["tox-tree--directory__label", "tox-trbtn"].concat(visible ? ["tox-tree--directory__label--visible"] : [])
					},
					components: components$2,
					action: toggleExpandChildren,
					eventOrder: { [keydown()]: [directoryLabelEventsId, "keying"] },
					buttonBehaviours: derive$1([...visible ? [Tabstopping.config({})] : [], config(directoryLabelEventsId, [run$1(keydown(), (comp, se) => {
						const isRightArrowKey = se.event.raw.code === "ArrowRight";
						const isLeftArrowKey = se.event.raw.code === "ArrowLeft";
						if (isRightArrowKey && noChildren) se.stop();
						if (isRightArrowKey || isLeftArrowKey) ancestor(comp.element, ".tox-tree--directory").each((directoryEle) => {
							comp.getSystem().getByDom(directoryEle).each((directoryComp) => {
								if (!Toggling.isOn(directoryComp) && isRightArrowKey || Toggling.isOn(directoryComp) && isLeftArrowKey) {
									toggleExpandChildren(comp);
									se.stop();
								} else if (isLeftArrowKey && !Toggling.isOn(directoryComp)) {
									ancestor(directoryComp.element, ".tox-tree--directory").each((parentDirElement) => {
										child(parentDirElement, ".tox-tree--directory__label").each((parentDirLabelElement) => {
											directoryComp.getSystem().getByDom(parentDirLabelElement).each(Focusing.focus);
										});
									});
									se.stop();
								}
							});
						});
					})])])
				});
			};
			const renderDirectoryChildren = ({ children: children$1, onLeafAction, visible, treeId, expandedIds, selectedId, backstage }) => {
				return {
					dom: {
						tag: "div",
						classes: ["tox-tree--directory__children"]
					},
					components: children$1.map((item$1) => {
						return item$1.type === "leaf" ? renderLeafLabel({
							leaf: item$1,
							selectedId,
							onLeafAction,
							visible,
							treeId,
							backstage
						}) : renderDirectory({
							directory: item$1,
							expandedIds,
							selectedId,
							onLeafAction,
							labelTabstopping: visible,
							treeId,
							backstage
						});
					}),
					behaviours: derive$1([Sliding.config({
						dimension: { property: "height" },
						closedClass: "tox-tree--directory__children--closed",
						openClass: "tox-tree--directory__children--open",
						growingClass: "tox-tree--directory__children--growing",
						shrinkingClass: "tox-tree--directory__children--shrinking",
						expanded: visible
					}), Replacing.config({})])
				};
			};
			const directoryEventsId = generate$6("directory-event-id");
			const renderDirectory = ({ directory, onLeafAction, labelTabstopping, treeId, backstage, expandedIds, selectedId }) => {
				const { children: children$1 } = directory;
				const expandedIdsCell = Cell(expandedIds);
				const computedChildrenComponents = (visible) => children$1.map((item$1) => {
					return item$1.type === "leaf" ? renderLeafLabel({
						leaf: item$1,
						selectedId,
						onLeafAction,
						visible,
						treeId,
						backstage
					}) : renderDirectory({
						directory: item$1,
						expandedIds: expandedIdsCell.get(),
						selectedId,
						onLeafAction,
						labelTabstopping: visible,
						treeId,
						backstage
					});
				});
				const childrenVisible = expandedIds.includes(directory.id);
				return {
					dom: {
						tag: "div",
						classes: ["tox-tree--directory"],
						attributes: { role: "treeitem" }
					},
					components: [renderDirectoryLabel({
						directory,
						visible: labelTabstopping,
						noChildren: directory.children.length === 0,
						backstage
					}), renderDirectoryChildren({
						children: children$1,
						expandedIds,
						selectedId,
						onLeafAction,
						visible: childrenVisible,
						treeId,
						backstage
					})],
					behaviours: derive$1([config(directoryEventsId, [runOnAttached((comp, _se) => {
						Toggling.set(comp, childrenVisible);
					}), run$1("expand-tree-node", (_cmp, se) => {
						const { expanded, node } = se.event;
						expandedIdsCell.set(expanded ? [...expandedIdsCell.get(), node] : expandedIdsCell.get().filter((id) => id !== node));
					})]), Toggling.config({
						...directory.children.length > 0 ? { aria: { mode: "expanded" } } : {},
						toggleClass: "tox-tree--directory--expanded",
						onToggled: (comp, childrenVisible$1) => {
							const childrenComp = comp.components()[1];
							const newChildren = computedChildrenComponents(childrenVisible$1);
							if (childrenVisible$1) Sliding.grow(childrenComp);
							else Sliding.shrink(childrenComp);
							Replacing.set(childrenComp, newChildren);
						}
					})])
				};
			};
			const treeEventsId = generate$6("tree-event-id");
			const renderTree = (spec, backstage) => {
				const onLeafAction = spec.onLeafAction.getOr(noop);
				const onToggleExpand = spec.onToggleExpand.getOr(noop);
				const defaultExpandedIds = spec.defaultExpandedIds;
				const expandedIds = Cell(defaultExpandedIds);
				const selectedIdCell = Cell(spec.defaultSelectedId);
				const treeId = generate$6("tree-id");
				const children$1 = (selectedId, expandedIds$1) => spec.items.map((item$1) => {
					return item$1.type === "leaf" ? renderLeafLabel({
						leaf: item$1,
						selectedId,
						onLeafAction,
						visible: true,
						treeId,
						backstage
					}) : renderDirectory({
						directory: item$1,
						selectedId,
						onLeafAction,
						expandedIds: expandedIds$1,
						labelTabstopping: true,
						treeId,
						backstage
					});
				});
				return {
					dom: {
						tag: "div",
						classes: ["tox-tree"],
						attributes: { role: "tree" }
					},
					components: children$1(selectedIdCell.get(), expandedIds.get()),
					behaviours: derive$1([
						Keying.config({
							mode: "flow",
							selector: ".tox-tree--leaf__label--visible, .tox-tree--directory__label--visible",
							cycles: false
						}),
						config(treeEventsId, [run$1("expand-tree-node", (_cmp, se) => {
							const { expanded, node } = se.event;
							expandedIds.set(expanded ? [...expandedIds.get(), node] : expandedIds.get().filter((id) => id !== node));
							onToggleExpand(expandedIds.get(), {
								expanded,
								node
							});
						})]),
						Receiving.config({ channels: { [`update-active-item-${treeId}`]: { onReceive: (comp, message) => {
							selectedIdCell.set(Optional.some(message.value));
							Replacing.set(comp, children$1(Optional.some(message.value), expandedIds.get()));
						} } } }),
						Replacing.config({})
					])
				};
			};
			const events$5 = (streamConfig, streamState) => {
				const processor = streamConfig.stream.streams.setup(streamConfig, streamState);
				return derive$2([run$1(streamConfig.event, processor), runOnDetached(() => streamState.cancel())].concat(streamConfig.cancelEvent.map((e) => [run$1(e, () => streamState.cancel())]).getOr([])));
			};
			var ActiveStreaming = /* @__PURE__ */ Object.freeze({
				__proto__: null,
				events: events$5
			});
			const throttle = (_config) => {
				const state = Cell(null);
				const readState = () => ({ timer: state.get() !== null ? "set" : "unset" });
				const setTimer = (t$1) => {
					state.set(t$1);
				};
				const cancel = () => {
					const t$1 = state.get();
					if (t$1 !== null) t$1.cancel();
				};
				return nu$8({
					readState,
					setTimer,
					cancel
				});
			};
			const init$8 = (spec) => spec.stream.streams.state(spec);
			var StreamingState = /* @__PURE__ */ Object.freeze({
				__proto__: null,
				throttle,
				init: init$8
			});
			const setup$c = (streamInfo, streamState) => {
				const sInfo = streamInfo.stream;
				const throttler = last(streamInfo.onStream, sInfo.delay);
				streamState.setTimer(throttler);
				return (component, simulatedEvent) => {
					throttler.throttle(component, simulatedEvent);
					if (sInfo.stopEvent) simulatedEvent.stop();
				};
			};
			const Streaming = create$4({
				fields: [
					requiredOf("stream", choose$1("mode", { throttle: [
						required$1("delay"),
						defaulted("stopEvent", true),
						output$1("streams", {
							setup: setup$c,
							state: throttle
						})
					] })),
					defaulted("event", "input"),
					option$3("cancelEvent"),
					onStrictHandler("onStream")
				],
				name: "streaming",
				active: ActiveStreaming,
				state: StreamingState
			});
			const setValueFromItem = (model, input$1, item$1) => {
				const itemData = Representing.getValue(item$1);
				Representing.setValue(input$1, itemData);
				setCursorAtEnd(input$1);
			};
			const setSelectionOn = (input$1, f$1) => {
				const el = input$1.element;
				const value$5 = get$6(el);
				const node = el.dom;
				if (get$f(el, "type") !== "number") f$1(node, value$5);
			};
			const setCursorAtEnd = (input$1) => {
				setSelectionOn(input$1, (node, value$5) => node.setSelectionRange(value$5.length, value$5.length));
			};
			const setSelectionToEnd = (input$1, startOffset) => {
				setSelectionOn(input$1, (node, value$5) => node.setSelectionRange(startOffset, value$5.length));
			};
			const attemptSelectOver = (model, input$1, item$1) => {
				if (!model.selectsOver) return Optional.none();
				else {
					const currentValue$1 = Representing.getValue(input$1);
					const inputDisplay = model.getDisplayText(currentValue$1);
					const itemValue = Representing.getValue(item$1);
					return model.getDisplayText(itemValue).indexOf(inputDisplay) === 0 ? Optional.some(() => {
						setValueFromItem(model, input$1, item$1);
						setSelectionToEnd(input$1, inputDisplay.length);
					}) : Optional.none();
				}
			};
			const itemExecute = constant$1("alloy.typeahead.itemexecute");
			const make$3 = (detail, components$2, spec, externals) => {
				const navigateList = (comp, simulatedEvent, highlighter) => {
					detail.previewing.set(false);
					const sandbox = Coupling.getCoupled(comp, "sandbox");
					if (Sandboxing.isOpen(sandbox)) Composing.getCurrent(sandbox).each((menu$1) => {
						Highlighting.getHighlighted(menu$1).fold(() => {
							highlighter(menu$1);
						}, () => {
							dispatchEvent(sandbox, menu$1.element, "keydown", simulatedEvent);
						});
					});
					else {
						const onOpenSync = (sandbox$1) => {
							Composing.getCurrent(sandbox$1).each(highlighter);
						};
						open(detail, mapFetch(comp), comp, sandbox, externals, onOpenSync, HighlightOnOpen.HighlightMenuAndItem).get(noop);
					}
				};
				const focusBehaviours$1 = focusBehaviours(detail);
				const mapFetch = (comp) => (tdata) => tdata.map((data) => {
					const items = bind$3(values(data.menus), (menu$1) => filter$2(menu$1.items, (item$1) => item$1.type === "item"));
					Representing.getState(comp).update(map$2(items, (item$1) => item$1.data));
					return data;
				});
				const getActiveMenu = (sandboxComp) => Composing.getCurrent(sandboxComp);
				const typeaheadCustomEvents = "typeaheadevents";
				const behaviours$1 = [
					Focusing.config({}),
					Representing.config({
						onSetValue: detail.onSetValue,
						store: {
							mode: "dataset",
							getDataKey: (comp) => get$6(comp.element),
							getFallbackEntry: (itemString) => ({
								value: itemString,
								meta: {}
							}),
							setValue: (comp, data) => {
								set$5(comp.element, detail.model.getDisplayText(data));
							},
							...detail.initialData.map((d) => wrap$1("initialValue", d)).getOr({})
						}
					}),
					Streaming.config({
						stream: {
							mode: "throttle",
							delay: detail.responseTime,
							stopEvent: false
						},
						onStream: (component, _simulatedEvent) => {
							const sandbox = Coupling.getCoupled(component, "sandbox");
							if (Focusing.isFocused(component)) {
								if (get$6(component.element).length >= detail.minChars) {
									const previousValue = getActiveMenu(sandbox).bind((activeMenu) => Highlighting.getHighlighted(activeMenu).map(Representing.getValue));
									detail.previewing.set(true);
									const onOpenSync = (_sandbox) => {
										getActiveMenu(sandbox).each((activeMenu) => {
											previousValue.fold(() => {
												if (detail.model.selectsOver) Highlighting.highlightFirst(activeMenu);
											}, (pv) => {
												Highlighting.highlightBy(activeMenu, (item$1) => {
													return Representing.getValue(item$1).value === pv.value;
												});
												Highlighting.getHighlighted(activeMenu).orThunk(() => {
													Highlighting.highlightFirst(activeMenu);
													return Optional.none();
												});
											});
										});
									};
									open(detail, mapFetch(component), component, sandbox, externals, onOpenSync, HighlightOnOpen.HighlightJustMenu).get(noop);
								}
							}
						},
						cancelEvent: typeaheadCancel()
					}),
					Keying.config({
						mode: "special",
						onDown: (comp, simulatedEvent) => {
							navigateList(comp, simulatedEvent, Highlighting.highlightFirst);
							return Optional.some(true);
						},
						onEscape: (comp) => {
							const sandbox = Coupling.getCoupled(comp, "sandbox");
							if (Sandboxing.isOpen(sandbox)) {
								Sandboxing.close(sandbox);
								return Optional.some(true);
							}
							return Optional.none();
						},
						onUp: (comp, simulatedEvent) => {
							navigateList(comp, simulatedEvent, Highlighting.highlightLast);
							return Optional.some(true);
						},
						onEnter: (comp) => {
							const sandbox = Coupling.getCoupled(comp, "sandbox");
							const sandboxIsOpen = Sandboxing.isOpen(sandbox);
							if (sandboxIsOpen && !detail.previewing.get()) return getActiveMenu(sandbox).bind((activeMenu) => Highlighting.getHighlighted(activeMenu)).map((item$1) => {
								emitWith(comp, itemExecute(), { item: item$1 });
								return true;
							});
							else {
								const currentValue$1 = Representing.getValue(comp);
								emit(comp, typeaheadCancel());
								detail.onExecute(sandbox, comp, currentValue$1);
								if (sandboxIsOpen) Sandboxing.close(sandbox);
								return Optional.some(true);
							}
						}
					}),
					Toggling.config({
						toggleClass: detail.markers.openClass,
						aria: { mode: "expanded" }
					}),
					Coupling.config({ others: { sandbox: (hotspot) => {
						return makeSandbox$1(detail, hotspot, {
							onOpen: () => Toggling.on(hotspot),
							onClose: () => {
								detail.lazyTypeaheadComp.get().each((input$1) => remove$7(input$1.element, "aria-activedescendant"));
								Toggling.off(hotspot);
							}
						});
					} } }),
					config(typeaheadCustomEvents, [
						runOnAttached((typeaheadComp) => {
							detail.lazyTypeaheadComp.set(Optional.some(typeaheadComp));
						}),
						runOnDetached((_typeaheadComp) => {
							detail.lazyTypeaheadComp.set(Optional.none());
						}),
						runOnExecute$1((comp) => {
							const onOpenSync = noop;
							togglePopup(detail, mapFetch(comp), comp, externals, onOpenSync, HighlightOnOpen.HighlightMenuAndItem).get(noop);
						}),
						run$1(itemExecute(), (comp, se) => {
							const sandbox = Coupling.getCoupled(comp, "sandbox");
							setValueFromItem(detail.model, comp, se.event.item);
							emit(comp, typeaheadCancel());
							detail.onItemExecute(comp, sandbox, se.event.item, Representing.getValue(comp));
							Sandboxing.close(sandbox);
							setCursorAtEnd(comp);
						})
					].concat(detail.dismissOnBlur ? [run$1(postBlur(), (typeahead) => {
						const sandbox = Coupling.getCoupled(typeahead, "sandbox");
						if (search(sandbox.element).isNone()) Sandboxing.close(sandbox);
					})] : []))
				];
				const eventOrder = {
					[detachedFromDom()]: [
						Representing.name(),
						Streaming.name(),
						typeaheadCustomEvents
					],
					...detail.eventOrder
				};
				return {
					uid: detail.uid,
					dom: dom(deepMerge(detail, { inputAttributes: {
						"role": "combobox",
						"aria-autocomplete": "list",
						"aria-haspopup": "true"
					} })),
					behaviours: {
						...focusBehaviours$1,
						...augment(detail.typeaheadBehaviours, behaviours$1)
					},
					eventOrder
				};
			};
			const schema$g = constant$1([
				option$3("lazySink"),
				required$1("fetch"),
				defaulted("minChars", 5),
				defaulted("responseTime", 1e3),
				onHandler("onOpen"),
				defaulted("getHotspot", Optional.some),
				defaulted("getAnchorOverrides", constant$1({})),
				defaulted("layouts", Optional.none()),
				defaulted("eventOrder", {}),
				defaultedObjOf("model", {}, [
					defaulted("getDisplayText", (itemData) => itemData.meta !== void 0 && itemData.meta.text !== void 0 ? itemData.meta.text : itemData.value),
					defaulted("selectsOver", true),
					defaulted("populateFromBrowse", true)
				]),
				onHandler("onSetValue"),
				onKeyboardHandler("onExecute"),
				onHandler("onItemExecute"),
				defaulted("inputClasses", []),
				defaulted("inputAttributes", {}),
				defaulted("inputStyles", {}),
				defaulted("matchWidth", true),
				defaulted("useMinWidth", false),
				defaulted("dismissOnBlur", true),
				markers$1(["openClass"]),
				option$3("initialData"),
				field("typeaheadBehaviours", [
					Focusing,
					Representing,
					Streaming,
					Keying,
					Toggling,
					Coupling
				]),
				customField("lazyTypeaheadComp", () => Cell(Optional.none)),
				customField("previewing", () => Cell(true))
			].concat(schema$l()).concat(sandboxFields()));
			const parts$b = constant$1([external({
				schema: [tieredMenuMarkers()],
				name: "menu",
				overrides: (detail) => {
					return {
						fakeFocus: true,
						onHighlightItem: (_tmenu, menu$1, item$1) => {
							if (!detail.previewing.get()) detail.lazyTypeaheadComp.get().each((input$1) => {
								if (detail.model.populateFromBrowse) setValueFromItem(detail.model, input$1, item$1);
								getOpt(item$1.element, "id").each((id) => set$9(input$1.element, "aria-activedescendant", id));
							});
							else detail.lazyTypeaheadComp.get().each((input$1) => {
								attemptSelectOver(detail.model, input$1, item$1).fold(() => {
									if (detail.model.selectsOver) {
										Highlighting.dehighlight(menu$1, item$1);
										detail.previewing.set(true);
									} else detail.previewing.set(false);
								}, (selectOverTextInInput) => {
									selectOverTextInInput();
									detail.previewing.set(false);
								});
							});
						},
						onExecute: (_menu, item$1) => {
							return detail.lazyTypeaheadComp.get().map((typeahead) => {
								emitWith(typeahead, itemExecute(), { item: item$1 });
								return true;
							});
						},
						onHover: (menu$1, item$1) => {
							detail.previewing.set(false);
							detail.lazyTypeaheadComp.get().each((input$1) => {
								if (detail.model.populateFromBrowse) setValueFromItem(detail.model, input$1, item$1);
							});
						}
					};
				}
			})]);
			const Typeahead = composite({
				name: "Typeahead",
				configFields: schema$g(),
				partFields: parts$b(),
				factory: make$3
			});
			const wrap = (delegate) => {
				const toCached = () => {
					return wrap(delegate.toCached());
				};
				const bindFuture = (f$1) => {
					return wrap(delegate.bind((resA) => resA.fold((err) => Future.pure(Result.error(err)), (a) => f$1(a))));
				};
				const bindResult = (f$1) => {
					return wrap(delegate.map((resA) => resA.bind(f$1)));
				};
				const mapResult = (f$1) => {
					return wrap(delegate.map((resA) => resA.map(f$1)));
				};
				const mapError$1 = (f$1) => {
					return wrap(delegate.map((resA) => resA.mapError(f$1)));
				};
				const foldResult = (whenError, whenValue) => {
					return delegate.map((res) => res.fold(whenError, whenValue));
				};
				const withTimeout = (timeout, errorThunk) => {
					return wrap(Future.nu((callback) => {
						let timedOut = false;
						const timer = setTimeout(() => {
							timedOut = true;
							callback(Result.error(errorThunk()));
						}, timeout);
						delegate.get((result) => {
							if (!timedOut) {
								clearTimeout(timer);
								callback(result);
							}
						});
					}));
				};
				return {
					...delegate,
					toCached,
					bindFuture,
					bindResult,
					mapResult,
					mapError: mapError$1,
					foldResult,
					withTimeout
				};
			};
			const nu$1 = (worker) => {
				return wrap(Future.nu(worker));
			};
			const value = (value$5) => {
				return wrap(Future.pure(Result.value(value$5)));
			};
			const error = (error$2) => {
				return wrap(Future.pure(Result.error(error$2)));
			};
			const fromResult = (result) => {
				return wrap(Future.pure(result));
			};
			const fromFuture = (future) => {
				return wrap(future.map(Result.value));
			};
			const fromPromise = (promise) => {
				return nu$1((completer) => {
					promise.then((value$5) => {
						completer(Result.value(value$5));
					}, (error$2) => {
						completer(Result.error(error$2));
					});
				});
			};
			const FutureResult = {
				nu: nu$1,
				wrap,
				pure: value,
				value,
				error,
				fromResult,
				fromFuture,
				fromPromise
			};
			const renderCommonSpec = (spec, actionOpt, extraBehaviours = [], dom$3, components$2, providersBackstage) => {
				const action = actionOpt.fold(() => ({}), (action$1) => ({ action: action$1 }));
				return deepMerge(deepMerge({
					buttonBehaviours: derive$1([
						DisablingConfigs.button(() => !spec.enabled || providersBackstage.isDisabled()),
						receivingConfig(),
						Tabstopping.config({}),
						config("button press", [preventDefault("click"), preventDefault("mousedown")])
					].concat(extraBehaviours)),
					eventOrder: {
						click: ["button press", "alloy.base.behaviour"],
						mousedown: ["button press", "alloy.base.behaviour"]
					},
					...action
				}, { dom: dom$3 }), { components: components$2 });
			};
			const renderIconButtonSpec = (spec, action, providersBackstage, extraBehaviours = []) => {
				return renderCommonSpec(spec, action, extraBehaviours, {
					tag: "button",
					classes: ["tox-tbtn"],
					attributes: spec.tooltip.map((tooltip) => ({
						"aria-label": providersBackstage.translate(tooltip),
						"title": providersBackstage.translate(tooltip)
					})).getOr({})
				}, componentRenderPipeline([spec.icon.map((iconName) => renderIconFromPack$1(iconName, providersBackstage.icons))]), providersBackstage);
			};
			const calculateClassesFromButtonType = (buttonType) => {
				switch (buttonType) {
					case "primary": return ["tox-button"];
					case "toolbar": return ["tox-tbtn"];
					case "secondary":
					default: return ["tox-button", "tox-button--secondary"];
				}
			};
			const renderButtonSpec = (spec, action, providersBackstage, extraBehaviours = [], extraClasses = []) => {
				const translatedText = providersBackstage.translate(spec.text);
				const icon$1 = spec.icon.map((iconName) => renderIconFromPack$1(iconName, providersBackstage.icons));
				const components$2 = [icon$1.getOrThunk(() => text$2(translatedText))];
				return renderCommonSpec(spec, action, extraBehaviours, {
					tag: "button",
					classes: [
						...calculateClassesFromButtonType(spec.buttonType.getOr(!spec.primary && !spec.borderless ? "secondary" : "primary")),
						...icon$1.isSome() ? ["tox-button--icon"] : [],
						...spec.borderless ? ["tox-button--naked"] : [],
						...extraClasses
					],
					attributes: { title: translatedText }
				}, components$2, providersBackstage);
			};
			const renderButton$1 = (spec, action, providersBackstage, extraBehaviours = [], extraClasses = []) => {
				const buttonSpec = renderButtonSpec(spec, Optional.some(action), providersBackstage, extraBehaviours, extraClasses);
				return Button.sketch(buttonSpec);
			};
			const getAction = (name$4, buttonType) => (comp) => {
				if (buttonType === "custom") emitWith(comp, formActionEvent, {
					name: name$4,
					value: {}
				});
				else if (buttonType === "submit") emit(comp, formSubmitEvent);
				else if (buttonType === "cancel") emit(comp, formCancelEvent);
				else console.error("Unknown button type: ", buttonType);
			};
			const isMenuFooterButtonSpec = (spec, buttonType) => buttonType === "menu";
			const isNormalFooterButtonSpec = (spec, buttonType) => buttonType === "custom" || buttonType === "cancel" || buttonType === "submit";
			const isToggleButtonSpec = (spec, buttonType) => buttonType === "togglebutton";
			const renderToggleButton = (spec, providers) => {
				var _a, _b;
				const optMemIcon = spec.icon.map((memIcon) => renderReplaceableIconFromPack(memIcon, providers.icons)).map(record);
				const action = (comp) => {
					emitWith(comp, formActionEvent, {
						name: spec.name,
						value: { setIcon: (newIcon) => {
							optMemIcon.map((memIcon) => memIcon.getOpt(comp).each((displayIcon) => {
								Replacing.set(displayIcon, [renderReplaceableIconFromPack(newIcon, providers.icons)]);
							}));
						} }
					});
				};
				const buttonType = spec.buttonType.getOr(!spec.primary ? "secondary" : "primary");
				const buttonSpec = {
					...spec,
					name: (_a = spec.name) !== null && _a !== void 0 ? _a : "",
					primary: buttonType === "primary",
					tooltip: Optional.from(spec.tooltip),
					enabled: (_b = spec.enabled) !== null && _b !== void 0 ? _b : false,
					borderless: false
				};
				const tooltipAttributes = buttonSpec.tooltip.map((tooltip) => ({
					"aria-label": providers.translate(tooltip),
					"title": providers.translate(tooltip)
				})).getOr({});
				const buttonTypeClasses = calculateClassesFromButtonType(buttonType !== null && buttonType !== void 0 ? buttonType : "secondary");
				const showIconAndText = spec.icon.isSome() && spec.text.isSome();
				const dom$3 = {
					tag: "button",
					classes: [
						...buttonTypeClasses.concat(spec.icon.isSome() ? ["tox-button--icon"] : []),
						...spec.active ? ["tox-button--enabled"] : [],
						...showIconAndText ? ["tox-button--icon-and-text"] : []
					],
					attributes: tooltipAttributes
				};
				const extraBehaviours = [];
				const translatedTextComponed = text$2(providers.translate(spec.text.getOr("")));
				const components$2 = [...componentRenderPipeline([optMemIcon.map((memIcon) => memIcon.asSpec())]), ...spec.text.isSome() ? [translatedTextComponed] : []];
				const iconButtonSpec = renderCommonSpec(buttonSpec, Optional.some(action), extraBehaviours, dom$3, components$2, providers);
				return Button.sketch(iconButtonSpec);
			};
			const renderFooterButton = (spec, buttonType, backstage) => {
				if (isMenuFooterButtonSpec(spec, buttonType)) {
					const getButton = () => memButton;
					const menuButtonSpec = spec;
					const memButton = record(renderMenuButton({
						...spec,
						type: "menubutton",
						search: Optional.none(),
						onSetup: (api$3) => {
							api$3.setEnabled(spec.enabled);
							return noop;
						},
						fetch: getFetch(menuButtonSpec.items, getButton, backstage)
					}, "tox-tbtn", backstage, Optional.none()));
					return memButton.asSpec();
				} else if (isNormalFooterButtonSpec(spec, buttonType)) {
					const action = getAction(spec.name, buttonType);
					return renderButton$1({
						...spec,
						borderless: false
					}, action, backstage.shared.providers, []);
				} else if (isToggleButtonSpec(spec, buttonType)) return renderToggleButton(spec, backstage.shared.providers);
				else {
					console.error("Unknown footer button type: ", buttonType);
					throw new Error("Unknown footer button type");
				}
			};
			const renderDialogButton = (spec, providersBackstage) => {
				const action = getAction(spec.name, "custom");
				return renderFormField(Optional.none(), FormField.parts.field({
					factory: Button,
					...renderButtonSpec(spec, Optional.some(action), providersBackstage, [memory(""), ComposingConfigs.self()])
				}));
			};
			const separator$1 = { type: "separator" };
			const toMenuItem = (target) => ({
				type: "menuitem",
				value: target.url,
				text: target.title,
				meta: { attach: target.attach },
				onAction: noop
			});
			const staticMenuItem = (title$1, url) => ({
				type: "menuitem",
				value: url,
				text: title$1,
				meta: { attach: void 0 },
				onAction: noop
			});
			const toMenuItems = (targets) => map$2(targets, toMenuItem);
			const filterLinkTargets = (type$2, targets) => filter$2(targets, (target) => target.type === type$2);
			const filteredTargets = (type$2, targets) => toMenuItems(filterLinkTargets(type$2, targets));
			const headerTargets = (linkInfo) => filteredTargets("header", linkInfo.targets);
			const anchorTargets = (linkInfo) => filteredTargets("anchor", linkInfo.targets);
			const anchorTargetTop = (linkInfo) => Optional.from(linkInfo.anchorTop).map((url) => staticMenuItem("<top>", url)).toArray();
			const anchorTargetBottom = (linkInfo) => Optional.from(linkInfo.anchorBottom).map((url) => staticMenuItem("<bottom>", url)).toArray();
			const historyTargets = (history) => map$2(history, (url) => staticMenuItem(url, url));
			const joinMenuLists = (items) => {
				return foldl(items, (a, b$1) => {
					return a.length === 0 || b$1.length === 0 ? a.concat(b$1) : a.concat(separator$1, b$1);
				}, []);
			};
			const filterByQuery = (term, menuItems) => {
				const lowerCaseTerm = term.toLowerCase();
				return filter$2(menuItems, (item$1) => {
					var _a;
					const text$3 = item$1.meta !== void 0 && item$1.meta.text !== void 0 ? item$1.meta.text : item$1.text;
					const value$5 = (_a = item$1.value) !== null && _a !== void 0 ? _a : "";
					return contains$1(text$3.toLowerCase(), lowerCaseTerm) || contains$1(value$5.toLowerCase(), lowerCaseTerm);
				});
			};
			const getItems = (fileType, input$1, urlBackstage) => {
				var _a, _b;
				const urlInputValue = Representing.getValue(input$1);
				const term = (_b = (_a = urlInputValue === null || urlInputValue === void 0 ? void 0 : urlInputValue.meta) === null || _a === void 0 ? void 0 : _a.text) !== null && _b !== void 0 ? _b : urlInputValue.value;
				return urlBackstage.getLinkInformation().fold(() => [], (linkInfo) => {
					const history = filterByQuery(term, historyTargets(urlBackstage.getHistory(fileType)));
					return fileType === "file" ? joinMenuLists([
						history,
						filterByQuery(term, headerTargets(linkInfo)),
						filterByQuery(term, flatten([
							anchorTargetTop(linkInfo),
							anchorTargets(linkInfo),
							anchorTargetBottom(linkInfo)
						]))
					]) : history;
				});
			};
			const errorId = generate$6("aria-invalid");
			const renderUrlInput = (spec, backstage, urlBackstage, initialData) => {
				const providersBackstage = backstage.shared.providers;
				const updateHistory = (component) => {
					const urlEntry = Representing.getValue(component);
					urlBackstage.addToHistory(urlEntry.value, spec.filetype);
				};
				const typeaheadSpec = {
					...initialData.map((initialData$1) => ({ initialData: initialData$1 })).getOr({}),
					dismissOnBlur: true,
					inputClasses: ["tox-textfield"],
					sandboxClasses: ["tox-dialog__popups"],
					inputAttributes: {
						"aria-errormessage": errorId,
						"type": "url"
					},
					minChars: 0,
					responseTime: 0,
					fetch: (input$1) => {
						const tdata = build(getItems(spec.filetype, input$1, urlBackstage), ItemResponse$1.BUBBLE_TO_SANDBOX, backstage, {
							isHorizontalMenu: false,
							search: Optional.none()
						});
						return Future.pure(tdata);
					},
					getHotspot: (comp) => memUrlBox.getOpt(comp),
					onSetValue: (comp, _newValue) => {
						if (comp.hasConfigured(Invalidating)) Invalidating.run(comp).get(noop);
					},
					typeaheadBehaviours: derive$1([
						...urlBackstage.getValidationHandler().map((handler) => Invalidating.config({
							getRoot: (comp) => parentElement(comp.element),
							invalidClass: "tox-control-wrap--status-invalid",
							notify: { onInvalid: (comp, err) => {
								memInvalidIcon.getOpt(comp).each((invalidComp) => {
									set$9(invalidComp.element, "title", providersBackstage.translate(err));
								});
							} },
							validator: {
								validate: (input$1) => {
									const urlEntry = Representing.getValue(input$1);
									return FutureResult.nu((completer) => {
										handler({
											type: spec.filetype,
											url: urlEntry.value
										}, (validation) => {
											if (validation.status === "invalid") completer(Result.error(validation.message));
											else completer(Result.value(validation.message));
										});
									});
								},
								validateOnLoad: false
							}
						})).toArray(),
						Disabling.config({ disabled: () => !spec.enabled || providersBackstage.isDisabled() }),
						Tabstopping.config({}),
						config("urlinput-events", [
							run$1(input(), (comp) => {
								const currentValue$1 = get$6(comp.element);
								const trimmedValue = currentValue$1.trim();
								if (trimmedValue !== currentValue$1) set$5(comp.element, trimmedValue);
								if (spec.filetype === "file") emitWith(comp, formChangeEvent, { name: spec.name });
							}),
							run$1(change(), (comp) => {
								emitWith(comp, formChangeEvent, { name: spec.name });
								updateHistory(comp);
							}),
							run$1(postPaste(), (comp) => {
								emitWith(comp, formChangeEvent, { name: spec.name });
								updateHistory(comp);
							})
						])
					]),
					eventOrder: { [input()]: [
						"streaming",
						"urlinput-events",
						"invalidating"
					] },
					model: {
						getDisplayText: (itemData) => itemData.value,
						selectsOver: false,
						populateFromBrowse: false
					},
					markers: { openClass: "tox-textfield--popup-open" },
					lazySink: backstage.shared.getSink,
					parts: { menu: part(false, 1, "normal") },
					onExecute: (_menu, component, _entry) => {
						emitWith(component, formSubmitEvent, {});
					},
					onItemExecute: (typeahead, _sandbox, _item, _value) => {
						updateHistory(typeahead);
						emitWith(typeahead, formChangeEvent, { name: spec.name });
					}
				};
				const pField = FormField.parts.field({
					...typeaheadSpec,
					factory: Typeahead
				});
				const pLabel = spec.label.map((label$1) => renderLabel$3(label$1, providersBackstage));
				const makeIcon = (name$4, errId, icon$1 = name$4, label$1 = name$4) => render$3(icon$1, {
					tag: "div",
					classes: ["tox-icon", "tox-control-wrap__status-icon-" + name$4],
					attributes: {
						"title": providersBackstage.translate(label$1),
						"aria-live": "polite",
						...errId.fold(() => ({}), (id) => ({ id }))
					}
				}, providersBackstage.icons);
				const memInvalidIcon = record(makeIcon("invalid", Optional.some(errorId), "warning"));
				const memStatus = record({
					dom: {
						tag: "div",
						classes: ["tox-control-wrap__status-icon-wrap"]
					},
					components: [memInvalidIcon.asSpec()]
				});
				const optUrlPicker = urlBackstage.getUrlPicker(spec.filetype);
				const browseUrlEvent = generate$6("browser.url.event");
				const memUrlBox = record({
					dom: {
						tag: "div",
						classes: ["tox-control-wrap"]
					},
					components: [pField, memStatus.asSpec()],
					behaviours: derive$1([Disabling.config({ disabled: () => !spec.enabled || providersBackstage.isDisabled() })])
				});
				const memUrlPickerButton = record(renderButton$1({
					name: spec.name,
					icon: Optional.some("browse"),
					text: spec.label.getOr(""),
					enabled: spec.enabled,
					primary: false,
					buttonType: Optional.none(),
					borderless: true
				}, (component) => emit(component, browseUrlEvent), providersBackstage, [], ["tox-browse-url"]));
				const controlHWrapper = () => ({
					dom: {
						tag: "div",
						classes: ["tox-form__controls-h-stack"]
					},
					components: flatten([[memUrlBox.asSpec()], optUrlPicker.map(() => memUrlPickerButton.asSpec()).toArray()])
				});
				const openUrlPicker = (comp) => {
					Composing.getCurrent(comp).each((field$3) => {
						const componentData = Representing.getValue(field$3);
						const urlData = {
							fieldname: spec.name,
							...componentData
						};
						optUrlPicker.each((picker) => {
							picker(urlData).get((chosenData) => {
								Representing.setValue(field$3, chosenData);
								emitWith(comp, formChangeEvent, { name: spec.name });
							});
						});
					});
				};
				return FormField.sketch({
					dom: renderFormFieldDom(),
					components: pLabel.toArray().concat([controlHWrapper()]),
					fieldBehaviours: derive$1([
						Disabling.config({
							disabled: () => !spec.enabled || providersBackstage.isDisabled(),
							onDisabled: (comp) => {
								FormField.getField(comp).each(Disabling.disable);
								memUrlPickerButton.getOpt(comp).each(Disabling.disable);
							},
							onEnabled: (comp) => {
								FormField.getField(comp).each(Disabling.enable);
								memUrlPickerButton.getOpt(comp).each(Disabling.enable);
							}
						}),
						receivingConfig(),
						config("url-input-events", [run$1(browseUrlEvent, openUrlPicker)])
					])
				});
			};
			const renderAlertBanner = (spec, providersBackstage) => {
				const icon$1 = get$2(spec.icon, providersBackstage.icons);
				return Container.sketch({
					dom: {
						tag: "div",
						attributes: { role: "alert" },
						classes: [
							"tox-notification",
							"tox-notification--in",
							`tox-notification--${spec.level}`
						]
					},
					components: [{
						dom: {
							tag: "div",
							classes: ["tox-notification__icon"],
							innerHtml: !spec.url ? icon$1 : void 0
						},
						components: spec.url ? [Button.sketch({
							dom: {
								tag: "button",
								classes: [
									"tox-button",
									"tox-button--naked",
									"tox-button--icon"
								],
								innerHtml: icon$1,
								attributes: { title: providersBackstage.translate(spec.iconTooltip) }
							},
							action: (comp) => emitWith(comp, formActionEvent, {
								name: "alert-banner",
								value: spec.url
							}),
							buttonBehaviours: derive$1([addFocusableBehaviour()])
						})] : void 0
					}, { dom: {
						tag: "div",
						classes: ["tox-notification__body"],
						innerHtml: providersBackstage.translate(spec.text)
					} }]
				});
			};
			const set$1 = (element$1, status) => {
				element$1.dom.checked = status;
			};
			const get$1 = (element$1) => element$1.dom.checked;
			const renderCheckbox = (spec, providerBackstage, initialData) => {
				const toggleCheckboxHandler = (comp) => {
					comp.element.dom.click();
					return Optional.some(true);
				};
				const pField = FormField.parts.field({
					factory: { sketch: identity },
					dom: {
						tag: "input",
						classes: ["tox-checkbox__input"],
						attributes: { type: "checkbox" }
					},
					behaviours: derive$1([
						ComposingConfigs.self(),
						Disabling.config({
							disabled: () => !spec.enabled || providerBackstage.isDisabled(),
							onDisabled: (component) => {
								parentElement(component.element).each((element$1) => add$2(element$1, "tox-checkbox--disabled"));
							},
							onEnabled: (component) => {
								parentElement(component.element).each((element$1) => remove$2(element$1, "tox-checkbox--disabled"));
							}
						}),
						Tabstopping.config({}),
						Focusing.config({}),
						withElement(initialData, get$1, set$1),
						Keying.config({
							mode: "special",
							onEnter: toggleCheckboxHandler,
							onSpace: toggleCheckboxHandler,
							stopSpaceKeyup: true
						}),
						config("checkbox-events", [run$1(change(), (component, _) => {
							emitWith(component, formChangeEvent, { name: spec.name });
						})])
					])
				});
				const pLabel = FormField.parts.label({
					dom: {
						tag: "span",
						classes: ["tox-checkbox__label"]
					},
					components: [text$2(providerBackstage.translate(spec.label))],
					behaviours: derive$1([Unselecting.config({})])
				});
				const makeIcon = (className) => {
					return render$3(className === "checked" ? "selected" : "unselected", {
						tag: "span",
						classes: ["tox-icon", "tox-checkbox-icon__" + className]
					}, providerBackstage.icons);
				};
				const memIcons = record({
					dom: {
						tag: "div",
						classes: ["tox-checkbox__icons"]
					},
					components: [makeIcon("checked"), makeIcon("unchecked")]
				});
				return FormField.sketch({
					dom: {
						tag: "label",
						classes: ["tox-checkbox"]
					},
					components: [
						pField,
						memIcons.asSpec(),
						pLabel
					],
					fieldBehaviours: derive$1([Disabling.config({ disabled: () => !spec.enabled || providerBackstage.isDisabled() }), receivingConfig()])
				});
			};
			const renderHtmlPanel = (spec) => {
				if (spec.presets === "presentation") return Container.sketch({ dom: {
					tag: "div",
					classes: ["tox-form__group"],
					innerHtml: spec.html
				} });
				else return Container.sketch({
					dom: {
						tag: "div",
						classes: ["tox-form__group"],
						innerHtml: spec.html,
						attributes: { role: "document" }
					},
					containerBehaviours: derive$1([Tabstopping.config({}), Focusing.config({})])
				});
			};
			const make$2 = (render$4) => {
				return (parts$10, spec, dialogData, backstage) => get$g(spec, "name").fold(() => render$4(spec, backstage, Optional.none()), (fieldName) => parts$10.field(fieldName, render$4(spec, backstage, get$g(dialogData, fieldName))));
			};
			const makeIframe = (render$4) => (parts$10, spec, dialogData, backstage) => {
				const iframeSpec = deepMerge(spec, { source: "dynamic" });
				return make$2(render$4)(parts$10, iframeSpec, dialogData, backstage);
			};
			const factories = {
				bar: make$2((spec, backstage) => renderBar(spec, backstage.shared)),
				collection: make$2((spec, backstage, data) => renderCollection(spec, backstage.shared.providers, data)),
				alertbanner: make$2((spec, backstage) => renderAlertBanner(spec, backstage.shared.providers)),
				input: make$2((spec, backstage, data) => renderInput(spec, backstage.shared.providers, data)),
				textarea: make$2((spec, backstage, data) => renderTextarea(spec, backstage.shared.providers, data)),
				label: make$2((spec, backstage) => renderLabel$2(spec, backstage.shared)),
				iframe: makeIframe((spec, backstage, data) => renderIFrame(spec, backstage.shared.providers, data)),
				button: make$2((spec, backstage) => renderDialogButton(spec, backstage.shared.providers)),
				checkbox: make$2((spec, backstage, data) => renderCheckbox(spec, backstage.shared.providers, data)),
				colorinput: make$2((spec, backstage, data) => renderColorInput(spec, backstage.shared, backstage.colorinput, data)),
				colorpicker: make$2((spec, backstage, data) => renderColorPicker(spec, backstage.shared.providers, data)),
				dropzone: make$2((spec, backstage, data) => renderDropZone(spec, backstage.shared.providers, data)),
				grid: make$2((spec, backstage) => renderGrid(spec, backstage.shared)),
				listbox: make$2((spec, backstage, data) => renderListBox(spec, backstage, data)),
				selectbox: make$2((spec, backstage, data) => renderSelectBox(spec, backstage.shared.providers, data)),
				sizeinput: make$2((spec, backstage) => renderSizeInput(spec, backstage.shared.providers)),
				slider: make$2((spec, backstage, data) => renderSlider(spec, backstage.shared.providers, data)),
				urlinput: make$2((spec, backstage, data) => renderUrlInput(spec, backstage, backstage.urlinput, data)),
				customeditor: make$2(renderCustomEditor),
				htmlpanel: make$2(renderHtmlPanel),
				imagepreview: make$2((spec, _, data) => renderImagePreview(spec, data)),
				table: make$2((spec, backstage) => renderTable(spec, backstage.shared.providers)),
				tree: make$2((spec, backstage) => renderTree(spec, backstage)),
				panel: make$2((spec, backstage) => renderPanel(spec, backstage))
			};
			const noFormParts = {
				field: (_name, spec) => spec,
				record: constant$1([])
			};
			const interpretInForm = (parts$10, spec, dialogData, oldBackstage) => {
				const newBackstage = deepMerge(oldBackstage, { shared: { interpreter: (childSpec) => interpretParts(parts$10, childSpec, dialogData, newBackstage) } });
				return interpretParts(parts$10, spec, dialogData, newBackstage);
			};
			const interpretParts = (parts$10, spec, dialogData, backstage) => get$g(factories, spec.type).fold(() => {
				console.error(`Unknown factory type "${spec.type}", defaulting to container: `, spec);
				return spec;
			}, (factory$10) => factory$10(parts$10, spec, dialogData, backstage));
			const interpretWithoutForm = (spec, dialogData, backstage) => interpretParts(noFormParts, spec, dialogData, backstage);
			const labelPrefix = "layout-inset";
			const westEdgeX = (anchor$1) => anchor$1.x;
			const middleX = (anchor$1, element$1) => anchor$1.x + anchor$1.width / 2 - element$1.width / 2;
			const eastEdgeX = (anchor$1, element$1) => anchor$1.x + anchor$1.width - element$1.width;
			const northY = (anchor$1) => anchor$1.y;
			const southY = (anchor$1, element$1) => anchor$1.y + anchor$1.height - element$1.height;
			const centreY = (anchor$1, element$1) => anchor$1.y + anchor$1.height / 2 - element$1.height / 2;
			const southwest = (anchor$1, element$1, bubbles) => nu$6(eastEdgeX(anchor$1, element$1), southY(anchor$1, element$1), bubbles.insetSouthwest(), northwest$3(), "southwest", boundsRestriction(anchor$1, {
				right: 0,
				bottom: 3
			}), labelPrefix);
			const southeast = (anchor$1, element$1, bubbles) => nu$6(westEdgeX(anchor$1), southY(anchor$1, element$1), bubbles.insetSoutheast(), northeast$3(), "southeast", boundsRestriction(anchor$1, {
				left: 1,
				bottom: 3
			}), labelPrefix);
			const northwest = (anchor$1, element$1, bubbles) => nu$6(eastEdgeX(anchor$1, element$1), northY(anchor$1), bubbles.insetNorthwest(), southwest$3(), "northwest", boundsRestriction(anchor$1, {
				right: 0,
				top: 2
			}), labelPrefix);
			const northeast = (anchor$1, element$1, bubbles) => nu$6(westEdgeX(anchor$1), northY(anchor$1), bubbles.insetNortheast(), southeast$3(), "northeast", boundsRestriction(anchor$1, {
				left: 1,
				top: 2
			}), labelPrefix);
			const north = (anchor$1, element$1, bubbles) => nu$6(middleX(anchor$1, element$1), northY(anchor$1), bubbles.insetNorth(), south$3(), "north", boundsRestriction(anchor$1, { top: 2 }), labelPrefix);
			const south = (anchor$1, element$1, bubbles) => nu$6(middleX(anchor$1, element$1), southY(anchor$1, element$1), bubbles.insetSouth(), north$3(), "south", boundsRestriction(anchor$1, { bottom: 3 }), labelPrefix);
			const east = (anchor$1, element$1, bubbles) => nu$6(eastEdgeX(anchor$1, element$1), centreY(anchor$1, element$1), bubbles.insetEast(), west$3(), "east", boundsRestriction(anchor$1, { right: 0 }), labelPrefix);
			const west = (anchor$1, element$1, bubbles) => nu$6(westEdgeX(anchor$1), centreY(anchor$1, element$1), bubbles.insetWest(), east$3(), "west", boundsRestriction(anchor$1, { left: 1 }), labelPrefix);
			const lookupPreserveLayout = (lastPlacement) => {
				switch (lastPlacement) {
					case "north": return north;
					case "northeast": return northeast;
					case "northwest": return northwest;
					case "south": return south;
					case "southeast": return southeast;
					case "southwest": return southwest;
					case "east": return east;
					case "west": return west;
				}
			};
			const preserve = (anchor$1, element$1, bubbles, placee, bounds$2) => {
				return getPlacement(placee).map(lookupPreserveLayout).getOr(north)(anchor$1, element$1, bubbles, placee, bounds$2);
			};
			const lookupFlippedLayout = (lastPlacement) => {
				switch (lastPlacement) {
					case "north": return south;
					case "northeast": return southeast;
					case "northwest": return southwest;
					case "south": return north;
					case "southeast": return northeast;
					case "southwest": return northwest;
					case "east": return west;
					case "west": return east;
				}
			};
			const flip = (anchor$1, element$1, bubbles, placee, bounds$2) => {
				return getPlacement(placee).map(lookupFlippedLayout).getOr(north)(anchor$1, element$1, bubbles, placee, bounds$2);
			};
			const bubbleAlignments$2 = {
				valignCentre: [],
				alignCentre: [],
				alignLeft: [],
				alignRight: [],
				right: [],
				left: [],
				bottom: [],
				top: []
			};
			const getInlineDialogAnchor = (contentAreaElement, lazyAnchorbar, lazyUseEditableAreaAnchor) => {
				const bubbleSize$2 = 12;
				const overrides = { maxHeightFunction: expandable$1() };
				const editableAreaAnchor = () => ({
					type: "node",
					root: getContentContainer(getRootNode(contentAreaElement())),
					node: Optional.from(contentAreaElement()),
					bubble: nu$5(bubbleSize$2, bubbleSize$2, bubbleAlignments$2),
					layouts: {
						onRtl: () => [northeast],
						onLtr: () => [northwest]
					},
					overrides
				});
				const standardAnchor = () => ({
					type: "hotspot",
					hotspot: lazyAnchorbar(),
					bubble: nu$5(-bubbleSize$2, bubbleSize$2, bubbleAlignments$2),
					layouts: {
						onRtl: () => [
							southeast$2,
							southwest$2,
							south$2
						],
						onLtr: () => [
							southwest$2,
							southeast$2,
							south$2
						]
					},
					overrides
				});
				return () => lazyUseEditableAreaAnchor() ? editableAreaAnchor() : standardAnchor();
			};
			const getInlineBottomDialogAnchor = (inline$1, contentAreaElement, lazyBottomAnchorBar, lazyUseEditableAreaAnchor) => {
				const bubbleSize$2 = 12;
				const overrides = { maxHeightFunction: expandable$1() };
				const editableAreaAnchor = () => ({
					type: "node",
					root: getContentContainer(getRootNode(contentAreaElement())),
					node: Optional.from(contentAreaElement()),
					bubble: nu$5(bubbleSize$2, bubbleSize$2, bubbleAlignments$2),
					layouts: {
						onRtl: () => [north],
						onLtr: () => [north]
					},
					overrides
				});
				const standardAnchor = () => inline$1 ? {
					type: "node",
					root: getContentContainer(getRootNode(contentAreaElement())),
					node: Optional.from(contentAreaElement()),
					bubble: nu$5(0, -getOuter$2(contentAreaElement()), bubbleAlignments$2),
					layouts: {
						onRtl: () => [north$2],
						onLtr: () => [north$2]
					},
					overrides
				} : {
					type: "hotspot",
					hotspot: lazyBottomAnchorBar(),
					bubble: nu$5(0, 0, bubbleAlignments$2),
					layouts: {
						onRtl: () => [north$2],
						onLtr: () => [north$2]
					},
					overrides
				};
				return () => lazyUseEditableAreaAnchor() ? editableAreaAnchor() : standardAnchor();
			};
			const getBannerAnchor = (contentAreaElement, lazyAnchorbar, lazyUseEditableAreaAnchor) => {
				const editableAreaAnchor = () => ({
					type: "node",
					root: getContentContainer(getRootNode(contentAreaElement())),
					node: Optional.from(contentAreaElement()),
					layouts: {
						onRtl: () => [north],
						onLtr: () => [north]
					}
				});
				const standardAnchor = () => ({
					type: "hotspot",
					hotspot: lazyAnchorbar(),
					layouts: {
						onRtl: () => [south$2],
						onLtr: () => [south$2]
					}
				});
				return () => lazyUseEditableAreaAnchor() ? editableAreaAnchor() : standardAnchor();
			};
			const getCursorAnchor = (editor, bodyElement) => () => ({
				type: "selection",
				root: bodyElement(),
				getSelection: () => {
					const rng = editor.selection.getRng();
					const selectedCells = editor.model.table.getSelectedCells();
					if (selectedCells.length > 1) {
						const firstCell = selectedCells[0];
						const lastCell = selectedCells[selectedCells.length - 1];
						const selectionTableCellRange = {
							firstCell: SugarElement.fromDom(firstCell),
							lastCell: SugarElement.fromDom(lastCell)
						};
						return Optional.some(selectionTableCellRange);
					}
					return Optional.some(SimSelection.range(SugarElement.fromDom(rng.startContainer), rng.startOffset, SugarElement.fromDom(rng.endContainer), rng.endOffset));
				}
			});
			const getNodeAnchor$1 = (bodyElement) => (element$1) => ({
				type: "node",
				root: bodyElement(),
				node: element$1
			});
			const getAnchors = (editor, lazyAnchorbar, lazyBottomAnchorBar, isToolbarTop) => {
				const useFixedToolbarContainer = useFixedContainer(editor);
				const bodyElement = () => SugarElement.fromDom(editor.getBody());
				const contentAreaElement = () => SugarElement.fromDom(editor.getContentAreaContainer());
				const lazyUseEditableAreaAnchor = () => useFixedToolbarContainer || !isToolbarTop();
				return {
					inlineDialog: getInlineDialogAnchor(contentAreaElement, lazyAnchorbar, lazyUseEditableAreaAnchor),
					inlineBottomDialog: getInlineBottomDialogAnchor(editor.inline, contentAreaElement, lazyBottomAnchorBar, lazyUseEditableAreaAnchor),
					banner: getBannerAnchor(contentAreaElement, lazyAnchorbar, lazyUseEditableAreaAnchor),
					cursor: getCursorAnchor(editor, bodyElement),
					node: getNodeAnchor$1(bodyElement)
				};
			};
			const colorPicker = (editor) => (callback, value$5) => {
				colorPickerDialog(editor)(callback, value$5);
			};
			const hasCustomColors = (editor) => () => hasCustomColors$1(editor);
			const getColors = (editor) => (id) => getColors$2(editor, id);
			const getColorCols = (editor) => (id) => getColorCols$1(editor, id);
			const ColorInputBackstage = (editor) => ({
				colorPicker: colorPicker(editor),
				hasCustomColors: hasCustomColors(editor),
				getColors: getColors(editor),
				getColorCols: getColorCols(editor)
			});
			const isDraggableModal = (editor) => () => isDraggableModal$1(editor);
			const DialogBackstage = (editor) => ({ isDraggableModal: isDraggableModal(editor) });
			const HeaderBackstage = (editor) => {
				const mode = Cell(isToolbarLocationBottom(editor) ? "bottom" : "top");
				return {
					isPositionedAtTop: () => mode.get() === "top",
					getDockingMode: mode.get,
					setDockingMode: mode.set
				};
			};
			const isNestedFormat = (format) => hasNonNullableKey(format, "items");
			const isFormatReference = (format) => hasNonNullableKey(format, "format");
			const defaultStyleFormats = [
				{
					title: "Headings",
					items: [
						{
							title: "Heading 1",
							format: "h1"
						},
						{
							title: "Heading 2",
							format: "h2"
						},
						{
							title: "Heading 3",
							format: "h3"
						},
						{
							title: "Heading 4",
							format: "h4"
						},
						{
							title: "Heading 5",
							format: "h5"
						},
						{
							title: "Heading 6",
							format: "h6"
						}
					]
				},
				{
					title: "Inline",
					items: [
						{
							title: "Bold",
							format: "bold"
						},
						{
							title: "Italic",
							format: "italic"
						},
						{
							title: "Underline",
							format: "underline"
						},
						{
							title: "Strikethrough",
							format: "strikethrough"
						},
						{
							title: "Superscript",
							format: "superscript"
						},
						{
							title: "Subscript",
							format: "subscript"
						},
						{
							title: "Code",
							format: "code"
						}
					]
				},
				{
					title: "Blocks",
					items: [
						{
							title: "Paragraph",
							format: "p"
						},
						{
							title: "Blockquote",
							format: "blockquote"
						},
						{
							title: "Div",
							format: "div"
						},
						{
							title: "Pre",
							format: "pre"
						}
					]
				},
				{
					title: "Align",
					items: [
						{
							title: "Left",
							format: "alignleft"
						},
						{
							title: "Center",
							format: "aligncenter"
						},
						{
							title: "Right",
							format: "alignright"
						},
						{
							title: "Justify",
							format: "alignjustify"
						}
					]
				}
			];
			const isNestedFormats = (format) => has$2(format, "items");
			const isBlockFormat = (format) => has$2(format, "block");
			const isInlineFormat = (format) => has$2(format, "inline");
			const isSelectorFormat = (format) => has$2(format, "selector");
			const mapFormats = (userFormats) => foldl(userFormats, (acc, fmt) => {
				if (isNestedFormats(fmt)) {
					const result = mapFormats(fmt.items);
					return {
						customFormats: acc.customFormats.concat(result.customFormats),
						formats: acc.formats.concat([{
							title: fmt.title,
							items: result.formats
						}])
					};
				} else if (isInlineFormat(fmt) || isBlockFormat(fmt) || isSelectorFormat(fmt)) {
					const formatNameWithPrefix = `custom-${isString(fmt.name) ? fmt.name : fmt.title.toLowerCase()}`;
					return {
						customFormats: acc.customFormats.concat([{
							name: formatNameWithPrefix,
							format: fmt
						}]),
						formats: acc.formats.concat([{
							title: fmt.title,
							format: formatNameWithPrefix,
							icon: fmt.icon
						}])
					};
				} else return {
					...acc,
					formats: acc.formats.concat(fmt)
				};
			}, {
				customFormats: [],
				formats: []
			});
			const registerCustomFormats = (editor, userFormats) => {
				const result = mapFormats(userFormats);
				const registerFormats = (customFormats) => {
					each$1(customFormats, (fmt) => {
						if (!editor.formatter.has(fmt.name)) editor.formatter.register(fmt.name, fmt.format);
					});
				};
				if (editor.formatter) registerFormats(result.customFormats);
				else editor.on("init", () => {
					registerFormats(result.customFormats);
				});
				return result.formats;
			};
			const getStyleFormats = (editor) => getUserStyleFormats(editor).map((userFormats) => {
				const registeredUserFormats = registerCustomFormats(editor, userFormats);
				return shouldMergeStyleFormats(editor) ? defaultStyleFormats.concat(registeredUserFormats) : registeredUserFormats;
			}).getOr(defaultStyleFormats);
			const isSeparator$1 = (format) => {
				const keys$1 = keys(format);
				return keys$1.length === 1 && contains$2(keys$1, "title");
			};
			const processBasic = (item$1, isSelectedFor, getPreviewFor) => ({
				...item$1,
				type: "formatter",
				isSelected: isSelectedFor(item$1.format),
				getStylePreview: getPreviewFor(item$1.format)
			});
			const register$a = (editor, formats, isSelectedFor, getPreviewFor) => {
				const enrichSupported = (item$1) => processBasic(item$1, isSelectedFor, getPreviewFor);
				const enrichMenu = (item$1) => {
					const newItems = doEnrich(item$1.items);
					return {
						...item$1,
						type: "submenu",
						getStyleItems: constant$1(newItems)
					};
				};
				const enrichCustom = (item$1) => {
					const formatName = isString(item$1.name) ? item$1.name : generate$6(item$1.title);
					const formatNameWithPrefix = `custom-${formatName}`;
					const newItem = {
						...item$1,
						type: "formatter",
						format: formatNameWithPrefix,
						isSelected: isSelectedFor(formatNameWithPrefix),
						getStylePreview: getPreviewFor(formatNameWithPrefix)
					};
					editor.formatter.register(formatName, newItem);
					return newItem;
				};
				const doEnrich = (items) => map$2(items, (item$1) => {
					if (isNestedFormat(item$1)) return enrichMenu(item$1);
					else if (isFormatReference(item$1)) return enrichSupported(item$1);
					else if (isSeparator$1(item$1)) return {
						...item$1,
						type: "separator"
					};
					else return enrichCustom(item$1);
				});
				return doEnrich(formats);
			};
			const init$7 = (editor) => {
				const isSelectedFor = (format) => () => editor.formatter.match(format);
				const getPreviewFor = (format) => () => {
					const fmt = editor.formatter.get(format);
					return fmt !== void 0 ? Optional.some({
						tag: fmt.length > 0 ? fmt[0].inline || fmt[0].block || "div" : "div",
						styles: editor.dom.parseStyle(editor.formatter.getCssText(format))
					}) : Optional.none();
				};
				const settingsFormats = Cell([]);
				const eventsFormats = Cell([]);
				const replaceSettings = Cell(false);
				editor.on("PreInit", (_e) => {
					const enriched = register$a(editor, getStyleFormats(editor), isSelectedFor, getPreviewFor);
					settingsFormats.set(enriched);
				});
				editor.on("addStyleModifications", (e) => {
					const modifications = register$a(editor, e.items, isSelectedFor, getPreviewFor);
					eventsFormats.set(modifications);
					replaceSettings.set(e.replace);
				});
				const getData$3 = () => {
					const fromSettings = replaceSettings.get() ? [] : settingsFormats.get();
					const fromEvents = eventsFormats.get();
					return fromSettings.concat(fromEvents);
				};
				return { getData: getData$3 };
			};
			const isElement = (node) => isNonNullable(node) && node.nodeType === 1;
			const trim = global$1.trim;
			const hasContentEditableState = (value$5) => {
				return (node) => {
					if (isElement(node)) {
						if (node.contentEditable === value$5) return true;
						if (node.getAttribute("data-mce-contenteditable") === value$5) return true;
					}
					return false;
				};
			};
			const isContentEditableTrue = hasContentEditableState("true");
			const isContentEditableFalse = hasContentEditableState("false");
			const create$1 = (type$2, title$1, url, level, attach$2) => ({
				type: type$2,
				title: title$1,
				url,
				level,
				attach: attach$2
			});
			const isChildOfContentEditableTrue = (node) => {
				let tempNode = node;
				while (tempNode = tempNode.parentNode) {
					const value$5 = tempNode.contentEditable;
					if (value$5 && value$5 !== "inherit") return isContentEditableTrue(tempNode);
				}
				return false;
			};
			const select = (selector, root) => {
				return map$2(descendants(SugarElement.fromDom(root), selector), (element$1) => {
					return element$1.dom;
				});
			};
			const getElementText = (elm) => {
				return elm.innerText || elm.textContent;
			};
			const getOrGenerateId = (elm) => {
				return elm.id ? elm.id : generate$6("h");
			};
			const isAnchor = (elm) => {
				return elm && elm.nodeName === "A" && (elm.id || elm.name) !== void 0;
			};
			const isValidAnchor = (elm) => {
				return isAnchor(elm) && isEditable(elm);
			};
			const isHeader = (elm) => {
				return elm && /^(H[1-6])$/.test(elm.nodeName);
			};
			const isEditable = (elm) => {
				return isChildOfContentEditableTrue(elm) && !isContentEditableFalse(elm);
			};
			const isValidHeader = (elm) => {
				return isHeader(elm) && isEditable(elm);
			};
			const getLevel = (elm) => {
				return isHeader(elm) ? parseInt(elm.nodeName.substr(1), 10) : 0;
			};
			const headerTarget = (elm) => {
				var _a;
				const headerId = getOrGenerateId(elm);
				const attach$2 = () => {
					elm.id = headerId;
				};
				return create$1("header", (_a = getElementText(elm)) !== null && _a !== void 0 ? _a : "", "#" + headerId, getLevel(elm), attach$2);
			};
			const anchorTarget = (elm) => {
				const anchorId = elm.id || elm.name;
				const anchorText = getElementText(elm);
				return create$1("anchor", anchorText ? anchorText : "#" + anchorId, "#" + anchorId, 0, noop);
			};
			const getHeaderTargets = (elms) => {
				return map$2(filter$2(elms, isValidHeader), headerTarget);
			};
			const getAnchorTargets = (elms) => {
				return map$2(filter$2(elms, isValidAnchor), anchorTarget);
			};
			const getTargetElements = (elm) => {
				return select("h1,h2,h3,h4,h5,h6,a:not([href])", elm);
			};
			const hasTitle = (target) => {
				return trim(target.title).length > 0;
			};
			const find = (elm) => {
				const elms = getTargetElements(elm);
				return filter$2(getHeaderTargets(elms).concat(getAnchorTargets(elms)), hasTitle);
			};
			const LinkTargets = { find };
			const STORAGE_KEY = "tinymce-url-history";
			const HISTORY_LENGTH = 5;
			const isHttpUrl = (url) => isString(url) && /^https?/.test(url);
			const isArrayOfUrl = (a) => isArray(a) && a.length <= HISTORY_LENGTH && forall(a, isHttpUrl);
			const isRecordOfUrlArray = (r$2) => isObject(r$2) && find$4(r$2, (value$5) => !isArrayOfUrl(value$5)).isNone();
			const getAllHistory = () => {
				const unparsedHistory = global$4.getItem(STORAGE_KEY);
				if (unparsedHistory === null) return {};
				let history;
				try {
					history = JSON.parse(unparsedHistory);
				} catch (e) {
					if (e instanceof SyntaxError) {
						console.log("Local storage " + STORAGE_KEY + " was not valid JSON", e);
						return {};
					}
					throw e;
				}
				if (!isRecordOfUrlArray(history)) {
					console.log("Local storage " + STORAGE_KEY + " was not valid format", history);
					return {};
				}
				return history;
			};
			const setAllHistory = (history) => {
				if (!isRecordOfUrlArray(history)) throw new Error("Bad format for history:\n" + JSON.stringify(history));
				global$4.setItem(STORAGE_KEY, JSON.stringify(history));
			};
			const getHistory = (fileType) => {
				return get$g(getAllHistory(), fileType).getOr([]);
			};
			const addToHistory = (url, fileType) => {
				if (!isHttpUrl(url)) return;
				const history = getAllHistory();
				const itemsWithoutUrl = filter$2(get$g(history, fileType).getOr([]), (item$1) => item$1 !== url);
				history[fileType] = [url].concat(itemsWithoutUrl).slice(0, HISTORY_LENGTH);
				setAllHistory(history);
			};
			const isTruthy = (value$5) => !!value$5;
			const makeMap = (value$5) => map$1(global$1.makeMap(value$5, /[, ]/), isTruthy);
			const getPicker = (editor) => Optional.from(getFilePickerCallback(editor));
			const getPickerTypes = (editor) => {
				const optFileTypes = Optional.from(getFilePickerTypes(editor)).filter(isTruthy).map(makeMap);
				return getPicker(editor).fold(never, (_picker) => optFileTypes.fold(always, (types$1) => keys(types$1).length > 0 ? types$1 : false));
			};
			const getPickerSetting = (editor, filetype) => {
				const pickerTypes = getPickerTypes(editor);
				if (isBoolean(pickerTypes)) return pickerTypes ? getPicker(editor) : Optional.none();
				else return pickerTypes[filetype] ? getPicker(editor) : Optional.none();
			};
			const getUrlPicker = (editor, filetype) => getPickerSetting(editor, filetype).map((picker) => (entry) => Future.nu((completer) => {
				const handler = (value$5, meta$1) => {
					if (!isString(value$5)) throw new Error("Expected value to be string");
					if (meta$1 !== void 0 && !isObject(meta$1)) throw new Error("Expected meta to be a object");
					completer({
						value: value$5,
						meta: meta$1
					});
				};
				const meta = {
					filetype,
					fieldname: entry.fieldname,
					...Optional.from(entry.meta).getOr({})
				};
				picker.call(editor, handler, entry.value, meta);
			}));
			const getTextSetting = (value$5) => Optional.from(value$5).filter(isString).getOrUndefined();
			const getLinkInformation = (editor) => {
				if (!useTypeaheadUrls(editor)) return Optional.none();
				return Optional.some({
					targets: LinkTargets.find(editor.getBody()),
					anchorTop: getTextSetting(getAnchorTop(editor)),
					anchorBottom: getTextSetting(getAnchorBottom(editor))
				});
			};
			const getValidationHandler = (editor) => Optional.from(getFilePickerValidatorHandler(editor));
			const UrlInputBackstage = (editor) => ({
				getHistory,
				addToHistory,
				getLinkInformation: () => getLinkInformation(editor),
				getValidationHandler: () => getValidationHandler(editor),
				getUrlPicker: (filetype) => getUrlPicker(editor, filetype)
			});
			const init$6 = (lazySinks, editor, lazyAnchorbar, lazyBottomAnchorBar) => {
				const contextMenuState = Cell(false);
				const toolbar = HeaderBackstage(editor);
				const providers = {
					icons: () => editor.ui.registry.getAll().icons,
					menuItems: () => editor.ui.registry.getAll().menuItems,
					translate: global$8.translate,
					isDisabled: () => editor.mode.isReadOnly() || !editor.ui.isEnabled(),
					getOption: editor.options.get
				};
				const urlinput = UrlInputBackstage(editor);
				const styles = init$7(editor);
				const colorinput = ColorInputBackstage(editor);
				const dialogSettings = DialogBackstage(editor);
				const isContextMenuOpen = () => contextMenuState.get();
				const setContextMenuState = (state) => contextMenuState.set(state);
				const commonBackstage = {
					shared: {
						providers,
						anchors: getAnchors(editor, lazyAnchorbar, lazyBottomAnchorBar, toolbar.isPositionedAtTop),
						header: toolbar
					},
					urlinput,
					styles,
					colorinput,
					dialog: dialogSettings,
					isContextMenuOpen,
					setContextMenuState
				};
				const popupBackstage = {
					...commonBackstage,
					shared: {
						...commonBackstage.shared,
						interpreter: (s) => interpretWithoutForm(s, {}, popupBackstage),
						getSink: lazySinks.popup
					}
				};
				const dialogBackstage = {
					...commonBackstage,
					shared: {
						...commonBackstage.shared,
						interpreter: (s) => interpretWithoutForm(s, {}, dialogBackstage),
						getSink: lazySinks.dialog
					}
				};
				return {
					popup: popupBackstage,
					dialog: dialogBackstage
				};
			};
			const setup$b = (editor, mothership, uiMotherships) => {
				const broadcastEvent = (name$4, evt) => {
					each$1([mothership, ...uiMotherships], (m) => {
						m.broadcastEvent(name$4, evt);
					});
				};
				const broadcastOn = (channel, message) => {
					each$1([mothership, ...uiMotherships], (m) => {
						m.broadcastOn([channel], message);
					});
				};
				const fireDismissPopups = (evt) => broadcastOn(dismissPopups(), { target: evt.target });
				const doc = getDocument();
				const onTouchstart = bind(doc, "touchstart", fireDismissPopups);
				const onTouchmove = bind(doc, "touchmove", (evt) => broadcastEvent(documentTouchmove(), evt));
				const onTouchend = bind(doc, "touchend", (evt) => broadcastEvent(documentTouchend(), evt));
				const onMousedown = bind(doc, "mousedown", fireDismissPopups);
				const onMouseup = bind(doc, "mouseup", (evt) => {
					if (evt.raw.button === 0) broadcastOn(mouseReleased(), { target: evt.target });
				});
				const onContentClick = (raw) => broadcastOn(dismissPopups(), { target: SugarElement.fromDom(raw.target) });
				const onContentMouseup = (raw) => {
					if (raw.button === 0) broadcastOn(mouseReleased(), { target: SugarElement.fromDom(raw.target) });
				};
				const onContentMousedown = () => {
					each$1(editor.editorManager.get(), (loopEditor) => {
						if (editor !== loopEditor) loopEditor.dispatch("DismissPopups", { relatedTarget: editor });
					});
				};
				const onWindowScroll = (evt) => broadcastEvent(windowScroll(), fromRawEvent(evt));
				const onWindowResize = (evt) => {
					broadcastOn(repositionPopups(), {});
					broadcastEvent(windowResize(), fromRawEvent(evt));
				};
				const onElementScroll = capture(getRootNode(SugarElement.fromDom(editor.getElement())), "scroll", (evt) => {
					requestAnimationFrame(() => {
						const c = editor.getContainer();
						if (c !== void 0 && c !== null) {
							if (exists(detectWhenSplitUiMode(editor, mothership.element).map((sc) => [sc.element, ...sc.others]).getOr([]), (s) => eq(s, evt.target))) {
								editor.dispatch("ElementScroll", { target: evt.target.dom });
								broadcastEvent(externalElementScroll(), evt);
							}
						}
					});
				});
				const onEditorResize = () => broadcastOn(repositionPopups(), {});
				const onEditorProgress = (evt) => {
					if (evt.state) broadcastOn(dismissPopups(), { target: SugarElement.fromDom(editor.getContainer()) });
				};
				const onDismissPopups = (event) => {
					broadcastOn(dismissPopups(), { target: SugarElement.fromDom(event.relatedTarget.getContainer()) });
				};
				editor.on("PostRender", () => {
					editor.on("click", onContentClick);
					editor.on("tap", onContentClick);
					editor.on("mouseup", onContentMouseup);
					editor.on("mousedown", onContentMousedown);
					editor.on("ScrollWindow", onWindowScroll);
					editor.on("ResizeWindow", onWindowResize);
					editor.on("ResizeEditor", onEditorResize);
					editor.on("AfterProgressState", onEditorProgress);
					editor.on("DismissPopups", onDismissPopups);
				});
				editor.on("remove", () => {
					editor.off("click", onContentClick);
					editor.off("tap", onContentClick);
					editor.off("mouseup", onContentMouseup);
					editor.off("mousedown", onContentMousedown);
					editor.off("ScrollWindow", onWindowScroll);
					editor.off("ResizeWindow", onWindowResize);
					editor.off("ResizeEditor", onEditorResize);
					editor.off("AfterProgressState", onEditorProgress);
					editor.off("DismissPopups", onDismissPopups);
					onMousedown.unbind();
					onTouchstart.unbind();
					onTouchmove.unbind();
					onTouchend.unbind();
					onMouseup.unbind();
					onElementScroll.unbind();
				});
				editor.on("detach", () => {
					each$1([mothership, ...uiMotherships], detachSystem);
					each$1([mothership, ...uiMotherships], (m) => m.destroy());
				});
			};
			const parts$a = AlloyParts;
			const partType = PartType;
			const schema$f = constant$1([
				defaulted("shell", false),
				required$1("makeItem"),
				defaulted("setupItem", noop),
				SketchBehaviours.field("listBehaviours", [Replacing])
			]);
			const customListDetail = () => ({ behaviours: derive$1([Replacing.config({})]) });
			const parts$9 = constant$1([optional({
				name: "items",
				overrides: customListDetail
			})]);
			const name = constant$1("CustomList");
			const factory$f = (detail, components$2, _spec, _external) => {
				const setItems = (list, items) => {
					getListContainer(list).fold(() => {
						console.error("Custom List was defined to not be a shell, but no item container was specified in components");
						throw new Error("Custom List was defined to not be a shell, but no item container was specified in components");
					}, (container) => {
						const itemComps = Replacing.contents(container);
						const numListsRequired = items.length;
						const numListsToAdd = numListsRequired - itemComps.length;
						const itemsToAdd = numListsToAdd > 0 ? range$2(numListsToAdd, () => detail.makeItem()) : [];
						each$1(itemComps.slice(numListsRequired), (item$1) => Replacing.remove(container, item$1));
						each$1(itemsToAdd, (item$1) => Replacing.append(container, item$1));
						each$1(Replacing.contents(container), (item$1, i) => {
							detail.setupItem(list, item$1, items[i], i);
						});
					});
				};
				const extra = detail.shell ? {
					behaviours: [Replacing.config({})],
					components: []
				} : {
					behaviours: [],
					components: components$2
				};
				const getListContainer = (component) => detail.shell ? Optional.some(component) : getPart(component, detail, "items");
				return {
					uid: detail.uid,
					dom: detail.dom,
					components: extra.components,
					behaviours: augment(detail.listBehaviours, extra.behaviours),
					apis: { setItems }
				};
			};
			const CustomList = composite({
				name: name(),
				configFields: schema$f(),
				partFields: parts$9(),
				factory: factory$f,
				apis: { setItems: (apis, list, items) => {
					apis.setItems(list, items);
				} }
			});
			const schema$e = constant$1([
				required$1("dom"),
				defaulted("shell", true),
				field("toolbarBehaviours", [Replacing])
			]);
			const enhanceGroups = () => ({ behaviours: derive$1([Replacing.config({})]) });
			const parts$8 = constant$1([optional({
				name: "groups",
				overrides: enhanceGroups
			})]);
			const factory$e = (detail, components$2, _spec, _externals) => {
				const setGroups$2 = (toolbar, groups) => {
					getGroupContainer(toolbar).fold(() => {
						console.error("Toolbar was defined to not be a shell, but no groups container was specified in components");
						throw new Error("Toolbar was defined to not be a shell, but no groups container was specified in components");
					}, (container) => {
						Replacing.set(container, groups);
					});
				};
				const getGroupContainer = (component) => detail.shell ? Optional.some(component) : getPart(component, detail, "groups");
				const extra = detail.shell ? {
					behaviours: [Replacing.config({})],
					components: []
				} : {
					behaviours: [],
					components: components$2
				};
				return {
					uid: detail.uid,
					dom: detail.dom,
					components: extra.components,
					behaviours: augment(detail.toolbarBehaviours, extra.behaviours),
					apis: {
						setGroups: setGroups$2,
						refresh: noop
					},
					domModification: { attributes: { role: "group" } }
				};
			};
			const Toolbar = composite({
				name: "Toolbar",
				configFields: schema$e(),
				partFields: parts$8(),
				factory: factory$e,
				apis: { setGroups: (apis, toolbar, groups) => {
					apis.setGroups(toolbar, groups);
				} }
			});
			const setup$a = noop;
			const isDocked$2 = never;
			const getBehaviours$1 = constant$1([]);
			var StaticHeader = /* @__PURE__ */ Object.freeze({
				__proto__: null,
				setup: setup$a,
				isDocked: isDocked$2,
				getBehaviours: getBehaviours$1
			});
			const getOffsetParent = (element$1) => {
				return (is$1(getRaw(element$1, "position"), "fixed") ? Optional.none() : offsetParent(element$1)).orThunk(() => {
					const marker = SugarElement.fromTag("span");
					return parent(element$1).bind((parent$1) => {
						append$2(parent$1, marker);
						const offsetParent$1 = offsetParent(marker);
						remove$5(marker);
						return offsetParent$1;
					});
				});
			};
			const getOrigin = (element$1) => getOffsetParent(element$1).map(absolute$3).getOrThunk(() => SugarPosition(0, 0));
			const appear = (component, contextualInfo) => {
				const elem = component.element;
				add$2(elem, contextualInfo.transitionClass);
				remove$2(elem, contextualInfo.fadeOutClass);
				add$2(elem, contextualInfo.fadeInClass);
				contextualInfo.onShow(component);
			};
			const disappear = (component, contextualInfo) => {
				const elem = component.element;
				add$2(elem, contextualInfo.transitionClass);
				remove$2(elem, contextualInfo.fadeInClass);
				add$2(elem, contextualInfo.fadeOutClass);
				contextualInfo.onHide(component);
			};
			const isPartiallyVisible = (box$2, bounds$2) => box$2.y < bounds$2.bottom && box$2.bottom > bounds$2.y;
			const isTopCompletelyVisible = (box$2, bounds$2) => box$2.y >= bounds$2.y;
			const isBottomCompletelyVisible = (box$2, bounds$2) => box$2.bottom <= bounds$2.bottom;
			const forceTopPosition = (winBox, leftX, viewport$2) => ({
				location: "top",
				leftX,
				topY: viewport$2.bounds.y - winBox.y
			});
			const forceBottomPosition = (winBox, leftX, viewport$2) => ({
				location: "bottom",
				leftX,
				bottomY: winBox.bottom - viewport$2.bounds.bottom
			});
			const getDockedLeftPosition = (bounds$2) => {
				return bounds$2.box.x - bounds$2.win.x;
			};
			const tryDockingPosition = (modes, bounds$2, viewport$2) => {
				const winBox = bounds$2.win;
				const box$2 = bounds$2.box;
				const leftX = getDockedLeftPosition(bounds$2);
				return findMap(modes, (mode) => {
					switch (mode) {
						case "bottom": return !isBottomCompletelyVisible(box$2, viewport$2.bounds) ? Optional.some(forceBottomPosition(winBox, leftX, viewport$2)) : Optional.none();
						case "top": return !isTopCompletelyVisible(box$2, viewport$2.bounds) ? Optional.some(forceTopPosition(winBox, leftX, viewport$2)) : Optional.none();
						default: return Optional.none();
					}
				}).getOr({ location: "no-dock" });
			};
			const isVisibleForModes = (modes, box$2, viewport$2) => forall(modes, (mode) => {
				switch (mode) {
					case "bottom": return isBottomCompletelyVisible(box$2, viewport$2.bounds);
					case "top": return isTopCompletelyVisible(box$2, viewport$2.bounds);
				}
			});
			const getXYForRestoring = (pos, viewport$2) => {
				const priorY = viewport$2.optScrollEnv.fold(constant$1(pos.bounds.y), (scrollEnv) => scrollEnv.scrollElmTop + (pos.bounds.y - scrollEnv.currentScrollTop));
				return SugarPosition(pos.bounds.x, priorY);
			};
			const getXYForSaving = (box$2, viewport$2) => {
				const priorY = viewport$2.optScrollEnv.fold(constant$1(box$2.y), (scrollEnv) => box$2.y + scrollEnv.currentScrollTop - scrollEnv.scrollElmTop);
				return SugarPosition(box$2.x, priorY);
			};
			const getPrior = (elem, viewport$2, state) => state.getInitialPos().map((pos) => {
				const xy = getXYForRestoring(pos, viewport$2);
				return {
					box: bounds(xy.left, xy.top, get$c(elem), get$d(elem)),
					location: pos.location
				};
			});
			const storePrior = (elem, box$2, viewport$2, state, decision) => {
				const xy = getXYForSaving(box$2, viewport$2);
				const bounds$1$1 = bounds(xy.left, xy.top, box$2.width, box$2.height);
				state.setInitialPos({
					style: getAllRaw(elem),
					position: get$e(elem, "position") || "static",
					bounds: bounds$1$1,
					location: decision.location
				});
			};
			const storePriorIfNone = (elem, box$2, viewport$2, state, decision) => {
				state.getInitialPos().fold(() => storePrior(elem, box$2, viewport$2, state, decision), () => noop);
			};
			const revertToOriginal = (elem, box$2, state) => state.getInitialPos().bind((position$3) => {
				var _a;
				state.clearInitialPos();
				switch (position$3.position) {
					case "static": return Optional.some({ morph: "static" });
					case "absolute":
						const offsetParent$1 = getOffsetParent(elem).getOr(body());
						const offsetBox = box$1(offsetParent$1);
						const scrollDelta = (_a = offsetParent$1.dom.scrollTop) !== null && _a !== void 0 ? _a : 0;
						return Optional.some({
							morph: "absolute",
							positionCss: NuPositionCss("absolute", get$g(position$3.style, "left").map((_left) => box$2.x - offsetBox.x), get$g(position$3.style, "top").map((_top) => box$2.y - offsetBox.y + scrollDelta), get$g(position$3.style, "right").map((_right) => offsetBox.right - box$2.right), get$g(position$3.style, "bottom").map((_bottom) => offsetBox.bottom - box$2.bottom))
						});
					default: return Optional.none();
				}
			});
			const tryMorphToOriginal = (elem, viewport$2, state) => getPrior(elem, viewport$2, state).filter(({ box: box$2 }) => isVisibleForModes(state.getModes(), box$2, viewport$2)).bind(({ box: box$2 }) => revertToOriginal(elem, box$2, state));
			const tryDecisionToFixedMorph = (decision) => {
				switch (decision.location) {
					case "top": return Optional.some({
						morph: "fixed",
						positionCss: NuPositionCss("fixed", Optional.some(decision.leftX), Optional.some(decision.topY), Optional.none(), Optional.none())
					});
					case "bottom": return Optional.some({
						morph: "fixed",
						positionCss: NuPositionCss("fixed", Optional.some(decision.leftX), Optional.none(), Optional.none(), Optional.some(decision.bottomY))
					});
					default: return Optional.none();
				}
			};
			const tryMorphToFixed = (elem, viewport$2, state) => {
				const box$2 = box$1(elem);
				const winBox = win();
				const decision = tryDockingPosition(state.getModes(), {
					win: winBox,
					box: box$2
				}, viewport$2);
				if (decision.location === "top" || decision.location === "bottom") {
					storePrior(elem, box$2, viewport$2, state, decision);
					return tryDecisionToFixedMorph(decision);
				} else return Optional.none();
			};
			const tryMorphToOriginalOrUpdateFixed = (elem, viewport$2, state) => {
				return tryMorphToOriginal(elem, viewport$2, state).orThunk(() => {
					return viewport$2.optScrollEnv.bind((_) => getPrior(elem, viewport$2, state)).bind(({ box: box$2, location }) => {
						const winBox = win();
						const leftX = getDockedLeftPosition({
							win: winBox,
							box: box$2
						});
						return tryDecisionToFixedMorph(location === "top" ? forceTopPosition(winBox, leftX, viewport$2) : forceBottomPosition(winBox, leftX, viewport$2));
					});
				});
			};
			const tryMorph = (component, viewport$2, state) => {
				const elem = component.element;
				return is$1(getRaw(elem, "position"), "fixed") ? tryMorphToOriginalOrUpdateFixed(elem, viewport$2, state) : tryMorphToFixed(elem, viewport$2, state);
			};
			const calculateMorphToOriginal = (component, viewport$2, state) => {
				const elem = component.element;
				return getPrior(elem, viewport$2, state).bind(({ box: box$2 }) => revertToOriginal(elem, box$2, state));
			};
			const forceDockWith = (elem, viewport$2, state, getDecision) => {
				const box$2 = box$1(elem);
				const winBox = win();
				const decision = getDecision(winBox, getDockedLeftPosition({
					win: winBox,
					box: box$2
				}), viewport$2);
				if (decision.location === "bottom" || decision.location === "top") {
					storePriorIfNone(elem, box$2, viewport$2, state, decision);
					return tryDecisionToFixedMorph(decision);
				} else return Optional.none();
			};
			const morphToStatic = (component, config$1, state) => {
				state.setDocked(false);
				each$1([
					"left",
					"right",
					"top",
					"bottom",
					"position"
				], (prop) => remove$6(component.element, prop));
				config$1.onUndocked(component);
			};
			const morphToCoord = (component, config$1, state, position$3) => {
				const isDocked$3 = position$3.position === "fixed";
				state.setDocked(isDocked$3);
				applyPositionCss(component.element, position$3);
				(isDocked$3 ? config$1.onDocked : config$1.onUndocked)(component);
			};
			const updateVisibility = (component, config$1, state, viewport$2, morphToDocked = false) => {
				config$1.contextual.each((contextInfo) => {
					contextInfo.lazyContext(component).each((box$2) => {
						const isVisible$1 = isPartiallyVisible(box$2, viewport$2.bounds);
						if (isVisible$1 !== state.isVisible()) {
							state.setVisible(isVisible$1);
							if (morphToDocked && !isVisible$1) {
								add$1(component.element, [contextInfo.fadeOutClass]);
								contextInfo.onHide(component);
							} else (isVisible$1 ? appear : disappear)(component, contextInfo);
						}
					});
				});
			};
			const applyFixedMorph = (component, config$1, state, viewport$2, morph) => {
				updateVisibility(component, config$1, state, viewport$2, true);
				morphToCoord(component, config$1, state, morph.positionCss);
			};
			const applyMorph = (component, config$1, state, viewport$2, morph) => {
				switch (morph.morph) {
					case "static": return morphToStatic(component, config$1, state);
					case "absolute": return morphToCoord(component, config$1, state, morph.positionCss);
					case "fixed": return applyFixedMorph(component, config$1, state, viewport$2, morph);
				}
			};
			const refreshInternal = (component, config$1, state) => {
				const viewport$2 = config$1.lazyViewport(component);
				updateVisibility(component, config$1, state, viewport$2);
				tryMorph(component, viewport$2, state).each((morph) => {
					applyMorph(component, config$1, state, viewport$2, morph);
				});
			};
			const resetInternal = (component, config$1, state) => {
				const elem = component.element;
				state.setDocked(false);
				calculateMorphToOriginal(component, config$1.lazyViewport(component), state).each((staticOrAbsoluteMorph) => {
					switch (staticOrAbsoluteMorph.morph) {
						case "static":
							morphToStatic(component, config$1, state);
							break;
						case "absolute":
							morphToCoord(component, config$1, state, staticOrAbsoluteMorph.positionCss);
							break;
					}
				});
				state.setVisible(true);
				config$1.contextual.each((contextInfo) => {
					remove$1(elem, [
						contextInfo.fadeInClass,
						contextInfo.fadeOutClass,
						contextInfo.transitionClass
					]);
					contextInfo.onShow(component);
				});
				refresh$3(component, config$1, state);
			};
			const refresh$3 = (component, config$1, state) => {
				if (component.getSystem().isConnected()) refreshInternal(component, config$1, state);
			};
			const reset = (component, config$1, state) => {
				if (state.isDocked()) resetInternal(component, config$1, state);
			};
			const forceDockWithDecision = (getDecision) => (component, config$1, state) => {
				const viewport$2 = config$1.lazyViewport(component);
				forceDockWith(component.element, viewport$2, state, getDecision).each((morph) => {
					applyFixedMorph(component, config$1, state, viewport$2, morph);
				});
			};
			const forceDockToTop = forceDockWithDecision(forceTopPosition);
			const forceDockToBottom = forceDockWithDecision(forceBottomPosition);
			const isDocked$1 = (component, config$1, state) => state.isDocked();
			const setModes = (component, config$1, state, modes) => state.setModes(modes);
			const getModes = (component, config$1, state) => state.getModes();
			var DockingApis = /* @__PURE__ */ Object.freeze({
				__proto__: null,
				refresh: refresh$3,
				reset,
				isDocked: isDocked$1,
				getModes,
				setModes,
				forceDockToTop,
				forceDockToBottom
			});
			const events$4 = (dockInfo, dockState) => derive$2([
				runOnSource(transitionend(), (component, simulatedEvent) => {
					dockInfo.contextual.each((contextInfo) => {
						if (has(component.element, contextInfo.transitionClass)) {
							remove$1(component.element, [contextInfo.transitionClass, contextInfo.fadeInClass]);
							(dockState.isVisible() ? contextInfo.onShown : contextInfo.onHidden)(component);
						}
						simulatedEvent.stop();
					});
				}),
				run$1(windowScroll(), (component, _) => {
					refresh$3(component, dockInfo, dockState);
				}),
				run$1(externalElementScroll(), (component, _) => {
					refresh$3(component, dockInfo, dockState);
				}),
				run$1(windowResize(), (component, _) => {
					reset(component, dockInfo, dockState);
				})
			]);
			var ActiveDocking = /* @__PURE__ */ Object.freeze({
				__proto__: null,
				events: events$4
			});
			var DockingSchema = [
				optionObjOf("contextual", [
					requiredString("fadeInClass"),
					requiredString("fadeOutClass"),
					requiredString("transitionClass"),
					requiredFunction("lazyContext"),
					onHandler("onShow"),
					onHandler("onShown"),
					onHandler("onHide"),
					onHandler("onHidden")
				]),
				defaultedFunction("lazyViewport", () => ({
					bounds: win(),
					optScrollEnv: Optional.none()
				})),
				defaultedArrayOf("modes", ["top", "bottom"], string),
				onHandler("onDocked"),
				onHandler("onUndocked")
			];
			const init$5 = (spec) => {
				const docked = Cell(false);
				const visible = Cell(true);
				const initialBounds = value$2();
				const modes = Cell(spec.modes);
				const readState = () => `docked:  ${docked.get()}, visible: ${visible.get()}, modes: ${modes.get().join(",")}`;
				return nu$8({
					isDocked: docked.get,
					setDocked: docked.set,
					getInitialPos: initialBounds.get,
					setInitialPos: initialBounds.set,
					clearInitialPos: initialBounds.clear,
					isVisible: visible.get,
					setVisible: visible.set,
					getModes: modes.get,
					setModes: modes.set,
					readState
				});
			};
			const Docking = create$4({
				fields: DockingSchema,
				name: "docking",
				active: ActiveDocking,
				apis: DockingApis,
				state: /* @__PURE__ */ Object.freeze({
					__proto__: null,
					init: init$5
				})
			});
			const toolbarHeightChange = constant$1(generate$6("toolbar-height-change"));
			const visibility = {
				fadeInClass: "tox-editor-dock-fadein",
				fadeOutClass: "tox-editor-dock-fadeout",
				transitionClass: "tox-editor-dock-transition"
			};
			const editorStickyOnClass = "tox-tinymce--toolbar-sticky-on";
			const editorStickyOffClass = "tox-tinymce--toolbar-sticky-off";
			const scrollFromBehindHeader = (e, containerHeader) => {
				const doc = owner$4(containerHeader);
				const viewHeight = defaultView(containerHeader).dom.innerHeight;
				const scrollPos = get$b(doc);
				const markerElement = SugarElement.fromDom(e.elm);
				const markerPos = absolute$2(markerElement);
				const markerHeight = get$d(markerElement);
				const markerTop = markerPos.y;
				const markerBottom = markerTop + markerHeight;
				const editorHeaderPos = absolute$3(containerHeader);
				const editorHeaderHeight = get$d(containerHeader);
				const editorHeaderTop = editorHeaderPos.top;
				const editorHeaderBottom = editorHeaderTop + editorHeaderHeight;
				const editorHeaderDockedAtTop = Math.abs(editorHeaderTop - scrollPos.top) < 2;
				const editorHeaderDockedAtBottom = Math.abs(editorHeaderBottom - (scrollPos.top + viewHeight)) < 2;
				if (editorHeaderDockedAtTop && markerTop < editorHeaderBottom) to(scrollPos.left, markerTop - editorHeaderHeight, doc);
				else if (editorHeaderDockedAtBottom && markerBottom > editorHeaderTop) {
					const y = markerTop - viewHeight + markerHeight + editorHeaderHeight;
					to(scrollPos.left, y, doc);
				}
			};
			const isDockedMode = (header, mode) => contains$2(Docking.getModes(header), mode);
			const updateIframeContentFlow = (header) => {
				const getOccupiedHeight = (elm$1) => getOuter$2(elm$1) + (parseInt(get$e(elm$1, "margin-top"), 10) || 0) + (parseInt(get$e(elm$1, "margin-bottom"), 10) || 0);
				const elm = header.element;
				parentElement(elm).each((parentElem) => {
					const padding = "padding-" + Docking.getModes(header)[0];
					if (Docking.isDocked(header)) {
						set$8(elm, "width", get$c(parentElem) + "px");
						set$8(parentElem, padding, getOccupiedHeight(elm) + "px");
					} else {
						remove$6(elm, "width");
						remove$6(parentElem, padding);
					}
				});
			};
			const updateSinkVisibility = (sinkElem, visible) => {
				if (visible) {
					remove$2(sinkElem, visibility.fadeOutClass);
					add$1(sinkElem, [visibility.transitionClass, visibility.fadeInClass]);
				} else {
					remove$2(sinkElem, visibility.fadeInClass);
					add$1(sinkElem, [visibility.fadeOutClass, visibility.transitionClass]);
				}
			};
			const updateEditorClasses = (editor, docked) => {
				const editorContainer = SugarElement.fromDom(editor.getContainer());
				if (docked) {
					add$2(editorContainer, editorStickyOnClass);
					remove$2(editorContainer, editorStickyOffClass);
				} else {
					add$2(editorContainer, editorStickyOffClass);
					remove$2(editorContainer, editorStickyOnClass);
				}
			};
			const restoreFocus = (headerElem, focusedElem) => {
				const ownerDoc = owner$4(focusedElem);
				active$1(ownerDoc).filter((activeElm) => !eq(focusedElem, activeElm)).filter((activeElm) => eq(activeElm, SugarElement.fromDom(ownerDoc.dom.body)) || contains(headerElem, activeElm)).each(() => focus$3(focusedElem));
			};
			const findFocusedElem = (rootElm, lazySink) => search(rootElm).orThunk(() => lazySink().toOptional().bind((sink) => search(sink.element)));
			const setup$9 = (editor, sharedBackstage, lazyHeader) => {
				if (!editor.inline) {
					if (!sharedBackstage.header.isPositionedAtTop()) editor.on("ResizeEditor", () => {
						lazyHeader().each(Docking.reset);
					});
					editor.on("ResizeWindow ResizeEditor", () => {
						lazyHeader().each(updateIframeContentFlow);
					});
					editor.on("SkinLoaded", () => {
						lazyHeader().each((comp) => {
							Docking.isDocked(comp) ? Docking.reset(comp) : Docking.refresh(comp);
						});
					});
					editor.on("FullscreenStateChanged", () => {
						lazyHeader().each(Docking.reset);
					});
				}
				editor.on("AfterScrollIntoView", (e) => {
					lazyHeader().each((header) => {
						Docking.refresh(header);
						const headerElem = header.element;
						if (isVisible(headerElem)) scrollFromBehindHeader(e, headerElem);
					});
				});
				editor.on("PostRender", () => {
					updateEditorClasses(editor, false);
				});
			};
			const isDocked = (lazyHeader) => lazyHeader().map(Docking.isDocked).getOr(false);
			const getIframeBehaviours = () => [Receiving.config({ channels: { [toolbarHeightChange()]: { onReceive: updateIframeContentFlow } } })];
			const getBehaviours = (editor, sharedBackstage) => {
				const focusedElm = value$2();
				const lazySink = sharedBackstage.getSink;
				const runOnSinkElement = (f$1) => {
					lazySink().each((sink) => f$1(sink.element));
				};
				const onDockingSwitch = (comp) => {
					if (!editor.inline) updateIframeContentFlow(comp);
					updateEditorClasses(editor, Docking.isDocked(comp));
					comp.getSystem().broadcastOn([repositionPopups()], {});
					lazySink().each((sink) => sink.getSystem().broadcastOn([repositionPopups()], {}));
				};
				const additionalBehaviours = editor.inline ? [] : getIframeBehaviours();
				return [
					Focusing.config({}),
					Docking.config({
						contextual: {
							lazyContext: (comp) => {
								const headerHeight = getOuter$2(comp.element);
								const container = editor.inline ? editor.getContentAreaContainer() : editor.getContainer();
								return Optional.from(container).map((c) => {
									const box$2 = box$1(SugarElement.fromDom(c));
									return detectWhenSplitUiMode(editor, comp.element).fold(() => {
										const boxHeight = box$2.height - headerHeight;
										const topBound = box$2.y + (isDockedMode(comp, "top") ? 0 : headerHeight);
										return bounds(box$2.x, topBound, box$2.width, boxHeight);
									}, (scrollEnv) => {
										const constrainedBounds = constrain(box$2, getBoundsFrom(scrollEnv));
										const constrainedBoundsY = isDockedMode(comp, "top") ? constrainedBounds.y : constrainedBounds.y + headerHeight;
										return bounds(constrainedBounds.x, constrainedBoundsY, constrainedBounds.width, constrainedBounds.height - headerHeight);
									});
								});
							},
							onShow: () => {
								runOnSinkElement((elem) => updateSinkVisibility(elem, true));
							},
							onShown: (comp) => {
								runOnSinkElement((elem) => remove$1(elem, [visibility.transitionClass, visibility.fadeInClass]));
								focusedElm.get().each((elem) => {
									restoreFocus(comp.element, elem);
									focusedElm.clear();
								});
							},
							onHide: (comp) => {
								findFocusedElem(comp.element, lazySink).fold(focusedElm.clear, focusedElm.set);
								runOnSinkElement((elem) => updateSinkVisibility(elem, false));
							},
							onHidden: () => {
								runOnSinkElement((elem) => remove$1(elem, [visibility.transitionClass]));
							},
							...visibility
						},
						lazyViewport: (comp) => {
							return detectWhenSplitUiMode(editor, comp.element).fold(() => {
								const boundsWithoutOffset = win();
								const offset$1 = getStickyToolbarOffset(editor);
								const top$1 = boundsWithoutOffset.y + (isDockedMode(comp, "top") ? offset$1 : 0);
								const height$1 = boundsWithoutOffset.height - (isDockedMode(comp, "bottom") ? offset$1 : 0);
								return {
									bounds: bounds(boundsWithoutOffset.x, top$1, boundsWithoutOffset.width, height$1),
									optScrollEnv: Optional.none()
								};
							}, (sc) => {
								return {
									bounds: getBoundsFrom(sc),
									optScrollEnv: Optional.some({
										currentScrollTop: sc.element.dom.scrollTop,
										scrollElmTop: absolute$3(sc.element).top
									})
								};
							});
						},
						modes: [sharedBackstage.header.getDockingMode()],
						onDocked: onDockingSwitch,
						onUndocked: onDockingSwitch
					}),
					...additionalBehaviours
				];
			};
			var StickyHeader = /* @__PURE__ */ Object.freeze({
				__proto__: null,
				setup: setup$9,
				isDocked,
				getBehaviours
			});
			const renderHeader = (spec) => {
				const editor = spec.editor;
				const getBehaviours$2$1 = spec.sticky ? getBehaviours : getBehaviours$1;
				return {
					uid: spec.uid,
					dom: spec.dom,
					components: spec.components,
					behaviours: derive$1(getBehaviours$2$1(editor, spec.sharedBackstage))
				};
			};
			const groupToolbarButtonSchema = objOf([type, requiredOf("items", oneOf([arrOfObj([name$1, requiredArrayOf("items", string)]), string]))].concat(baseToolbarButtonFields));
			const createGroupToolbarButton = (spec) => asRaw("GroupToolbarButton", groupToolbarButtonSchema, spec);
			const MenuButtonSchema = objOf([type, ...[
				optionString("text"),
				optionString("tooltip"),
				optionString("icon"),
				defaultedOf("search", false, oneOf([boolean, objOf([optionString("placeholder")])], (x) => {
					if (isBoolean(x)) return x ? Optional.some({ placeholder: Optional.none() }) : Optional.none();
					else return Optional.some(x);
				})),
				requiredFunction("fetch"),
				defaultedFunction("onSetup", () => noop)
			]]);
			const createMenuButton = (spec) => asRaw("menubutton", MenuButtonSchema, spec);
			const splitButtonSchema = objOf([
				type,
				optionalTooltip,
				optionalIcon,
				optionalText,
				optionalSelect,
				fetch$1,
				onSetup,
				defaultedStringEnum("presets", "normal", [
					"normal",
					"color",
					"listpreview"
				]),
				defaultedColumns(1),
				onAction,
				onItemAction
			]);
			const createSplitButton = (spec) => asRaw("SplitButton", splitButtonSchema, spec);
			const factory$d = (detail, spec) => {
				const setMenus = (comp, menus) => {
					const newMenus = map$2(menus, (m) => {
						return renderMenuButton(createMenuButton({
							type: "menubutton",
							text: m.text,
							fetch: (callback) => {
								callback(m.getItems());
							}
						}).mapError((errInfo) => formatError(errInfo)).getOrDie(), "tox-mbtn", spec.backstage, Optional.some("menuitem"));
					});
					Replacing.set(comp, newMenus);
				};
				const apis = {
					focus: Keying.focusIn,
					setMenus
				};
				return {
					uid: detail.uid,
					dom: detail.dom,
					components: [],
					behaviours: derive$1([
						Replacing.config({}),
						config("menubar-events", [
							runOnAttached((component) => {
								detail.onSetup(component);
							}),
							run$1(mouseover(), (comp, se) => {
								descendant(comp.element, ".tox-mbtn--active").each((activeButton) => {
									closest$1(se.event.target, ".tox-mbtn").each((hoveredButton) => {
										if (!eq(activeButton, hoveredButton)) comp.getSystem().getByDom(activeButton).each((activeComp) => {
											comp.getSystem().getByDom(hoveredButton).each((hoveredComp) => {
												Dropdown.expand(hoveredComp);
												Dropdown.close(activeComp);
												Focusing.focus(hoveredComp);
											});
										});
									});
								});
							}),
							run$1(focusShifted(), (comp, se) => {
								se.event.prevFocus.bind((prev) => comp.getSystem().getByDom(prev).toOptional()).each((prev) => {
									se.event.newFocus.bind((nu$10) => comp.getSystem().getByDom(nu$10).toOptional()).each((nu$10) => {
										if (Dropdown.isOpen(prev)) {
											Dropdown.expand(nu$10);
											Dropdown.close(prev);
										}
									});
								});
							})
						]),
						Keying.config({
							mode: "flow",
							selector: ".tox-mbtn",
							onEscape: (comp) => {
								detail.onEscape(comp);
								return Optional.some(true);
							}
						}),
						Tabstopping.config({})
					]),
					apis,
					domModification: { attributes: { role: "menubar" } }
				};
			};
			var SilverMenubar = single({
				factory: factory$d,
				name: "silver.Menubar",
				configFields: [
					required$1("dom"),
					required$1("uid"),
					required$1("onEscape"),
					required$1("backstage"),
					defaulted("onSetup", noop)
				],
				apis: {
					focus: (apis, comp) => {
						apis.focus(comp);
					},
					setMenus: (apis, comp, menus) => {
						apis.setMenus(comp, menus);
					}
				}
			});
			const promotionMessage = "Upgrade";
			const promotionLink = "https://www.tiny.cloud/tinymce-self-hosted-premium-features/?utm_source=TinyMCE&utm_medium=SPAP&utm_campaign=SPAP&utm_id=editorreferral";
			const renderPromotion = (spec) => {
				return {
					uid: spec.uid,
					dom: spec.dom,
					components: [{ dom: {
						tag: "a",
						attributes: {
							"href": promotionLink,
							"rel": "noopener",
							"target": "_blank",
							"aria-hidden": "true"
						},
						classes: ["tox-promotion-link"],
						innerHtml: promotionMessage
					} }]
				};
			};
			const owner = "container";
			const schema$d = [field("slotBehaviours", [])];
			const getPartName = (name$4) => "<alloy.field." + name$4 + ">";
			const sketch = (sSpec) => {
				const parts$10 = (() => {
					const record$1 = [];
					const slot = (name$4, config$1) => {
						record$1.push(name$4);
						return generateOne$1(owner, getPartName(name$4), config$1);
					};
					return {
						slot,
						record: constant$1(record$1)
					};
				})();
				const spec = sSpec(parts$10);
				return composite$1(owner, schema$d, map$2(parts$10.record(), (n) => required({
					name: n,
					pname: getPartName(n)
				})), make$1, spec);
			};
			const make$1 = (detail, components$2) => {
				const getSlotNames = (_) => getAllPartNames(detail);
				const getSlot = (container, key) => getPart(container, detail, key);
				const onSlot = (f$1, def) => (container, key) => getPart(container, detail, key).map((slot) => f$1(slot, key)).getOr(def);
				const onSlots = (f$1) => (container, keys$1) => {
					each$1(keys$1, (key) => f$1(container, key));
				};
				const doShowing = (comp, _key) => get$f(comp.element, "aria-hidden") !== "true";
				const doShow = (comp, key) => {
					if (!doShowing(comp)) {
						const element$1 = comp.element;
						remove$6(element$1, "display");
						remove$7(element$1, "aria-hidden");
						emitWith(comp, slotVisibility(), {
							name: key,
							visible: true
						});
					}
				};
				const doHide = (comp, key) => {
					if (doShowing(comp)) {
						const element$1 = comp.element;
						set$8(element$1, "display", "none");
						set$9(element$1, "aria-hidden", "true");
						emitWith(comp, slotVisibility(), {
							name: key,
							visible: false
						});
					}
				};
				const isShowing = onSlot(doShowing, false);
				const hideSlot = onSlot(doHide);
				const hideSlots = onSlots(hideSlot);
				const hideAllSlots = (container) => hideSlots(container, getSlotNames());
				const apis = {
					getSlotNames,
					getSlot,
					isShowing,
					hideSlot,
					hideAllSlots,
					showSlot: onSlot(doShow)
				};
				return {
					uid: detail.uid,
					dom: detail.dom,
					components: components$2,
					behaviours: get$3(detail.slotBehaviours),
					apis
				};
			};
			const SlotContainer = {
				...map$1({
					getSlotNames: (apis, c) => apis.getSlotNames(c),
					getSlot: (apis, c, key) => apis.getSlot(c, key),
					isShowing: (apis, c, key) => apis.isShowing(c, key),
					hideSlot: (apis, c, key) => apis.hideSlot(c, key),
					hideAllSlots: (apis, c) => apis.hideAllSlots(c),
					showSlot: (apis, c, key) => apis.showSlot(c, key)
				}, (value$5) => makeApi(value$5)),
				sketch
			};
			const sidebarSchema = objOf([
				optionalIcon,
				optionalTooltip,
				defaultedFunction("onShow", noop),
				defaultedFunction("onHide", noop),
				onSetup
			]);
			const createSidebar = (spec) => asRaw("sidebar", sidebarSchema, spec);
			const setup$8 = (editor) => {
				const { sidebars } = editor.ui.registry.getAll();
				each$1(keys(sidebars), (name$4) => {
					const spec = sidebars[name$4];
					const isActive = () => is$1(Optional.from(editor.queryCommandValue("ToggleSidebar")), name$4);
					editor.ui.registry.addToggleButton(name$4, {
						icon: spec.icon,
						tooltip: spec.tooltip,
						onAction: (buttonApi) => {
							editor.execCommand("ToggleSidebar", false, name$4);
							buttonApi.setActive(isActive());
						},
						onSetup: (buttonApi) => {
							buttonApi.setActive(isActive());
							const handleToggle = () => buttonApi.setActive(isActive());
							editor.on("ToggleSidebar", handleToggle);
							return () => {
								editor.off("ToggleSidebar", handleToggle);
							};
						}
					});
				});
			};
			const getApi = (comp) => ({ element: () => comp.element.dom });
			const makePanels = (parts$10, panelConfigs) => {
				const specs = map$2(keys(panelConfigs), (name$4) => {
					const spec = panelConfigs[name$4];
					const bridged = getOrDie(createSidebar(spec));
					return {
						name: name$4,
						getApi,
						onSetup: bridged.onSetup,
						onShow: bridged.onShow,
						onHide: bridged.onHide
					};
				});
				return map$2(specs, (spec) => {
					const editorOffCell = Cell(noop);
					return parts$10.slot(spec.name, {
						dom: {
							tag: "div",
							classes: ["tox-sidebar__pane"]
						},
						behaviours: SimpleBehaviours.unnamedEvents([
							onControlAttached(spec, editorOffCell),
							onControlDetached(spec, editorOffCell),
							run$1(slotVisibility(), (sidepanel, se) => {
								const data = se.event;
								find$5(specs, (config$1) => config$1.name === data.name).each((sidePanelSpec) => {
									(data.visible ? sidePanelSpec.onShow : sidePanelSpec.onHide)(sidePanelSpec.getApi(sidepanel));
								});
							})
						])
					});
				});
			};
			const makeSidebar = (panelConfigs) => SlotContainer.sketch((parts$10) => ({
				dom: {
					tag: "div",
					classes: ["tox-sidebar__pane-container"]
				},
				components: makePanels(parts$10, panelConfigs),
				slotBehaviours: SimpleBehaviours.unnamedEvents([runOnAttached((slotContainer) => SlotContainer.hideAllSlots(slotContainer))])
			}));
			const setSidebar = (sidebar, panelConfigs, showSidebar) => {
				Composing.getCurrent(sidebar).each((slider) => {
					Replacing.set(slider, [makeSidebar(panelConfigs)]);
					const configKey = showSidebar === null || showSidebar === void 0 ? void 0 : showSidebar.toLowerCase();
					if (isString(configKey) && has$2(panelConfigs, configKey)) Composing.getCurrent(slider).each((slotContainer) => {
						SlotContainer.showSlot(slotContainer, configKey);
						Sliding.immediateGrow(slider);
						remove$6(slider.element, "width");
						updateSidebarRoleOnToggle(sidebar.element, "region");
					});
				});
			};
			const updateSidebarRoleOnToggle = (sidebar, sidebarState) => {
				set$9(sidebar, "role", sidebarState);
			};
			const toggleSidebar = (sidebar, name$4) => {
				Composing.getCurrent(sidebar).each((slider) => {
					Composing.getCurrent(slider).each((slotContainer) => {
						if (Sliding.hasGrown(slider)) if (SlotContainer.isShowing(slotContainer, name$4)) {
							Sliding.shrink(slider);
							updateSidebarRoleOnToggle(sidebar.element, "presentation");
						} else {
							SlotContainer.hideAllSlots(slotContainer);
							SlotContainer.showSlot(slotContainer, name$4);
							updateSidebarRoleOnToggle(sidebar.element, "region");
						}
						else {
							SlotContainer.hideAllSlots(slotContainer);
							SlotContainer.showSlot(slotContainer, name$4);
							Sliding.grow(slider);
							updateSidebarRoleOnToggle(sidebar.element, "region");
						}
					});
				});
			};
			const whichSidebar = (sidebar) => {
				return Composing.getCurrent(sidebar).bind((slider) => {
					if (Sliding.isGrowing(slider) || Sliding.hasGrown(slider)) return Composing.getCurrent(slider).bind((slotContainer) => find$5(SlotContainer.getSlotNames(slotContainer), (name$4) => SlotContainer.isShowing(slotContainer, name$4)));
					else return Optional.none();
				});
			};
			const fixSize = generate$6("FixSizeEvent");
			const autoSize = generate$6("AutoSizeEvent");
			const renderSidebar = (spec) => ({
				uid: spec.uid,
				dom: {
					tag: "div",
					classes: ["tox-sidebar"],
					attributes: { role: "presentation" }
				},
				components: [{
					dom: {
						tag: "div",
						classes: ["tox-sidebar__slider"]
					},
					components: [],
					behaviours: derive$1([
						Tabstopping.config({}),
						Focusing.config({}),
						Sliding.config({
							dimension: { property: "width" },
							closedClass: "tox-sidebar--sliding-closed",
							openClass: "tox-sidebar--sliding-open",
							shrinkingClass: "tox-sidebar--sliding-shrinking",
							growingClass: "tox-sidebar--sliding-growing",
							onShrunk: (slider) => {
								Composing.getCurrent(slider).each(SlotContainer.hideAllSlots);
								emit(slider, autoSize);
							},
							onGrown: (slider) => {
								emit(slider, autoSize);
							},
							onStartGrow: (slider) => {
								emitWith(slider, fixSize, { width: getRaw(slider.element, "width").getOr("") });
							},
							onStartShrink: (slider) => {
								emitWith(slider, fixSize, { width: get$c(slider.element) + "px" });
							}
						}),
						Replacing.config({}),
						Composing.config({ find: (comp) => {
							return head(Replacing.contents(comp));
						} })
					])
				}],
				behaviours: derive$1([ComposingConfigs.childAt(0), config("sidebar-sliding-events", [run$1(fixSize, (comp, se) => {
					set$8(comp.element, "width", se.event.width);
				}), run$1(autoSize, (comp, _se) => {
					remove$6(comp.element, "width");
				})])])
			});
			const block = (component, config$1, state, getBusySpec$2) => {
				set$9(component.element, "aria-busy", true);
				const root = config$1.getRoot(component).getOr(component);
				const blockSpec = getBusySpec$2(root, derive$1([Keying.config({
					mode: "special",
					onTab: () => Optional.some(true),
					onShiftTab: () => Optional.some(true)
				}), Focusing.config({})]));
				const blocker = root.getSystem().build(blockSpec);
				Replacing.append(root, premade(blocker));
				if (blocker.hasConfigured(Keying) && config$1.focus) Keying.focusIn(blocker);
				if (!state.isBlocked()) config$1.onBlock(component);
				state.blockWith(() => Replacing.remove(root, blocker));
			};
			const unblock = (component, config$1, state) => {
				remove$7(component.element, "aria-busy");
				if (state.isBlocked()) config$1.onUnblock(component);
				state.clear();
			};
			const isBlocked = (component, blockingConfig, blockingState) => blockingState.isBlocked();
			var BlockingApis = /* @__PURE__ */ Object.freeze({
				__proto__: null,
				block,
				unblock,
				isBlocked
			});
			var BlockingSchema = [
				defaultedFunction("getRoot", Optional.none),
				defaultedBoolean("focus", true),
				onHandler("onBlock"),
				onHandler("onUnblock")
			];
			const init$4 = () => {
				const blocker = destroyable();
				const blockWith = (destroy) => {
					blocker.set({ destroy });
				};
				return nu$8({
					readState: blocker.isSet,
					blockWith,
					clear: blocker.clear,
					isBlocked: blocker.isSet
				});
			};
			const Blocking = create$4({
				fields: BlockingSchema,
				name: "blocking",
				apis: BlockingApis,
				state: /* @__PURE__ */ Object.freeze({
					__proto__: null,
					init: init$4
				})
			});
			const getAttrs = (elem) => {
				return foldl(elem.dom.attributes !== void 0 ? elem.dom.attributes : [], (b$1, attr) => {
					if (attr.name === "class") return b$1;
					else return {
						...b$1,
						[attr.name]: attr.value
					};
				}, {});
			};
			const getClasses = (elem) => Array.prototype.slice.call(elem.dom.classList, 0);
			const fromHtml = (html$2) => {
				const elem = SugarElement.fromHtml(html$2);
				const children$1 = children(elem);
				const attrs = getAttrs(elem);
				const classes$1 = getClasses(elem);
				const contents$1 = children$1.length === 0 ? {} : { innerHtml: get$9(elem) };
				return {
					tag: name$3(elem),
					classes: classes$1,
					attributes: attrs,
					...contents$1
				};
			};
			const getBusySpec$1 = (providerBackstage) => (_root, _behaviours) => ({
				dom: {
					tag: "div",
					attributes: {
						"aria-label": providerBackstage.translate("Loading..."),
						"tabindex": "0"
					},
					classes: ["tox-throbber__busy-spinner"]
				},
				components: [{ dom: fromHtml("<div class=\"tox-spinner\"><div></div><div></div><div></div></div>") }]
			});
			const focusBusyComponent = (throbber) => Composing.getCurrent(throbber).each((comp) => focus$3(comp.element));
			const toggleEditorTabIndex = (editor, state) => {
				const tabIndexAttr = "tabindex";
				const dataTabIndexAttr = `data-mce-${tabIndexAttr}`;
				Optional.from(editor.iframeElement).map(SugarElement.fromDom).each((iframe$1) => {
					if (state) {
						getOpt(iframe$1, tabIndexAttr).each((tabIndex) => set$9(iframe$1, dataTabIndexAttr, tabIndex));
						set$9(iframe$1, tabIndexAttr, -1);
					} else {
						remove$7(iframe$1, tabIndexAttr);
						getOpt(iframe$1, dataTabIndexAttr).each((tabIndex) => {
							set$9(iframe$1, tabIndexAttr, tabIndex);
							remove$7(iframe$1, dataTabIndexAttr);
						});
					}
				});
			};
			const toggleThrobber = (editor, comp, state, providerBackstage) => {
				const element$1 = comp.element;
				toggleEditorTabIndex(editor, state);
				if (state) {
					Blocking.block(comp, getBusySpec$1(providerBackstage));
					remove$6(element$1, "display");
					remove$7(element$1, "aria-hidden");
					if (editor.hasFocus()) focusBusyComponent(comp);
				} else {
					const throbberFocus = Composing.getCurrent(comp).exists((busyComp) => hasFocus(busyComp.element));
					Blocking.unblock(comp);
					set$8(element$1, "display", "none");
					set$9(element$1, "aria-hidden", "true");
					if (throbberFocus) editor.focus();
				}
			};
			const renderThrobber = (spec) => ({
				uid: spec.uid,
				dom: {
					tag: "div",
					attributes: { "aria-hidden": "true" },
					classes: ["tox-throbber"],
					styles: { display: "none" }
				},
				behaviours: derive$1([
					Replacing.config({}),
					Blocking.config({ focus: false }),
					Composing.config({ find: (comp) => head(comp.components()) })
				]),
				components: []
			});
			const isFocusEvent = (event) => event.type === "focusin";
			const isPasteBinTarget = (event) => {
				if (isFocusEvent(event)) return (event.composed ? head(event.composedPath()) : Optional.from(event.target)).map(SugarElement.fromDom).filter(isElement$1).exists((targetElm) => has(targetElm, "mce-pastebin"));
				else return false;
			};
			const setup$7 = (editor, lazyThrobber, sharedBackstage) => {
				const throbberState = Cell(false);
				const timer = value$2();
				const stealFocus = (e) => {
					if (throbberState.get() && !isPasteBinTarget(e)) {
						e.preventDefault();
						focusBusyComponent(lazyThrobber());
						editor.editorManager.setActive(editor);
					}
				};
				if (!editor.inline) editor.on("PreInit", () => {
					editor.dom.bind(editor.getWin(), "focusin", stealFocus);
					editor.on("BeforeExecCommand", (e) => {
						if (e.command.toLowerCase() === "mcefocus" && e.value !== true) stealFocus(e);
					});
				});
				const toggle$3 = (state) => {
					if (state !== throbberState.get()) {
						throbberState.set(state);
						toggleThrobber(editor, lazyThrobber(), state, sharedBackstage.providers);
						fireAfterProgressState(editor, state);
					}
				};
				editor.on("ProgressState", (e) => {
					timer.on(clearTimeout);
					if (isNumber(e.time)) {
						const timerId = global$9.setEditorTimeout(editor, () => toggle$3(e.state), e.time);
						timer.set(timerId);
					} else {
						toggle$3(e.state);
						timer.clear();
					}
				});
			};
			const generate$1 = (xs, f$1) => {
				return foldl(xs, (b$1, a) => {
					return f$1(a, b$1.len).fold(constant$1(b$1), (v) => ({
						len: v.finish,
						list: b$1.list.concat([v])
					}));
				}, {
					len: 0,
					list: []
				}).list;
			};
			const output = (within, extra, withinWidth) => ({
				within,
				extra,
				withinWidth
			});
			const apportion = (units$1, total, len) => {
				const parray = generate$1(units$1, (unit, current) => {
					const width$1 = len(unit);
					return Optional.some({
						element: unit,
						start: current,
						finish: current + width$1,
						width: width$1
					});
				});
				const within = filter$2(parray, (unit) => unit.finish <= total);
				const withinWidth = foldr(within, (acc, el) => acc + el.width, 0);
				return {
					within,
					extra: parray.slice(within.length),
					withinWidth
				};
			};
			const toUnit = (parray) => map$2(parray, (unit) => unit.element);
			const fitLast = (within, extra, withinWidth) => {
				return output(toUnit(within.concat(extra)), [], withinWidth);
			};
			const overflow = (within, extra, overflower, withinWidth) => {
				return output(toUnit(within).concat([overflower]), toUnit(extra), withinWidth);
			};
			const fitAll = (within, extra, withinWidth) => output(toUnit(within), [], withinWidth);
			const tryFit = (total, units$1, len) => {
				const divide = apportion(units$1, total, len);
				return divide.extra.length === 0 ? Optional.some(divide) : Optional.none();
			};
			const partition = (total, units$1, len, overflower) => {
				const divide = tryFit(total, units$1, len).getOrThunk(() => apportion(units$1, total - len(overflower), len));
				const within = divide.within;
				const extra = divide.extra;
				const withinWidth = divide.withinWidth;
				if (extra.length === 1 && extra[0].width <= len(overflower)) return fitLast(within, extra, withinWidth);
				else if (extra.length >= 1) return overflow(within, extra, overflower, withinWidth);
				else return fitAll(within, extra, withinWidth);
			};
			const setGroups$1 = (toolbar, storedGroups) => {
				const bGroups = map$2(storedGroups, (g) => premade(g));
				Toolbar.setGroups(toolbar, bGroups);
			};
			const findFocusedComp = (comps) => findMap(comps, (comp) => search(comp.element).bind((focusedElm) => comp.getSystem().getByDom(focusedElm).toOptional()));
			const refresh$2 = (toolbar, detail, setOverflow) => {
				const builtGroups = detail.builtGroups.get();
				if (builtGroups.length === 0) return;
				const primary$1 = getPartOrDie(toolbar, detail, "primary");
				const overflowGroup = Coupling.getCoupled(toolbar, "overflowGroup");
				set$8(primary$1.element, "visibility", "hidden");
				const groups = builtGroups.concat([overflowGroup]);
				const focusedComp = findFocusedComp(groups);
				setOverflow([]);
				setGroups$1(primary$1, groups);
				const overflows = partition(get$c(primary$1.element), detail.builtGroups.get(), (comp) => get$c(comp.element), overflowGroup);
				if (overflows.extra.length === 0) {
					Replacing.remove(primary$1, overflowGroup);
					setOverflow([]);
				} else {
					setGroups$1(primary$1, overflows.within);
					setOverflow(overflows.extra);
				}
				remove$6(primary$1.element, "visibility");
				reflow(primary$1.element);
				focusedComp.each(Focusing.focus);
			};
			const schema$c = constant$1([field("splitToolbarBehaviours", [Coupling]), customField("builtGroups", () => Cell([]))]);
			const schema$b = constant$1([
				markers$1(["overflowToggledClass"]),
				optionFunction("getOverflowBounds"),
				required$1("lazySink"),
				customField("overflowGroups", () => Cell([])),
				onHandler("onOpened"),
				onHandler("onClosed")
			].concat(schema$c()));
			const parts$7 = constant$1([
				required({
					factory: Toolbar,
					schema: schema$e(),
					name: "primary"
				}),
				external({
					schema: schema$e(),
					name: "overflow"
				}),
				external({ name: "overflow-button" }),
				external({ name: "overflow-group" })
			]);
			const expandable = constant$1((element$1, available) => {
				setMax(element$1, Math.floor(available));
			});
			const schema$a = constant$1([
				markers$1(["toggledClass"]),
				required$1("lazySink"),
				requiredFunction("fetch"),
				optionFunction("getBounds"),
				optionObjOf("fireDismissalEventInstead", [defaulted("event", dismissRequested())]),
				schema$y(),
				onHandler("onToggled")
			]);
			const parts$6 = constant$1([external({
				name: "button",
				overrides: (detail) => ({
					dom: { attributes: { "aria-haspopup": "true" } },
					buttonBehaviours: derive$1([Toggling.config({
						toggleClass: detail.markers.toggledClass,
						aria: { mode: "expanded" },
						toggleOnExecute: false,
						onToggled: detail.onToggled
					})])
				})
			}), external({
				factory: Toolbar,
				schema: schema$e(),
				name: "toolbar",
				overrides: (detail) => {
					return { toolbarBehaviours: derive$1([Keying.config({
						mode: "cyclic",
						onEscape: (comp) => {
							getPart(comp, detail, "button").each(Focusing.focus);
							return Optional.none();
						}
					})]) };
				}
			})]);
			const shouldSkipFocus = value$2();
			const toggleWithoutFocusing = (button$1, externals) => {
				shouldSkipFocus.set(true);
				toggle(button$1, externals);
				shouldSkipFocus.clear();
			};
			const toggle = (button$1, externals) => {
				const toolbarSandbox = Coupling.getCoupled(button$1, "toolbarSandbox");
				if (Sandboxing.isOpen(toolbarSandbox)) Sandboxing.close(toolbarSandbox);
				else Sandboxing.open(toolbarSandbox, externals.toolbar());
			};
			const position = (button$1, toolbar, detail, layouts$1) => {
				const bounds$2 = detail.getBounds.map((bounder) => bounder());
				const sink = detail.lazySink(button$1).getOrDie();
				Positioning.positionWithinBounds(sink, toolbar, { anchor: {
					type: "hotspot",
					hotspot: button$1,
					layouts: layouts$1,
					overrides: { maxWidthFunction: expandable() }
				} }, bounds$2);
			};
			const setGroups = (button$1, toolbar, detail, layouts$1, groups) => {
				Toolbar.setGroups(toolbar, groups);
				position(button$1, toolbar, detail, layouts$1);
				Toggling.on(button$1);
			};
			const makeSandbox = (button$1, spec, detail) => {
				const ariaControls = manager();
				const onOpen = (sandbox, toolbar) => {
					const skipFocus = shouldSkipFocus.get().getOr(false);
					detail.fetch().get((groups) => {
						setGroups(button$1, toolbar, detail, spec.layouts, groups);
						ariaControls.link(button$1.element);
						if (!skipFocus) Keying.focusIn(toolbar);
					});
				};
				const onClose = () => {
					Toggling.off(button$1);
					if (!shouldSkipFocus.get().getOr(false)) Focusing.focus(button$1);
					ariaControls.unlink(button$1.element);
				};
				return {
					dom: {
						tag: "div",
						attributes: { id: ariaControls.id }
					},
					behaviours: derive$1([
						Keying.config({
							mode: "special",
							onEscape: (comp) => {
								Sandboxing.close(comp);
								return Optional.some(true);
							}
						}),
						Sandboxing.config({
							onOpen,
							onClose,
							isPartOf: (container, data, queryElem) => {
								return isPartOf$1(data, queryElem) || isPartOf$1(button$1, queryElem);
							},
							getAttachPoint: () => {
								return detail.lazySink(button$1).getOrDie();
							}
						}),
						Receiving.config({ channels: {
							...receivingChannel$1({
								isExtraPart: never,
								...detail.fireDismissalEventInstead.map((fe) => ({ fireEventInstead: { event: fe.event } })).getOr({})
							}),
							...receivingChannel({ doReposition: () => {
								Sandboxing.getState(Coupling.getCoupled(button$1, "toolbarSandbox")).each((toolbar) => {
									position(button$1, toolbar, detail, spec.layouts);
								});
							} })
						} })
					])
				};
			};
			const factory$c = (detail, components$2, spec, externals) => ({
				...Button.sketch({
					...externals.button(),
					action: (button$1) => {
						toggle(button$1, externals);
					},
					buttonBehaviours: SketchBehaviours.augment({ dump: externals.button().buttonBehaviours }, [Coupling.config({ others: { toolbarSandbox: (button$1) => {
						return makeSandbox(button$1, spec, detail);
					} } })])
				}),
				apis: {
					setGroups: (button$1, groups) => {
						Sandboxing.getState(Coupling.getCoupled(button$1, "toolbarSandbox")).each((toolbar) => {
							setGroups(button$1, toolbar, detail, spec.layouts, groups);
						});
					},
					reposition: (button$1) => {
						Sandboxing.getState(Coupling.getCoupled(button$1, "toolbarSandbox")).each((toolbar) => {
							position(button$1, toolbar, detail, spec.layouts);
						});
					},
					toggle: (button$1) => {
						toggle(button$1, externals);
					},
					toggleWithoutFocusing: (button$1) => {
						toggleWithoutFocusing(button$1, externals);
					},
					getToolbar: (button$1) => {
						return Sandboxing.getState(Coupling.getCoupled(button$1, "toolbarSandbox"));
					},
					isOpen: (button$1) => {
						return Sandboxing.isOpen(Coupling.getCoupled(button$1, "toolbarSandbox"));
					}
				}
			});
			const FloatingToolbarButton = composite({
				name: "FloatingToolbarButton",
				factory: factory$c,
				configFields: schema$a(),
				partFields: parts$6(),
				apis: {
					setGroups: (apis, button$1, groups) => {
						apis.setGroups(button$1, groups);
					},
					reposition: (apis, button$1) => {
						apis.reposition(button$1);
					},
					toggle: (apis, button$1) => {
						apis.toggle(button$1);
					},
					toggleWithoutFocusing: (apis, button$1) => {
						apis.toggleWithoutFocusing(button$1);
					},
					getToolbar: (apis, button$1) => apis.getToolbar(button$1),
					isOpen: (apis, button$1) => apis.isOpen(button$1)
				}
			});
			const schema$9 = constant$1([
				required$1("items"),
				markers$1(["itemSelector"]),
				field("tgroupBehaviours", [Keying])
			]);
			const parts$5 = constant$1([group({
				name: "items",
				unit: "item"
			})]);
			const factory$b = (detail, components$2, _spec, _externals) => ({
				uid: detail.uid,
				dom: detail.dom,
				components: components$2,
				behaviours: augment(detail.tgroupBehaviours, [Keying.config({
					mode: "flow",
					selector: detail.markers.itemSelector
				})]),
				domModification: { attributes: { role: "toolbar" } }
			});
			const ToolbarGroup = composite({
				name: "ToolbarGroup",
				configFields: schema$9(),
				partFields: parts$5(),
				factory: factory$b
			});
			const buildGroups = (comps) => map$2(comps, (g) => premade(g));
			const refresh$1 = (toolbar, memFloatingToolbarButton, detail) => {
				refresh$2(toolbar, detail, (overflowGroups) => {
					detail.overflowGroups.set(overflowGroups);
					memFloatingToolbarButton.getOpt(toolbar).each((floatingToolbarButton) => {
						FloatingToolbarButton.setGroups(floatingToolbarButton, buildGroups(overflowGroups));
					});
				});
			};
			const factory$a = (detail, components$2, spec, externals) => {
				const memFloatingToolbarButton = record(FloatingToolbarButton.sketch({
					fetch: () => Future.nu((resolve$1) => {
						resolve$1(buildGroups(detail.overflowGroups.get()));
					}),
					layouts: {
						onLtr: () => [southwest$2, southeast$2],
						onRtl: () => [southeast$2, southwest$2],
						onBottomLtr: () => [northwest$2, northeast$2],
						onBottomRtl: () => [northeast$2, northwest$2]
					},
					getBounds: spec.getOverflowBounds,
					lazySink: detail.lazySink,
					fireDismissalEventInstead: {},
					markers: { toggledClass: detail.markers.overflowToggledClass },
					parts: {
						button: externals["overflow-button"](),
						toolbar: externals.overflow()
					},
					onToggled: (comp, state) => detail[state ? "onOpened" : "onClosed"](comp)
				}));
				return {
					uid: detail.uid,
					dom: detail.dom,
					components: components$2,
					behaviours: augment(detail.splitToolbarBehaviours, [Coupling.config({ others: { overflowGroup: () => {
						return ToolbarGroup.sketch({
							...externals["overflow-group"](),
							items: [memFloatingToolbarButton.asSpec()]
						});
					} } })]),
					apis: {
						setGroups: (toolbar, groups) => {
							detail.builtGroups.set(map$2(groups, toolbar.getSystem().build));
							refresh$1(toolbar, memFloatingToolbarButton, detail);
						},
						refresh: (toolbar) => refresh$1(toolbar, memFloatingToolbarButton, detail),
						toggle: (toolbar) => {
							memFloatingToolbarButton.getOpt(toolbar).each((floatingToolbarButton) => {
								FloatingToolbarButton.toggle(floatingToolbarButton);
							});
						},
						toggleWithoutFocusing: (toolbar) => {
							memFloatingToolbarButton.getOpt(toolbar).each(FloatingToolbarButton.toggleWithoutFocusing);
						},
						isOpen: (toolbar) => memFloatingToolbarButton.getOpt(toolbar).map(FloatingToolbarButton.isOpen).getOr(false),
						reposition: (toolbar) => {
							memFloatingToolbarButton.getOpt(toolbar).each((floatingToolbarButton) => {
								FloatingToolbarButton.reposition(floatingToolbarButton);
							});
						},
						getOverflow: (toolbar) => memFloatingToolbarButton.getOpt(toolbar).bind(FloatingToolbarButton.getToolbar)
					},
					domModification: { attributes: { role: "group" } }
				};
			};
			const SplitFloatingToolbar = composite({
				name: "SplitFloatingToolbar",
				configFields: schema$b(),
				partFields: parts$7(),
				factory: factory$a,
				apis: {
					setGroups: (apis, toolbar, groups) => {
						apis.setGroups(toolbar, groups);
					},
					refresh: (apis, toolbar) => {
						apis.refresh(toolbar);
					},
					reposition: (apis, toolbar) => {
						apis.reposition(toolbar);
					},
					toggle: (apis, toolbar) => {
						apis.toggle(toolbar);
					},
					toggleWithoutFocusing: (apis, toolbar) => {
						apis.toggle(toolbar);
					},
					isOpen: (apis, toolbar) => apis.isOpen(toolbar),
					getOverflow: (apis, toolbar) => apis.getOverflow(toolbar)
				}
			});
			const schema$8 = constant$1([
				markers$1([
					"closedClass",
					"openClass",
					"shrinkingClass",
					"growingClass",
					"overflowToggledClass"
				]),
				onHandler("onOpened"),
				onHandler("onClosed")
			].concat(schema$c()));
			const parts$4 = constant$1([
				required({
					factory: Toolbar,
					schema: schema$e(),
					name: "primary"
				}),
				required({
					factory: Toolbar,
					schema: schema$e(),
					name: "overflow",
					overrides: (detail) => {
						return { toolbarBehaviours: derive$1([Sliding.config({
							dimension: { property: "height" },
							closedClass: detail.markers.closedClass,
							openClass: detail.markers.openClass,
							shrinkingClass: detail.markers.shrinkingClass,
							growingClass: detail.markers.growingClass,
							onShrunk: (comp) => {
								getPart(comp, detail, "overflow-button").each((button$1) => {
									Toggling.off(button$1);
									Focusing.focus(button$1);
								});
								detail.onClosed(comp);
							},
							onGrown: (comp) => {
								Keying.focusIn(comp);
								detail.onOpened(comp);
							},
							onStartGrow: (comp) => {
								getPart(comp, detail, "overflow-button").each(Toggling.on);
							}
						}), Keying.config({
							mode: "acyclic",
							onEscape: (comp) => {
								getPart(comp, detail, "overflow-button").each(Focusing.focus);
								return Optional.some(true);
							}
						})]) };
					}
				}),
				external({
					name: "overflow-button",
					overrides: (detail) => ({ buttonBehaviours: derive$1([Toggling.config({
						toggleClass: detail.markers.overflowToggledClass,
						aria: { mode: "pressed" },
						toggleOnExecute: false
					})]) })
				}),
				external({ name: "overflow-group" })
			]);
			const isOpen = (toolbar, detail) => getPart(toolbar, detail, "overflow").map(Sliding.hasGrown).getOr(false);
			const toggleToolbar = (toolbar, detail) => {
				getPart(toolbar, detail, "overflow-button").bind(() => getPart(toolbar, detail, "overflow")).each((overf) => {
					refresh(toolbar, detail);
					Sliding.toggleGrow(overf);
				});
			};
			const refresh = (toolbar, detail) => {
				getPart(toolbar, detail, "overflow").each((overflow$1) => {
					refresh$2(toolbar, detail, (groups) => {
						const builtGroups = map$2(groups, (g) => premade(g));
						Toolbar.setGroups(overflow$1, builtGroups);
					});
					getPart(toolbar, detail, "overflow-button").each((button$1) => {
						if (Sliding.hasGrown(overflow$1)) Toggling.on(button$1);
					});
					Sliding.refresh(overflow$1);
				});
			};
			const factory$9 = (detail, components$2, spec, externals) => {
				const toolbarToggleEvent = "alloy.toolbar.toggle";
				const doSetGroups = (toolbar, groups) => {
					const built = map$2(groups, toolbar.getSystem().build);
					detail.builtGroups.set(built);
				};
				return {
					uid: detail.uid,
					dom: detail.dom,
					components: components$2,
					behaviours: augment(detail.splitToolbarBehaviours, [Coupling.config({ others: { overflowGroup: (toolbar) => {
						return ToolbarGroup.sketch({
							...externals["overflow-group"](),
							items: [Button.sketch({
								...externals["overflow-button"](),
								action: (_button) => {
									emit(toolbar, toolbarToggleEvent);
								}
							})]
						});
					} } }), config("toolbar-toggle-events", [run$1(toolbarToggleEvent, (toolbar) => {
						toggleToolbar(toolbar, detail);
					})])]),
					apis: {
						setGroups: (toolbar, groups) => {
							doSetGroups(toolbar, groups);
							refresh(toolbar, detail);
						},
						refresh: (toolbar) => refresh(toolbar, detail),
						toggle: (toolbar) => toggleToolbar(toolbar, detail),
						isOpen: (toolbar) => isOpen(toolbar, detail)
					},
					domModification: { attributes: { role: "group" } }
				};
			};
			const SplitSlidingToolbar = composite({
				name: "SplitSlidingToolbar",
				configFields: schema$8(),
				partFields: parts$4(),
				factory: factory$9,
				apis: {
					setGroups: (apis, toolbar, groups) => {
						apis.setGroups(toolbar, groups);
					},
					refresh: (apis, toolbar) => {
						apis.refresh(toolbar);
					},
					toggle: (apis, toolbar) => {
						apis.toggle(toolbar);
					},
					isOpen: (apis, toolbar) => apis.isOpen(toolbar)
				}
			});
			const renderToolbarGroupCommon = (toolbarGroup) => {
				return {
					dom: {
						tag: "div",
						classes: ["tox-toolbar__group"],
						...toolbarGroup.title.fold(() => ({}), (title$1) => ({ attributes: { title: title$1 } }))
					},
					components: [ToolbarGroup.parts.items({})],
					items: toolbarGroup.items,
					markers: { itemSelector: "*:not(.tox-split-button) > .tox-tbtn:not([disabled]), .tox-split-button:not([disabled]), .tox-toolbar-nav-js:not([disabled]), .tox-number-input:not([disabled])" },
					tgroupBehaviours: derive$1([Tabstopping.config({}), Focusing.config({})])
				};
			};
			const renderToolbarGroup = (toolbarGroup) => ToolbarGroup.sketch(renderToolbarGroupCommon(toolbarGroup));
			const getToolbarBehaviours = (toolbarSpec, modeName) => {
				const onAttached = runOnAttached((component) => {
					const groups = map$2(toolbarSpec.initGroups, renderToolbarGroup);
					Toolbar.setGroups(component, groups);
				});
				return derive$1([
					DisablingConfigs.toolbarButton(toolbarSpec.providers.isDisabled),
					receivingConfig(),
					Keying.config({
						mode: modeName,
						onEscape: toolbarSpec.onEscape,
						selector: ".tox-toolbar__group"
					}),
					config("toolbar-events", [onAttached])
				]);
			};
			const renderMoreToolbarCommon = (toolbarSpec) => {
				const modeName = toolbarSpec.cyclicKeying ? "cyclic" : "acyclic";
				return {
					uid: toolbarSpec.uid,
					dom: {
						tag: "div",
						classes: ["tox-toolbar-overlord"]
					},
					parts: {
						"overflow-group": renderToolbarGroupCommon({
							title: Optional.none(),
							items: []
						}),
						"overflow-button": renderIconButtonSpec({
							name: "more",
							icon: Optional.some("more-drawer"),
							enabled: true,
							tooltip: Optional.some("Reveal or hide additional toolbar items"),
							primary: false,
							buttonType: Optional.none(),
							borderless: false
						}, Optional.none(), toolbarSpec.providers)
					},
					splitToolbarBehaviours: getToolbarBehaviours(toolbarSpec, modeName)
				};
			};
			const renderFloatingMoreToolbar = (toolbarSpec) => {
				const baseSpec = renderMoreToolbarCommon(toolbarSpec);
				const overflowXOffset = 4;
				const primary$1 = SplitFloatingToolbar.parts.primary({ dom: {
					tag: "div",
					classes: ["tox-toolbar__primary"]
				} });
				return SplitFloatingToolbar.sketch({
					...baseSpec,
					lazySink: toolbarSpec.getSink,
					getOverflowBounds: () => {
						const headerElem = toolbarSpec.moreDrawerData.lazyHeader().element;
						const headerBounds = absolute$2(headerElem);
						const docElem = documentElement(headerElem);
						const docBounds = absolute$2(docElem);
						const height$1 = Math.max(docElem.dom.scrollHeight, docBounds.height);
						return bounds(headerBounds.x + overflowXOffset, docBounds.y, headerBounds.width - overflowXOffset * 2, height$1);
					},
					parts: {
						...baseSpec.parts,
						overflow: { dom: {
							tag: "div",
							classes: ["tox-toolbar__overflow"],
							attributes: toolbarSpec.attributes
						} }
					},
					components: [primary$1],
					markers: { overflowToggledClass: "tox-tbtn--enabled" },
					onOpened: (comp) => toolbarSpec.onToggled(comp, true),
					onClosed: (comp) => toolbarSpec.onToggled(comp, false)
				});
			};
			const renderSlidingMoreToolbar = (toolbarSpec) => {
				const primary$1 = SplitSlidingToolbar.parts.primary({ dom: {
					tag: "div",
					classes: ["tox-toolbar__primary"]
				} });
				const overflow$1 = SplitSlidingToolbar.parts.overflow({ dom: {
					tag: "div",
					classes: ["tox-toolbar__overflow"]
				} });
				const baseSpec = renderMoreToolbarCommon(toolbarSpec);
				return SplitSlidingToolbar.sketch({
					...baseSpec,
					components: [primary$1, overflow$1],
					markers: {
						openClass: "tox-toolbar__overflow--open",
						closedClass: "tox-toolbar__overflow--closed",
						growingClass: "tox-toolbar__overflow--growing",
						shrinkingClass: "tox-toolbar__overflow--shrinking",
						overflowToggledClass: "tox-tbtn--enabled"
					},
					onOpened: (comp) => {
						comp.getSystem().broadcastOn([toolbarHeightChange()], { type: "opened" });
						toolbarSpec.onToggled(comp, true);
					},
					onClosed: (comp) => {
						comp.getSystem().broadcastOn([toolbarHeightChange()], { type: "closed" });
						toolbarSpec.onToggled(comp, false);
					}
				});
			};
			const renderToolbar = (toolbarSpec) => {
				const modeName = toolbarSpec.cyclicKeying ? "cyclic" : "acyclic";
				return Toolbar.sketch({
					uid: toolbarSpec.uid,
					dom: {
						tag: "div",
						classes: ["tox-toolbar"].concat(toolbarSpec.type === ToolbarMode$1.scrolling ? ["tox-toolbar--scrolling"] : [])
					},
					components: [Toolbar.parts.groups({})],
					toolbarBehaviours: getToolbarBehaviours(toolbarSpec, modeName)
				});
			};
			const baseButtonFields = [
				optionalText,
				optionalIcon,
				optionString("tooltip"),
				defaultedStringEnum("buttonType", "secondary", ["primary", "secondary"]),
				defaultedBoolean("borderless", false),
				requiredFunction("onAction")
			];
			const schemaWithoutGroupButton = {
				button: [
					...baseButtonFields,
					text$1,
					requiredStringEnum("type", ["button"])
				],
				togglebutton: [
					...baseButtonFields,
					defaultedBoolean("active", false),
					requiredStringEnum("type", ["togglebutton"])
				]
			};
			const groupFields = [requiredStringEnum("type", ["group"]), defaultedArrayOf("buttons", [], choose$1("type", schemaWithoutGroupButton))];
			const viewSchema = objOf([
				defaultedArrayOf("buttons", [], choose$1("type", {
					...schemaWithoutGroupButton,
					group: groupFields
				})),
				requiredFunction("onShow"),
				requiredFunction("onHide")
			]);
			const createView = (spec) => asRaw("view", viewSchema, spec);
			const renderButton = (spec, providers) => {
				var _a, _b;
				const isToggleButton$1 = spec.type === "togglebutton";
				const optMemIcon = spec.icon.map((memIcon) => renderReplaceableIconFromPack(memIcon, providers.icons)).map(record);
				const getAction$1 = () => (comp) => {
					const setIcon = (newIcon) => {
						optMemIcon.map((memIcon) => memIcon.getOpt(comp).each((displayIcon) => {
							Replacing.set(displayIcon, [renderReplaceableIconFromPack(newIcon, providers.icons)]);
						}));
					};
					const setActive = (state) => {
						const elm = comp.element;
						if (state) {
							add$2(elm, "tox-button--enabled");
							set$9(elm, "aria-pressed", true);
						} else {
							remove$2(elm, "tox-button--enabled");
							remove$7(elm, "aria-pressed");
						}
					};
					const isActive = () => has(comp.element, "tox-button--enabled");
					if (isToggleButton$1) return spec.onAction({
						setIcon,
						setActive,
						isActive
					});
					if (spec.type === "button") return spec.onAction({ setIcon });
				};
				const action = getAction$1();
				const buttonSpec = {
					...spec,
					name: isToggleButton$1 ? spec.text.getOr(spec.icon.getOr("")) : (_a = spec.text) !== null && _a !== void 0 ? _a : spec.icon.getOr(""),
					primary: spec.buttonType === "primary",
					buttonType: Optional.from(spec.buttonType),
					tooltip: spec.tooltip,
					icon: spec.icon,
					enabled: true,
					borderless: spec.borderless
				};
				const buttonTypeClasses = calculateClassesFromButtonType((_b = spec.buttonType) !== null && _b !== void 0 ? _b : "secondary");
				const optTranslatedText = isToggleButton$1 ? spec.text.map(providers.translate) : Optional.some(providers.translate(spec.text));
				const optTranslatedTextComponed = optTranslatedText.map(text$2);
				const tooltipAttributes = buttonSpec.tooltip.or(optTranslatedText).map((tooltip) => ({
					"aria-label": providers.translate(tooltip),
					"title": providers.translate(tooltip)
				})).getOr({});
				const components$2 = componentRenderPipeline([optMemIcon.map((memIcon) => memIcon.asSpec()), optTranslatedTextComponed]);
				const hasIconAndText = spec.icon.isSome() && optTranslatedTextComponed.isSome();
				const dom$3 = {
					tag: "button",
					classes: buttonTypeClasses.concat(...spec.icon.isSome() && !hasIconAndText ? ["tox-button--icon"] : []).concat(...hasIconAndText ? ["tox-button--icon-and-text"] : []).concat(...spec.borderless ? ["tox-button--naked"] : []).concat(...spec.type === "togglebutton" && spec.active ? ["tox-button--enabled"] : []),
					attributes: tooltipAttributes
				};
				const iconButtonSpec = renderCommonSpec(buttonSpec, Optional.some(action), [], dom$3, components$2, providers);
				return Button.sketch(iconButtonSpec);
			};
			const renderViewButton = (spec, providers) => renderButton(spec, providers);
			const renderButtonsGroup = (spec, providers) => {
				return {
					dom: {
						tag: "div",
						classes: ["tox-view__toolbar__group"]
					},
					components: map$2(spec.buttons, (button$1) => renderViewButton(button$1, providers))
				};
			};
			const deviceDetection = detect$2().deviceType;
			const isPhone = deviceDetection.isPhone();
			const isTablet = deviceDetection.isTablet();
			const renderViewHeader = (spec) => {
				let hasGroups = false;
				const endButtons = map$2(spec.buttons, (btnspec) => {
					if (btnspec.type === "group") {
						hasGroups = true;
						return renderButtonsGroup(btnspec, spec.providers);
					} else return renderViewButton(btnspec, spec.providers);
				});
				return {
					uid: spec.uid,
					dom: {
						tag: "div",
						classes: [!hasGroups ? "tox-view__header" : "tox-view__toolbar", ...isPhone || isTablet ? ["tox-view--mobile", "tox-view--scrolling"] : []]
					},
					behaviours: derive$1([Focusing.config({}), Keying.config({
						mode: "flow",
						selector: "button, .tox-button",
						focusInside: FocusInsideModes.OnEnterOrSpaceMode
					})]),
					components: hasGroups ? endButtons : [Container.sketch({
						dom: {
							tag: "div",
							classes: ["tox-view__header-start"]
						},
						components: []
					}), Container.sketch({
						dom: {
							tag: "div",
							classes: ["tox-view__header-end"]
						},
						components: endButtons
					})]
				};
			};
			const renderViewPane = (spec) => {
				return {
					uid: spec.uid,
					dom: {
						tag: "div",
						classes: ["tox-view__pane"]
					}
				};
			};
			const factory$8 = (detail, components$2, _spec, _externals) => {
				return {
					uid: detail.uid,
					dom: detail.dom,
					components: components$2,
					apis: {
						getPane: (comp) => parts$a.getPart(comp, detail, "pane"),
						getOnShow: (_comp) => detail.viewConfig.onShow,
						getOnHide: (_comp) => detail.viewConfig.onHide
					}
				};
			};
			var View = composite({
				name: "silver.View",
				configFields: [required$1("viewConfig")],
				partFields: [optional({
					factory: { sketch: renderViewHeader },
					schema: [required$1("buttons"), required$1("providers")],
					name: "header"
				}), optional({
					factory: { sketch: renderViewPane },
					schema: [],
					name: "pane"
				})],
				factory: factory$8,
				apis: {
					getPane: (apis, comp) => apis.getPane(comp),
					getOnShow: (apis, comp) => apis.getOnShow(comp),
					getOnHide: (apis, comp) => apis.getOnHide(comp)
				}
			});
			const makeViews = (parts$10, viewConfigs, providers) => {
				return mapToArray(viewConfigs, (config$1, name$4) => {
					const internalViewConfig = getOrDie(createView(config$1));
					return parts$10.slot(name$4, View.sketch({
						dom: {
							tag: "div",
							classes: ["tox-view"]
						},
						viewConfig: internalViewConfig,
						components: [...internalViewConfig.buttons.length > 0 ? [View.parts.header({
							buttons: internalViewConfig.buttons,
							providers
						})] : [], View.parts.pane({})]
					}));
				});
			};
			const makeSlotContainer = (viewConfigs, providers) => SlotContainer.sketch((parts$10) => ({
				dom: {
					tag: "div",
					classes: ["tox-view-wrap__slot-container"]
				},
				components: makeViews(parts$10, viewConfigs, providers),
				slotBehaviours: SimpleBehaviours.unnamedEvents([runOnAttached((slotContainer) => SlotContainer.hideAllSlots(slotContainer))])
			}));
			const getCurrentName = (slotContainer) => {
				return find$5(SlotContainer.getSlotNames(slotContainer), (name$4) => SlotContainer.isShowing(slotContainer, name$4));
			};
			const hideContainer = (comp) => {
				const element$1 = comp.element;
				set$8(element$1, "display", "none");
				set$9(element$1, "aria-hidden", "true");
			};
			const showContainer = (comp) => {
				const element$1 = comp.element;
				remove$6(element$1, "display");
				remove$7(element$1, "aria-hidden");
			};
			const makeViewInstanceApi = (slot) => ({ getContainer: constant$1(slot) });
			const runOnPaneWithInstanceApi = (slotContainer, name$4, get$10) => {
				SlotContainer.getSlot(slotContainer, name$4).each((view$1) => {
					View.getPane(view$1).each((pane) => {
						get$10(view$1)(makeViewInstanceApi(pane.element.dom));
					});
				});
			};
			const runOnShow = (slotContainer, name$4) => runOnPaneWithInstanceApi(slotContainer, name$4, View.getOnShow);
			const runOnHide = (slotContainer, name$4) => runOnPaneWithInstanceApi(slotContainer, name$4, View.getOnHide);
			const factory$7 = (detail, spec) => {
				const setViews = (comp, viewConfigs) => {
					Replacing.set(comp, [makeSlotContainer(viewConfigs, spec.backstage.shared.providers)]);
				};
				const whichView = (comp) => {
					return Composing.getCurrent(comp).bind(getCurrentName);
				};
				const toggleView = (comp, showMainView, hideMainView, name$4) => {
					return Composing.getCurrent(comp).exists((slotContainer) => {
						const optCurrentSlotName = getCurrentName(slotContainer);
						const isTogglingCurrentView = optCurrentSlotName.exists((current) => name$4 === current);
						const exists$1 = SlotContainer.getSlot(slotContainer, name$4).isSome();
						if (exists$1) {
							SlotContainer.hideAllSlots(slotContainer);
							if (!isTogglingCurrentView) {
								hideMainView();
								showContainer(comp);
								SlotContainer.showSlot(slotContainer, name$4);
								runOnShow(slotContainer, name$4);
							} else {
								hideContainer(comp);
								showMainView();
							}
							optCurrentSlotName.each((prevName) => runOnHide(slotContainer, prevName));
						}
						return exists$1;
					});
				};
				const apis = {
					setViews,
					whichView,
					toggleView
				};
				return {
					uid: detail.uid,
					dom: {
						tag: "div",
						classes: ["tox-view-wrap"],
						attributes: { "aria-hidden": "true" },
						styles: { display: "none" }
					},
					components: [],
					behaviours: derive$1([Replacing.config({}), Composing.config({ find: (comp) => {
						return head(Replacing.contents(comp));
					} })]),
					apis
				};
			};
			var ViewWrapper = single({
				factory: factory$7,
				name: "silver.ViewWrapper",
				configFields: [required$1("backstage")],
				apis: {
					setViews: (apis, comp, views) => apis.setViews(comp, views),
					toggleView: (apis, comp, outerContainer, editorCont, name$4) => apis.toggleView(comp, outerContainer, editorCont, name$4),
					whichView: (apis, comp) => apis.whichView(comp)
				}
			});
			const factory$6 = (detail, components$2, _spec) => {
				let toolbarDrawerOpenState = false;
				const apis = {
					getSocket: (comp) => {
						return parts$a.getPart(comp, detail, "socket");
					},
					setSidebar: (comp, panelConfigs, showSidebar) => {
						parts$a.getPart(comp, detail, "sidebar").each((sidebar) => setSidebar(sidebar, panelConfigs, showSidebar));
					},
					toggleSidebar: (comp, name$4) => {
						parts$a.getPart(comp, detail, "sidebar").each((sidebar) => toggleSidebar(sidebar, name$4));
					},
					whichSidebar: (comp) => {
						return parts$a.getPart(comp, detail, "sidebar").bind(whichSidebar).getOrNull();
					},
					getHeader: (comp) => {
						return parts$a.getPart(comp, detail, "header");
					},
					getToolbar: (comp) => {
						return parts$a.getPart(comp, detail, "toolbar");
					},
					setToolbar: (comp, groups) => {
						parts$a.getPart(comp, detail, "toolbar").each((toolbar) => {
							const renderedGroups = map$2(groups, renderToolbarGroup);
							toolbar.getApis().setGroups(toolbar, renderedGroups);
						});
					},
					setToolbars: (comp, toolbars) => {
						parts$a.getPart(comp, detail, "multiple-toolbar").each((mToolbar) => {
							const renderedToolbars = map$2(toolbars, (g) => map$2(g, renderToolbarGroup));
							CustomList.setItems(mToolbar, renderedToolbars);
						});
					},
					refreshToolbar: (comp) => {
						parts$a.getPart(comp, detail, "toolbar").each((toolbar) => toolbar.getApis().refresh(toolbar));
					},
					toggleToolbarDrawer: (comp) => {
						parts$a.getPart(comp, detail, "toolbar").each((toolbar) => {
							mapFrom(toolbar.getApis().toggle, (toggle$3) => toggle$3(toolbar));
						});
					},
					toggleToolbarDrawerWithoutFocusing: (comp) => {
						parts$a.getPart(comp, detail, "toolbar").each((toolbar) => {
							mapFrom(toolbar.getApis().toggleWithoutFocusing, (toggleWithoutFocusing$1) => toggleWithoutFocusing$1(toolbar));
						});
					},
					isToolbarDrawerToggled: (comp) => {
						return parts$a.getPart(comp, detail, "toolbar").bind((toolbar) => Optional.from(toolbar.getApis().isOpen).map((isOpen$2) => isOpen$2(toolbar))).getOr(false);
					},
					getThrobber: (comp) => {
						return parts$a.getPart(comp, detail, "throbber");
					},
					focusToolbar: (comp) => {
						parts$a.getPart(comp, detail, "toolbar").orThunk(() => parts$a.getPart(comp, detail, "multiple-toolbar")).each((toolbar) => {
							Keying.focusIn(toolbar);
						});
					},
					setMenubar: (comp, menus) => {
						parts$a.getPart(comp, detail, "menubar").each((menubar) => {
							SilverMenubar.setMenus(menubar, menus);
						});
					},
					focusMenubar: (comp) => {
						parts$a.getPart(comp, detail, "menubar").each((menubar) => {
							SilverMenubar.focus(menubar);
						});
					},
					setViews: (comp, viewConfigs) => {
						parts$a.getPart(comp, detail, "viewWrapper").each((wrapper) => {
							ViewWrapper.setViews(wrapper, viewConfigs);
						});
					},
					toggleView: (comp, name$4) => {
						return parts$a.getPart(comp, detail, "viewWrapper").exists((wrapper) => ViewWrapper.toggleView(wrapper, () => apis.showMainView(comp), () => apis.hideMainView(comp), name$4));
					},
					whichView: (comp) => {
						return parts$a.getPart(comp, detail, "viewWrapper").bind(ViewWrapper.whichView).getOrNull();
					},
					hideMainView: (comp) => {
						toolbarDrawerOpenState = apis.isToolbarDrawerToggled(comp);
						if (toolbarDrawerOpenState) apis.toggleToolbarDrawer(comp);
						parts$a.getPart(comp, detail, "editorContainer").each((editorContainer) => {
							const element$1 = editorContainer.element;
							set$8(element$1, "display", "none");
							set$9(element$1, "aria-hidden", "true");
						});
					},
					showMainView: (comp) => {
						if (toolbarDrawerOpenState) apis.toggleToolbarDrawer(comp);
						parts$a.getPart(comp, detail, "editorContainer").each((editorContainer) => {
							const element$1 = editorContainer.element;
							remove$6(element$1, "display");
							remove$7(element$1, "aria-hidden");
						});
					}
				};
				return {
					uid: detail.uid,
					dom: detail.dom,
					components: components$2,
					apis,
					behaviours: detail.behaviours
				};
			};
			const partMenubar = partType.optional({
				factory: SilverMenubar,
				name: "menubar",
				schema: [required$1("backstage")]
			});
			const toolbarFactory = (spec) => {
				if (spec.type === ToolbarMode$1.sliding) return renderSlidingMoreToolbar;
				else if (spec.type === ToolbarMode$1.floating) return renderFloatingMoreToolbar;
				else return renderToolbar;
			};
			const partMultipleToolbar = partType.optional({
				factory: { sketch: (spec) => CustomList.sketch({
					uid: spec.uid,
					dom: spec.dom,
					listBehaviours: derive$1([Keying.config({
						mode: "acyclic",
						selector: ".tox-toolbar"
					})]),
					makeItem: () => renderToolbar({
						type: spec.type,
						uid: generate$6("multiple-toolbar-item"),
						cyclicKeying: false,
						initGroups: [],
						providers: spec.providers,
						onEscape: () => {
							spec.onEscape();
							return Optional.some(true);
						}
					}),
					setupItem: (_mToolbar, tc, data, _index) => {
						Toolbar.setGroups(tc, data);
					},
					shell: true
				}) },
				name: "multiple-toolbar",
				schema: [required$1("dom"), required$1("onEscape")]
			});
			const partToolbar = partType.optional({
				factory: { sketch: (spec) => {
					return toolbarFactory(spec)({
						type: spec.type,
						uid: spec.uid,
						onEscape: () => {
							spec.onEscape();
							return Optional.some(true);
						},
						onToggled: (_comp, state) => spec.onToolbarToggled(state),
						cyclicKeying: false,
						initGroups: [],
						getSink: spec.getSink,
						providers: spec.providers,
						moreDrawerData: {
							lazyToolbar: spec.lazyToolbar,
							lazyMoreButton: spec.lazyMoreButton,
							lazyHeader: spec.lazyHeader
						},
						attributes: spec.attributes
					});
				} },
				name: "toolbar",
				schema: [
					required$1("dom"),
					required$1("onEscape"),
					required$1("getSink")
				]
			});
			const partHeader = partType.optional({
				factory: { sketch: renderHeader },
				name: "header",
				schema: [required$1("dom")]
			});
			const partPromotion = partType.optional({
				factory: { sketch: renderPromotion },
				name: "promotion",
				schema: [required$1("dom")]
			});
			const partSocket = partType.optional({
				name: "socket",
				schema: [required$1("dom")]
			});
			const partSidebar = partType.optional({
				factory: { sketch: renderSidebar },
				name: "sidebar",
				schema: [required$1("dom")]
			});
			const partThrobber = partType.optional({
				factory: { sketch: renderThrobber },
				name: "throbber",
				schema: [required$1("dom")]
			});
			const partViewWrapper = partType.optional({
				factory: ViewWrapper,
				name: "viewWrapper",
				schema: [required$1("backstage")]
			});
			const renderEditorContainer = (spec) => ({
				uid: spec.uid,
				dom: {
					tag: "div",
					classes: ["tox-editor-container"]
				},
				components: spec.components
			});
			const partEditorContainer = partType.optional({
				factory: { sketch: renderEditorContainer },
				name: "editorContainer",
				schema: []
			});
			var OuterContainer = composite({
				name: "OuterContainer",
				factory: factory$6,
				configFields: [required$1("dom"), required$1("behaviours")],
				partFields: [
					partHeader,
					partMenubar,
					partToolbar,
					partMultipleToolbar,
					partSocket,
					partSidebar,
					partPromotion,
					partThrobber,
					partViewWrapper,
					partEditorContainer
				],
				apis: {
					getSocket: (apis, comp) => {
						return apis.getSocket(comp);
					},
					setSidebar: (apis, comp, panelConfigs, showSidebar) => {
						apis.setSidebar(comp, panelConfigs, showSidebar);
					},
					toggleSidebar: (apis, comp, name$4) => {
						apis.toggleSidebar(comp, name$4);
					},
					whichSidebar: (apis, comp) => {
						return apis.whichSidebar(comp);
					},
					getHeader: (apis, comp) => {
						return apis.getHeader(comp);
					},
					getToolbar: (apis, comp) => {
						return apis.getToolbar(comp);
					},
					setToolbar: (apis, comp, groups) => {
						apis.setToolbar(comp, groups);
					},
					setToolbars: (apis, comp, toolbars) => {
						apis.setToolbars(comp, toolbars);
					},
					refreshToolbar: (apis, comp) => {
						return apis.refreshToolbar(comp);
					},
					toggleToolbarDrawer: (apis, comp) => {
						apis.toggleToolbarDrawer(comp);
					},
					toggleToolbarDrawerWithoutFocusing: (apis, comp) => {
						apis.toggleToolbarDrawerWithoutFocusing(comp);
					},
					isToolbarDrawerToggled: (apis, comp) => {
						return apis.isToolbarDrawerToggled(comp);
					},
					getThrobber: (apis, comp) => {
						return apis.getThrobber(comp);
					},
					setMenubar: (apis, comp, menus) => {
						apis.setMenubar(comp, menus);
					},
					focusMenubar: (apis, comp) => {
						apis.focusMenubar(comp);
					},
					focusToolbar: (apis, comp) => {
						apis.focusToolbar(comp);
					},
					setViews: (apis, comp, views) => {
						apis.setViews(comp, views);
					},
					toggleView: (apis, comp, name$4) => {
						return apis.toggleView(comp, name$4);
					},
					whichView: (apis, comp) => {
						return apis.whichView(comp);
					}
				}
			});
			const defaultMenubar = "file edit view insert format tools table help";
			const defaultMenus = {
				file: {
					title: "File",
					items: "newdocument restoredraft | preview | export print | deleteallconversations"
				},
				edit: {
					title: "Edit",
					items: "undo redo | cut copy paste pastetext | selectall | searchreplace"
				},
				view: {
					title: "View",
					items: "code | visualaid visualchars visualblocks | spellchecker | preview fullscreen | showcomments"
				},
				insert: {
					title: "Insert",
					items: "image link media addcomment pageembed template inserttemplate codesample inserttable accordion | charmap emoticons hr | pagebreak nonbreaking anchor tableofcontents footnotes | mergetags | insertdatetime"
				},
				format: {
					title: "Format",
					items: "bold italic underline strikethrough superscript subscript codeformat | styles blocks fontfamily fontsize align lineheight | forecolor backcolor | language | removeformat"
				},
				tools: {
					title: "Tools",
					items: "aidialog aishortcuts | spellchecker spellcheckerlanguage | autocorrect capitalization | a11ycheck code typography wordcount addtemplate"
				},
				table: {
					title: "Table",
					items: "inserttable | cell row column | advtablesort | tableprops deletetable"
				},
				help: {
					title: "Help",
					items: "help"
				}
			};
			const make = (menu$1, registry, editor) => {
				const removedMenuItems = getRemovedMenuItems(editor).split(/[ ,]/);
				return {
					text: menu$1.title,
					getItems: () => bind$3(menu$1.items, (i) => {
						const itemName = i.toLowerCase();
						if (itemName.trim().length === 0) return [];
						else if (exists(removedMenuItems, (removedMenuItem) => removedMenuItem === itemName)) return [];
						else if (itemName === "separator" || itemName === "|") return [{ type: "separator" }];
						else if (registry.menuItems[itemName]) return [registry.menuItems[itemName]];
						else return [];
					})
				};
			};
			const parseItemsString = (items) => {
				return items.split(" ");
			};
			const identifyMenus = (editor, registry) => {
				const rawMenuData = {
					...defaultMenus,
					...registry.menus
				};
				const userDefinedMenus = keys(registry.menus).length > 0;
				return filter$2(map$2(filter$2(registry.menubar === void 0 || registry.menubar === true ? parseItemsString(defaultMenubar) : parseItemsString(registry.menubar === false ? "" : registry.menubar), (menuName) => {
					const isDefaultMenu = has$2(defaultMenus, menuName);
					if (userDefinedMenus) return isDefaultMenu || get$g(registry.menus, menuName).exists((menu$1) => has$2(menu$1, "items"));
					else return isDefaultMenu;
				}), (menuName) => {
					const menuData = rawMenuData[menuName];
					return make({
						title: menuData.title,
						items: parseItemsString(menuData.items)
					}, registry, editor);
				}), (menu$1) => {
					const isNotSeparator = (item$1) => isString(item$1) || item$1.type !== "separator";
					return menu$1.getItems().length > 0 && exists(menu$1.getItems(), isNotSeparator);
				});
			};
			const fireSkinLoaded = (editor) => {
				const done = () => {
					editor._skinLoaded = true;
					fireSkinLoaded$1(editor);
				};
				return () => {
					if (editor.initialized) done();
					else editor.on("init", done);
				};
			};
			const fireSkinLoadError = (editor, err) => () => fireSkinLoadError$1(editor, { message: err });
			const loadStylesheet = (editor, stylesheetUrl, styleSheetLoader) => {
				editor.on("remove", () => styleSheetLoader.unload(stylesheetUrl));
				return styleSheetLoader.load(stylesheetUrl);
			};
			const loadUiSkins = (editor, skinUrl) => {
				return loadStylesheet(editor, skinUrl + "/skin.min.css", editor.ui.styleSheetLoader);
			};
			const loadShadowDomUiSkins = (editor, skinUrl) => {
				if (isInShadowRoot(SugarElement.fromDom(editor.getElement()))) return loadStylesheet(editor, skinUrl + "/skin.shadowdom.min.css", global$7.DOM.styleSheetLoader);
				else return Promise.resolve();
			};
			const loadSkin = (isInline, editor) => {
				const skinUrl = getSkinUrl(editor);
				if (skinUrl) editor.contentCSS.push(skinUrl + (isInline ? "/content.inline" : "/content") + ".min.css");
				if (!isSkinDisabled(editor) && isString(skinUrl)) return Promise.all([loadUiSkins(editor, skinUrl), loadShadowDomUiSkins(editor, skinUrl)]).then(fireSkinLoaded(editor), fireSkinLoadError(editor, "Skin could not be loaded"));
				else return Promise.resolve(fireSkinLoaded(editor)());
			};
			const iframe = curry(loadSkin, false);
			const inline = curry(loadSkin, true);
			const generateSelectItems = (_editor, backstage, spec) => {
				const generateItem = (rawItem, response, invalid, value$5) => {
					const translatedText = backstage.shared.providers.translate(rawItem.title);
					if (rawItem.type === "separator") return Optional.some({
						type: "separator",
						text: translatedText
					});
					else if (rawItem.type === "submenu") {
						const items = bind$3(rawItem.getStyleItems(), (si) => validate(si, response, value$5));
						if (response === 0 && items.length <= 0) return Optional.none();
						else return Optional.some({
							type: "nestedmenuitem",
							text: translatedText,
							enabled: items.length > 0,
							getSubmenuItems: () => bind$3(rawItem.getStyleItems(), (si) => validate(si, response, value$5))
						});
					} else return Optional.some({
						type: "togglemenuitem",
						text: translatedText,
						icon: rawItem.icon,
						active: rawItem.isSelected(value$5),
						enabled: !invalid,
						onAction: spec.onAction(rawItem),
						...rawItem.getStylePreview().fold(() => ({}), (preview) => ({ meta: { style: preview } }))
					});
				};
				const validate = (item$1, response, value$5) => {
					const invalid = item$1.type === "formatter" && spec.isInvalid(item$1);
					if (response === 0) return invalid ? [] : generateItem(item$1, response, false, value$5).toArray();
					else return generateItem(item$1, response, invalid, value$5).toArray();
				};
				const validateItems = (preItems) => {
					const value$5 = spec.getCurrentValue();
					const response = spec.shouldHide ? 0 : 1;
					return bind$3(preItems, (item$1) => validate(item$1, response, value$5));
				};
				const getFetch$2 = (backstage$1, getStyleItems) => (comp, callback) => {
					callback(build(validateItems(getStyleItems()), ItemResponse$1.CLOSE_ON_EXECUTE, backstage$1, {
						isHorizontalMenu: false,
						search: Optional.none()
					}));
				};
				return {
					validateItems,
					getFetch: getFetch$2
				};
			};
			const createMenuItems = (editor, backstage, spec) => {
				const dataset$1 = spec.dataset;
				const getStyleItems = dataset$1.type === "basic" ? () => map$2(dataset$1.data, (d) => processBasic(d, spec.isSelectedFor, spec.getPreviewFor)) : dataset$1.getData;
				return {
					items: generateSelectItems(editor, backstage, spec),
					getStyleItems
				};
			};
			const createSelectButton = (editor, backstage, spec) => {
				const { items, getStyleItems } = createMenuItems(editor, backstage, spec);
				const getApi$1 = (comp) => ({ getComponent: constant$1(comp) });
				const onSetup$1 = onSetupEvent(editor, "NodeChange", (api$3) => {
					const comp = api$3.getComponent();
					spec.updateText(comp);
					Disabling.set(api$3.getComponent(), !editor.selection.isEditable());
				});
				return renderCommonDropdown({
					text: spec.icon.isSome() ? Optional.none() : spec.text,
					icon: spec.icon,
					tooltip: Optional.from(spec.tooltip),
					role: Optional.none(),
					fetch: items.getFetch(backstage, getStyleItems),
					onSetup: onSetup$1,
					getApi: getApi$1,
					columns: 1,
					presets: "normal",
					classes: spec.icon.isSome() ? [] : ["bespoke"],
					dropdownBehaviours: []
				}, "tox-tbtn", backstage.shared);
			};
			const process = (rawFormats) => map$2(rawFormats, (item$1) => {
				let title$1 = item$1, format = item$1;
				const values$1 = item$1.split("=");
				if (values$1.length > 1) {
					title$1 = values$1[0];
					format = values$1[1];
				}
				return {
					title: title$1,
					format
				};
			});
			const buildBasicStaticDataset = (data) => ({
				type: "basic",
				data
			});
			var Delimiter;
			(function(Delimiter$1) {
				Delimiter$1[Delimiter$1["SemiColon"] = 0] = "SemiColon";
				Delimiter$1[Delimiter$1["Space"] = 1] = "Space";
			})(Delimiter || (Delimiter = {}));
			const split = (rawFormats, delimiter) => {
				if (delimiter === Delimiter.SemiColon) return rawFormats.replace(/;$/, "").split(";");
				else return rawFormats.split(" ");
			};
			const buildBasicSettingsDataset = (editor, settingName, delimiter) => {
				return {
					type: "basic",
					data: process(split(editor.options.get(settingName), delimiter))
				};
			};
			const alignMenuItems = [
				{
					title: "Left",
					icon: "align-left",
					format: "alignleft",
					command: "JustifyLeft"
				},
				{
					title: "Center",
					icon: "align-center",
					format: "aligncenter",
					command: "JustifyCenter"
				},
				{
					title: "Right",
					icon: "align-right",
					format: "alignright",
					command: "JustifyRight"
				},
				{
					title: "Justify",
					icon: "align-justify",
					format: "alignjustify",
					command: "JustifyFull"
				}
			];
			const getSpec$4 = (editor) => {
				const getMatchingValue = () => find$5(alignMenuItems, (item$1) => editor.formatter.match(item$1.format));
				const isSelectedFor = (format) => () => editor.formatter.match(format);
				const getPreviewFor = (_format) => Optional.none;
				const updateSelectMenuIcon = (comp) => {
					emitWith(comp, updateMenuIcon, { icon: `align-${getMatchingValue().fold(constant$1("left"), (item$1) => item$1.title.toLowerCase())}` });
				};
				const dataset$1 = buildBasicStaticDataset(alignMenuItems);
				const onAction$1 = (rawItem) => () => find$5(alignMenuItems, (item$1) => item$1.format === rawItem.format).each((item$1) => editor.execCommand(item$1.command));
				return {
					tooltip: "Align",
					text: Optional.none(),
					icon: Optional.some("align-left"),
					isSelectedFor,
					getCurrentValue: Optional.none,
					getPreviewFor,
					onAction: onAction$1,
					updateText: updateSelectMenuIcon,
					dataset: dataset$1,
					shouldHide: false,
					isInvalid: (item$1) => !editor.formatter.canApply(item$1.format)
				};
			};
			const createAlignButton = (editor, backstage) => createSelectButton(editor, backstage, getSpec$4(editor));
			const createAlignMenu = (editor, backstage) => {
				const menuItems = createMenuItems(editor, backstage, getSpec$4(editor));
				editor.ui.registry.addNestedMenuItem("align", {
					text: backstage.shared.providers.translate("Align"),
					onSetup: onSetupEditableToggle(editor),
					getSubmenuItems: () => menuItems.items.validateItems(menuItems.getStyleItems())
				});
			};
			const findNearest = (editor, getStyles) => {
				const styles = getStyles();
				const formats = map$2(styles, (style) => style.format);
				return Optional.from(editor.formatter.closest(formats)).bind((fmt) => find$5(styles, (data) => data.format === fmt)).orThunk(() => someIf(editor.formatter.match("p"), {
					title: "Paragraph",
					format: "p"
				}));
			};
			const getSpec$3 = (editor) => {
				const fallbackFormat = "Paragraph";
				const isSelectedFor = (format) => () => editor.formatter.match(format);
				const getPreviewFor = (format) => () => {
					const fmt = editor.formatter.get(format);
					if (fmt) return Optional.some({
						tag: fmt.length > 0 ? fmt[0].inline || fmt[0].block || "div" : "div",
						styles: editor.dom.parseStyle(editor.formatter.getCssText(format))
					});
					else return Optional.none();
				};
				const updateSelectMenuText = (comp) => {
					emitWith(comp, updateMenuText, { text: findNearest(editor, () => dataset$1.data).fold(constant$1(fallbackFormat), (fmt) => fmt.title) });
				};
				const dataset$1 = buildBasicSettingsDataset(editor, "block_formats", Delimiter.SemiColon);
				return {
					tooltip: "Blocks",
					text: Optional.some(fallbackFormat),
					icon: Optional.none(),
					isSelectedFor,
					getCurrentValue: Optional.none,
					getPreviewFor,
					onAction: onActionToggleFormat$1(editor),
					updateText: updateSelectMenuText,
					dataset: dataset$1,
					shouldHide: false,
					isInvalid: (item$1) => !editor.formatter.canApply(item$1.format)
				};
			};
			const createBlocksButton = (editor, backstage) => createSelectButton(editor, backstage, getSpec$3(editor));
			const createBlocksMenu = (editor, backstage) => {
				const menuItems = createMenuItems(editor, backstage, getSpec$3(editor));
				editor.ui.registry.addNestedMenuItem("blocks", {
					text: "Blocks",
					onSetup: onSetupEditableToggle(editor),
					getSubmenuItems: () => menuItems.items.validateItems(menuItems.getStyleItems())
				});
			};
			const systemStackFonts = [
				"-apple-system",
				"Segoe UI",
				"Roboto",
				"Helvetica Neue",
				"sans-serif"
			];
			const splitFonts = (fontFamily) => {
				return map$2(fontFamily.split(/\s*,\s*/), (font) => font.replace(/^['"]+|['"]+$/g, ""));
			};
			const isSystemFontStack = (fontFamily) => {
				const matchesSystemStack = () => {
					const fonts = splitFonts(fontFamily.toLowerCase());
					return forall(systemStackFonts, (font) => fonts.indexOf(font.toLowerCase()) > -1);
				};
				return fontFamily.indexOf("-apple-system") === 0 && matchesSystemStack();
			};
			const getSpec$2 = (editor) => {
				const systemFont = "System Font";
				const getMatchingValue = () => {
					const getFirstFont = (fontFamily$1) => fontFamily$1 ? splitFonts(fontFamily$1)[0] : "";
					const fontFamily = editor.queryCommandValue("FontName");
					const items = dataset$1.data;
					const font = fontFamily ? fontFamily.toLowerCase() : "";
					return {
						matchOpt: find$5(items, (item$1) => {
							const format = item$1.format;
							return format.toLowerCase() === font || getFirstFont(format).toLowerCase() === getFirstFont(font).toLowerCase();
						}).orThunk(() => {
							return someIf(isSystemFontStack(font), {
								title: systemFont,
								format: font
							});
						}),
						font: fontFamily
					};
				};
				const isSelectedFor = (item$1) => (valueOpt) => valueOpt.exists((value$5) => value$5.format === item$1);
				const getCurrentValue = () => {
					const { matchOpt } = getMatchingValue();
					return matchOpt;
				};
				const getPreviewFor = (item$1) => () => Optional.some({
					tag: "div",
					styles: item$1.indexOf("dings") === -1 ? { "font-family": item$1 } : {}
				});
				const onAction$1 = (rawItem) => () => {
					editor.undoManager.transact(() => {
						editor.focus();
						editor.execCommand("FontName", false, rawItem.format);
					});
				};
				const updateSelectMenuText = (comp) => {
					const { matchOpt, font } = getMatchingValue();
					emitWith(comp, updateMenuText, { text: matchOpt.fold(constant$1(font), (item$1) => item$1.title) });
				};
				const dataset$1 = buildBasicSettingsDataset(editor, "font_family_formats", Delimiter.SemiColon);
				return {
					tooltip: "Fonts",
					text: Optional.some(systemFont),
					icon: Optional.none(),
					isSelectedFor,
					getCurrentValue,
					getPreviewFor,
					onAction: onAction$1,
					updateText: updateSelectMenuText,
					dataset: dataset$1,
					shouldHide: false,
					isInvalid: never
				};
			};
			const createFontFamilyButton = (editor, backstage) => createSelectButton(editor, backstage, getSpec$2(editor));
			const createFontFamilyMenu = (editor, backstage) => {
				const menuItems = createMenuItems(editor, backstage, getSpec$2(editor));
				editor.ui.registry.addNestedMenuItem("fontfamily", {
					text: backstage.shared.providers.translate("Fonts"),
					onSetup: onSetupEditableToggle(editor),
					getSubmenuItems: () => menuItems.items.validateItems(menuItems.getStyleItems())
				});
			};
			const units = {
				unsupportedLength: [
					"em",
					"ex",
					"cap",
					"ch",
					"ic",
					"rem",
					"lh",
					"rlh",
					"vw",
					"vh",
					"vi",
					"vb",
					"vmin",
					"vmax",
					"cm",
					"mm",
					"Q",
					"in",
					"pc",
					"pt",
					"px"
				],
				fixed: ["px", "pt"],
				relative: ["%"],
				empty: [""]
			};
			const pattern = (() => {
				const decimalDigits = "[0-9]+";
				const exponentPart = "[eE]" + ("[+-]?" + decimalDigits);
				const dot = "\\.";
				const opt = (input$1) => `(?:${input$1})?`;
				const float = `[+-]?(?:${[
					"Infinity",
					decimalDigits + dot + opt(decimalDigits) + opt(exponentPart),
					dot + decimalDigits + opt(exponentPart),
					decimalDigits + opt(exponentPart)
				].join("|")})`;
				return /* @__PURE__ */ new RegExp(`^(${float})(.*)$`);
			})();
			const isUnit = (unit, accepted) => exists(accepted, (acc) => exists(units[acc], (check) => unit === check));
			const parse = (input$1, accepted) => {
				return Optional.from(pattern.exec(input$1)).bind((array) => {
					const value$5 = Number(array[1]);
					const unitRaw = array[2];
					if (isUnit(unitRaw, accepted)) return Optional.some({
						value: value$5,
						unit: unitRaw
					});
					else return Optional.none();
				});
			};
			const normalise = (input$1, accepted) => parse(input$1, accepted).map(({ value: value$5, unit }) => value$5 + unit);
			const Keys = {
				tab: constant$1(9),
				escape: constant$1(27),
				enter: constant$1(13),
				backspace: constant$1(8),
				delete: constant$1(46),
				left: constant$1(37),
				up: constant$1(38),
				right: constant$1(39),
				down: constant$1(40),
				space: constant$1(32),
				home: constant$1(36),
				end: constant$1(35),
				pageUp: constant$1(33),
				pageDown: constant$1(34)
			};
			const createBespokeNumberInput = (editor, backstage, spec) => {
				let currentComp = Optional.none();
				const getValueFromCurrentComp = (comp) => comp.map((alloyComp) => Representing.getValue(alloyComp)).getOr("");
				const onSetup$1 = onSetupEvent(editor, "NodeChange SwitchMode", (api$3) => {
					const comp = api$3.getComponent();
					currentComp = Optional.some(comp);
					spec.updateInputValue(comp);
					Disabling.set(comp, !editor.selection.isEditable());
				});
				const getApi$1 = (comp) => ({ getComponent: constant$1(comp) });
				const editorOffCell = Cell(noop);
				const customEvents = generate$6("custom-number-input-events");
				const changeValue = (f$1, fromInput, focusBack) => {
					const text$3 = getValueFromCurrentComp(currentComp);
					const newValue = spec.getNewValue(text$3, f$1);
					const lenghtDelta = text$3.length - `${newValue}`.length;
					const oldStart = currentComp.map((comp) => comp.element.dom.selectionStart - lenghtDelta);
					const oldEnd = currentComp.map((comp) => comp.element.dom.selectionEnd - lenghtDelta);
					spec.onAction(newValue, focusBack);
					currentComp.each((comp) => {
						Representing.setValue(comp, newValue);
						if (fromInput) {
							oldStart.each((oldStart$1) => comp.element.dom.selectionStart = oldStart$1);
							oldEnd.each((oldEnd$1) => comp.element.dom.selectionEnd = oldEnd$1);
						}
					});
				};
				const decrease = (fromInput, focusBack) => changeValue((n, s) => n - s, fromInput, focusBack);
				const increase = (fromInput, focusBack) => changeValue((n, s) => n + s, fromInput, focusBack);
				const goToParent = (comp) => parentElement(comp.element).fold(Optional.none, (parent$1) => {
					focus$3(parent$1);
					return Optional.some(true);
				});
				const focusInput = (comp) => {
					if (hasFocus(comp.element)) {
						firstChild(comp.element).each((input$1) => focus$3(input$1));
						return Optional.some(true);
					} else return Optional.none();
				};
				const makeStepperButton = (action, title$1, tooltip, classes$1) => {
					const translatedTooltip = backstage.shared.providers.translate(tooltip);
					const altExecuting = generate$6("altExecuting");
					const onSetup$2 = onSetupEvent(editor, "NodeChange SwitchMode", (api$3) => {
						Disabling.set(api$3.getComponent(), !editor.selection.isEditable());
					});
					const onClick = (comp) => {
						if (!Disabling.isDisabled(comp)) action(true);
					};
					return Button.sketch({
						dom: {
							tag: "button",
							attributes: {
								"title": translatedTooltip,
								"aria-label": translatedTooltip
							},
							classes: classes$1.concat(title$1)
						},
						components: [renderIconFromPack$1(title$1, backstage.shared.providers.icons)],
						buttonBehaviours: derive$1([Disabling.config({}), config(altExecuting, [
							onControlAttached({
								onSetup: onSetup$2,
								getApi: getApi$1
							}, editorOffCell),
							onControlDetached({ getApi: getApi$1 }, editorOffCell),
							run$1(keydown(), (comp, se) => {
								if (se.event.raw.keyCode === Keys.space() || se.event.raw.keyCode === Keys.enter()) {
									if (!Disabling.isDisabled(comp)) action(false);
								}
							}),
							run$1(click(), onClick),
							run$1(touchend(), onClick)
						])]),
						eventOrder: {
							[keydown()]: [altExecuting, "keying"],
							[click()]: [altExecuting, "alloy.base.behaviour"],
							[touchend()]: [altExecuting, "alloy.base.behaviour"]
						}
					});
				};
				const memMinus = record(makeStepperButton((focusBack) => decrease(false, focusBack), "minus", "Decrease font size", ["highlight-on-focus"]));
				const memPlus = record(makeStepperButton((focusBack) => increase(false, focusBack), "plus", "Increase font size", ["highlight-on-focus"]));
				const memInput = record({
					dom: {
						tag: "div",
						classes: ["tox-input-wrapper", "highlight-on-focus"]
					},
					components: [Input.sketch({ inputBehaviours: derive$1([
						Disabling.config({}),
						config(customEvents, [onControlAttached({
							onSetup: onSetup$1,
							getApi: getApi$1
						}, editorOffCell), onControlDetached({ getApi: getApi$1 }, editorOffCell)]),
						config("input-update-display-text", [
							run$1(updateMenuText, (comp, se) => {
								Representing.setValue(comp, se.event.text);
							}),
							run$1(focusout(), (comp) => {
								spec.onAction(Representing.getValue(comp));
							}),
							run$1(change(), (comp) => {
								spec.onAction(Representing.getValue(comp));
							})
						]),
						Keying.config({
							mode: "special",
							onEnter: (_comp) => {
								changeValue(identity, true, true);
								return Optional.some(true);
							},
							onEscape: goToParent,
							onUp: (_comp) => {
								increase(true, false);
								return Optional.some(true);
							},
							onDown: (_comp) => {
								decrease(true, false);
								return Optional.some(true);
							},
							onLeft: (_comp, se) => {
								se.cut();
								return Optional.none();
							},
							onRight: (_comp, se) => {
								se.cut();
								return Optional.none();
							}
						})
					]) })],
					behaviours: derive$1([
						Focusing.config({}),
						Keying.config({
							mode: "special",
							onEnter: focusInput,
							onSpace: focusInput,
							onEscape: goToParent
						}),
						config("input-wrapper-events", [run$1(mouseover(), (comp) => {
							each$1([memMinus, memPlus], (button$1) => {
								const buttonNode = SugarElement.fromDom(button$1.get(comp).element.dom);
								if (hasFocus(buttonNode)) blur$1(buttonNode);
							});
						})])
					])
				});
				return {
					dom: {
						tag: "div",
						classes: ["tox-number-input"]
					},
					components: [
						memMinus.asSpec(),
						memInput.asSpec(),
						memPlus.asSpec()
					],
					behaviours: derive$1([Focusing.config({}), Keying.config({
						mode: "flow",
						focusInside: FocusInsideModes.OnEnterOrSpaceMode,
						cycles: false,
						selector: "button, .tox-input-wrapper",
						onEscape: (wrapperComp) => {
							if (hasFocus(wrapperComp.element)) return Optional.none();
							else {
								focus$3(wrapperComp.element);
								return Optional.some(true);
							}
						}
					})])
				};
			};
			const legacyFontSizes = {
				"8pt": "1",
				"10pt": "2",
				"12pt": "3",
				"14pt": "4",
				"18pt": "5",
				"24pt": "6",
				"36pt": "7"
			};
			const keywordFontSizes = {
				"xx-small": "7pt",
				"x-small": "8pt",
				"small": "10pt",
				"medium": "12pt",
				"large": "14pt",
				"x-large": "18pt",
				"xx-large": "24pt"
			};
			const round = (number$1, precision) => {
				const factor = Math.pow(10, precision);
				return Math.round(number$1 * factor) / factor;
			};
			const toPt = (fontSize, precision) => {
				if (/[0-9.]+px$/.test(fontSize)) return round(parseInt(fontSize, 10) * 72 / 96, precision || 0) + "pt";
				else return get$g(keywordFontSizes, fontSize).getOr(fontSize);
			};
			const toLegacy = (fontSize) => get$g(legacyFontSizes, fontSize).getOr("");
			const getSpec$1 = (editor) => {
				const getMatchingValue = () => {
					let matchOpt = Optional.none();
					const items = dataset$1.data;
					const fontSize = editor.queryCommandValue("FontSize");
					if (fontSize) for (let precision = 3; matchOpt.isNone() && precision >= 0; precision--) {
						const pt = toPt(fontSize, precision);
						const legacy = toLegacy(pt);
						matchOpt = find$5(items, (item$1) => item$1.format === fontSize || item$1.format === pt || item$1.format === legacy);
					}
					return {
						matchOpt,
						size: fontSize
					};
				};
				const isSelectedFor = (item$1) => (valueOpt) => valueOpt.exists((value$5) => value$5.format === item$1);
				const getCurrentValue = () => {
					const { matchOpt } = getMatchingValue();
					return matchOpt;
				};
				const getPreviewFor = constant$1(Optional.none);
				const onAction$1 = (rawItem) => () => {
					editor.undoManager.transact(() => {
						editor.focus();
						editor.execCommand("FontSize", false, rawItem.format);
					});
				};
				const updateSelectMenuText = (comp) => {
					const { matchOpt, size } = getMatchingValue();
					emitWith(comp, updateMenuText, { text: matchOpt.fold(constant$1(size), (match) => match.title) });
				};
				const dataset$1 = buildBasicSettingsDataset(editor, "font_size_formats", Delimiter.Space);
				return {
					tooltip: "Font sizes",
					text: Optional.some("12pt"),
					icon: Optional.none(),
					isSelectedFor,
					getPreviewFor,
					getCurrentValue,
					onAction: onAction$1,
					updateText: updateSelectMenuText,
					dataset: dataset$1,
					shouldHide: false,
					isInvalid: never
				};
			};
			const createFontSizeButton = (editor, backstage) => createSelectButton(editor, backstage, getSpec$1(editor));
			const getConfigFromUnit = (unit) => {
				var _a;
				return (_a = {
					em: { step: .1 },
					cm: { step: .1 },
					in: { step: .1 },
					pc: { step: .1 },
					ch: { step: .1 },
					rem: { step: .1 }
				}[unit]) !== null && _a !== void 0 ? _a : { step: 1 };
			};
			const defaultValue = 16;
			const isValidValue = (value$5) => value$5 >= 0;
			const getNumberInputSpec = (editor) => {
				const getCurrentValue = () => editor.queryCommandValue("FontSize");
				const updateInputValue = (comp) => emitWith(comp, updateMenuText, { text: getCurrentValue() });
				return {
					updateInputValue,
					onAction: (format, focusBack) => editor.execCommand("FontSize", false, format, { skip_focus: !focusBack }),
					getNewValue: (text$3, updateFunction) => {
						parse(text$3, ["unsupportedLength", "empty"]);
						const parsedText = parse(text$3, ["unsupportedLength", "empty"]).or(parse(getCurrentValue(), ["unsupportedLength", "empty"]));
						const value$5 = parsedText.map((res) => res.value).getOr(defaultValue);
						const defaultUnit = getFontSizeInputDefaultUnit(editor);
						const unit = parsedText.map((res) => res.unit).filter((u) => u !== "").getOr(defaultUnit);
						const newValue = updateFunction(value$5, getConfigFromUnit(unit).step);
						return `${isValidValue(newValue) ? newValue : value$5}${unit}`;
					}
				};
			};
			const createFontSizeInputButton = (editor, backstage) => createBespokeNumberInput(editor, backstage, getNumberInputSpec(editor));
			const createFontSizeMenu = (editor, backstage) => {
				const menuItems = createMenuItems(editor, backstage, getSpec$1(editor));
				editor.ui.registry.addNestedMenuItem("fontsize", {
					text: "Font sizes",
					onSetup: onSetupEditableToggle(editor),
					getSubmenuItems: () => menuItems.items.validateItems(menuItems.getStyleItems())
				});
			};
			const getSpec = (editor, dataset$1) => {
				const fallbackFormat = "Paragraph";
				const isSelectedFor = (format) => () => editor.formatter.match(format);
				const getPreviewFor = (format) => () => {
					const fmt = editor.formatter.get(format);
					return fmt !== void 0 ? Optional.some({
						tag: fmt.length > 0 ? fmt[0].inline || fmt[0].block || "div" : "div",
						styles: editor.dom.parseStyle(editor.formatter.getCssText(format))
					}) : Optional.none();
				};
				const updateSelectMenuText = (comp) => {
					const getFormatItems = (fmt) => {
						if (isNestedFormat(fmt)) return bind$3(fmt.items, getFormatItems);
						else if (isFormatReference(fmt)) return [{
							title: fmt.title,
							format: fmt.format
						}];
						else return [];
					};
					emitWith(comp, updateMenuText, { text: findNearest(editor, constant$1(bind$3(getStyleFormats(editor), getFormatItems))).fold(constant$1(fallbackFormat), (fmt) => fmt.title) });
				};
				return {
					tooltip: "Formats",
					text: Optional.some(fallbackFormat),
					icon: Optional.none(),
					isSelectedFor,
					getCurrentValue: Optional.none,
					getPreviewFor,
					onAction: onActionToggleFormat$1(editor),
					updateText: updateSelectMenuText,
					shouldHide: shouldAutoHideStyleFormats(editor),
					isInvalid: (item$1) => !editor.formatter.canApply(item$1.format),
					dataset: dataset$1
				};
			};
			const createStylesButton = (editor, backstage) => {
				return createSelectButton(editor, backstage, getSpec(editor, {
					type: "advanced",
					...backstage.styles
				}));
			};
			const createStylesMenu = (editor, backstage) => {
				const menuItems = createMenuItems(editor, backstage, getSpec(editor, {
					type: "advanced",
					...backstage.styles
				}));
				editor.ui.registry.addNestedMenuItem("styles", {
					text: "Formats",
					onSetup: onSetupEditableToggle(editor),
					getSubmenuItems: () => menuItems.items.validateItems(menuItems.getStyleItems())
				});
			};
			const schema$7 = constant$1([
				required$1("toggleClass"),
				required$1("fetch"),
				onStrictHandler("onExecute"),
				defaulted("getHotspot", Optional.some),
				defaulted("getAnchorOverrides", constant$1({})),
				schema$y(),
				onStrictHandler("onItemExecute"),
				option$3("lazySink"),
				required$1("dom"),
				onHandler("onOpen"),
				field("splitDropdownBehaviours", [
					Coupling,
					Keying,
					Focusing
				]),
				defaulted("matchWidth", false),
				defaulted("useMinWidth", false),
				defaulted("eventOrder", {}),
				option$3("role")
			].concat(sandboxFields()));
			const parts$3 = constant$1([
				required({
					factory: Button,
					schema: [required$1("dom")],
					name: "arrow",
					defaults: () => {
						return { buttonBehaviours: derive$1([Focusing.revoke()]) };
					},
					overrides: (detail) => {
						return {
							dom: {
								tag: "span",
								attributes: { role: "presentation" }
							},
							action: (arrow) => {
								arrow.getSystem().getByUid(detail.uid).each(emitExecute);
							},
							buttonBehaviours: derive$1([Toggling.config({
								toggleOnExecute: false,
								toggleClass: detail.toggleClass
							})])
						};
					}
				}),
				required({
					factory: Button,
					schema: [required$1("dom")],
					name: "button",
					defaults: () => {
						return { buttonBehaviours: derive$1([Focusing.revoke()]) };
					},
					overrides: (detail) => {
						return {
							dom: {
								tag: "span",
								attributes: { role: "presentation" }
							},
							action: (btn) => {
								btn.getSystem().getByUid(detail.uid).each((splitDropdown) => {
									detail.onExecute(splitDropdown, btn);
								});
							}
						};
					}
				}),
				optional({
					factory: { sketch: (spec) => {
						return {
							uid: spec.uid,
							dom: {
								tag: "span",
								styles: { display: "none" },
								attributes: { "aria-hidden": "true" },
								innerHtml: spec.text
							}
						};
					} },
					schema: [required$1("text")],
					name: "aria-descriptor"
				}),
				external({
					schema: [tieredMenuMarkers()],
					name: "menu",
					defaults: (detail) => {
						return { onExecute: (tmenu, item$1) => {
							tmenu.getSystem().getByUid(detail.uid).each((splitDropdown) => {
								detail.onItemExecute(splitDropdown, tmenu, item$1);
							});
						} };
					}
				}),
				partType$1()
			]);
			const factory$5 = (detail, components$2, spec, externals) => {
				const switchToMenu = (sandbox) => {
					Composing.getCurrent(sandbox).each((current) => {
						Highlighting.highlightFirst(current);
						Keying.focusIn(current);
					});
				};
				const action = (component) => {
					togglePopup(detail, identity, component, externals, switchToMenu, HighlightOnOpen.HighlightMenuAndItem).get(noop);
				};
				const openMenu = (comp) => {
					action(comp);
					return Optional.some(true);
				};
				const executeOnButton = (comp) => {
					emitExecute(getPartOrDie(comp, detail, "button"));
					return Optional.some(true);
				};
				const buttonEvents = {
					...derive$2([runOnAttached((component, _simulatedEvent) => {
						getPart(component, detail, "aria-descriptor").each((descriptor) => {
							const descriptorId = generate$6("aria");
							set$9(descriptor.element, "id", descriptorId);
							set$9(component.element, "aria-describedby", descriptorId);
						});
					})]),
					...events$a(Optional.some(action))
				};
				return {
					uid: detail.uid,
					dom: detail.dom,
					components: components$2,
					apis: { repositionMenus: (comp) => {
						if (Toggling.isOn(comp)) repositionMenus(comp);
					} },
					eventOrder: {
						...detail.eventOrder,
						[execute$5()]: [
							"disabling",
							"toggling",
							"alloy.base.behaviour"
						]
					},
					events: buttonEvents,
					behaviours: augment(detail.splitDropdownBehaviours, [
						Coupling.config({ others: { sandbox: (hotspot) => {
							const arrow = getPartOrDie(hotspot, detail, "arrow");
							return makeSandbox$1(detail, hotspot, {
								onOpen: () => {
									Toggling.on(arrow);
									Toggling.on(hotspot);
								},
								onClose: () => {
									Toggling.off(arrow);
									Toggling.off(hotspot);
								}
							});
						} } }),
						Keying.config({
							mode: "special",
							onSpace: executeOnButton,
							onEnter: executeOnButton,
							onDown: openMenu
						}),
						Focusing.config({}),
						Toggling.config({
							toggleOnExecute: false,
							aria: { mode: "expanded" }
						})
					]),
					domModification: { attributes: {
						"role": detail.role.getOr("button"),
						"aria-haspopup": true
					} }
				};
			};
			const SplitDropdown = composite({
				name: "SplitDropdown",
				configFields: schema$7(),
				partFields: parts$3(),
				factory: factory$5,
				apis: { repositionMenus: (apis, comp) => apis.repositionMenus(comp) }
			});
			const getButtonApi = (component) => ({
				isEnabled: () => !Disabling.isDisabled(component),
				setEnabled: (state) => Disabling.set(component, !state),
				setText: (text$3) => emitWith(component, updateMenuText, { text: text$3 }),
				setIcon: (icon$1) => emitWith(component, updateMenuIcon, { icon: icon$1 })
			});
			const getToggleApi = (component) => ({
				setActive: (state) => {
					Toggling.set(component, state);
				},
				isActive: () => Toggling.isOn(component),
				isEnabled: () => !Disabling.isDisabled(component),
				setEnabled: (state) => Disabling.set(component, !state),
				setText: (text$3) => emitWith(component, updateMenuText, { text: text$3 }),
				setIcon: (icon$1) => emitWith(component, updateMenuIcon, { icon: icon$1 })
			});
			const getTooltipAttributes = (tooltip, providersBackstage) => tooltip.map((tooltip$1) => ({
				"aria-label": providersBackstage.translate(tooltip$1),
				"title": providersBackstage.translate(tooltip$1)
			})).getOr({});
			const focusButtonEvent = generate$6("focus-button");
			const renderCommonStructure = (optIcon, optText, tooltip, behaviours$1, providersBackstage) => {
				const optMemDisplayText = optText.map((text$3) => record(renderLabel$1(text$3, "tox-tbtn", providersBackstage)));
				const optMemDisplayIcon = optIcon.map((icon$1) => record(renderReplaceableIconFromPack(icon$1, providersBackstage.icons)));
				return {
					dom: {
						tag: "button",
						classes: ["tox-tbtn"].concat(optText.isSome() ? ["tox-tbtn--select"] : []),
						attributes: getTooltipAttributes(tooltip, providersBackstage)
					},
					components: componentRenderPipeline([optMemDisplayIcon.map((mem) => mem.asSpec()), optMemDisplayText.map((mem) => mem.asSpec())]),
					eventOrder: {
						[mousedown()]: [
							"focusing",
							"alloy.base.behaviour",
							commonButtonDisplayEvent
						],
						[attachedToDom()]: [commonButtonDisplayEvent, "toolbar-group-button-events"]
					},
					buttonBehaviours: derive$1([
						DisablingConfigs.toolbarButton(providersBackstage.isDisabled),
						receivingConfig(),
						config(commonButtonDisplayEvent, [
							runOnAttached((comp, _se) => forceInitialSize(comp)),
							run$1(updateMenuText, (comp, se) => {
								optMemDisplayText.bind((mem) => mem.getOpt(comp)).each((displayText) => {
									Replacing.set(displayText, [text$2(providersBackstage.translate(se.event.text))]);
								});
							}),
							run$1(updateMenuIcon, (comp, se) => {
								optMemDisplayIcon.bind((mem) => mem.getOpt(comp)).each((displayIcon) => {
									Replacing.set(displayIcon, [renderReplaceableIconFromPack(se.event.icon, providersBackstage.icons)]);
								});
							}),
							run$1(mousedown(), (button$1, se) => {
								se.event.prevent();
								emit(button$1, focusButtonEvent);
							})
						])
					].concat(behaviours$1.getOr([])))
				};
			};
			const renderFloatingToolbarButton = (spec, backstage, identifyButtons$1, attributes) => {
				const sharedBackstage = backstage.shared;
				const editorOffCell = Cell(noop);
				const specialisation = {
					toolbarButtonBehaviours: [],
					getApi: getButtonApi,
					onSetup: spec.onSetup
				};
				const behaviours$1 = [config("toolbar-group-button-events", [onControlAttached(specialisation, editorOffCell), onControlDetached(specialisation, editorOffCell)])];
				return FloatingToolbarButton.sketch({
					lazySink: sharedBackstage.getSink,
					fetch: () => Future.nu((resolve$1) => {
						resolve$1(map$2(identifyButtons$1(spec.items), renderToolbarGroup));
					}),
					markers: { toggledClass: "tox-tbtn--enabled" },
					parts: {
						button: renderCommonStructure(spec.icon, spec.text, spec.tooltip, Optional.some(behaviours$1), sharedBackstage.providers),
						toolbar: { dom: {
							tag: "div",
							classes: ["tox-toolbar__overflow"],
							attributes
						} }
					}
				});
			};
			const renderCommonToolbarButton = (spec, specialisation, providersBackstage) => {
				var _d;
				const editorOffCell = Cell(noop);
				const structure = renderCommonStructure(spec.icon, spec.text, spec.tooltip, Optional.none(), providersBackstage);
				return Button.sketch({
					dom: structure.dom,
					components: structure.components,
					eventOrder: toolbarButtonEventOrder,
					buttonBehaviours: {
						...derive$1([
							config("toolbar-button-events", [
								onToolbarButtonExecute({
									onAction: spec.onAction,
									getApi: specialisation.getApi
								}),
								onControlAttached(specialisation, editorOffCell),
								onControlDetached(specialisation, editorOffCell)
							]),
							DisablingConfigs.toolbarButton(() => !spec.enabled || providersBackstage.isDisabled()),
							receivingConfig()
						].concat(specialisation.toolbarButtonBehaviours)),
						[commonButtonDisplayEvent]: (_d = structure.buttonBehaviours) === null || _d === void 0 ? void 0 : _d[commonButtonDisplayEvent]
					}
				});
			};
			const renderToolbarButton = (spec, providersBackstage) => renderToolbarButtonWith(spec, providersBackstage, []);
			const renderToolbarButtonWith = (spec, providersBackstage, bonusEvents) => renderCommonToolbarButton(spec, {
				toolbarButtonBehaviours: bonusEvents.length > 0 ? [config("toolbarButtonWith", bonusEvents)] : [],
				getApi: getButtonApi,
				onSetup: spec.onSetup
			}, providersBackstage);
			const renderToolbarToggleButton = (spec, providersBackstage) => renderToolbarToggleButtonWith(spec, providersBackstage, []);
			const renderToolbarToggleButtonWith = (spec, providersBackstage, bonusEvents) => renderCommonToolbarButton(spec, {
				toolbarButtonBehaviours: [Replacing.config({}), Toggling.config({
					toggleClass: "tox-tbtn--enabled",
					aria: { mode: "pressed" },
					toggleOnExecute: false
				})].concat(bonusEvents.length > 0 ? [config("toolbarToggleButtonWith", bonusEvents)] : []),
				getApi: getToggleApi,
				onSetup: spec.onSetup
			}, providersBackstage);
			const fetchChoices = (getApi$1, spec, providersBackstage) => (comp) => Future.nu((callback) => spec.fetch(callback)).map((items) => Optional.from(createTieredDataFrom(deepMerge(createPartialChoiceMenu(generate$6("menu-value"), items, (value$5) => {
				spec.onItemAction(getApi$1(comp), value$5);
			}, spec.columns, spec.presets, ItemResponse$1.CLOSE_ON_EXECUTE, spec.select.getOr(never), providersBackstage), {
				movement: deriveMenuMovement(spec.columns, spec.presets),
				menuBehaviours: SimpleBehaviours.unnamedEvents(spec.columns !== "auto" ? [] : [runOnAttached((comp$1, _se) => {
					detectSize(comp$1, 4, classForPreset(spec.presets)).each(({ numRows, numColumns }) => {
						Keying.setGridSize(comp$1, numRows, numColumns);
					});
				})])
			}))));
			const renderSplitButton = (spec, sharedBackstage) => {
				const getApi$1 = (comp) => ({
					isEnabled: () => !Disabling.isDisabled(comp),
					setEnabled: (state) => Disabling.set(comp, !state),
					setIconFill: (id, value$5) => {
						descendant(comp.element, `svg path[class="${id}"], rect[class="${id}"]`).each((underlinePath) => {
							set$9(underlinePath, "fill", value$5);
						});
					},
					setActive: (state) => {
						set$9(comp.element, "aria-pressed", state);
						descendant(comp.element, "span").each((button$1) => {
							comp.getSystem().getByDom(button$1).each((buttonComp) => Toggling.set(buttonComp, state));
						});
					},
					isActive: () => descendant(comp.element, "span").exists((button$1) => comp.getSystem().getByDom(button$1).exists(Toggling.isOn)),
					setText: (text$3) => descendant(comp.element, "span").each((button$1) => comp.getSystem().getByDom(button$1).each((buttonComp) => emitWith(buttonComp, updateMenuText, { text: text$3 }))),
					setIcon: (icon$1) => descendant(comp.element, "span").each((button$1) => comp.getSystem().getByDom(button$1).each((buttonComp) => emitWith(buttonComp, updateMenuIcon, { icon: icon$1 })))
				});
				const editorOffCell = Cell(noop);
				const specialisation = {
					getApi: getApi$1,
					onSetup: spec.onSetup
				};
				return SplitDropdown.sketch({
					dom: {
						tag: "div",
						classes: ["tox-split-button"],
						attributes: {
							"aria-pressed": false,
							...getTooltipAttributes(spec.tooltip, sharedBackstage.providers)
						}
					},
					onExecute: (button$1) => {
						const api$3 = getApi$1(button$1);
						if (api$3.isEnabled()) spec.onAction(api$3);
					},
					onItemExecute: (_a, _b, _c) => {},
					splitDropdownBehaviours: derive$1([
						DisablingConfigs.splitButton(sharedBackstage.providers.isDisabled),
						receivingConfig(),
						config("split-dropdown-events", [
							runOnAttached((comp, _se) => forceInitialSize(comp)),
							run$1(focusButtonEvent, Focusing.focus),
							onControlAttached(specialisation, editorOffCell),
							onControlDetached(specialisation, editorOffCell)
						]),
						Unselecting.config({})
					]),
					eventOrder: { [attachedToDom()]: ["alloy.base.behaviour", "split-dropdown-events"] },
					toggleClass: "tox-tbtn--enabled",
					lazySink: sharedBackstage.getSink,
					fetch: fetchChoices(getApi$1, spec, sharedBackstage.providers),
					parts: { menu: part(false, spec.columns, spec.presets) },
					components: [
						SplitDropdown.parts.button(renderCommonStructure(spec.icon, spec.text, Optional.none(), Optional.some([Toggling.config({
							toggleClass: "tox-tbtn--enabled",
							toggleOnExecute: false
						})]), sharedBackstage.providers)),
						SplitDropdown.parts.arrow({
							dom: {
								tag: "button",
								classes: ["tox-tbtn", "tox-split-button__chevron"],
								innerHtml: get$2("chevron-down", sharedBackstage.providers.icons)
							},
							buttonBehaviours: derive$1([
								DisablingConfigs.splitButton(sharedBackstage.providers.isDisabled),
								receivingConfig(),
								addFocusableBehaviour()
							])
						}),
						SplitDropdown.parts["aria-descriptor"]({ text: sharedBackstage.providers.translate("To open the popup, press Shift+Enter") })
					]
				});
			};
			const defaultToolbar = [
				{
					name: "history",
					items: ["undo", "redo"]
				},
				{
					name: "ai",
					items: ["aidialog", "aishortcuts"]
				},
				{
					name: "styles",
					items: ["styles"]
				},
				{
					name: "formatting",
					items: ["bold", "italic"]
				},
				{
					name: "alignment",
					items: [
						"alignleft",
						"aligncenter",
						"alignright",
						"alignjustify"
					]
				},
				{
					name: "indentation",
					items: ["outdent", "indent"]
				},
				{
					name: "permanent pen",
					items: ["permanentpen"]
				},
				{
					name: "comments",
					items: ["addcomment"]
				}
			];
			const renderFromBridge = (bridgeBuilder, render$4) => (spec, backstage, editor) => {
				return render$4(bridgeBuilder(spec).mapError((errInfo) => formatError(errInfo)).getOrDie(), backstage, editor);
			};
			const types = {
				button: renderFromBridge(createToolbarButton, (s, backstage) => renderToolbarButton(s, backstage.shared.providers)),
				togglebutton: renderFromBridge(createToggleButton, (s, backstage) => renderToolbarToggleButton(s, backstage.shared.providers)),
				menubutton: renderFromBridge(createMenuButton, (s, backstage) => renderMenuButton(s, "tox-tbtn", backstage, Optional.none(), false)),
				splitbutton: renderFromBridge(createSplitButton, (s, backstage) => renderSplitButton(s, backstage.shared)),
				grouptoolbarbutton: renderFromBridge(createGroupToolbarButton, (s, backstage, editor) => {
					const buttons = editor.ui.registry.getAll().buttons;
					const identify = (toolbar) => identifyButtons(editor, {
						buttons,
						toolbar,
						allowToolbarGroups: false
					}, backstage, Optional.none());
					const attributes = { [Attribute]: backstage.shared.header.isPositionedAtTop() ? AttributeValue.TopToBottom : AttributeValue.BottomToTop };
					switch (getToolbarMode(editor)) {
						case ToolbarMode$1.floating: return renderFloatingToolbarButton(s, backstage, identify, attributes);
						default: throw new Error("Toolbar groups are only supported when using floating toolbar mode");
					}
				})
			};
			const extractFrom = (spec, backstage, editor) => get$g(types, spec.type).fold(() => {
				console.error("skipping button defined by", spec);
				return Optional.none();
			}, (render$4) => Optional.some(render$4(spec, backstage, editor)));
			const bespokeButtons = {
				styles: createStylesButton,
				fontsize: createFontSizeButton,
				fontsizeinput: createFontSizeInputButton,
				fontfamily: createFontFamilyButton,
				blocks: createBlocksButton,
				align: createAlignButton
			};
			const removeUnusedDefaults = (buttons) => {
				return filter$2(map$2(defaultToolbar, (group$1) => {
					const items = filter$2(group$1.items, (subItem) => has$2(buttons, subItem) || has$2(bespokeButtons, subItem));
					return {
						name: group$1.name,
						items
					};
				}), (group$1) => group$1.items.length > 0);
			};
			const convertStringToolbar = (strToolbar) => {
				return map$2(strToolbar.split("|"), (g) => ({ items: g.trim().split(" ") }));
			};
			const isToolbarGroupSettingArray = (toolbar) => isArrayOf(toolbar, (t$1) => has$2(t$1, "name") && has$2(t$1, "items"));
			const createToolbar = (toolbarConfig) => {
				const toolbar = toolbarConfig.toolbar;
				const buttons = toolbarConfig.buttons;
				if (toolbar === false) return [];
				else if (toolbar === void 0 || toolbar === true) return removeUnusedDefaults(buttons);
				else if (isString(toolbar)) return convertStringToolbar(toolbar);
				else if (isToolbarGroupSettingArray(toolbar)) return toolbar;
				else {
					console.error("Toolbar type should be string, string[], boolean or ToolbarGroup[]");
					return [];
				}
			};
			const lookupButton = (editor, buttons, toolbarItem, allowToolbarGroups, backstage, prefixes) => get$g(buttons, toolbarItem.toLowerCase()).orThunk(() => prefixes.bind((ps) => findMap(ps, (prefix$2) => get$g(buttons, prefix$2 + toolbarItem.toLowerCase())))).fold(() => get$g(bespokeButtons, toolbarItem.toLowerCase()).map((r$2) => r$2(editor, backstage)), (spec) => {
				if (spec.type === "grouptoolbarbutton" && !allowToolbarGroups) {
					console.warn(`Ignoring the '${toolbarItem}' toolbar button. Group toolbar buttons are only supported when using floating toolbar mode and cannot be nested.`);
					return Optional.none();
				} else return extractFrom(spec, backstage, editor);
			});
			const identifyButtons = (editor, toolbarConfig, backstage, prefixes) => {
				return filter$2(map$2(createToolbar(toolbarConfig), (group$1) => {
					const items = bind$3(group$1.items, (toolbarItem) => {
						return toolbarItem.trim().length === 0 ? [] : lookupButton(editor, toolbarConfig.buttons, toolbarItem, toolbarConfig.allowToolbarGroups, backstage, prefixes).toArray();
					});
					return {
						title: Optional.from(editor.translate(group$1.name)),
						items
					};
				}), (group$1) => group$1.items.length > 0);
			};
			const setToolbar = (editor, uiRefs, rawUiConfig, backstage) => {
				const outerContainer = uiRefs.mainUi.outerContainer;
				const toolbarConfig = rawUiConfig.toolbar;
				const toolbarButtonsConfig = rawUiConfig.buttons;
				if (isArrayOf(toolbarConfig, isString)) {
					const toolbars = toolbarConfig.map((t$1) => {
						return identifyButtons(editor, {
							toolbar: t$1,
							buttons: toolbarButtonsConfig,
							allowToolbarGroups: rawUiConfig.allowToolbarGroups
						}, backstage, Optional.none());
					});
					OuterContainer.setToolbars(outerContainer, toolbars);
				} else OuterContainer.setToolbar(outerContainer, identifyButtons(editor, rawUiConfig, backstage, Optional.none()));
			};
			const detection = detect$2();
			const isiOS12 = detection.os.isiOS() && detection.os.version.major <= 12;
			const setupEvents$1 = (editor, uiRefs) => {
				const { uiMotherships } = uiRefs;
				const dom$3 = editor.dom;
				let contentWindow = editor.getWin();
				const initialDocEle = editor.getDoc().documentElement;
				const lastWindowDimensions = Cell(SugarPosition(contentWindow.innerWidth, contentWindow.innerHeight));
				const lastDocumentDimensions = Cell(SugarPosition(initialDocEle.offsetWidth, initialDocEle.offsetHeight));
				const resizeWindow = () => {
					const outer = lastWindowDimensions.get();
					if (outer.left !== contentWindow.innerWidth || outer.top !== contentWindow.innerHeight) {
						lastWindowDimensions.set(SugarPosition(contentWindow.innerWidth, contentWindow.innerHeight));
						fireResizeContent(editor);
					}
				};
				const resizeDocument = () => {
					const docEle = editor.getDoc().documentElement;
					const inner = lastDocumentDimensions.get();
					if (inner.left !== docEle.offsetWidth || inner.top !== docEle.offsetHeight) {
						lastDocumentDimensions.set(SugarPosition(docEle.offsetWidth, docEle.offsetHeight));
						fireResizeContent(editor);
					}
				};
				const scroll = (e) => {
					fireScrollContent(editor, e);
				};
				dom$3.bind(contentWindow, "resize", resizeWindow);
				dom$3.bind(contentWindow, "scroll", scroll);
				const elementLoad = capture(SugarElement.fromDom(editor.getBody()), "load", resizeDocument);
				editor.on("hide", () => {
					each$1(uiMotherships, (m) => {
						set$8(m.element, "display", "none");
					});
				});
				editor.on("show", () => {
					each$1(uiMotherships, (m) => {
						remove$6(m.element, "display");
					});
				});
				editor.on("NodeChange", resizeDocument);
				editor.on("remove", () => {
					elementLoad.unbind();
					dom$3.unbind(contentWindow, "resize", resizeWindow);
					dom$3.unbind(contentWindow, "scroll", scroll);
					contentWindow = null;
				});
			};
			const attachUiMotherships = (editor, uiRoot, uiRefs) => {
				if (isSplitUiMode(editor)) attachSystemAfter(uiRefs.mainUi.mothership.element, uiRefs.popupUi.mothership);
				attachSystem(uiRoot, uiRefs.dialogUi.mothership);
			};
			const render$1 = async (editor, uiRefs, rawUiConfig, backstage, args) => {
				const { mainUi, uiMotherships } = uiRefs;
				const lastToolbarWidth = Cell(0);
				const outerContainer = mainUi.outerContainer;
				await iframe(editor);
				const eTargetNode = SugarElement.fromDom(args.targetNode);
				const uiRoot = getContentContainer(getRootNode(eTargetNode));
				attachSystemAfter(eTargetNode, mainUi.mothership);
				attachUiMotherships(editor, uiRoot, uiRefs);
				editor.on("PostRender", () => {
					OuterContainer.setSidebar(outerContainer, rawUiConfig.sidebar, getSidebarShow(editor));
					setToolbar(editor, uiRefs, rawUiConfig, backstage);
					lastToolbarWidth.set(editor.getWin().innerWidth);
					OuterContainer.setMenubar(outerContainer, identifyMenus(editor, rawUiConfig));
					OuterContainer.setViews(outerContainer, rawUiConfig.views);
					setupEvents$1(editor, uiRefs);
				});
				const socket = OuterContainer.getSocket(outerContainer).getOrDie("Could not find expected socket element");
				if (isiOS12) {
					setAll(socket.element, {
						"overflow": "scroll",
						"-webkit-overflow-scrolling": "touch"
					});
					const limit = first(() => {
						editor.dispatch("ScrollContent");
					}, 20);
					const unbinder = bind(socket.element, "scroll", limit.throttle);
					editor.on("remove", unbinder.unbind);
				}
				setupReadonlyModeSwitch(editor, uiRefs);
				editor.addCommand("ToggleSidebar", (_ui, value$5) => {
					OuterContainer.toggleSidebar(outerContainer, value$5);
					editor.dispatch("ToggleSidebar");
				});
				editor.addQueryValueHandler("ToggleSidebar", () => {
					var _a;
					return (_a = OuterContainer.whichSidebar(outerContainer)) !== null && _a !== void 0 ? _a : "";
				});
				editor.addCommand("ToggleView", (_ui, value$5) => {
					if (OuterContainer.toggleView(outerContainer, value$5)) {
						const target = outerContainer.element;
						mainUi.mothership.broadcastOn([dismissPopups()], { target });
						each$1(uiMotherships, (m) => {
							m.broadcastOn([dismissPopups()], { target });
						});
						if (isNull(OuterContainer.whichView(outerContainer))) {
							editor.focus();
							editor.nodeChanged();
							OuterContainer.refreshToolbar(outerContainer);
						}
					}
				});
				editor.addQueryValueHandler("ToggleView", () => {
					var _a;
					return (_a = OuterContainer.whichView(outerContainer)) !== null && _a !== void 0 ? _a : "";
				});
				const toolbarMode = getToolbarMode(editor);
				const refreshDrawer = () => {
					OuterContainer.refreshToolbar(uiRefs.mainUi.outerContainer);
				};
				if (toolbarMode === ToolbarMode$1.sliding || toolbarMode === ToolbarMode$1.floating) editor.on("ResizeWindow ResizeEditor ResizeContent", () => {
					const width$1 = editor.getWin().innerWidth;
					if (width$1 !== lastToolbarWidth.get()) {
						refreshDrawer();
						lastToolbarWidth.set(width$1);
					}
				});
				return {
					iframeContainer: socket.element.dom,
					editorContainer: outerContainer.element.dom,
					api: {
						setEnabled: (state) => {
							broadcastReadonly(uiRefs, !state);
						},
						isEnabled: () => !Disabling.isDisabled(outerContainer)
					}
				};
			};
			var Iframe = /* @__PURE__ */ Object.freeze({
				__proto__: null,
				render: render$1
			});
			const parseToInt = (val) => {
				if (/^[0-9\.]+(|px)$/i.test("" + val)) return Optional.some(parseInt("" + val, 10));
				return Optional.none();
			};
			const numToPx = (val) => isNumber(val) ? val + "px" : val;
			const calcCappedSize = (size, minSize, maxSize) => {
				const minOverride = minSize.filter((min$1) => size < min$1);
				const maxOverride = maxSize.filter((max$1) => size > max$1);
				return minOverride.or(maxOverride).getOr(size);
			};
			const getHeight = (editor) => {
				const baseHeight = getHeightOption(editor);
				const minHeight = getMinHeightOption(editor);
				const maxHeight = getMaxHeightOption(editor);
				return parseToInt(baseHeight).map((height$1) => calcCappedSize(height$1, minHeight, maxHeight));
			};
			const getHeightWithFallback = (editor) => {
				return getHeight(editor).getOr(getHeightOption(editor));
			};
			const getWidth = (editor) => {
				const baseWidth = getWidthOption(editor);
				const minWidth = getMinWidthOption(editor);
				const maxWidth = getMaxWidthOption(editor);
				return parseToInt(baseWidth).map((width$1) => calcCappedSize(width$1, minWidth, maxWidth));
			};
			const getWidthWithFallback = (editor) => {
				return getWidth(editor).getOr(getWidthOption(editor));
			};
			const { ToolbarLocation, ToolbarMode } = Options;
			const maximumDistanceToEdge = 40;
			const InlineHeader = (editor, targetElm, uiRefs, backstage, floatContainer) => {
				const { mainUi, uiMotherships } = uiRefs;
				const DOM = global$7.DOM;
				const useFixedToolbarContainer = useFixedContainer(editor);
				const isSticky = isStickyToolbar(editor);
				const editorMaxWidthOpt = getMaxWidthOption(editor).or(getWidth(editor));
				const headerBackstage = backstage.shared.header;
				const isPositionedAtTop = headerBackstage.isPositionedAtTop;
				const toolbarMode = getToolbarMode(editor);
				const isSplitToolbar = toolbarMode === ToolbarMode.sliding || toolbarMode === ToolbarMode.floating;
				const visible = Cell(false);
				const isVisible$1 = () => visible.get() && !editor.removed;
				const calcToolbarOffset = (toolbar) => isSplitToolbar ? toolbar.fold(constant$1(0), (tbar) => tbar.components().length > 1 ? get$d(tbar.components()[1].element) : 0) : 0;
				const calcMode = (container) => {
					switch (getToolbarLocation(editor)) {
						case ToolbarLocation.auto:
							const offset$1 = calcToolbarOffset(OuterContainer.getToolbar(mainUi.outerContainer));
							const toolbarHeight = get$d(container.element) - offset$1;
							const targetBounds = box$1(targetElm);
							if (targetBounds.y > toolbarHeight) return "top";
							else {
								const doc = documentElement(targetElm);
								const docHeight = Math.max(doc.dom.scrollHeight, get$d(doc));
								if (targetBounds.bottom < docHeight - toolbarHeight) return "bottom";
								else return win().bottom < targetBounds.bottom - toolbarHeight ? "bottom" : "top";
							}
						case ToolbarLocation.bottom: return "bottom";
						case ToolbarLocation.top:
						default: return "top";
					}
				};
				const setupMode = (mode) => {
					floatContainer.on((container) => {
						Docking.setModes(container, [mode]);
						headerBackstage.setDockingMode(mode);
						const verticalDir = isPositionedAtTop() ? AttributeValue.TopToBottom : AttributeValue.BottomToTop;
						set$9(container.element, Attribute, verticalDir);
					});
				};
				const updateChromeWidth = () => {
					floatContainer.on((container) => {
						const maxWidth = editorMaxWidthOpt.getOrThunk(() => {
							const bodyMargin = parseToInt(get$e(body(), "margin-left")).getOr(0);
							return get$c(body()) - absolute$3(targetElm).left + bodyMargin;
						});
						set$8(container.element, "max-width", maxWidth + "px");
					});
				};
				const updateChromePosition = (optToolbarWidth) => {
					floatContainer.on((container) => {
						const offset$1 = calcToolbarOffset(OuterContainer.getToolbar(mainUi.outerContainer));
						const targetBounds = box$1(targetElm);
						const { top: top$1, left: left$1 } = getOffsetParent$1(editor, mainUi.outerContainer.element).fold(() => {
							return {
								top: isPositionedAtTop() ? Math.max(targetBounds.y - get$d(container.element) + offset$1, 0) : targetBounds.bottom,
								left: targetBounds.x
							};
						}, (offsetParent$1) => {
							var _a;
							const offsetBox = box$1(offsetParent$1);
							const scrollDelta = (_a = offsetParent$1.dom.scrollTop) !== null && _a !== void 0 ? _a : 0;
							const isOffsetParentBody = eq(offsetParent$1, body());
							const topValue = isOffsetParentBody ? Math.max(targetBounds.y - get$d(container.element) + offset$1, 0) : targetBounds.y - offsetBox.y + scrollDelta - get$d(container.element) + offset$1;
							return {
								top: isPositionedAtTop() ? topValue : targetBounds.bottom,
								left: isOffsetParentBody ? targetBounds.x : targetBounds.x - offsetBox.x
							};
						});
						const baseProperties = {
							position: "absolute",
							left: Math.round(left$1) + "px",
							top: Math.round(top$1) + "px"
						};
						const widthProperties = optToolbarWidth.map((toolbarWidth) => {
							const scroll = get$b();
							const minimumToolbarWidth = 150;
							const availableWidth = window.innerWidth - (left$1 - scroll.left);
							return { width: Math.max(Math.min(toolbarWidth, availableWidth), minimumToolbarWidth) + "px" };
						}).getOr({});
						setAll(mainUi.outerContainer.element, {
							...baseProperties,
							...widthProperties
						});
					});
				};
				const getOffsetParent$1 = (editor$1, element$1) => isSplitUiMode(editor$1) ? getOffsetParent(element$1) : Optional.none();
				const repositionPopups$1 = () => {
					each$1(uiMotherships, (m) => {
						m.broadcastOn([repositionPopups()], {});
					});
				};
				const restoreAndGetCompleteOuterContainerWidth = () => {
					if (!useFixedToolbarContainer) if (absolute$3(mainUi.outerContainer.element).left + getOuter$1(mainUi.outerContainer.element) >= window.innerWidth - maximumDistanceToEdge || getRaw(mainUi.outerContainer.element, "width").isSome()) {
						set$8(mainUi.outerContainer.element, "position", "absolute");
						set$8(mainUi.outerContainer.element, "left", "0px");
						remove$6(mainUi.outerContainer.element, "width");
						const w = getOuter$1(mainUi.outerContainer.element);
						return Optional.some(w);
					} else return Optional.none();
					else return Optional.none();
				};
				const update = (stickyAction) => {
					if (!isVisible$1()) return;
					if (!useFixedToolbarContainer) updateChromeWidth();
					const optToolbarWidth = useFixedToolbarContainer ? Optional.none() : restoreAndGetCompleteOuterContainerWidth();
					if (isSplitToolbar) OuterContainer.refreshToolbar(mainUi.outerContainer);
					if (!useFixedToolbarContainer) updateChromePosition(optToolbarWidth);
					if (isSticky) floatContainer.on(stickyAction);
					repositionPopups$1();
				};
				const doUpdateMode = () => {
					if (useFixedToolbarContainer || !isSticky || !isVisible$1()) return false;
					return floatContainer.get().exists((fc) => {
						const currentMode = headerBackstage.getDockingMode();
						const newMode = calcMode(fc);
						if (newMode !== currentMode) {
							setupMode(newMode);
							return true;
						} else return false;
					});
				};
				const show$1 = () => {
					visible.set(true);
					set$8(mainUi.outerContainer.element, "display", "flex");
					DOM.addClass(editor.getBody(), "mce-edit-focus");
					each$1(uiMotherships, (m) => {
						remove$6(m.element, "display");
					});
					doUpdateMode();
					if (isSplitUiMode(editor)) update((elem) => Docking.isDocked(elem) ? Docking.reset(elem) : Docking.refresh(elem));
					else update(Docking.refresh);
				};
				const hide = () => {
					visible.set(false);
					set$8(mainUi.outerContainer.element, "display", "none");
					DOM.removeClass(editor.getBody(), "mce-edit-focus");
					each$1(uiMotherships, (m) => {
						set$8(m.element, "display", "none");
					});
				};
				const updateMode = () => {
					if (doUpdateMode()) update(Docking.reset);
				};
				return {
					isVisible: isVisible$1,
					isPositionedAtTop,
					show: show$1,
					hide,
					update,
					updateMode,
					repositionPopups: repositionPopups$1
				};
			};
			const getTargetPosAndBounds = (targetElm, isToolbarTop) => {
				const bounds$2 = box$1(targetElm);
				return {
					pos: isToolbarTop ? bounds$2.y : bounds$2.bottom,
					bounds: bounds$2
				};
			};
			const setupEvents = (editor, targetElm, ui, toolbarPersist) => {
				const prevPosAndBounds = Cell(getTargetPosAndBounds(targetElm, ui.isPositionedAtTop()));
				const resizeContent = (e) => {
					const { pos, bounds: bounds$2 } = getTargetPosAndBounds(targetElm, ui.isPositionedAtTop());
					const { pos: prevPos, bounds: prevBounds } = prevPosAndBounds.get();
					const hasResized = bounds$2.height !== prevBounds.height || bounds$2.width !== prevBounds.width;
					prevPosAndBounds.set({
						pos,
						bounds: bounds$2
					});
					if (hasResized) fireResizeContent(editor, e);
					if (ui.isVisible()) {
						if (prevPos !== pos) ui.update(Docking.reset);
						else if (hasResized) {
							ui.updateMode();
							ui.repositionPopups();
						}
					}
				};
				if (!toolbarPersist) {
					editor.on("activate", ui.show);
					editor.on("deactivate", ui.hide);
				}
				editor.on("SkinLoaded ResizeWindow", () => ui.update(Docking.reset));
				editor.on("NodeChange keydown", (e) => {
					requestAnimationFrame(() => resizeContent(e));
				});
				let lastScrollX = 0;
				const updateUi = last(() => ui.update(Docking.refresh), 33);
				editor.on("ScrollWindow", () => {
					const newScrollX = get$b().left;
					if (newScrollX !== lastScrollX) {
						lastScrollX = newScrollX;
						updateUi.throttle();
					}
					ui.updateMode();
				});
				if (isSplitUiMode(editor)) editor.on("ElementScroll", (_args) => {
					ui.update(Docking.refresh);
				});
				const elementLoad = unbindable();
				elementLoad.set(capture(SugarElement.fromDom(editor.getBody()), "load", (e) => resizeContent(e.raw)));
				editor.on("remove", () => {
					elementLoad.clear();
				});
			};
			const render = async (editor, uiRefs, rawUiConfig, backstage, args) => {
				const { mainUi } = uiRefs;
				const floatContainer = value$2();
				const targetElm = SugarElement.fromDom(args.targetNode);
				const ui = InlineHeader(editor, targetElm, uiRefs, backstage, floatContainer);
				const toolbarPersist = isToolbarPersist(editor);
				await inline(editor);
				const render$4 = () => {
					if (floatContainer.isSet()) {
						ui.show();
						return;
					}
					floatContainer.set(OuterContainer.getHeader(mainUi.outerContainer).getOrDie());
					const uiContainer = getUiContainer(editor);
					if (isSplitUiMode(editor)) {
						attachSystemAfter(targetElm, mainUi.mothership);
						attachSystemAfter(targetElm, uiRefs.popupUi.mothership);
					} else attachSystem(uiContainer, mainUi.mothership);
					attachSystem(uiContainer, uiRefs.dialogUi.mothership);
					setToolbar(editor, uiRefs, rawUiConfig, backstage);
					OuterContainer.setMenubar(mainUi.outerContainer, identifyMenus(editor, rawUiConfig));
					ui.show();
					setupEvents(editor, targetElm, ui, toolbarPersist);
					editor.nodeChanged();
				};
				editor.on("show", render$4);
				editor.on("hide", ui.hide);
				if (!toolbarPersist) {
					editor.on("focus", render$4);
					editor.on("blur", ui.hide);
				}
				editor.on("init", () => {
					if (editor.hasFocus() || toolbarPersist) render$4();
				});
				setupReadonlyModeSwitch(editor, uiRefs);
				const api$3 = {
					show: render$4,
					hide: ui.hide,
					setEnabled: (state) => {
						broadcastReadonly(uiRefs, !state);
					},
					isEnabled: () => !Disabling.isDisabled(mainUi.outerContainer)
				};
				return {
					editorContainer: mainUi.outerContainer.element.dom,
					api: api$3
				};
			};
			var Inline = /* @__PURE__ */ Object.freeze({
				__proto__: null,
				render
			});
			const LazyUiReferences = () => {
				const dialogUi = value$2();
				const popupUi = value$2();
				const mainUi = value$2();
				const lazyGetInOuterOrDie = (label$1, f$1) => () => mainUi.get().bind((oc) => f$1(oc.outerContainer)).getOrDie(`Could not find ${label$1} element in OuterContainer`);
				const getUiMotherships = () => {
					const optDialogMothership = dialogUi.get().map((ui) => ui.mothership);
					const optPopupMothership = popupUi.get().map((ui) => ui.mothership);
					return optDialogMothership.fold(() => optPopupMothership.toArray(), (dm) => optPopupMothership.fold(() => [dm], (pm) => eq(dm.element, pm.element) ? [dm] : [dm, pm]));
				};
				return {
					dialogUi,
					popupUi,
					mainUi,
					getUiMotherships,
					lazyGetInOuterOrDie
				};
			};
			const showContextToolbarEvent = "contexttoolbar-show";
			const hideContextToolbarEvent = "contexttoolbar-hide";
			const getFormApi = (input$1) => ({
				hide: () => emit(input$1, sandboxClose()),
				getValue: () => Representing.getValue(input$1)
			});
			const runOnExecute = (memInput, original$1) => run$1(internalToolbarButtonExecute, (comp, se) => {
				const formApi = getFormApi(memInput.get(comp));
				original$1.onAction(formApi, se.event.buttonApi);
			});
			const renderContextButton = (memInput, button$1, providers) => {
				const { primary: primary$1, ...rest } = button$1.original;
				return renderToolbarButtonWith(getOrDie(createToolbarButton({
					...rest,
					type: "button",
					onAction: noop
				})), providers, [runOnExecute(memInput, button$1)]);
			};
			const renderContextToggleButton = (memInput, button$1, providers) => {
				const { primary: primary$1, ...rest } = button$1.original;
				return renderToolbarToggleButtonWith(getOrDie(createToggleButton({
					...rest,
					type: "togglebutton",
					onAction: noop
				})), providers, [runOnExecute(memInput, button$1)]);
			};
			const isToggleButton = (button$1) => button$1.type === "contextformtogglebutton";
			const generateOne = (memInput, button$1, providersBackstage) => {
				if (isToggleButton(button$1)) return renderContextToggleButton(memInput, button$1, providersBackstage);
				else return renderContextButton(memInput, button$1, providersBackstage);
			};
			const generate = (memInput, buttons, providersBackstage) => {
				const mementos = map$2(buttons, (button$1) => record(generateOne(memInput, button$1, providersBackstage)));
				const asSpecs = () => map$2(mementos, (mem) => mem.asSpec());
				const findPrimary = (compInSystem) => findMap(buttons, (button$1, i) => {
					if (button$1.primary) return Optional.from(mementos[i]).bind((mem) => mem.getOpt(compInSystem)).filter(not(Disabling.isDisabled));
					else return Optional.none();
				});
				return {
					asSpecs,
					findPrimary
				};
			};
			const buildInitGroups = (ctx, providers) => {
				const inputAttributes = ctx.label.fold(() => ({}), (label$1) => ({ "aria-label": label$1 }));
				const memInput = record(Input.sketch({
					inputClasses: ["tox-toolbar-textfield", "tox-toolbar-nav-js"],
					data: ctx.initValue(),
					inputAttributes,
					selectOnFocus: true,
					inputBehaviours: derive$1([Keying.config({
						mode: "special",
						onEnter: (input$1) => commands.findPrimary(input$1).map((primary$1) => {
							emitExecute(primary$1);
							return true;
						}),
						onLeft: (comp, se) => {
							se.cut();
							return Optional.none();
						},
						onRight: (comp, se) => {
							se.cut();
							return Optional.none();
						}
					})])
				}));
				const commands = generate(memInput, ctx.commands, providers);
				return [{
					title: Optional.none(),
					items: [memInput.asSpec()]
				}, {
					title: Optional.none(),
					items: commands.asSpecs()
				}];
			};
			const renderContextForm = (toolbarType, ctx, providers) => renderToolbar({
				type: toolbarType,
				uid: generate$6("context-toolbar"),
				initGroups: buildInitGroups(ctx, providers),
				onEscape: Optional.none,
				cyclicKeying: true,
				providers
			});
			const ContextForm = {
				renderContextForm,
				buildInitGroups
			};
			const isVerticalOverlap = (a, b$1, threshold) => b$1.bottom - a.y >= threshold && a.bottom - b$1.y >= threshold;
			const getRangeRect = (rng) => {
				const rect$1 = rng.getBoundingClientRect();
				if (rect$1.height <= 0 && rect$1.width <= 0) {
					const leaf$1 = leaf(SugarElement.fromDom(rng.startContainer), rng.startOffset).element;
					return (isText(leaf$1) ? parent(leaf$1) : Optional.some(leaf$1)).filter(isElement$1).map((e) => e.dom.getBoundingClientRect()).getOr(rect$1);
				} else return rect$1;
			};
			const getSelectionBounds = (editor) => {
				const rect$1 = getRangeRect(editor.selection.getRng());
				if (editor.inline) {
					const scroll = get$b();
					return bounds(scroll.left + rect$1.left, scroll.top + rect$1.top, rect$1.width, rect$1.height);
				} else {
					const bodyPos = absolute$2(SugarElement.fromDom(editor.getBody()));
					return bounds(bodyPos.x + rect$1.left, bodyPos.y + rect$1.top, rect$1.width, rect$1.height);
				}
			};
			const getAnchorElementBounds = (editor, lastElement) => lastElement.filter((elem) => inBody(elem) && isHTMLElement(elem)).map(absolute$2).getOrThunk(() => getSelectionBounds(editor));
			const getHorizontalBounds = (contentAreaBox, viewportBounds, margin) => {
				const x = Math.max(contentAreaBox.x + margin, viewportBounds.x);
				return {
					x,
					width: Math.min(contentAreaBox.right - margin, viewportBounds.right) - x
				};
			};
			const getVerticalBounds = (editor, contentAreaBox, viewportBounds, isToolbarLocationTop, toolbarType, margin) => {
				const container = SugarElement.fromDom(editor.getContainer());
				const headerBox = box$1(descendant(container, ".tox-editor-header").getOr(container));
				const isToolbarBelowContentArea = headerBox.y >= contentAreaBox.bottom;
				const isToolbarAbove = isToolbarLocationTop && !isToolbarBelowContentArea;
				if (editor.inline && isToolbarAbove) return {
					y: Math.max(headerBox.bottom + margin, viewportBounds.y),
					bottom: viewportBounds.bottom
				};
				if (editor.inline && !isToolbarAbove) return {
					y: viewportBounds.y,
					bottom: Math.min(headerBox.y - margin, viewportBounds.bottom)
				};
				const containerBounds = toolbarType === "line" ? box$1(container) : contentAreaBox;
				if (isToolbarAbove) return {
					y: Math.max(headerBox.bottom + margin, viewportBounds.y),
					bottom: Math.min(containerBounds.bottom - margin, viewportBounds.bottom)
				};
				return {
					y: Math.max(containerBounds.y + margin, viewportBounds.y),
					bottom: Math.min(headerBox.y - margin, viewportBounds.bottom)
				};
			};
			const getContextToolbarBounds = (editor, sharedBackstage, toolbarType, margin = 0) => {
				const viewportBounds = getBounds$3(window);
				const contentAreaBox = box$1(SugarElement.fromDom(editor.getContentAreaContainer()));
				const toolbarOrMenubarEnabled = isMenubarEnabled(editor) || isToolbarEnabled(editor) || isMultipleToolbars(editor);
				const { x, width: width$1 } = getHorizontalBounds(contentAreaBox, viewportBounds, margin);
				if (editor.inline && !toolbarOrMenubarEnabled) return bounds(x, viewportBounds.y, width$1, viewportBounds.height);
				else {
					const { y, bottom: bottom$1 } = getVerticalBounds(editor, contentAreaBox, viewportBounds, sharedBackstage.header.isPositionedAtTop(), toolbarType, margin);
					return bounds(x, y, width$1, bottom$1 - y);
				}
			};
			const bubbleSize$1 = 12;
			const bubbleAlignments$1 = {
				valignCentre: [],
				alignCentre: [],
				alignLeft: ["tox-pop--align-left"],
				alignRight: ["tox-pop--align-right"],
				right: ["tox-pop--right"],
				left: ["tox-pop--left"],
				bottom: ["tox-pop--bottom"],
				top: ["tox-pop--top"],
				inset: ["tox-pop--inset"]
			};
			const anchorOverrides = {
				maxHeightFunction: expandable$1(),
				maxWidthFunction: expandable()
			};
			const isEntireElementSelected = (editor, elem) => {
				const rng = editor.selection.getRng();
				const leaf$1 = leaf(SugarElement.fromDom(rng.startContainer), rng.startOffset);
				return rng.startContainer === rng.endContainer && rng.startOffset === rng.endOffset - 1 && eq(leaf$1.element, elem);
			};
			const preservePosition = (elem, position$3, f$1) => {
				const currentPosition = getRaw(elem, "position");
				set$8(elem, "position", position$3);
				const result = f$1(elem);
				currentPosition.each((pos) => set$8(elem, "position", pos));
				return result;
			};
			const shouldUseInsetLayouts = (position$3) => position$3 === "node";
			const determineInsetLayout = (editor, contextbar, elem, data, bounds$2) => {
				const selectionBounds = getSelectionBounds(editor);
				const isSameAnchorElement = data.lastElement().exists((prev) => eq(elem, prev));
				if (isEntireElementSelected(editor, elem)) return isSameAnchorElement ? preserve : north;
				else if (isSameAnchorElement) return preservePosition(contextbar, data.getMode(), () => {
					return isVerticalOverlap(selectionBounds, box$1(contextbar), -20) && !data.isReposition() ? flip : preserve;
				});
				else return (data.getMode() === "fixed" ? bounds$2.y + get$b().top : bounds$2.y) + (get$d(contextbar) + bubbleSize$1) <= selectionBounds.y ? north : south;
			};
			const getAnchorSpec$2 = (editor, mobile, data, position$3) => {
				const smartInsetLayout = (elem) => (anchor$1, element$1, bubbles, placee, bounds$2) => {
					return {
						...determineInsetLayout(editor, placee, elem, data, bounds$2)({
							...anchor$1,
							y: bounds$2.y,
							height: bounds$2.height
						}, element$1, bubbles, placee, bounds$2),
						alwaysFit: true
					};
				};
				const getInsetLayouts = (elem) => shouldUseInsetLayouts(position$3) ? [smartInsetLayout(elem)] : [];
				return mobile ? {
					onLtr: (elem) => [
						south$2,
						southeast$2,
						southwest$2,
						northeast$2,
						northwest$2,
						north$2
					].concat(getInsetLayouts(elem)),
					onRtl: (elem) => [
						south$2,
						southwest$2,
						southeast$2,
						northwest$2,
						northeast$2,
						north$2
					].concat(getInsetLayouts(elem))
				} : {
					onLtr: (elem) => [
						north$2,
						south$2,
						northeast$2,
						southeast$2,
						northwest$2,
						southwest$2
					].concat(getInsetLayouts(elem)),
					onRtl: (elem) => [
						north$2,
						south$2,
						northwest$2,
						southwest$2,
						northeast$2,
						southeast$2
					].concat(getInsetLayouts(elem))
				};
			};
			const getAnchorLayout = (editor, position$3, isTouch$1, data) => {
				if (position$3 === "line") return {
					bubble: nu$5(bubbleSize$1, 0, bubbleAlignments$1),
					layouts: {
						onLtr: () => [east$2],
						onRtl: () => [west$2]
					},
					overrides: anchorOverrides
				};
				else return {
					bubble: nu$5(0, bubbleSize$1, bubbleAlignments$1, 1 / bubbleSize$1),
					layouts: getAnchorSpec$2(editor, isTouch$1, data, position$3),
					overrides: anchorOverrides
				};
			};
			const matchTargetWith = (elem, candidates) => {
				const { pass, fail } = partition$3(filter$2(candidates, (toolbarApi) => toolbarApi.predicate(elem.dom)), (t$1) => t$1.type === "contexttoolbar");
				return {
					contextToolbars: pass,
					contextForms: fail
				};
			};
			const filterByPositionForStartNode = (toolbars) => {
				if (toolbars.length <= 1) return toolbars;
				else {
					const doesPositionExist = (value$5) => exists(toolbars, (t$1) => t$1.position === value$5);
					const filterToolbarsByPosition = (value$5) => filter$2(toolbars, (t$1) => t$1.position === value$5);
					const hasSelectionToolbars = doesPositionExist("selection");
					const hasNodeToolbars = doesPositionExist("node");
					if (hasSelectionToolbars || hasNodeToolbars) if (hasNodeToolbars && hasSelectionToolbars) {
						const nodeToolbars = filterToolbarsByPosition("node");
						const selectionToolbars = map$2(filterToolbarsByPosition("selection"), (t$1) => ({
							...t$1,
							position: "node"
						}));
						return nodeToolbars.concat(selectionToolbars);
					} else return hasSelectionToolbars ? filterToolbarsByPosition("selection") : filterToolbarsByPosition("node");
					else return filterToolbarsByPosition("line");
				}
			};
			const filterByPositionForAncestorNode = (toolbars) => {
				if (toolbars.length <= 1) return toolbars;
				else {
					const findPosition = (value$5) => find$5(toolbars, (t$1) => t$1.position === value$5);
					return findPosition("selection").orThunk(() => findPosition("node")).orThunk(() => findPosition("line")).map((t$1) => t$1.position).fold(() => [], (pos) => filter$2(toolbars, (t$1) => t$1.position === pos));
				}
			};
			const matchStartNode = (elem, nodeCandidates, editorCandidates) => {
				const nodeMatches = matchTargetWith(elem, nodeCandidates);
				if (nodeMatches.contextForms.length > 0) return Optional.some({
					elem,
					toolbars: [nodeMatches.contextForms[0]]
				});
				else {
					const editorMatches = matchTargetWith(elem, editorCandidates);
					if (editorMatches.contextForms.length > 0) return Optional.some({
						elem,
						toolbars: [editorMatches.contextForms[0]]
					});
					else if (nodeMatches.contextToolbars.length > 0 || editorMatches.contextToolbars.length > 0) {
						const toolbars = filterByPositionForStartNode(nodeMatches.contextToolbars.concat(editorMatches.contextToolbars));
						return Optional.some({
							elem,
							toolbars
						});
					} else return Optional.none();
				}
			};
			const matchAncestor = (isRoot, startNode, scopes) => {
				if (isRoot(startNode)) return Optional.none();
				else return ancestor$2(startNode, (ancestorElem) => {
					if (isElement$1(ancestorElem)) {
						const { contextToolbars, contextForms } = matchTargetWith(ancestorElem, scopes.inNodeScope);
						const toolbars = contextForms.length > 0 ? contextForms : filterByPositionForAncestorNode(contextToolbars);
						return toolbars.length > 0 ? Optional.some({
							elem: ancestorElem,
							toolbars
						}) : Optional.none();
					} else return Optional.none();
				}, isRoot);
			};
			const lookup$1 = (scopes, editor) => {
				const rootElem = SugarElement.fromDom(editor.getBody());
				const isRoot = (elem) => eq(elem, rootElem);
				const isOutsideRoot = (startNode$1) => !isRoot(startNode$1) && !contains(rootElem, startNode$1);
				const startNode = SugarElement.fromDom(editor.selection.getNode());
				if (isOutsideRoot(startNode)) return Optional.none();
				return matchStartNode(startNode, scopes.inNodeScope, scopes.inEditorScope).orThunk(() => matchAncestor(isRoot, startNode, scopes));
			};
			const categorise = (contextToolbars, navigate) => {
				const forms = {};
				const inNodeScope = [];
				const inEditorScope = [];
				const formNavigators = {};
				const lookupTable = {};
				const registerForm = (key, toolbarSpec) => {
					const contextForm = getOrDie(createContextForm(toolbarSpec));
					forms[key] = contextForm;
					contextForm.launch.map((launch) => {
						formNavigators["form:" + key] = {
							...toolbarSpec.launch,
							type: launch.type === "contextformtogglebutton" ? "togglebutton" : "button",
							onAction: () => {
								navigate(contextForm);
							}
						};
					});
					if (contextForm.scope === "editor") inEditorScope.push(contextForm);
					else inNodeScope.push(contextForm);
					lookupTable[key] = contextForm;
				};
				const registerToolbar = (key, toolbarSpec) => {
					createContextToolbar(toolbarSpec).each((contextToolbar) => {
						if (toolbarSpec.scope === "editor") inEditorScope.push(contextToolbar);
						else inNodeScope.push(contextToolbar);
						lookupTable[key] = contextToolbar;
					});
				};
				each$1(keys(contextToolbars), (key) => {
					const toolbarApi = contextToolbars[key];
					if (toolbarApi.type === "contextform") registerForm(key, toolbarApi);
					else if (toolbarApi.type === "contexttoolbar") registerToolbar(key, toolbarApi);
				});
				return {
					forms,
					inNodeScope,
					inEditorScope,
					lookupTable,
					formNavigators
				};
			};
			const forwardSlideEvent = generate$6("forward-slide");
			const backSlideEvent = generate$6("backward-slide");
			const changeSlideEvent = generate$6("change-slide-event");
			const resizingClass = "tox-pop--resizing";
			const renderContextToolbar = (spec) => {
				const stack = Cell([]);
				return InlineView.sketch({
					dom: {
						tag: "div",
						classes: ["tox-pop"]
					},
					fireDismissalEventInstead: { event: "doNotDismissYet" },
					onShow: (comp) => {
						stack.set([]);
						InlineView.getContent(comp).each((c) => {
							remove$6(c.element, "visibility");
						});
						remove$2(comp.element, resizingClass);
						remove$6(comp.element, "width");
					},
					inlineBehaviours: derive$1([config("context-toolbar-events", [
						runOnSource(transitionend(), (comp, se) => {
							if (se.event.raw.propertyName === "width") {
								remove$2(comp.element, resizingClass);
								remove$6(comp.element, "width");
							}
						}),
						run$1(changeSlideEvent, (comp, se) => {
							const elem = comp.element;
							remove$6(elem, "width");
							const currentWidth = get$c(elem);
							InlineView.setContent(comp, se.event.contents);
							add$2(elem, resizingClass);
							const newWidth = get$c(elem);
							set$8(elem, "width", currentWidth + "px");
							InlineView.getContent(comp).each((newContents) => {
								se.event.focus.bind((f$1) => {
									focus$3(f$1);
									return search(elem);
								}).orThunk(() => {
									Keying.focusIn(newContents);
									return active$1(getRootNode(elem));
								});
							});
							setTimeout(() => {
								set$8(comp.element, "width", newWidth + "px");
							}, 0);
						}),
						run$1(forwardSlideEvent, (comp, se) => {
							InlineView.getContent(comp).each((oldContents) => {
								stack.set(stack.get().concat([{
									bar: oldContents,
									focus: active$1(getRootNode(comp.element))
								}]));
							});
							emitWith(comp, changeSlideEvent, {
								contents: se.event.forwardContents,
								focus: Optional.none()
							});
						}),
						run$1(backSlideEvent, (comp, _se) => {
							last$1(stack.get()).each((last$2) => {
								stack.set(stack.get().slice(0, stack.get().length - 1));
								emitWith(comp, changeSlideEvent, {
									contents: premade(last$2.bar),
									focus: last$2.focus
								});
							});
						})
					]), Keying.config({
						mode: "special",
						onEscape: (comp) => last$1(stack.get()).fold(() => spec.onEscape(), (_) => {
							emit(comp, backSlideEvent);
							return Optional.some(true);
						})
					})]),
					lazySink: () => Result.value(spec.sink)
				});
			};
			const transitionClass = "tox-pop--transition";
			const register$9 = (editor, registryContextToolbars, sink, extras) => {
				const backstage = extras.backstage;
				const sharedBackstage = backstage.shared;
				const isTouch$1 = detect$2().deviceType.isTouch;
				const lastElement = value$2();
				const lastTrigger = value$2();
				const lastContextPosition = value$2();
				const contextbar = build$1(renderContextToolbar({
					sink,
					onEscape: () => {
						editor.focus();
						return Optional.some(true);
					}
				}));
				const getBounds$4 = () => {
					const position$3 = lastContextPosition.get().getOr("node");
					return getContextToolbarBounds(editor, sharedBackstage, position$3, shouldUseInsetLayouts(position$3) ? 1 : 0);
				};
				const canLaunchToolbar = () => {
					return !editor.removed && !(isTouch$1() && backstage.isContextMenuOpen());
				};
				const isSameLaunchElement = (elem) => is$1(lift2(elem, lastElement.get(), eq), true);
				const shouldContextToolbarHide = () => {
					if (!canLaunchToolbar()) return true;
					else {
						const contextToolbarBounds = getBounds$4();
						const anchorBounds = is$1(lastContextPosition.get(), "node") ? getAnchorElementBounds(editor, lastElement.get()) : getSelectionBounds(editor);
						return contextToolbarBounds.height <= 0 || !isVerticalOverlap(anchorBounds, contextToolbarBounds, .01);
					}
				};
				const close$2 = () => {
					lastElement.clear();
					lastTrigger.clear();
					lastContextPosition.clear();
					InlineView.hide(contextbar);
				};
				const hideOrRepositionIfNecessary = () => {
					if (InlineView.isOpen(contextbar)) {
						const contextBarEle = contextbar.element;
						remove$6(contextBarEle, "display");
						if (shouldContextToolbarHide()) set$8(contextBarEle, "display", "none");
						else {
							lastTrigger.set(0);
							InlineView.reposition(contextbar);
						}
					}
				};
				const wrapInPopDialog = (toolbarSpec) => ({
					dom: {
						tag: "div",
						classes: ["tox-pop__dialog"]
					},
					components: [toolbarSpec],
					behaviours: derive$1([Keying.config({ mode: "acyclic" }), config("pop-dialog-wrap-events", [runOnAttached((comp) => {
						editor.shortcuts.add("ctrl+F9", "focus statusbar", () => Keying.focusIn(comp));
					}), runOnDetached((_comp) => {
						editor.shortcuts.remove("ctrl+F9");
					})])])
				});
				const getScopes = cached(() => categorise(registryContextToolbars, (toolbarApi) => {
					emitWith(contextbar, forwardSlideEvent, { forwardContents: wrapInPopDialog(buildToolbar([toolbarApi])) });
				}));
				const buildContextToolbarGroups = (allButtons, ctx) => identifyButtons(editor, {
					buttons: allButtons,
					toolbar: ctx.items,
					allowToolbarGroups: false
				}, extras.backstage, Optional.some(["form:"]));
				const buildContextFormGroups = (ctx, providers) => ContextForm.buildInitGroups(ctx, providers);
				const buildToolbar = (toolbars) => {
					const { buttons } = editor.ui.registry.getAll();
					const scopes = getScopes();
					const allButtons = {
						...buttons,
						...scopes.formNavigators
					};
					const toolbarType = getToolbarMode(editor) === ToolbarMode$1.scrolling ? ToolbarMode$1.scrolling : ToolbarMode$1.default;
					const initGroups = flatten(map$2(toolbars, (ctx) => ctx.type === "contexttoolbar" ? buildContextToolbarGroups(allButtons, ctx) : buildContextFormGroups(ctx, sharedBackstage.providers)));
					return renderToolbar({
						type: toolbarType,
						uid: generate$6("context-toolbar"),
						initGroups,
						onEscape: Optional.none,
						cyclicKeying: true,
						providers: sharedBackstage.providers
					});
				};
				const getAnchor$1 = (position$3, element$1) => {
					return deepMerge(position$3 === "node" ? sharedBackstage.anchors.node(element$1) : sharedBackstage.anchors.cursor(), getAnchorLayout(editor, position$3, isTouch$1(), {
						lastElement: lastElement.get,
						isReposition: () => is$1(lastTrigger.get(), 0),
						getMode: () => Positioning.getMode(sink)
					}));
				};
				const launchContext = (toolbarApi, elem) => {
					launchContextToolbar.cancel();
					if (!canLaunchToolbar()) return;
					const toolbarSpec = buildToolbar(toolbarApi);
					const position$3 = toolbarApi[0].position;
					const anchor$1 = getAnchor$1(position$3, elem);
					lastContextPosition.set(position$3);
					lastTrigger.set(1);
					const contextBarEle = contextbar.element;
					remove$6(contextBarEle, "display");
					if (!isSameLaunchElement(elem)) {
						remove$2(contextBarEle, transitionClass);
						Positioning.reset(sink, contextbar);
					}
					InlineView.showWithinBounds(contextbar, wrapInPopDialog(toolbarSpec), {
						anchor: anchor$1,
						transition: {
							classes: [transitionClass],
							mode: "placement"
						}
					}, () => Optional.some(getBounds$4()));
					elem.fold(lastElement.clear, lastElement.set);
					if (shouldContextToolbarHide()) set$8(contextBarEle, "display", "none");
				};
				let isDragging = false;
				const launchContextToolbar = last(() => {
					if (!editor.hasFocus() || editor.removed || isDragging) return;
					if (has(contextbar.element, transitionClass)) launchContextToolbar.throttle();
					else lookup$1(getScopes(), editor).fold(close$2, (info) => {
						launchContext(info.toolbars, Optional.some(info.elem));
					});
				}, 17);
				editor.on("init", () => {
					editor.on("remove", close$2);
					editor.on("ScrollContent ScrollWindow ObjectResized ResizeEditor longpress", hideOrRepositionIfNecessary);
					editor.on("click keyup focus SetContent", launchContextToolbar.throttle);
					editor.on(hideContextToolbarEvent, close$2);
					editor.on(showContextToolbarEvent, (e) => {
						get$g(getScopes().lookupTable, e.toolbarKey).each((ctx) => {
							launchContext([ctx], someIf(e.target !== editor, e.target));
							InlineView.getContent(contextbar).each(Keying.focusIn);
						});
					});
					editor.on("focusout", (_e) => {
						global$9.setEditorTimeout(editor, () => {
							if (search(sink.element).isNone() && search(contextbar.element).isNone()) close$2();
						}, 0);
					});
					editor.on("SwitchMode", () => {
						if (editor.mode.isReadOnly()) close$2();
					});
					editor.on("AfterProgressState", (event) => {
						if (event.state) close$2();
						else if (editor.hasFocus()) launchContextToolbar.throttle();
					});
					editor.on("dragstart", () => {
						isDragging = true;
					});
					editor.on("dragend drop", () => {
						isDragging = false;
					});
					editor.on("NodeChange", (_e) => {
						search(contextbar.element).fold(launchContextToolbar.throttle, noop);
					});
				});
			};
			const register$8 = (editor) => {
				each$1([
					{
						name: "alignleft",
						text: "Align left",
						cmd: "JustifyLeft",
						icon: "align-left"
					},
					{
						name: "aligncenter",
						text: "Align center",
						cmd: "JustifyCenter",
						icon: "align-center"
					},
					{
						name: "alignright",
						text: "Align right",
						cmd: "JustifyRight",
						icon: "align-right"
					},
					{
						name: "alignjustify",
						text: "Justify",
						cmd: "JustifyFull",
						icon: "align-justify"
					}
				], (item$1) => {
					editor.ui.registry.addToggleButton(item$1.name, {
						tooltip: item$1.text,
						icon: item$1.icon,
						onAction: onActionExecCommand(editor, item$1.cmd),
						onSetup: onSetupStateToggle(editor, item$1.name)
					});
				});
				editor.ui.registry.addButton("alignnone", {
					tooltip: "No alignment",
					icon: "align-none",
					onSetup: onSetupEditableToggle(editor),
					onAction: onActionExecCommand(editor, "JustifyNone")
				});
			};
			const registerController = (editor, spec) => {
				const getMenuItems = () => {
					const options = spec.getOptions(editor);
					const initial = spec.getCurrent(editor).map(spec.hash);
					const current = value$2();
					return map$2(options, (value$5) => ({
						type: "togglemenuitem",
						text: spec.display(value$5),
						onSetup: (api$3) => {
							const setActive = (active$2) => {
								if (active$2) {
									current.on((oldApi) => oldApi.setActive(false));
									current.set(api$3);
								}
								api$3.setActive(active$2);
							};
							setActive(is$1(initial, spec.hash(value$5)));
							const unbindWatcher = spec.watcher(editor, value$5, setActive);
							return () => {
								current.clear();
								unbindWatcher();
							};
						},
						onAction: () => spec.setCurrent(editor, value$5)
					}));
				};
				editor.ui.registry.addMenuButton(spec.name, {
					tooltip: spec.text,
					icon: spec.icon,
					fetch: (callback) => callback(getMenuItems()),
					onSetup: spec.onToolbarSetup
				});
				editor.ui.registry.addNestedMenuItem(spec.name, {
					type: "nestedmenuitem",
					text: spec.text,
					getSubmenuItems: getMenuItems,
					onSetup: spec.onMenuSetup
				});
			};
			const lineHeightSpec = (editor) => ({
				name: "lineheight",
				text: "Line height",
				icon: "line-height",
				getOptions: getLineHeightFormats,
				hash: (input$1) => normalise(input$1, [
					"fixed",
					"relative",
					"empty"
				]).getOr(input$1),
				display: identity,
				watcher: (editor$1, value$5, callback) => editor$1.formatter.formatChanged("lineheight", callback, false, { value: value$5 }).unbind,
				getCurrent: (editor$1) => Optional.from(editor$1.queryCommandValue("LineHeight")),
				setCurrent: (editor$1, value$5) => editor$1.execCommand("LineHeight", false, value$5),
				onToolbarSetup: onSetupEditableToggle(editor),
				onMenuSetup: onSetupEditableToggle(editor)
			});
			const languageSpec = (editor) => {
				return Optional.from(getContentLanguages(editor)).map((settings) => ({
					name: "language",
					text: "Language",
					icon: "language",
					getOptions: constant$1(settings),
					hash: (input$1) => isUndefined(input$1.customCode) ? input$1.code : `${input$1.code}/${input$1.customCode}`,
					display: (input$1) => input$1.title,
					watcher: (editor$1, value$5, callback) => {
						var _a;
						return editor$1.formatter.formatChanged("lang", callback, false, {
							value: value$5.code,
							customValue: (_a = value$5.customCode) !== null && _a !== void 0 ? _a : null
						}).unbind;
					},
					getCurrent: (editor$1) => {
						return closest$4(SugarElement.fromDom(editor$1.selection.getNode()), (n) => Optional.some(n).filter(isElement$1).bind((ele) => {
							return getOpt(ele, "lang").map((code) => {
								return {
									code,
									customCode: getOpt(ele, "data-mce-lang").getOrUndefined(),
									title: ""
								};
							});
						}));
					},
					setCurrent: (editor$1, lang) => editor$1.execCommand("Lang", false, lang),
					onToolbarSetup: (api$3) => {
						const unbinder = unbindable();
						api$3.setActive(editor.formatter.match("lang", {}, void 0, true));
						unbinder.set(editor.formatter.formatChanged("lang", api$3.setActive, true));
						return composeUnbinders(unbinder.clear, onSetupEditableToggle(editor)(api$3));
					},
					onMenuSetup: onSetupEditableToggle(editor)
				}));
			};
			const register$7 = (editor) => {
				registerController(editor, lineHeightSpec(editor));
				languageSpec(editor).each((spec) => registerController(editor, spec));
			};
			const register$6 = (editor, backstage) => {
				createAlignMenu(editor, backstage);
				createFontFamilyMenu(editor, backstage);
				createStylesMenu(editor, backstage);
				createBlocksMenu(editor, backstage);
				createFontSizeMenu(editor, backstage);
			};
			const onSetupOutdentState = (editor) => onSetupEvent(editor, "NodeChange", (api$3) => {
				api$3.setEnabled(editor.queryCommandState("outdent") && editor.selection.isEditable());
			});
			const registerButtons$2 = (editor) => {
				editor.ui.registry.addButton("outdent", {
					tooltip: "Decrease indent",
					icon: "outdent",
					onSetup: onSetupOutdentState(editor),
					onAction: onActionExecCommand(editor, "outdent")
				});
				editor.ui.registry.addButton("indent", {
					tooltip: "Increase indent",
					icon: "indent",
					onSetup: onSetupEditableToggle(editor),
					onAction: onActionExecCommand(editor, "indent")
				});
			};
			const register$5 = (editor) => {
				registerButtons$2(editor);
			};
			const makeSetupHandler = (editor, pasteAsText) => (api$3) => {
				api$3.setActive(pasteAsText.get());
				const pastePlainTextToggleHandler = (e) => {
					pasteAsText.set(e.state);
					api$3.setActive(e.state);
				};
				editor.on("PastePlainTextToggle", pastePlainTextToggleHandler);
				return composeUnbinders(() => editor.off("PastePlainTextToggle", pastePlainTextToggleHandler), onSetupEditableToggle(editor)(api$3));
			};
			const register$4 = (editor) => {
				const pasteAsText = Cell(getPasteAsText(editor));
				const onAction$1 = () => editor.execCommand("mceTogglePlainTextPaste");
				editor.ui.registry.addToggleButton("pastetext", {
					active: false,
					icon: "paste-text",
					tooltip: "Paste as text",
					onAction: onAction$1,
					onSetup: makeSetupHandler(editor, pasteAsText)
				});
				editor.ui.registry.addToggleMenuItem("pastetext", {
					text: "Paste as text",
					icon: "paste-text",
					onAction: onAction$1,
					onSetup: makeSetupHandler(editor, pasteAsText)
				});
			};
			const onActionToggleFormat = (editor, fmt) => () => {
				editor.execCommand("mceToggleFormat", false, fmt);
			};
			const registerFormatButtons = (editor) => {
				global$1.each([
					{
						name: "bold",
						text: "Bold",
						icon: "bold"
					},
					{
						name: "italic",
						text: "Italic",
						icon: "italic"
					},
					{
						name: "underline",
						text: "Underline",
						icon: "underline"
					},
					{
						name: "strikethrough",
						text: "Strikethrough",
						icon: "strike-through"
					},
					{
						name: "subscript",
						text: "Subscript",
						icon: "subscript"
					},
					{
						name: "superscript",
						text: "Superscript",
						icon: "superscript"
					}
				], (btn, _idx) => {
					editor.ui.registry.addToggleButton(btn.name, {
						tooltip: btn.text,
						icon: btn.icon,
						onSetup: onSetupStateToggle(editor, btn.name),
						onAction: onActionToggleFormat(editor, btn.name)
					});
				});
				for (let i = 1; i <= 6; i++) {
					const name$4 = "h" + i;
					editor.ui.registry.addToggleButton(name$4, {
						text: name$4.toUpperCase(),
						tooltip: "Heading " + i,
						onSetup: onSetupStateToggle(editor, name$4),
						onAction: onActionToggleFormat(editor, name$4)
					});
				}
			};
			const registerCommandButtons = (editor) => {
				global$1.each([
					{
						name: "copy",
						text: "Copy",
						action: "Copy",
						icon: "copy"
					},
					{
						name: "help",
						text: "Help",
						action: "mceHelp",
						icon: "help"
					},
					{
						name: "selectall",
						text: "Select all",
						action: "SelectAll",
						icon: "select-all"
					},
					{
						name: "newdocument",
						text: "New document",
						action: "mceNewDocument",
						icon: "new-document"
					},
					{
						name: "print",
						text: "Print",
						action: "mcePrint",
						icon: "print"
					}
				], (btn) => {
					editor.ui.registry.addButton(btn.name, {
						tooltip: btn.text,
						icon: btn.icon,
						onAction: onActionExecCommand(editor, btn.action)
					});
				});
				global$1.each([
					{
						name: "cut",
						text: "Cut",
						action: "Cut",
						icon: "cut"
					},
					{
						name: "paste",
						text: "Paste",
						action: "Paste",
						icon: "paste"
					},
					{
						name: "removeformat",
						text: "Clear formatting",
						action: "RemoveFormat",
						icon: "remove-formatting"
					},
					{
						name: "remove",
						text: "Remove",
						action: "Delete",
						icon: "remove"
					},
					{
						name: "hr",
						text: "Horizontal line",
						action: "InsertHorizontalRule",
						icon: "horizontal-rule"
					}
				], (btn) => {
					editor.ui.registry.addButton(btn.name, {
						tooltip: btn.text,
						icon: btn.icon,
						onSetup: onSetupEditableToggle(editor),
						onAction: onActionExecCommand(editor, btn.action)
					});
				});
			};
			const registerCommandToggleButtons = (editor) => {
				global$1.each([{
					name: "blockquote",
					text: "Blockquote",
					action: "mceBlockQuote",
					icon: "quote"
				}], (btn) => {
					editor.ui.registry.addToggleButton(btn.name, {
						tooltip: btn.text,
						icon: btn.icon,
						onAction: onActionExecCommand(editor, btn.action),
						onSetup: onSetupStateToggle(editor, btn.name)
					});
				});
			};
			const registerButtons$1 = (editor) => {
				registerFormatButtons(editor);
				registerCommandButtons(editor);
				registerCommandToggleButtons(editor);
			};
			const registerMenuItems$2 = (editor) => {
				global$1.each([
					{
						name: "newdocument",
						text: "New document",
						action: "mceNewDocument",
						icon: "new-document"
					},
					{
						name: "copy",
						text: "Copy",
						action: "Copy",
						icon: "copy",
						shortcut: "Meta+C"
					},
					{
						name: "selectall",
						text: "Select all",
						action: "SelectAll",
						icon: "select-all",
						shortcut: "Meta+A"
					},
					{
						name: "print",
						text: "Print...",
						action: "mcePrint",
						icon: "print",
						shortcut: "Meta+P"
					}
				], (menuitem) => {
					editor.ui.registry.addMenuItem(menuitem.name, {
						text: menuitem.text,
						icon: menuitem.icon,
						shortcut: menuitem.shortcut,
						onAction: onActionExecCommand(editor, menuitem.action)
					});
				});
				global$1.each([
					{
						name: "bold",
						text: "Bold",
						action: "Bold",
						icon: "bold",
						shortcut: "Meta+B"
					},
					{
						name: "italic",
						text: "Italic",
						action: "Italic",
						icon: "italic",
						shortcut: "Meta+I"
					},
					{
						name: "underline",
						text: "Underline",
						action: "Underline",
						icon: "underline",
						shortcut: "Meta+U"
					},
					{
						name: "strikethrough",
						text: "Strikethrough",
						action: "Strikethrough",
						icon: "strike-through"
					},
					{
						name: "subscript",
						text: "Subscript",
						action: "Subscript",
						icon: "subscript"
					},
					{
						name: "superscript",
						text: "Superscript",
						action: "Superscript",
						icon: "superscript"
					},
					{
						name: "removeformat",
						text: "Clear formatting",
						action: "RemoveFormat",
						icon: "remove-formatting"
					},
					{
						name: "cut",
						text: "Cut",
						action: "Cut",
						icon: "cut",
						shortcut: "Meta+X"
					},
					{
						name: "paste",
						text: "Paste",
						action: "Paste",
						icon: "paste",
						shortcut: "Meta+V"
					},
					{
						name: "hr",
						text: "Horizontal line",
						action: "InsertHorizontalRule",
						icon: "horizontal-rule"
					}
				], (menuitem) => {
					editor.ui.registry.addMenuItem(menuitem.name, {
						text: menuitem.text,
						icon: menuitem.icon,
						shortcut: menuitem.shortcut,
						onSetup: onSetupEditableToggle(editor),
						onAction: onActionExecCommand(editor, menuitem.action)
					});
				});
				editor.ui.registry.addMenuItem("codeformat", {
					text: "Code",
					icon: "sourcecode",
					onSetup: onSetupEditableToggle(editor),
					onAction: onActionToggleFormat(editor, "code")
				});
			};
			const register$3 = (editor) => {
				registerButtons$1(editor);
				registerMenuItems$2(editor);
			};
			const onSetupUndoRedoState = (editor, type$2) => onSetupEvent(editor, "Undo Redo AddUndo TypingUndo ClearUndos SwitchMode", (api$3) => {
				api$3.setEnabled(!editor.mode.isReadOnly() && editor.undoManager[type$2]());
			});
			const registerMenuItems$1 = (editor) => {
				editor.ui.registry.addMenuItem("undo", {
					text: "Undo",
					icon: "undo",
					shortcut: "Meta+Z",
					onSetup: onSetupUndoRedoState(editor, "hasUndo"),
					onAction: onActionExecCommand(editor, "undo")
				});
				editor.ui.registry.addMenuItem("redo", {
					text: "Redo",
					icon: "redo",
					shortcut: "Meta+Y",
					onSetup: onSetupUndoRedoState(editor, "hasRedo"),
					onAction: onActionExecCommand(editor, "redo")
				});
			};
			const registerButtons = (editor) => {
				editor.ui.registry.addButton("undo", {
					tooltip: "Undo",
					icon: "undo",
					enabled: false,
					onSetup: onSetupUndoRedoState(editor, "hasUndo"),
					onAction: onActionExecCommand(editor, "undo")
				});
				editor.ui.registry.addButton("redo", {
					tooltip: "Redo",
					icon: "redo",
					enabled: false,
					onSetup: onSetupUndoRedoState(editor, "hasRedo"),
					onAction: onActionExecCommand(editor, "redo")
				});
			};
			const register$2 = (editor) => {
				registerMenuItems$1(editor);
				registerButtons(editor);
			};
			const onSetupVisualAidState = (editor) => onSetupEvent(editor, "VisualAid", (api$3) => {
				api$3.setActive(editor.hasVisual);
			});
			const registerMenuItems = (editor) => {
				editor.ui.registry.addToggleMenuItem("visualaid", {
					text: "Visual aids",
					onSetup: onSetupVisualAidState(editor),
					onAction: onActionExecCommand(editor, "mceToggleVisualAid")
				});
			};
			const registerToolbarButton = (editor) => {
				editor.ui.registry.addButton("visualaid", {
					tooltip: "Visual aids",
					text: "Visual aids",
					onAction: onActionExecCommand(editor, "mceToggleVisualAid")
				});
			};
			const register$1 = (editor) => {
				registerToolbarButton(editor);
				registerMenuItems(editor);
			};
			const setup$6 = (editor, backstage) => {
				register$8(editor);
				register$3(editor);
				register$6(editor, backstage);
				register$2(editor);
				register$c(editor);
				register$1(editor);
				register$5(editor);
				register$7(editor);
				register$4(editor);
			};
			const patchPipeConfig = (config$1) => isString(config$1) ? config$1.split(/[ ,]/) : config$1;
			const option = (name$4) => (editor) => editor.options.get(name$4);
			const register = (editor) => {
				const registerOption = editor.options.register;
				registerOption("contextmenu_avoid_overlap", {
					processor: "string",
					default: ""
				});
				registerOption("contextmenu_never_use_native", {
					processor: "boolean",
					default: false
				});
				registerOption("contextmenu", {
					processor: (value$5) => {
						if (value$5 === false) return {
							value: [],
							valid: true
						};
						else if (isString(value$5) || isArrayOf(value$5, isString)) return {
							value: patchPipeConfig(value$5),
							valid: true
						};
						else return {
							valid: false,
							message: "Must be false or a string."
						};
					},
					default: "link linkchecker image editimage table spellchecker configurepermanentpen"
				});
			};
			const shouldNeverUseNative = option("contextmenu_never_use_native");
			const getAvoidOverlapSelector = option("contextmenu_avoid_overlap");
			const isContextMenuDisabled = (editor) => getContextMenu(editor).length === 0;
			const getContextMenu = (editor) => {
				const contextMenus = editor.ui.registry.getAll().contextMenus;
				const contextMenu = editor.options.get("contextmenu");
				if (editor.options.isSet("contextmenu")) return contextMenu;
				else return filter$2(contextMenu, (item$1) => has$2(contextMenus, item$1));
			};
			const nu = (x, y) => ({
				type: "makeshift",
				x,
				y
			});
			const transpose = (pos, dx, dy) => {
				return nu(pos.x + dx, pos.y + dy);
			};
			const isTouchEvent$1 = (e) => e.type === "longpress" || e.type.indexOf("touch") === 0;
			const fromPageXY = (e) => {
				if (isTouchEvent$1(e)) {
					const touch$1 = e.touches[0];
					return nu(touch$1.pageX, touch$1.pageY);
				} else return nu(e.pageX, e.pageY);
			};
			const fromClientXY = (e) => {
				if (isTouchEvent$1(e)) {
					const touch$1 = e.touches[0];
					return nu(touch$1.clientX, touch$1.clientY);
				} else return nu(e.clientX, e.clientY);
			};
			const transposeContentAreaContainer = (element$1, pos) => {
				const containerPos = global$7.DOM.getPos(element$1);
				return transpose(pos, containerPos.x, containerPos.y);
			};
			const getPointAnchor = (editor, e) => {
				if (e.type === "contextmenu" || e.type === "longpress") if (editor.inline) return fromPageXY(e);
				else return transposeContentAreaContainer(editor.getContentAreaContainer(), fromClientXY(e));
				else return getSelectionAnchor(editor);
			};
			const getSelectionAnchor = (editor) => {
				return {
					type: "selection",
					root: SugarElement.fromDom(editor.selection.getNode())
				};
			};
			const getNodeAnchor = (editor) => ({
				type: "node",
				node: Optional.some(SugarElement.fromDom(editor.selection.getNode())),
				root: SugarElement.fromDom(editor.getBody())
			});
			const getAnchorSpec$1 = (editor, e, anchorType) => {
				switch (anchorType) {
					case "node": return getNodeAnchor(editor);
					case "point": return getPointAnchor(editor, e);
					case "selection": return getSelectionAnchor(editor);
				}
			};
			const initAndShow$1 = (editor, e, buildMenu, backstage, contextmenu, anchorType) => {
				const items = buildMenu();
				const anchorSpec = getAnchorSpec$1(editor, e, anchorType);
				build(items, ItemResponse$1.CLOSE_ON_EXECUTE, backstage, {
					isHorizontalMenu: false,
					search: Optional.none()
				}).map((menuData) => {
					e.preventDefault();
					InlineView.showMenuAt(contextmenu, { anchor: anchorSpec }, {
						menu: { markers: markers("normal") },
						data: menuData
					});
				});
			};
			const layouts = {
				onLtr: () => [
					south$2,
					southeast$2,
					southwest$2,
					northeast$2,
					northwest$2,
					north$2,
					north,
					south,
					northeast,
					southeast,
					northwest,
					southwest
				],
				onRtl: () => [
					south$2,
					southwest$2,
					southeast$2,
					northwest$2,
					northeast$2,
					north$2,
					north,
					south,
					northwest,
					southwest,
					northeast,
					southeast
				]
			};
			const bubbleSize = 12;
			const bubbleAlignments = {
				valignCentre: [],
				alignCentre: [],
				alignLeft: ["tox-pop--align-left"],
				alignRight: ["tox-pop--align-right"],
				right: ["tox-pop--right"],
				left: ["tox-pop--left"],
				bottom: ["tox-pop--bottom"],
				top: ["tox-pop--top"]
			};
			const isTouchWithinSelection = (editor, e) => {
				const selection = editor.selection;
				if (selection.isCollapsed() || e.touches.length < 1) return false;
				else {
					const touch$1 = e.touches[0];
					const rng = selection.getRng();
					return getFirstRect(editor.getWin(), SimSelection.domRange(rng)).exists((rngRect) => rngRect.left <= touch$1.clientX && rngRect.right >= touch$1.clientX && rngRect.top <= touch$1.clientY && rngRect.bottom >= touch$1.clientY);
				}
			};
			const setupiOSOverrides = (editor) => {
				const originalSelection = editor.selection.getRng();
				const selectionReset = () => {
					global$9.setEditorTimeout(editor, () => {
						editor.selection.setRng(originalSelection);
					}, 10);
					unbindEventListeners();
				};
				editor.once("touchend", selectionReset);
				const preventMousedown = (e) => {
					e.preventDefault();
					e.stopImmediatePropagation();
				};
				editor.on("mousedown", preventMousedown, true);
				const clearSelectionReset = () => unbindEventListeners();
				editor.once("longpresscancel", clearSelectionReset);
				const unbindEventListeners = () => {
					editor.off("touchend", selectionReset);
					editor.off("longpresscancel", clearSelectionReset);
					editor.off("mousedown", preventMousedown);
				};
			};
			const getAnchorSpec = (editor, e, anchorType) => {
				const anchorSpec = getAnchorSpec$1(editor, e, anchorType);
				return {
					bubble: nu$5(0, anchorType === "point" ? bubbleSize : 0, bubbleAlignments),
					layouts,
					overrides: {
						maxWidthFunction: expandable(),
						maxHeightFunction: expandable$1()
					},
					...anchorSpec
				};
			};
			const show = (editor, e, items, backstage, contextmenu, anchorType, highlightImmediately) => {
				const anchorSpec = getAnchorSpec(editor, e, anchorType);
				build(items, ItemResponse$1.CLOSE_ON_EXECUTE, backstage, {
					isHorizontalMenu: true,
					search: Optional.none()
				}).map((menuData) => {
					e.preventDefault();
					const highlightOnOpen = highlightImmediately ? HighlightOnOpen.HighlightMenuAndItem : HighlightOnOpen.HighlightNone;
					InlineView.showMenuWithinBounds(contextmenu, { anchor: anchorSpec }, {
						menu: {
							markers: markers("normal"),
							highlightOnOpen
						},
						data: menuData,
						type: "horizontal"
					}, () => Optional.some(getContextToolbarBounds(editor, backstage.shared, anchorType === "node" ? "node" : "selection")));
					editor.dispatch(hideContextToolbarEvent);
				});
			};
			const initAndShow = (editor, e, buildMenu, backstage, contextmenu, anchorType) => {
				const detection$1 = detect$2();
				const isiOS = detection$1.os.isiOS();
				const isMacOS = detection$1.os.isMacOS();
				const isAndroid = detection$1.os.isAndroid();
				const isTouch$1 = detection$1.deviceType.isTouch();
				const shouldHighlightImmediately = () => !(isAndroid || isiOS || isMacOS && isTouch$1);
				const open$2 = () => {
					show(editor, e, buildMenu(), backstage, contextmenu, anchorType, shouldHighlightImmediately());
				};
				if ((isMacOS || isiOS) && anchorType !== "node") {
					const openiOS = () => {
						setupiOSOverrides(editor);
						open$2();
					};
					if (isTouchWithinSelection(editor, e)) openiOS();
					else {
						editor.once("selectionchange", openiOS);
						editor.once("touchend", () => editor.off("selectionchange", openiOS));
					}
				} else open$2();
			};
			const isSeparator = (item$1) => isString(item$1) ? item$1 === "|" : item$1.type === "separator";
			const separator = { type: "separator" };
			const makeContextItem = (item$1) => {
				const commonMenuItem = (item$2) => ({
					text: item$2.text,
					icon: item$2.icon,
					enabled: item$2.enabled,
					shortcut: item$2.shortcut
				});
				if (isString(item$1)) return item$1;
				else switch (item$1.type) {
					case "separator": return separator;
					case "submenu": return {
						type: "nestedmenuitem",
						...commonMenuItem(item$1),
						getSubmenuItems: () => {
							const items = item$1.getSubmenuItems();
							if (isString(items)) return items;
							else return map$2(items, makeContextItem);
						}
					};
					default:
						const commonItem = item$1;
						return {
							type: "menuitem",
							...commonMenuItem(commonItem),
							onAction: noarg(commonItem.onAction)
						};
				}
			};
			const addContextMenuGroup = (xs, groupItems) => {
				if (groupItems.length === 0) return xs;
				const before = last$1(xs).filter((item$1) => !isSeparator(item$1)).fold(() => [], (_) => [separator]);
				return xs.concat(before).concat(groupItems).concat([separator]);
			};
			const generateContextMenu = (contextMenus, menuConfig, selectedElement) => {
				const sections = foldl(menuConfig, (acc, name$4) => {
					return get$g(contextMenus, name$4.toLowerCase()).map((menu$1) => {
						const items = menu$1.update(selectedElement);
						if (isString(items) && isNotEmpty(trim$1(items))) return addContextMenuGroup(acc, items.split(" "));
						else if (isArray(items) && items.length > 0) return addContextMenuGroup(acc, map$2(items, makeContextItem));
						else return acc;
					}).getOrThunk(() => acc.concat([name$4]));
				}, []);
				if (sections.length > 0 && isSeparator(sections[sections.length - 1])) sections.pop();
				return sections;
			};
			const isNativeOverrideKeyEvent = (editor, e) => e.ctrlKey && !shouldNeverUseNative(editor);
			const isTouchEvent = (e) => e.type === "longpress" || has$2(e, "touches");
			const isTriggeredByKeyboard = (editor, e) => !isTouchEvent(e) && (e.button !== 2 || e.target === editor.getBody() && e.pointerType === "");
			const getSelectedElement = (editor, e) => isTriggeredByKeyboard(editor, e) ? editor.selection.getStart(true) : e.target;
			const getAnchorType = (editor, e) => {
				const selector = getAvoidOverlapSelector(editor);
				const anchorType = isTriggeredByKeyboard(editor, e) ? "selection" : "point";
				if (isNotEmpty(selector)) {
					const target = getSelectedElement(editor, e);
					return closest(SugarElement.fromDom(target), selector) ? "node" : anchorType;
				} else return anchorType;
			};
			const setup$5 = (editor, lazySink, backstage) => {
				const isTouch$1 = detect$2().deviceType.isTouch;
				const contextmenu = build$1(InlineView.sketch({
					dom: { tag: "div" },
					lazySink,
					onEscape: () => editor.focus(),
					onShow: () => backstage.setContextMenuState(true),
					onHide: () => backstage.setContextMenuState(false),
					fireDismissalEventInstead: {},
					inlineBehaviours: derive$1([config("dismissContextMenu", [run$1(dismissRequested(), (comp, _se) => {
						Sandboxing.close(comp);
						editor.focus();
					})])])
				}));
				const hideContextMenu = () => InlineView.hide(contextmenu);
				const showContextMenu = (e) => {
					if (shouldNeverUseNative(editor)) e.preventDefault();
					if (isNativeOverrideKeyEvent(editor, e) || isContextMenuDisabled(editor)) return;
					const anchorType = getAnchorType(editor, e);
					const buildMenu = () => {
						const selectedElement = getSelectedElement(editor, e);
						const registry = editor.ui.registry.getAll();
						const menuConfig = getContextMenu(editor);
						return generateContextMenu(registry.contextMenus, menuConfig, selectedElement);
					};
					(isTouch$1() ? initAndShow : initAndShow$1)(editor, e, buildMenu, backstage, contextmenu, anchorType);
				};
				editor.on("init", () => {
					const hideEvents = "ResizeEditor ScrollContent ScrollWindow longpresscancel" + (isTouch$1() ? "" : " ResizeWindow");
					editor.on(hideEvents, hideContextMenu);
					editor.on("longpress contextmenu", showContextMenu);
				});
			};
			const adt = Adt.generate([
				{ offset: ["x", "y"] },
				{ absolute: ["x", "y"] },
				{ fixed: ["x", "y"] }
			]);
			const subtract = (change$1) => (point$1) => point$1.translate(-change$1.left, -change$1.top);
			const add = (change$1) => (point$1) => point$1.translate(change$1.left, change$1.top);
			const transform = (changes) => (x, y) => foldl(changes, (rest, f$1) => f$1(rest), SugarPosition(x, y));
			const asFixed = (coord, scroll, origin) => coord.fold(transform([add(origin), subtract(scroll)]), transform([subtract(scroll)]), transform([]));
			const asAbsolute = (coord, scroll, origin) => coord.fold(transform([add(origin)]), transform([]), transform([add(scroll)]));
			const asOffset = (coord, scroll, origin) => coord.fold(transform([]), transform([subtract(origin)]), transform([add(scroll), subtract(origin)]));
			const withinRange = (coord1, coord2, xRange$1, yRange$1, scroll, origin) => {
				const a1 = asAbsolute(coord1, scroll, origin);
				const a2 = asAbsolute(coord2, scroll, origin);
				return Math.abs(a1.left - a2.left) <= xRange$1 && Math.abs(a1.top - a2.top) <= yRange$1;
			};
			const getDeltas = (coord1, coord2, xRange$1, yRange$1, scroll, origin) => {
				const a1 = asAbsolute(coord1, scroll, origin);
				const a2 = asAbsolute(coord2, scroll, origin);
				return SugarPosition(Math.abs(a1.left - a2.left), Math.abs(a1.top - a2.top));
			};
			const toStyles = (coord, scroll, origin) => {
				const stylesOpt = coord.fold((x, y) => ({
					position: Optional.some("absolute"),
					left: Optional.some(x + "px"),
					top: Optional.some(y + "px")
				}), (x, y) => ({
					position: Optional.some("absolute"),
					left: Optional.some(x - origin.left + "px"),
					top: Optional.some(y - origin.top + "px")
				}), (x, y) => ({
					position: Optional.some("fixed"),
					left: Optional.some(x + "px"),
					top: Optional.some(y + "px")
				}));
				return {
					right: Optional.none(),
					bottom: Optional.none(),
					...stylesOpt
				};
			};
			const translate = (coord, deltaX, deltaY) => coord.fold((x, y) => offset(x + deltaX, y + deltaY), (x, y) => absolute(x + deltaX, y + deltaY), (x, y) => fixed(x + deltaX, y + deltaY));
			const absorb = (partialCoord, originalCoord, scroll, origin) => {
				const absorbOne = (stencil, nu$10) => (optX, optY) => {
					const original$1 = stencil(originalCoord, scroll, origin);
					return nu$10(optX.getOr(original$1.left), optY.getOr(original$1.top));
				};
				return partialCoord.fold(absorbOne(asOffset, offset), absorbOne(asAbsolute, absolute), absorbOne(asFixed, fixed));
			};
			const offset = adt.offset;
			const absolute = adt.absolute;
			const fixed = adt.fixed;
			const parseAttrToInt = (element$1, name$4) => {
				const value$5 = get$f(element$1, name$4);
				return isUndefined(value$5) ? NaN : parseInt(value$5, 10);
			};
			const get = (component, snapsInfo) => {
				const element$1 = component.element;
				const x = parseAttrToInt(element$1, snapsInfo.leftAttr);
				const y = parseAttrToInt(element$1, snapsInfo.topAttr);
				return isNaN(x) || isNaN(y) ? Optional.none() : Optional.some(SugarPosition(x, y));
			};
			const set = (component, snapsInfo, pt) => {
				const element$1 = component.element;
				set$9(element$1, snapsInfo.leftAttr, pt.left + "px");
				set$9(element$1, snapsInfo.topAttr, pt.top + "px");
			};
			const clear = (component, snapsInfo) => {
				const element$1 = component.element;
				remove$7(element$1, snapsInfo.leftAttr);
				remove$7(element$1, snapsInfo.topAttr);
			};
			const getCoords = (component, snapInfo, coord, delta) => get(component, snapInfo).fold(() => coord, (fixed$1$1) => fixed(fixed$1$1.left + delta.left, fixed$1$1.top + delta.top));
			const moveOrSnap = (component, snapInfo, coord, delta, scroll, origin) => {
				const newCoord = getCoords(component, snapInfo, coord, delta);
				const snap$1 = snapInfo.mustSnap ? findClosestSnap(component, snapInfo, newCoord, scroll, origin) : findSnap(component, snapInfo, newCoord, scroll, origin);
				const fixedCoord = asFixed(newCoord, scroll, origin);
				set(component, snapInfo, fixedCoord);
				return snap$1.fold(() => ({
					coord: fixed(fixedCoord.left, fixedCoord.top),
					extra: Optional.none()
				}), (spanned) => ({
					coord: spanned.output,
					extra: spanned.extra
				}));
			};
			const stopDrag = (component, snapInfo) => {
				clear(component, snapInfo);
			};
			const findMatchingSnap = (snaps, newCoord, scroll, origin) => findMap(snaps, (snap$1) => {
				const sensor = snap$1.sensor;
				return withinRange(newCoord, sensor, snap$1.range.left, snap$1.range.top, scroll, origin) ? Optional.some({
					output: absorb(snap$1.output, newCoord, scroll, origin),
					extra: snap$1.extra
				}) : Optional.none();
			});
			const findClosestSnap = (component, snapInfo, newCoord, scroll, origin) => {
				const snaps = snapInfo.getSnapPoints(component);
				return findMatchingSnap(snaps, newCoord, scroll, origin).orThunk(() => {
					return foldl(snaps, (acc, snap$1) => {
						const sensor = snap$1.sensor;
						const deltas = getDeltas(newCoord, sensor, snap$1.range.left, snap$1.range.top, scroll, origin);
						return acc.deltas.fold(() => ({
							deltas: Optional.some(deltas),
							snap: Optional.some(snap$1)
						}), (bestDeltas) => {
							if ((deltas.left + deltas.top) / 2 <= (bestDeltas.left + bestDeltas.top) / 2) return {
								deltas: Optional.some(deltas),
								snap: Optional.some(snap$1)
							};
							else return acc;
						});
					}, {
						deltas: Optional.none(),
						snap: Optional.none()
					}).snap.map((snap$1) => ({
						output: absorb(snap$1.output, newCoord, scroll, origin),
						extra: snap$1.extra
					}));
				});
			};
			const findSnap = (component, snapInfo, newCoord, scroll, origin) => {
				return findMatchingSnap(snapInfo.getSnapPoints(component), newCoord, scroll, origin);
			};
			const snapTo$1 = (snap$1, scroll, origin) => ({
				coord: absorb(snap$1.output, snap$1.output, scroll, origin),
				extra: snap$1.extra
			});
			const snapTo = (component, dragConfig, _state, snap$1) => {
				const target = dragConfig.getTarget(component.element);
				if (dragConfig.repositionTarget) {
					const scroll = get$b(owner$4(component.element));
					const origin = getOrigin(target);
					setOptions(target, toStyles(snapTo$1(snap$1, scroll, origin).coord, scroll, origin));
				}
			};
			var DraggingApis = /* @__PURE__ */ Object.freeze({
				__proto__: null,
				snapTo
			});
			const initialAttribute = "data-initial-z-index";
			const resetZIndex = (blocker) => {
				parent(blocker.element).filter(isElement$1).each((root) => {
					getOpt(root, initialAttribute).fold(() => remove$6(root, "z-index"), (zIndex) => set$8(root, "z-index", zIndex));
					remove$7(root, initialAttribute);
				});
			};
			const changeZIndex = (blocker) => {
				parent(blocker.element).filter(isElement$1).each((root) => {
					getRaw(root, "z-index").each((zindex) => {
						set$9(root, initialAttribute, zindex);
					});
					set$8(root, "z-index", get$e(blocker.element, "z-index"));
				});
			};
			const instigate = (anyComponent, blocker) => {
				anyComponent.getSystem().addToGui(blocker);
				changeZIndex(blocker);
			};
			const discard = (blocker) => {
				resetZIndex(blocker);
				blocker.getSystem().removeFromGui(blocker);
			};
			const createComponent = (component, blockerClass, blockerEvents) => component.getSystem().build(Container.sketch({
				dom: {
					styles: {
						"left": "0px",
						"top": "0px",
						"width": "100%",
						"height": "100%",
						"position": "fixed",
						"z-index": "1000000000000000"
					},
					classes: [blockerClass]
				},
				events: blockerEvents
			}));
			var SnapSchema = optionObjOf("snaps", [
				required$1("getSnapPoints"),
				onHandler("onSensor"),
				required$1("leftAttr"),
				required$1("topAttr"),
				defaulted("lazyViewport", win),
				defaulted("mustSnap", false)
			]);
			const schema$6 = [
				defaulted("useFixed", never),
				required$1("blockerClass"),
				defaulted("getTarget", identity),
				defaulted("onDrag", noop),
				defaulted("repositionTarget", true),
				defaulted("onDrop", noop),
				defaultedFunction("getBounds", win),
				SnapSchema
			];
			const getCurrentCoord = (target) => lift3(getRaw(target, "left"), getRaw(target, "top"), getRaw(target, "position"), (left$1, top$1, position$3) => {
				return (position$3 === "fixed" ? fixed : offset)(parseInt(left$1, 10), parseInt(top$1, 10));
			}).getOrThunk(() => {
				const location = absolute$3(target);
				return absolute(location.left, location.top);
			});
			const clampCoords = (component, coords, scroll, origin, startData) => {
				const bounds$2 = startData.bounds;
				const absoluteCoord = asAbsolute(coords, scroll, origin);
				const newCoords = absolute(clamp(absoluteCoord.left, bounds$2.x, bounds$2.x + bounds$2.width - startData.width), clamp(absoluteCoord.top, bounds$2.y, bounds$2.y + bounds$2.height - startData.height));
				return coords.fold(() => {
					const offset$1 = asOffset(newCoords, scroll, origin);
					return offset(offset$1.left, offset$1.top);
				}, constant$1(newCoords), () => {
					const fixed$1$1 = asFixed(newCoords, scroll, origin);
					return fixed(fixed$1$1.left, fixed$1$1.top);
				});
			};
			const calcNewCoord = (component, optSnaps, currentCoord, scroll, origin, delta, startData) => {
				return clampCoords(component, optSnaps.fold(() => {
					const fixedCoord = asFixed(translate(currentCoord, delta.left, delta.top), scroll, origin);
					return fixed(fixedCoord.left, fixedCoord.top);
				}, (snapInfo) => {
					const snapping = moveOrSnap(component, snapInfo, currentCoord, delta, scroll, origin);
					snapping.extra.each((extra) => {
						snapInfo.onSensor(component, extra);
					});
					return snapping.coord;
				}), scroll, origin, startData);
			};
			const dragBy = (component, dragConfig, startData, delta) => {
				const target = dragConfig.getTarget(component.element);
				if (dragConfig.repositionTarget) {
					const scroll = get$b(owner$4(component.element));
					const origin = getOrigin(target);
					const currentCoord = getCurrentCoord(target);
					setOptions(target, toStyles(calcNewCoord(component, dragConfig.snaps, currentCoord, scroll, origin, delta, startData), scroll, origin));
				}
				dragConfig.onDrag(component, target, delta);
			};
			const calcStartData = (dragConfig, comp) => ({
				bounds: dragConfig.getBounds(),
				height: getOuter$2(comp.element),
				width: getOuter$1(comp.element)
			});
			const move = (component, dragConfig, dragState, dragMode, event) => {
				const delta = dragState.update(dragMode, event);
				const dragStartData = dragState.getStartData().getOrThunk(() => calcStartData(dragConfig, component));
				delta.each((dlt) => {
					dragBy(component, dragConfig, dragStartData, dlt);
				});
			};
			const stop = (component, blocker, dragConfig, dragState) => {
				blocker.each(discard);
				dragConfig.snaps.each((snapInfo) => {
					stopDrag(component, snapInfo);
				});
				const target = dragConfig.getTarget(component.element);
				dragState.reset();
				dragConfig.onDrop(component, target);
			};
			const handlers = (events$10) => (dragConfig, dragState) => {
				const updateStartState = (comp) => {
					dragState.setStartData(calcStartData(dragConfig, comp));
				};
				return derive$2([run$1(windowScroll(), (comp) => {
					dragState.getStartData().each(() => updateStartState(comp));
				}), ...events$10(dragConfig, dragState, updateStartState)]);
			};
			const init$3 = (dragApi) => derive$2([
				run$1(mousedown(), dragApi.forceDrop),
				run$1(mouseup(), dragApi.drop),
				run$1(mousemove(), (comp, simulatedEvent) => {
					dragApi.move(simulatedEvent.event);
				}),
				run$1(mouseout(), dragApi.delayDrop)
			]);
			const getData$1 = (event) => Optional.from(SugarPosition(event.x, event.y));
			const getDelta$1 = (old, nu$10) => SugarPosition(nu$10.left - old.left, nu$10.top - old.top);
			var MouseData = /* @__PURE__ */ Object.freeze({
				__proto__: null,
				getData: getData$1,
				getDelta: getDelta$1
			});
			const events$3 = (dragConfig, dragState, updateStartState) => [run$1(mousedown(), (component, simulatedEvent) => {
				if (simulatedEvent.event.raw.button !== 0) return;
				simulatedEvent.stop();
				const stop$1 = () => stop(component, Optional.some(blocker), dragConfig, dragState);
				const delayDrop = DelayedFunction(stop$1, 200);
				const dragApi = {
					drop: stop$1,
					delayDrop: delayDrop.schedule,
					forceDrop: stop$1,
					move: (event) => {
						delayDrop.cancel();
						move(component, dragConfig, dragState, MouseData, event);
					}
				};
				const blocker = createComponent(component, dragConfig.blockerClass, init$3(dragApi));
				const start = () => {
					updateStartState(component);
					instigate(component, blocker);
				};
				start();
			})];
			const schema$5 = [...schema$6, output$1("dragger", { handlers: handlers(events$3) })];
			const init$2 = (dragApi) => derive$2([
				run$1(touchstart(), dragApi.forceDrop),
				run$1(touchend(), dragApi.drop),
				run$1(touchcancel(), dragApi.drop),
				run$1(touchmove(), (comp, simulatedEvent) => {
					dragApi.move(simulatedEvent.event);
				})
			]);
			const getDataFrom = (touches) => {
				const touch$1 = touches[0];
				return Optional.some(SugarPosition(touch$1.clientX, touch$1.clientY));
			};
			const getData = (event) => {
				const touches = event.raw.touches;
				return touches.length === 1 ? getDataFrom(touches) : Optional.none();
			};
			const getDelta = (old, nu$10) => SugarPosition(nu$10.left - old.left, nu$10.top - old.top);
			var TouchData = /* @__PURE__ */ Object.freeze({
				__proto__: null,
				getData,
				getDelta
			});
			const events$2 = (dragConfig, dragState, updateStartState) => {
				const blockerSingleton = value$2();
				const stopBlocking = (component) => {
					stop(component, blockerSingleton.get(), dragConfig, dragState);
					blockerSingleton.clear();
				};
				return [
					run$1(touchstart(), (component, simulatedEvent) => {
						simulatedEvent.stop();
						const stop$1 = () => stopBlocking(component);
						const dragApi = {
							drop: stop$1,
							delayDrop: noop,
							forceDrop: stop$1,
							move: (event) => {
								move(component, dragConfig, dragState, TouchData, event);
							}
						};
						const blocker = createComponent(component, dragConfig.blockerClass, init$2(dragApi));
						blockerSingleton.set(blocker);
						const start = () => {
							updateStartState(component);
							instigate(component, blocker);
						};
						start();
					}),
					run$1(touchmove(), (component, simulatedEvent) => {
						simulatedEvent.stop();
						move(component, dragConfig, dragState, TouchData, simulatedEvent.event);
					}),
					run$1(touchend(), (component, simulatedEvent) => {
						simulatedEvent.stop();
						stopBlocking(component);
					}),
					run$1(touchcancel(), stopBlocking)
				];
			};
			const schema$4 = [...schema$6, output$1("dragger", { handlers: handlers(events$2) })];
			const events$1 = (dragConfig, dragState, updateStartState) => [...events$3(dragConfig, dragState, updateStartState), ...events$2(dragConfig, dragState, updateStartState)];
			const schema$3 = [...schema$6, output$1("dragger", { handlers: handlers(events$1) })];
			const mouse = schema$5;
			const touch = schema$4;
			const mouseOrTouch = schema$3;
			var DraggingBranches = /* @__PURE__ */ Object.freeze({
				__proto__: null,
				mouse,
				touch,
				mouseOrTouch
			});
			const init$1 = () => {
				let previous = Optional.none();
				let startData = Optional.none();
				const reset$3 = () => {
					previous = Optional.none();
					startData = Optional.none();
				};
				const calculateDelta = (mode, nu$10) => {
					const result = previous.map((old) => mode.getDelta(old, nu$10));
					previous = Optional.some(nu$10);
					return result;
				};
				const update = (mode, dragEvent) => mode.getData(dragEvent).bind((nuData) => calculateDelta(mode, nuData));
				const setStartData = (data) => {
					startData = Optional.some(data);
				};
				const getStartData = () => startData;
				return nu$8({
					readState: constant$1({}),
					reset: reset$3,
					update,
					getStartData,
					setStartData
				});
			};
			const Dragging = createModes({
				branchKey: "mode",
				branches: DraggingBranches,
				name: "dragging",
				active: { events: (dragConfig, dragState) => {
					return dragConfig.dragger.handlers(dragConfig, dragState);
				} },
				extra: { snap: (sConfig) => ({
					sensor: sConfig.sensor,
					range: sConfig.range,
					output: sConfig.output,
					extra: Optional.from(sConfig.extra)
				}) },
				state: /* @__PURE__ */ Object.freeze({
					__proto__: null,
					init: init$1
				}),
				apis: DraggingApis
			});
			const snapWidth = 40;
			const snapOffset = snapWidth / 2;
			const calcSnap = (selectorOpt, td, x, y, width$1, height$1) => selectorOpt.fold(() => Dragging.snap({
				sensor: absolute(x - snapOffset, y - snapOffset),
				range: SugarPosition(width$1, height$1),
				output: absolute(Optional.some(x), Optional.some(y)),
				extra: { td }
			}), (selectorHandle) => {
				const sensorLeft = x - snapOffset;
				const sensorTop = y - snapOffset;
				const sensorWidth = snapWidth;
				const sensorHeight = snapWidth;
				const rect$1 = selectorHandle.element.dom.getBoundingClientRect();
				return Dragging.snap({
					sensor: absolute(sensorLeft, sensorTop),
					range: SugarPosition(sensorWidth, sensorHeight),
					output: absolute(Optional.some(x - rect$1.width / 2), Optional.some(y - rect$1.height / 2)),
					extra: { td }
				});
			});
			const getSnapsConfig = (getSnapPoints, cell, onChange) => {
				const isSameCell = (cellOpt, td) => cellOpt.exists((currentTd) => eq(currentTd, td));
				return {
					getSnapPoints,
					leftAttr: "data-drag-left",
					topAttr: "data-drag-top",
					onSensor: (component, extra) => {
						const td = extra.td;
						if (!isSameCell(cell.get(), td)) {
							cell.set(td);
							onChange(td);
						}
					},
					mustSnap: true
				};
			};
			const createSelector = (snaps) => record(Button.sketch({
				dom: {
					tag: "div",
					classes: ["tox-selector"]
				},
				buttonBehaviours: derive$1([Dragging.config({
					mode: "mouseOrTouch",
					blockerClass: "blocker",
					snaps
				}), Unselecting.config({})]),
				eventOrder: {
					mousedown: ["dragging", "alloy.base.behaviour"],
					touchstart: ["dragging", "alloy.base.behaviour"]
				}
			}));
			const setup$4 = (editor, sink) => {
				const tlTds = Cell([]);
				const brTds = Cell([]);
				const isVisible$1 = Cell(false);
				const startCell = value$2();
				const finishCell = value$2();
				const getTopLeftSnap = (td) => {
					const box$2 = absolute$2(td);
					return calcSnap(memTopLeft.getOpt(sink), td, box$2.x, box$2.y, box$2.width, box$2.height);
				};
				const getTopLeftSnaps = () => map$2(tlTds.get(), (td) => getTopLeftSnap(td));
				const getBottomRightSnap = (td) => {
					const box$2 = absolute$2(td);
					return calcSnap(memBottomRight.getOpt(sink), td, box$2.right, box$2.bottom, box$2.width, box$2.height);
				};
				const getBottomRightSnaps = () => map$2(brTds.get(), (td) => getBottomRightSnap(td));
				const topLeftSnaps = getSnapsConfig(getTopLeftSnaps, startCell, (start) => {
					finishCell.get().each((finish) => {
						editor.dispatch("TableSelectorChange", {
							start,
							finish
						});
					});
				});
				const bottomRightSnaps = getSnapsConfig(getBottomRightSnaps, finishCell, (finish) => {
					startCell.get().each((start) => {
						editor.dispatch("TableSelectorChange", {
							start,
							finish
						});
					});
				});
				const memTopLeft = createSelector(topLeftSnaps);
				const memBottomRight = createSelector(bottomRightSnaps);
				const topLeft = build$1(memTopLeft.asSpec());
				const bottomRight = build$1(memBottomRight.asSpec());
				const showOrHideHandle = (selector, cell, isAbove, isBelow) => {
					const cellRect = cell.dom.getBoundingClientRect();
					remove$6(selector.element, "display");
					const viewportHeight = defaultView(SugarElement.fromDom(editor.getBody())).dom.innerHeight;
					const aboveViewport = isAbove(cellRect);
					const belowViewport = isBelow(cellRect, viewportHeight);
					if (aboveViewport || belowViewport) set$8(selector.element, "display", "none");
				};
				const snapTo$2 = (selector, cell, getSnapConfig, pos) => {
					const snap$1 = getSnapConfig(cell);
					Dragging.snapTo(selector, snap$1);
					const isAbove = (rect$1) => rect$1[pos] < 0;
					const isBelow = (rect$1, viewportHeight) => rect$1[pos] > viewportHeight;
					showOrHideHandle(selector, cell, isAbove, isBelow);
				};
				const snapTopLeft = (cell) => snapTo$2(topLeft, cell, getTopLeftSnap, "top");
				const snapLastTopLeft = () => startCell.get().each(snapTopLeft);
				const snapBottomRight = (cell) => snapTo$2(bottomRight, cell, getBottomRightSnap, "bottom");
				const snapLastBottomRight = () => finishCell.get().each(snapBottomRight);
				if (detect$2().deviceType.isTouch()) {
					editor.on("TableSelectionChange", (e) => {
						if (!isVisible$1.get()) {
							attach(sink, topLeft);
							attach(sink, bottomRight);
							isVisible$1.set(true);
						}
						startCell.set(e.start);
						finishCell.set(e.finish);
						e.otherCells.each((otherCells) => {
							tlTds.set(otherCells.upOrLeftCells);
							brTds.set(otherCells.downOrRightCells);
							snapTopLeft(e.start);
							snapBottomRight(e.finish);
						});
					});
					editor.on("ResizeEditor ResizeWindow ScrollContent", () => {
						snapLastTopLeft();
						snapLastBottomRight();
					});
					editor.on("TableSelectionClear", () => {
						if (isVisible$1.get()) {
							detach(topLeft);
							detach(bottomRight);
							isVisible$1.set(false);
						}
						startCell.clear();
						finishCell.clear();
					});
				}
			};
			var Logo = "<svg width=\"50px\" height=\"16px\" viewBox=\"0 0 50 16\" xmlns=\"http://www.w3.org/2000/svg\">\n  <path fill-rule=\"evenodd\" clip-rule=\"evenodd\" d=\"M10.143 0c2.608.015 5.186 2.178 5.186 5.331 0 0 .077 3.812-.084 4.87-.361 2.41-2.164 4.074-4.65 4.496-1.453.284-2.523.49-3.212.623-.373.071-.634.122-.785.152-.184.038-.997.145-1.35.145-2.732 0-5.21-2.04-5.248-5.33 0 0 0-3.514.03-4.442.093-2.4 1.758-4.342 4.926-4.963 0 0 3.875-.752 4.036-.782.368-.07.775-.1 1.15-.1Zm1.826 2.8L5.83 3.989v2.393l-2.455.475v5.968l6.137-1.189V9.243l2.456-.476V2.8ZM5.83 6.382l3.682-.713v3.574l-3.682.713V6.382Zm27.173-1.64-.084-1.066h-2.226v9.132h2.456V7.743c-.008-1.151.998-2.064 2.149-2.072 1.15-.008 1.987.92 1.995 2.072v5.065h2.455V7.359c-.015-2.18-1.657-3.929-3.837-3.913a3.993 3.993 0 0 0-2.908 1.296Zm-6.3-4.266L29.16 0v2.387l-2.456.475V.476Zm0 3.2v9.132h2.456V3.676h-2.456Zm18.179 11.787L49.11 3.676H46.58l-1.612 4.527-.46 1.382-.384-1.382-1.611-4.527H39.98l3.3 9.132L42.15 16l2.732-.537ZM22.867 9.738c0 .752.568 1.075.921 1.075.353 0 .668-.047.998-.154l.537 1.765c-.23.154-.92.537-2.225.537-1.305 0-2.655-.997-2.686-2.686a136.877 136.877 0 0 1 0-4.374H18.8V3.676h1.612v-1.98l2.455-.476v2.456h2.302V5.9h-2.302v3.837Z\"/>\n</svg>\n";
			const isHidden = (elm) => elm.nodeName === "BR" || !!elm.getAttribute("data-mce-bogus") || elm.getAttribute("data-mce-type") === "bookmark";
			const renderElementPath = (editor, settings, providersBackstage) => {
				var _a;
				const delimiter = (_a = settings.delimiter) !== null && _a !== void 0 ? _a : "";
				const renderElement = (name$4, element$1, index) => Button.sketch({
					dom: {
						tag: "div",
						classes: ["tox-statusbar__path-item"],
						attributes: {
							"data-index": index,
							"aria-level": index + 1
						}
					},
					components: [text$2(name$4)],
					action: (_btn) => {
						editor.focus();
						editor.selection.select(element$1);
						editor.nodeChanged();
					},
					buttonBehaviours: derive$1([DisablingConfigs.button(providersBackstage.isDisabled), receivingConfig()])
				});
				const renderDivider = () => ({
					dom: {
						tag: "div",
						classes: ["tox-statusbar__path-divider"],
						attributes: { "aria-hidden": true }
					},
					components: [text$2(` ${delimiter} `)]
				});
				const renderPathData = (data) => foldl(data, (acc, path$2, index) => {
					const element$1 = renderElement(path$2.name, path$2.element, index);
					if (index === 0) return acc.concat([element$1]);
					else return acc.concat([renderDivider(), element$1]);
				}, []);
				const updatePath = (parents$1) => {
					const newPath = [];
					let i = parents$1.length;
					while (i-- > 0) {
						const parent$1 = parents$1[i];
						if (parent$1.nodeType === 1 && !isHidden(parent$1)) {
							const args = fireResolveName(editor, parent$1);
							if (!args.isDefaultPrevented()) newPath.push({
								name: args.name,
								element: parent$1
							});
							if (args.isPropagationStopped()) break;
						}
					}
					return newPath;
				};
				return {
					dom: {
						tag: "div",
						classes: ["tox-statusbar__path"],
						attributes: { role: "navigation" }
					},
					behaviours: derive$1([
						Keying.config({
							mode: "flow",
							selector: "div[role=button]"
						}),
						Disabling.config({ disabled: providersBackstage.isDisabled }),
						receivingConfig(),
						Tabstopping.config({}),
						Replacing.config({}),
						config("elementPathEvents", [runOnAttached((comp, _e) => {
							editor.shortcuts.add("alt+F11", "focus statusbar elementpath", () => Keying.focusIn(comp));
							editor.on("NodeChange", (e) => {
								const newPath = updatePath(e.parents);
								const newChildren = newPath.length > 0 ? renderPathData(newPath) : [];
								Replacing.set(comp, newChildren);
							});
						})])
					]),
					components: []
				};
			};
			var ResizeTypes;
			(function(ResizeTypes$1) {
				ResizeTypes$1[ResizeTypes$1["None"] = 0] = "None";
				ResizeTypes$1[ResizeTypes$1["Both"] = 1] = "Both";
				ResizeTypes$1[ResizeTypes$1["Vertical"] = 2] = "Vertical";
			})(ResizeTypes || (ResizeTypes = {}));
			const getDimensions = (editor, deltas, resizeType, originalHeight, originalWidth) => {
				const dimensions = { height: calcCappedSize(originalHeight + deltas.top, getMinHeightOption(editor), getMaxHeightOption(editor)) };
				if (resizeType === ResizeTypes.Both) dimensions.width = calcCappedSize(originalWidth + deltas.left, getMinWidthOption(editor), getMaxWidthOption(editor));
				return dimensions;
			};
			const resize = (editor, deltas, resizeType) => {
				const container = SugarElement.fromDom(editor.getContainer());
				each(getDimensions(editor, deltas, resizeType, get$d(container), get$c(container)), (val, dim) => {
					if (isNumber(val)) set$8(container, dim, numToPx(val));
				});
				fireResizeEditor(editor);
			};
			const getResizeType = (editor) => {
				const resize$1 = getResize(editor);
				if (resize$1 === false) return ResizeTypes.None;
				else if (resize$1 === "both") return ResizeTypes.Both;
				else return ResizeTypes.Vertical;
			};
			const keyboardHandler = (editor, resizeType, x, y) => {
				const scale = 20;
				resize(editor, SugarPosition(x * scale, y * scale), resizeType);
				return Optional.some(true);
			};
			const renderResizeHandler = (editor, providersBackstage) => {
				const resizeType = getResizeType(editor);
				if (resizeType === ResizeTypes.None) return Optional.none();
				const resizeLabel = resizeType === ResizeTypes.Both ? "Press the arrow keys to resize the editor." : "Press the Up and Down arrow keys to resize the editor.";
				return Optional.some(render$3("resize-handle", {
					tag: "div",
					classes: ["tox-statusbar__resize-handle"],
					attributes: {
						"title": providersBackstage.translate("Resize"),
						"aria-label": providersBackstage.translate(resizeLabel)
					},
					behaviours: [
						Dragging.config({
							mode: "mouse",
							repositionTarget: false,
							onDrag: (_comp, _target, delta) => resize(editor, delta, resizeType),
							blockerClass: "tox-blocker"
						}),
						Keying.config({
							mode: "special",
							onLeft: () => keyboardHandler(editor, resizeType, -1, 0),
							onRight: () => keyboardHandler(editor, resizeType, 1, 0),
							onUp: () => keyboardHandler(editor, resizeType, 0, -1),
							onDown: () => keyboardHandler(editor, resizeType, 0, 1)
						}),
						Tabstopping.config({}),
						Focusing.config({})
					]
				}, providersBackstage.icons));
			};
			const renderWordCount = (editor, providersBackstage) => {
				const replaceCountText = (comp, count, mode) => Replacing.set(comp, [text$2(providersBackstage.translate(["{0} " + mode, count[mode]]))]);
				return Button.sketch({
					dom: {
						tag: "button",
						classes: ["tox-statusbar__wordcount"]
					},
					components: [],
					buttonBehaviours: derive$1([
						DisablingConfigs.button(providersBackstage.isDisabled),
						receivingConfig(),
						Tabstopping.config({}),
						Replacing.config({}),
						Representing.config({ store: {
							mode: "memory",
							initialValue: {
								mode: "words",
								count: {
									words: 0,
									characters: 0
								}
							}
						} }),
						config("wordcount-events", [runOnExecute$1((comp) => {
							const currentVal = Representing.getValue(comp);
							const newMode = currentVal.mode === "words" ? "characters" : "words";
							Representing.setValue(comp, {
								mode: newMode,
								count: currentVal.count
							});
							replaceCountText(comp, currentVal.count, newMode);
						}), runOnAttached((comp) => {
							editor.on("wordCountUpdate", (e) => {
								const { mode } = Representing.getValue(comp);
								Representing.setValue(comp, {
									mode,
									count: e.wordCount
								});
								replaceCountText(comp, e.wordCount, mode);
							});
						})])
					]),
					eventOrder: { [execute$5()]: [
						"disabling",
						"alloy.base.behaviour",
						"wordcount-events"
					] }
				});
			};
			const renderStatusbar = (editor, providersBackstage) => {
				const renderBranding = () => {
					return {
						dom: {
							tag: "span",
							classes: ["tox-statusbar__branding"]
						},
						components: [{
							dom: {
								tag: "a",
								attributes: {
									"href": "https://www.tiny.cloud/powered-by-tiny?utm_campaign=editor_referral&utm_medium=poweredby&utm_source=tinymce&utm_content=v6",
									"rel": "noopener",
									"target": "_blank",
									"aria-label": global$8.translate(["Powered by {0}", "Tiny"])
								},
								innerHtml: Logo.trim()
							},
							behaviours: derive$1([Focusing.config({})])
						}]
					};
				};
				const renderHelpAccessibility = () => {
					const shortcutText = convertText("Alt+0");
					return {
						dom: {
							tag: "div",
							classes: ["tox-statusbar__help-text"]
						},
						components: [text$2(global$8.translate([`Press {0} for help`, shortcutText]))]
					};
				};
				const renderRightContainer = () => {
					const components$2 = [];
					if (editor.hasPlugin("wordcount")) components$2.push(renderWordCount(editor, providersBackstage));
					if (useBranding(editor)) components$2.push(renderBranding());
					return {
						dom: {
							tag: "div",
							classes: ["tox-statusbar__right-container"]
						},
						components: components$2
					};
				};
				const getTextComponents = () => {
					const components$2 = [];
					const shouldRenderHelp = useHelpAccessibility(editor);
					const shouldRenderElementPath = useElementPath(editor);
					const shouldRenderRightContainer = useBranding(editor) || editor.hasPlugin("wordcount");
					const getTextComponentClasses = () => {
						const flexStart = "tox-statusbar__text-container--flex-start";
						const flexEnd = "tox-statusbar__text-container--flex-end";
						const spaceAround = "tox-statusbar__text-container--space-around";
						if (shouldRenderHelp) {
							const container3Columns = "tox-statusbar__text-container-3-cols";
							if (!shouldRenderRightContainer && !shouldRenderElementPath) return [container3Columns, spaceAround];
							if (shouldRenderRightContainer && !shouldRenderElementPath) return [container3Columns, flexEnd];
							return [container3Columns, flexStart];
						}
						return [shouldRenderRightContainer && !shouldRenderElementPath ? flexEnd : flexStart];
					};
					if (shouldRenderElementPath) components$2.push(renderElementPath(editor, {}, providersBackstage));
					if (shouldRenderHelp) components$2.push(renderHelpAccessibility());
					if (shouldRenderRightContainer) components$2.push(renderRightContainer());
					if (components$2.length > 0) return [{
						dom: {
							tag: "div",
							classes: ["tox-statusbar__text-container", ...getTextComponentClasses()]
						},
						components: components$2
					}];
					return [];
				};
				const getComponents = () => {
					const components$2 = getTextComponents();
					const resizeHandler = renderResizeHandler(editor, providersBackstage);
					return components$2.concat(resizeHandler.toArray());
				};
				return {
					dom: {
						tag: "div",
						classes: ["tox-statusbar"]
					},
					components: getComponents()
				};
			};
			const getLazyMothership = (label$1, singleton$2) => singleton$2.get().getOrDie(`UI for ${label$1} has not been rendered`);
			const setup$3 = (editor, setupForTheme) => {
				const isInline = editor.inline;
				const mode = isInline ? Inline : Iframe;
				const header = isStickyToolbar(editor) ? StickyHeader : StaticHeader;
				const lazyUiRefs = LazyUiReferences();
				const lazyMothership = value$2();
				const lazyDialogMothership = value$2();
				const lazyPopupMothership = value$2();
				const deviceClasses = detect$2().deviceType.isTouch() ? ["tox-platform-touch"] : [];
				const isToolbarBottom = isToolbarLocationBottom(editor);
				const toolbarMode = getToolbarMode(editor);
				const memAnchorBar = record({ dom: {
					tag: "div",
					classes: ["tox-anchorbar"]
				} });
				const memBottomAnchorBar = record({ dom: {
					tag: "div",
					classes: ["tox-bottom-anchorbar"]
				} });
				const lazyHeader = () => lazyUiRefs.mainUi.get().map((ui) => ui.outerContainer).bind(OuterContainer.getHeader);
				const lazyDialogSinkResult = () => Result.fromOption(lazyUiRefs.dialogUi.get().map((ui) => ui.sink), "UI has not been rendered");
				const lazyPopupSinkResult = () => Result.fromOption(lazyUiRefs.popupUi.get().map((ui) => ui.sink), "(popup) UI has not been rendered");
				const lazyAnchorBar = lazyUiRefs.lazyGetInOuterOrDie("anchor bar", memAnchorBar.getOpt);
				const lazyBottomAnchorBar = lazyUiRefs.lazyGetInOuterOrDie("bottom anchor bar", memBottomAnchorBar.getOpt);
				const lazyToolbar = lazyUiRefs.lazyGetInOuterOrDie("toolbar", OuterContainer.getToolbar);
				const lazyThrobber = lazyUiRefs.lazyGetInOuterOrDie("throbber", OuterContainer.getThrobber);
				const backstages = init$6({
					popup: lazyPopupSinkResult,
					dialog: lazyDialogSinkResult
				}, editor, lazyAnchorBar, lazyBottomAnchorBar);
				const makeHeaderPart = () => {
					const verticalDirAttributes = { attributes: { [Attribute]: isToolbarBottom ? AttributeValue.BottomToTop : AttributeValue.TopToBottom } };
					const partMenubar$1 = OuterContainer.parts.menubar({
						dom: {
							tag: "div",
							classes: ["tox-menubar"]
						},
						backstage: backstages.popup,
						onEscape: () => {
							editor.focus();
						}
					});
					const partToolbar$1 = OuterContainer.parts.toolbar({
						dom: {
							tag: "div",
							classes: ["tox-toolbar"]
						},
						getSink: backstages.popup.shared.getSink,
						providers: backstages.popup.shared.providers,
						onEscape: () => {
							editor.focus();
						},
						onToolbarToggled: (state) => {
							fireToggleToolbarDrawer(editor, state);
						},
						type: toolbarMode,
						lazyToolbar,
						lazyHeader: () => lazyHeader().getOrDie("Could not find header element"),
						...verticalDirAttributes
					});
					const partMultipleToolbar$1 = OuterContainer.parts["multiple-toolbar"]({
						dom: {
							tag: "div",
							classes: ["tox-toolbar-overlord"]
						},
						providers: backstages.popup.shared.providers,
						onEscape: () => {
							editor.focus();
						},
						type: toolbarMode
					});
					const hasMultipleToolbar = isMultipleToolbars(editor);
					const hasToolbar = isToolbarEnabled(editor);
					const hasMenubar = isMenubarEnabled(editor);
					const shouldHavePromotion = promotionEnabled(editor);
					const partPromotion$1 = makePromotion();
					const hasAnyContents = hasMultipleToolbar || hasToolbar || hasMenubar;
					const getPartToolbar = () => {
						if (hasMultipleToolbar) return [partMultipleToolbar$1];
						else if (hasToolbar) return [partToolbar$1];
						else return [];
					};
					const menubarCollection = shouldHavePromotion ? [partPromotion$1, partMenubar$1] : [partMenubar$1];
					return OuterContainer.parts.header({
						dom: {
							tag: "div",
							classes: ["tox-editor-header"].concat(hasAnyContents ? [] : ["tox-editor-header--empty"]),
							...verticalDirAttributes
						},
						components: flatten([
							hasMenubar ? menubarCollection : [],
							getPartToolbar(),
							useFixedContainer(editor) ? [] : [memAnchorBar.asSpec()]
						]),
						sticky: isStickyToolbar(editor),
						editor,
						sharedBackstage: backstages.popup.shared
					});
				};
				const makePromotion = () => {
					return OuterContainer.parts.promotion({ dom: {
						tag: "div",
						classes: ["tox-promotion"]
					} });
				};
				const makeSidebarDefinition = () => {
					return {
						dom: {
							tag: "div",
							classes: ["tox-sidebar-wrap"]
						},
						components: [OuterContainer.parts.socket({ dom: {
							tag: "div",
							classes: ["tox-edit-area"]
						} }), OuterContainer.parts.sidebar({ dom: {
							tag: "div",
							classes: ["tox-sidebar"]
						} })]
					};
				};
				const renderDialogUi = () => {
					const uiContainer = getUiContainer(editor);
					const isGridUiContainer = eq(body(), uiContainer) && get$e(uiContainer, "display") === "grid";
					const sinkSpec = {
						dom: {
							tag: "div",
							classes: [
								"tox",
								"tox-silver-sink",
								"tox-tinymce-aux"
							].concat(deviceClasses),
							attributes: { ...global$8.isRtl() ? { dir: "rtl" } : {} }
						},
						behaviours: derive$1([Positioning.config({ useFixed: () => header.isDocked(lazyHeader) })])
					};
					const reactiveWidthSpec = {
						dom: { styles: { width: document.body.clientWidth + "px" } },
						events: derive$2([run$1(windowResize(), (comp) => {
							set$8(comp.element, "width", document.body.clientWidth + "px");
						})])
					};
					const sink = build$1(deepMerge(sinkSpec, isGridUiContainer ? reactiveWidthSpec : {}));
					const uiMothership = takeover(sink);
					lazyDialogMothership.set(uiMothership);
					return {
						sink,
						mothership: uiMothership
					};
				};
				const renderPopupUi = () => {
					const sink = build$1({
						dom: {
							tag: "div",
							classes: [
								"tox",
								"tox-silver-sink",
								"tox-silver-popup-sink",
								"tox-tinymce-aux"
							].concat(deviceClasses),
							attributes: { ...global$8.isRtl() ? { dir: "rtl" } : {} }
						},
						behaviours: derive$1([Positioning.config({
							useFixed: () => header.isDocked(lazyHeader),
							getBounds: () => setupForTheme.getPopupSinkBounds()
						})])
					});
					const uiMothership = takeover(sink);
					lazyPopupMothership.set(uiMothership);
					return {
						sink,
						mothership: uiMothership
					};
				};
				const renderMainUi = () => {
					const partHeader$1 = makeHeaderPart();
					const sidebarContainer = makeSidebarDefinition();
					const partThrobber$1 = OuterContainer.parts.throbber({
						dom: {
							tag: "div",
							classes: ["tox-throbber"]
						},
						backstage: backstages.popup
					});
					const partViewWrapper$1 = OuterContainer.parts.viewWrapper({ backstage: backstages.popup });
					const statusbar = useStatusBar(editor) && !isInline ? Optional.some(renderStatusbar(editor, backstages.popup.shared.providers)) : Optional.none();
					const editorComponents = flatten([
						isToolbarBottom ? [] : [partHeader$1],
						isInline ? [] : [sidebarContainer],
						isToolbarBottom ? [partHeader$1] : []
					]);
					const editorContainer = OuterContainer.parts.editorContainer({ components: flatten([editorComponents, isInline ? [] : [memBottomAnchorBar.asSpec(), ...statusbar.toArray()]]) });
					const isHidden$2 = isDistractionFree(editor);
					const attributes = {
						role: "application",
						...global$8.isRtl() ? { dir: "rtl" } : {},
						...isHidden$2 ? { "aria-hidden": "true" } : {}
					};
					const outerContainer = build$1(OuterContainer.sketch({
						dom: {
							tag: "div",
							classes: ["tox", "tox-tinymce"].concat(isInline ? ["tox-tinymce-inline"] : []).concat(isToolbarBottom ? ["tox-tinymce--toolbar-bottom"] : []).concat(deviceClasses),
							styles: {
								visibility: "hidden",
								...isHidden$2 ? {
									opacity: "0",
									border: "0"
								} : {}
							},
							attributes
						},
						components: [
							editorContainer,
							...isInline ? [] : [partViewWrapper$1],
							partThrobber$1
						],
						behaviours: derive$1([
							receivingConfig(),
							Disabling.config({ disableClass: "tox-tinymce--disabled" }),
							Keying.config({
								mode: "cyclic",
								selector: ".tox-menubar, .tox-toolbar, .tox-toolbar__primary, .tox-toolbar__overflow--open, .tox-sidebar__overflow--open, .tox-statusbar__path, .tox-statusbar__wordcount, .tox-statusbar__branding a, .tox-statusbar__resize-handle"
							})
						])
					}));
					const mothership = takeover(outerContainer);
					lazyMothership.set(mothership);
					return {
						mothership,
						outerContainer
					};
				};
				const setEditorSize = (outerContainer) => {
					const parsedHeight = numToPx(getHeightWithFallback(editor));
					const parsedWidth = numToPx(getWidthWithFallback(editor));
					if (!editor.inline) {
						if (isValidValue$1("div", "width", parsedWidth)) set$8(outerContainer.element, "width", parsedWidth);
						if (isValidValue$1("div", "height", parsedHeight)) set$8(outerContainer.element, "height", parsedHeight);
						else set$8(outerContainer.element, "height", "400px");
					}
					return parsedHeight;
				};
				const setupShortcutsAndCommands = (outerContainer) => {
					editor.addShortcut("alt+F9", "focus menubar", () => {
						OuterContainer.focusMenubar(outerContainer);
					});
					editor.addShortcut("alt+F10", "focus toolbar", () => {
						OuterContainer.focusToolbar(outerContainer);
					});
					editor.addCommand("ToggleToolbarDrawer", (_ui, options) => {
						if (options === null || options === void 0 ? void 0 : options.skipFocus) OuterContainer.toggleToolbarDrawerWithoutFocusing(outerContainer);
						else OuterContainer.toggleToolbarDrawer(outerContainer);
					});
					editor.addQueryStateHandler("ToggleToolbarDrawer", () => OuterContainer.isToolbarDrawerToggled(outerContainer));
				};
				const renderUIWithRefs = (uiRefs) => {
					const { mainUi, popupUi, uiMotherships } = uiRefs;
					map$1(getToolbarGroups(editor), (toolbarGroupButtonConfig, name$4) => {
						editor.ui.registry.addGroupToolbarButton(name$4, toolbarGroupButtonConfig);
					});
					const { buttons, menuItems, contextToolbars, sidebars, views } = editor.ui.registry.getAll();
					const toolbarOpt = getMultipleToolbarsOption(editor);
					const rawUiConfig = {
						menuItems,
						menus: getMenus(editor),
						menubar: getMenubar(editor),
						toolbar: toolbarOpt.getOrThunk(() => getToolbar(editor)),
						allowToolbarGroups: toolbarMode === ToolbarMode$1.floating,
						buttons,
						sidebar: sidebars,
						views
					};
					setupShortcutsAndCommands(mainUi.outerContainer);
					setup$b(editor, mainUi.mothership, uiMotherships);
					header.setup(editor, backstages.popup.shared, lazyHeader);
					setup$6(editor, backstages.popup);
					setup$5(editor, backstages.popup.shared.getSink, backstages.popup);
					setup$8(editor);
					setup$7(editor, lazyThrobber, backstages.popup.shared);
					register$9(editor, contextToolbars, popupUi.sink, { backstage: backstages.popup });
					setup$4(editor, popupUi.sink);
					const args = {
						targetNode: editor.getElement(),
						height: setEditorSize(mainUi.outerContainer)
					};
					return mode.render(editor, uiRefs, rawUiConfig, backstages.popup, args);
				};
				const reuseDialogUiForPopuUi = (dialogUi) => {
					lazyPopupMothership.set(dialogUi.mothership);
					return dialogUi;
				};
				const renderUI = () => {
					const mainUi = renderMainUi();
					const dialogUi = renderDialogUi();
					const popupUi = isSplitUiMode(editor) ? renderPopupUi() : reuseDialogUiForPopuUi(dialogUi);
					lazyUiRefs.dialogUi.set(dialogUi);
					lazyUiRefs.popupUi.set(popupUi);
					lazyUiRefs.mainUi.set(mainUi);
					return renderUIWithRefs({
						popupUi,
						dialogUi,
						mainUi,
						uiMotherships: lazyUiRefs.getUiMotherships()
					});
				};
				return {
					popups: {
						backstage: backstages.popup,
						getMothership: () => getLazyMothership("popups", lazyPopupMothership)
					},
					dialogs: {
						backstage: backstages.dialog,
						getMothership: () => getLazyMothership("dialogs", lazyDialogMothership)
					},
					renderUI
				};
			};
			const labelledBy = (labelledElement, labelElement) => {
				set$9(labelledElement, "aria-labelledby", getOpt(labelledElement, "id").fold(() => {
					const id = generate$6("dialog-label");
					set$9(labelElement, "id", id);
					return id;
				}, identity));
			};
			const schema$2 = constant$1([
				required$1("lazySink"),
				option$3("dragBlockClass"),
				defaultedFunction("getBounds", win),
				defaulted("useTabstopAt", always),
				defaulted("firstTabstop", 0),
				defaulted("eventOrder", {}),
				field("modalBehaviours", [Keying]),
				onKeyboardHandler("onExecute"),
				onStrictKeyboardHandler("onEscape")
			]);
			const basic = { sketch: identity };
			const parts$2 = constant$1([
				optional({
					name: "draghandle",
					overrides: (detail, spec) => {
						return { behaviours: derive$1([Dragging.config({
							mode: "mouse",
							getTarget: (handle$1) => {
								return ancestor(handle$1, "[role=\"dialog\"]").getOr(handle$1);
							},
							blockerClass: detail.dragBlockClass.getOrDie((/* @__PURE__ */ new Error("The drag blocker class was not specified for a dialog with a drag handle: \n" + JSON.stringify(spec, null, 2))).message),
							getBounds: detail.getDragBounds
						})]) };
					}
				}),
				required({
					schema: [required$1("dom")],
					name: "title"
				}),
				required({
					factory: basic,
					schema: [required$1("dom")],
					name: "close"
				}),
				required({
					factory: basic,
					schema: [required$1("dom")],
					name: "body"
				}),
				optional({
					factory: basic,
					schema: [required$1("dom")],
					name: "footer"
				}),
				external({
					factory: { sketch: (spec, detail) => ({
						...spec,
						dom: detail.dom,
						components: detail.components
					}) },
					schema: [defaulted("dom", {
						tag: "div",
						styles: {
							position: "fixed",
							left: "0px",
							top: "0px",
							right: "0px",
							bottom: "0px"
						}
					}), defaulted("components", [])],
					name: "blocker"
				})
			]);
			const factory$4 = (detail, components$2, spec, externals) => {
				const dialogComp = value$2();
				const showDialog = (dialog) => {
					dialogComp.set(dialog);
					const sink = detail.lazySink(dialog).getOrDie();
					const externalBlocker = externals.blocker();
					attach(sink, sink.getSystem().build({
						...externalBlocker,
						components: externalBlocker.components.concat([premade(dialog)]),
						behaviours: derive$1([Focusing.config({}), config("dialog-blocker-events", [runOnSource(focusin(), () => {
							Blocking.isBlocked(dialog) ? noop() : Keying.focusIn(dialog);
						})])])
					}));
					Keying.focusIn(dialog);
				};
				const hideDialog = (dialog) => {
					dialogComp.clear();
					parent(dialog.element).each((blockerDom) => {
						dialog.getSystem().getByDom(blockerDom).each((blocker) => {
							detach(blocker);
						});
					});
				};
				const getDialogBody = (dialog) => getPartOrDie(dialog, detail, "body");
				const getDialogFooter = (dialog) => getPart(dialog, detail, "footer");
				const setBusy = (dialog, getBusySpec$2) => {
					Blocking.block(dialog, getBusySpec$2);
				};
				const setIdle = (dialog) => {
					Blocking.unblock(dialog);
				};
				const modalEventsId = generate$6("modal-events");
				const eventOrder = {
					...detail.eventOrder,
					[attachedToDom()]: [modalEventsId].concat(detail.eventOrder["alloy.system.attached"] || [])
				};
				return {
					uid: detail.uid,
					dom: detail.dom,
					components: components$2,
					apis: {
						show: showDialog,
						hide: hideDialog,
						getBody: getDialogBody,
						getFooter: getDialogFooter,
						setIdle,
						setBusy
					},
					eventOrder,
					domModification: { attributes: {
						"role": "dialog",
						"aria-modal": "true"
					} },
					behaviours: augment(detail.modalBehaviours, [
						Replacing.config({}),
						Keying.config({
							mode: "cyclic",
							onEnter: detail.onExecute,
							onEscape: detail.onEscape,
							useTabstopAt: detail.useTabstopAt,
							firstTabstop: detail.firstTabstop
						}),
						Blocking.config({ getRoot: dialogComp.get }),
						config(modalEventsId, [runOnAttached((c) => {
							labelledBy(c.element, getPartOrDie(c, detail, "title").element);
						})])
					])
				};
			};
			const ModalDialog = composite({
				name: "ModalDialog",
				configFields: schema$2(),
				partFields: parts$2(),
				factory: factory$4,
				apis: {
					show: (apis, dialog) => {
						apis.show(dialog);
					},
					hide: (apis, dialog) => {
						apis.hide(dialog);
					},
					getBody: (apis, dialog) => apis.getBody(dialog),
					getFooter: (apis, dialog) => apis.getFooter(dialog),
					setBusy: (apis, dialog, getBusySpec$2) => {
						apis.setBusy(dialog, getBusySpec$2);
					},
					setIdle: (apis, dialog) => {
						apis.setIdle(dialog);
					}
				}
			});
			const dialogToggleMenuItemSchema = objOf([type, name$1].concat(commonMenuItemFields));
			const dialogToggleMenuItemDataProcessor = boolean;
			const baseFooterButtonFields = [
				generatedName("button"),
				optionalIcon,
				defaultedStringEnum("align", "end", ["start", "end"]),
				primary,
				enabled,
				optionStringEnum("buttonType", ["primary", "secondary"])
			];
			const dialogFooterButtonFields = [...baseFooterButtonFields, text$1];
			const normalFooterButtonFields = [requiredStringEnum("type", [
				"submit",
				"cancel",
				"custom"
			]), ...dialogFooterButtonFields];
			const dialogFooterButtonSchema = choose$1("type", {
				submit: normalFooterButtonFields,
				cancel: normalFooterButtonFields,
				custom: normalFooterButtonFields,
				menu: [
					requiredStringEnum("type", ["menu"]),
					optionalText,
					optionalTooltip,
					optionalIcon,
					requiredArrayOf("items", dialogToggleMenuItemSchema),
					...baseFooterButtonFields
				],
				togglebutton: [
					...baseFooterButtonFields,
					requiredStringEnum("type", ["togglebutton"]),
					requiredString("tooltip"),
					optionalIcon,
					optionalText,
					defaultedBoolean("active", false)
				]
			});
			const alertBannerSchema = objOf([
				type,
				text$1,
				requiredStringEnum("level", [
					"info",
					"warn",
					"error",
					"success"
				]),
				icon,
				defaulted("url", "")
			]);
			const createBarFields = (itemsField) => [type, itemsField];
			const buttonSchema = objOf([
				type,
				text$1,
				enabled,
				generatedName("button"),
				optionalIcon,
				borderless,
				optionStringEnum("buttonType", [
					"primary",
					"secondary",
					"toolbar"
				]),
				primary
			]);
			const formComponentFields = [type, name$1];
			const formComponentWithLabelFields = formComponentFields.concat([optionalLabel]);
			const checkboxSchema = objOf(formComponentFields.concat([label, enabled]));
			const checkboxDataProcessor = boolean;
			const collectionSchema = objOf(formComponentWithLabelFields.concat([defaultedColumns("auto")]));
			const collectionDataProcessor = arrOfObj([
				value$1,
				text$1,
				icon
			]);
			const colorInputSchema = objOf(formComponentWithLabelFields.concat([defaultedString("storageKey", "default")]));
			const colorInputDataProcessor = string;
			const colorPickerSchema = objOf(formComponentWithLabelFields);
			const colorPickerDataProcessor = string;
			const customEditorFields = formComponentFields.concat([
				defaultedString("tag", "textarea"),
				requiredString("scriptId"),
				requiredString("scriptUrl"),
				defaultedPostMsg("settings", void 0)
			]);
			const customEditorFieldsOld = formComponentFields.concat([defaultedString("tag", "textarea"), requiredFunction("init")]);
			const customEditorSchema = valueOf((v) => asRaw("customeditor.old", objOfOnly(customEditorFieldsOld), v).orThunk(() => asRaw("customeditor.new", objOfOnly(customEditorFields), v)));
			const customEditorDataProcessor = string;
			const dropZoneSchema = objOf(formComponentWithLabelFields);
			const dropZoneDataProcessor = arrOfVal();
			const createGridFields = (itemsField) => [
				type,
				requiredNumber("columns"),
				itemsField
			];
			const htmlPanelSchema = objOf([
				type,
				requiredString("html"),
				defaultedStringEnum("presets", "presentation", ["presentation", "document"])
			]);
			const iframeSchema = objOf(formComponentWithLabelFields.concat([
				defaultedBoolean("border", false),
				defaultedBoolean("sandboxed", true),
				defaultedBoolean("streamContent", false),
				defaultedBoolean("transparent", true)
			]));
			const iframeDataProcessor = string;
			const imagePreviewSchema = objOf(formComponentFields.concat([optionString("height")]));
			const imagePreviewDataProcessor = objOf([
				requiredString("url"),
				optionNumber("zoom"),
				optionNumber("cachedWidth"),
				optionNumber("cachedHeight")
			]);
			const inputSchema = objOf(formComponentWithLabelFields.concat([
				optionString("inputMode"),
				optionString("placeholder"),
				defaultedBoolean("maximized", false),
				enabled
			]));
			const inputDataProcessor = string;
			const createLabelFields = (itemsField) => [
				type,
				label,
				itemsField,
				defaultedStringEnum("align", "start", [
					"start",
					"center",
					"end"
				])
			];
			const listBoxSingleItemFields = [text$1, value$1];
			const listBoxNestedItemFields = [text$1, requiredArrayOf("items", thunkOf("items", () => listBoxItemSchema))];
			const listBoxItemSchema = oneOf([objOf(listBoxSingleItemFields), objOf(listBoxNestedItemFields)]);
			const listBoxSchema = objOf(formComponentWithLabelFields.concat([requiredArrayOf("items", listBoxItemSchema), enabled]));
			const listBoxDataProcessor = string;
			const selectBoxSchema = objOf(formComponentWithLabelFields.concat([
				requiredArrayOfObj("items", [text$1, value$1]),
				defaultedNumber("size", 1),
				enabled
			]));
			const selectBoxDataProcessor = string;
			const sizeInputSchema = objOf(formComponentWithLabelFields.concat([defaultedBoolean("constrain", true), enabled]));
			const sizeInputDataProcessor = objOf([requiredString("width"), requiredString("height")]);
			const sliderSchema = objOf(formComponentFields.concat([
				label,
				defaultedNumber("min", 0),
				defaultedNumber("max", 0)
			]));
			const sliderInputDataProcessor = number;
			const tableSchema = objOf([
				type,
				requiredArrayOf("header", string),
				requiredArrayOf("cells", arrOf(string))
			]);
			const textAreaSchema = objOf(formComponentWithLabelFields.concat([
				optionString("placeholder"),
				defaultedBoolean("maximized", false),
				enabled
			]));
			const textAreaDataProcessor = string;
			const baseTreeItemFields = [
				requiredStringEnum("type", ["directory", "leaf"]),
				title,
				requiredString("id"),
				optionOf("menu", MenuButtonSchema)
			];
			const treeItemLeafSchema = objOf(baseTreeItemFields);
			const treeItemDirectorySchema = objOf(baseTreeItemFields.concat([requiredArrayOf("children", thunkOf("children", () => {
				return choose$2("type", {
					directory: treeItemDirectorySchema,
					leaf: treeItemLeafSchema
				});
			}))]));
			const treeSchema = objOf([
				type,
				requiredArrayOf("items", choose$2("type", {
					directory: treeItemDirectorySchema,
					leaf: treeItemLeafSchema
				})),
				optionFunction("onLeafAction"),
				optionFunction("onToggleExpand"),
				defaultedArrayOf("defaultExpandedIds", [], string),
				optionString("defaultSelectedId")
			]);
			const urlInputSchema = objOf(formComponentWithLabelFields.concat([defaultedStringEnum("filetype", "file", [
				"image",
				"media",
				"file"
			]), enabled]));
			const urlInputDataProcessor = objOf([value$1, defaultedMeta]);
			const createItemsField = (name$4) => field$1("items", "items", required$2(), arrOf(valueOf((v) => asRaw(`Checking item of ${name$4}`, itemSchema, v).fold((sErr) => Result.error(formatError(sErr)), (passValue) => Result.value(passValue)))));
			const itemSchema = valueThunk(() => choose$2("type", {
				alertbanner: alertBannerSchema,
				bar: objOf(createBarFields(createItemsField("bar"))),
				button: buttonSchema,
				checkbox: checkboxSchema,
				colorinput: colorInputSchema,
				colorpicker: colorPickerSchema,
				dropzone: dropZoneSchema,
				grid: objOf(createGridFields(createItemsField("grid"))),
				iframe: iframeSchema,
				input: inputSchema,
				listbox: listBoxSchema,
				selectbox: selectBoxSchema,
				sizeinput: sizeInputSchema,
				slider: sliderSchema,
				textarea: textAreaSchema,
				urlinput: urlInputSchema,
				customeditor: customEditorSchema,
				htmlpanel: htmlPanelSchema,
				imagepreview: imagePreviewSchema,
				collection: collectionSchema,
				label: objOf(createLabelFields(createItemsField("label"))),
				table: tableSchema,
				tree: treeSchema,
				panel: panelSchema
			}));
			const panelSchema = objOf([
				type,
				defaulted("classes", []),
				requiredArrayOf("items", itemSchema)
			]);
			const tabPanelSchema = objOf([type, requiredArrayOfObj("tabs", [
				generatedName("tab"),
				title,
				requiredArrayOf("items", itemSchema)
			])]);
			const dialogButtonFields = dialogFooterButtonFields;
			const dialogButtonSchema = dialogFooterButtonSchema;
			const dialogSchema = objOf([
				requiredString("title"),
				requiredOf("body", choose$2("type", {
					panel: panelSchema,
					tabpanel: tabPanelSchema
				})),
				defaultedString("size", "normal"),
				defaultedArrayOf("buttons", [], dialogButtonSchema),
				defaulted("initialData", {}),
				defaultedFunction("onAction", noop),
				defaultedFunction("onChange", noop),
				defaultedFunction("onSubmit", noop),
				defaultedFunction("onClose", noop),
				defaultedFunction("onCancel", noop),
				defaultedFunction("onTabChange", noop)
			]);
			const createDialog = (spec) => asRaw("dialog", dialogSchema, spec);
			const urlDialogButtonSchema = objOf([requiredStringEnum("type", ["cancel", "custom"]), ...dialogButtonFields]);
			const urlDialogSchema = objOf([
				requiredString("title"),
				requiredString("url"),
				optionNumber("height"),
				optionNumber("width"),
				optionArrayOf("buttons", urlDialogButtonSchema),
				defaultedFunction("onAction", noop),
				defaultedFunction("onCancel", noop),
				defaultedFunction("onClose", noop),
				defaultedFunction("onMessage", noop)
			]);
			const createUrlDialog = (spec) => asRaw("dialog", urlDialogSchema, spec);
			const getAllObjects = (obj) => {
				if (isObject(obj)) return [obj].concat(bind$3(values(obj), getAllObjects));
				else if (isArray(obj)) return bind$3(obj, getAllObjects);
				else return [];
			};
			const isNamedItem = (obj) => isString(obj.type) && isString(obj.name);
			const dataProcessors = {
				checkbox: checkboxDataProcessor,
				colorinput: colorInputDataProcessor,
				colorpicker: colorPickerDataProcessor,
				dropzone: dropZoneDataProcessor,
				input: inputDataProcessor,
				iframe: iframeDataProcessor,
				imagepreview: imagePreviewDataProcessor,
				selectbox: selectBoxDataProcessor,
				sizeinput: sizeInputDataProcessor,
				slider: sliderInputDataProcessor,
				listbox: listBoxDataProcessor,
				size: sizeInputDataProcessor,
				textarea: textAreaDataProcessor,
				urlinput: urlInputDataProcessor,
				customeditor: customEditorDataProcessor,
				collection: collectionDataProcessor,
				togglemenuitem: dialogToggleMenuItemDataProcessor
			};
			const getDataProcessor = (item$1) => Optional.from(dataProcessors[item$1.type]);
			const getNamedItems = (structure) => filter$2(getAllObjects(structure), isNamedItem);
			const createDataValidator = (structure) => {
				return objOf(bind$3(getNamedItems(structure), (item$1) => getDataProcessor(item$1).fold(() => [], (schema$10) => [requiredOf(item$1.name, schema$10)])));
			};
			const extract = (structure) => {
				var _a;
				return {
					internalDialog: getOrDie(createDialog(structure)),
					dataValidator: createDataValidator(structure),
					initialData: (_a = structure.initialData) !== null && _a !== void 0 ? _a : {}
				};
			};
			const DialogManager = {
				open: (factory$10, structure) => {
					const extraction = extract(structure);
					return factory$10(extraction.internalDialog, extraction.initialData, extraction.dataValidator);
				},
				openUrl: (factory$10, structure) => {
					return factory$10(getOrDie(createUrlDialog(structure)));
				},
				redial: (structure) => extract(structure)
			};
			const events = (reflectingConfig, reflectingState) => {
				const update = (component, data) => {
					reflectingConfig.updateState.each((updateState) => {
						const newState = updateState(component, data);
						reflectingState.set(newState);
					});
					reflectingConfig.renderComponents.each((renderComponents$1) => {
						const newComponents = renderComponents$1(data, reflectingState.get());
						(reflectingConfig.reuseDom ? withReuse : withoutReuse)(component, newComponents);
					});
				};
				return derive$2([run$1(receive(), (component, message) => {
					const receivingData = message;
					if (!receivingData.universal) {
						const channel = reflectingConfig.channel;
						if (contains$2(receivingData.channels, channel)) update(component, receivingData.data);
					}
				}), runOnAttached((comp, _se) => {
					reflectingConfig.initialData.each((rawData) => {
						update(comp, rawData);
					});
				})]);
			};
			var ActiveReflecting = /* @__PURE__ */ Object.freeze({
				__proto__: null,
				events
			});
			const getState = (component, replaceConfig, reflectState) => reflectState;
			var ReflectingApis = /* @__PURE__ */ Object.freeze({
				__proto__: null,
				getState
			});
			var ReflectingSchema = [
				required$1("channel"),
				option$3("renderComponents"),
				option$3("updateState"),
				option$3("initialData"),
				defaultedBoolean("reuseDom", true)
			];
			const init = () => {
				const cell = Cell(Optional.none());
				const clear$1 = () => cell.set(Optional.none());
				const readState = () => cell.get().getOr("none");
				return {
					readState,
					get: cell.get,
					set: cell.set,
					clear: clear$1
				};
			};
			const Reflecting = create$4({
				fields: ReflectingSchema,
				name: "reflecting",
				active: ActiveReflecting,
				apis: ReflectingApis,
				state: /* @__PURE__ */ Object.freeze({
					__proto__: null,
					init
				})
			});
			const toValidValues = (values$1) => {
				const errors = [];
				const result = {};
				each(values$1, (value$5, name$4) => {
					value$5.fold(() => {
						errors.push(name$4);
					}, (v) => {
						result[name$4] = v;
					});
				});
				return errors.length > 0 ? Result.error(errors) : Result.value(result);
			};
			const renderBodyPanel = (spec, dialogData, backstage) => {
				const memForm = record(Form.sketch((parts$10) => ({
					dom: {
						tag: "div",
						classes: ["tox-form"].concat(spec.classes)
					},
					components: map$2(spec.items, (item$1) => interpretInForm(parts$10, item$1, dialogData, backstage))
				})));
				return {
					dom: {
						tag: "div",
						classes: ["tox-dialog__body"]
					},
					components: [{
						dom: {
							tag: "div",
							classes: ["tox-dialog__body-content"]
						},
						components: [memForm.asSpec()]
					}],
					behaviours: derive$1([
						Keying.config({
							mode: "acyclic",
							useTabstopAt: not(isPseudoStop)
						}),
						ComposingConfigs.memento(memForm),
						memento(memForm, { postprocess: (formValue) => toValidValues(formValue).fold((err) => {
							console.error(err);
							return {};
						}, identity) }),
						config("dialog-body-panel", [run$1(focusin(), (comp, se) => {
							comp.getSystem().broadcastOn([dialogFocusShiftedChannel], { newFocus: Optional.some(se.event.target) });
						})])
					])
				};
			};
			const factory$3 = (detail, _spec) => ({
				uid: detail.uid,
				dom: detail.dom,
				components: detail.components,
				events: events$a(detail.action),
				behaviours: augment(detail.tabButtonBehaviours, [
					Focusing.config({}),
					Keying.config({
						mode: "execution",
						useSpace: true,
						useEnter: true
					}),
					Representing.config({ store: {
						mode: "memory",
						initialValue: detail.value
					} })
				]),
				domModification: detail.domModification
			});
			const TabButton = single({
				name: "TabButton",
				configFields: [
					defaulted("uid", void 0),
					required$1("value"),
					field$1("dom", "dom", mergeWithThunk(() => ({ attributes: {
						"role": "tab",
						"id": generate$6("aria"),
						"aria-selected": "false"
					} })), anyValue()),
					option$3("action"),
					defaulted("domModification", {}),
					field("tabButtonBehaviours", [
						Focusing,
						Keying,
						Representing
					]),
					required$1("view")
				],
				factory: factory$3
			});
			const schema$1 = constant$1([
				required$1("tabs"),
				required$1("dom"),
				defaulted("clickToDismiss", false),
				field("tabbarBehaviours", [Highlighting, Keying]),
				markers$1(["tabClass", "selectedClass"])
			]);
			const parts$1 = constant$1([group({
				factory: TabButton,
				name: "tabs",
				unit: "tab",
				overrides: (barDetail) => {
					const dismissTab$1 = (tabbar, button$1) => {
						Highlighting.dehighlight(tabbar, button$1);
						emitWith(tabbar, dismissTab(), {
							tabbar,
							button: button$1
						});
					};
					const changeTab$1 = (tabbar, button$1) => {
						Highlighting.highlight(tabbar, button$1);
						emitWith(tabbar, changeTab(), {
							tabbar,
							button: button$1
						});
					};
					return {
						action: (button$1) => {
							const tabbar = button$1.getSystem().getByUid(barDetail.uid).getOrDie();
							const activeButton = Highlighting.isHighlighted(tabbar, button$1);
							(() => {
								if (activeButton && barDetail.clickToDismiss) return dismissTab$1;
								else if (!activeButton) return changeTab$1;
								else return noop;
							})()(tabbar, button$1);
						},
						domModification: { classes: [barDetail.markers.tabClass] }
					};
				}
			})]);
			const factory$2 = (detail, components$2, _spec, _externals) => ({
				"uid": detail.uid,
				"dom": detail.dom,
				components: components$2,
				"debug.sketcher": "Tabbar",
				"domModification": { attributes: { role: "tablist" } },
				"behaviours": augment(detail.tabbarBehaviours, [Highlighting.config({
					highlightClass: detail.markers.selectedClass,
					itemClass: detail.markers.tabClass,
					onHighlight: (tabbar, tab) => {
						set$9(tab.element, "aria-selected", "true");
					},
					onDehighlight: (tabbar, tab) => {
						set$9(tab.element, "aria-selected", "false");
					}
				}), Keying.config({
					mode: "flow",
					getInitial: (tabbar) => {
						return Highlighting.getHighlighted(tabbar).map((tab) => tab.element);
					},
					selector: "." + detail.markers.tabClass,
					executeOnMove: true
				})])
			});
			const Tabbar = composite({
				name: "Tabbar",
				configFields: schema$1(),
				partFields: parts$1(),
				factory: factory$2
			});
			const factory$1 = (detail, _spec) => ({
				uid: detail.uid,
				dom: detail.dom,
				behaviours: augment(detail.tabviewBehaviours, [Replacing.config({})]),
				domModification: { attributes: { role: "tabpanel" } }
			});
			const Tabview = single({
				name: "Tabview",
				configFields: [field("tabviewBehaviours", [Replacing])],
				factory: factory$1
			});
			const schema = constant$1([
				defaulted("selectFirst", true),
				onHandler("onChangeTab"),
				onHandler("onDismissTab"),
				defaulted("tabs", []),
				field("tabSectionBehaviours", [])
			]);
			const parts = constant$1([required({
				factory: Tabbar,
				schema: [required$1("dom"), requiredObjOf("markers", [required$1("tabClass"), required$1("selectedClass")])],
				name: "tabbar",
				defaults: (detail) => {
					return { tabs: detail.tabs };
				}
			}), required({
				factory: Tabview,
				name: "tabview"
			})]);
			const factory = (detail, components$2, _spec, _externals) => {
				const changeTab$1 = (button$1) => {
					const tabValue = Representing.getValue(button$1);
					getPart(button$1, detail, "tabview").each((tabview) => {
						find$5(detail.tabs, (t$1) => t$1.value === tabValue).each((tabData) => {
							const panel = tabData.view();
							getOpt(button$1.element, "id").each((id) => {
								set$9(tabview.element, "aria-labelledby", id);
							});
							Replacing.set(tabview, panel);
							detail.onChangeTab(tabview, button$1, panel);
						});
					});
				};
				const changeTabBy = (section, byPred) => {
					getPart(section, detail, "tabbar").each((tabbar) => {
						byPred(tabbar).each(emitExecute);
					});
				};
				return {
					uid: detail.uid,
					dom: detail.dom,
					components: components$2,
					behaviours: get$3(detail.tabSectionBehaviours),
					events: derive$2(flatten([detail.selectFirst ? [runOnAttached((section, _simulatedEvent) => {
						changeTabBy(section, Highlighting.getFirst);
					})] : [], [run$1(changeTab(), (section, simulatedEvent) => {
						const button$1 = simulatedEvent.event.button;
						changeTab$1(button$1);
					}), run$1(dismissTab(), (section, simulatedEvent) => {
						const button$1 = simulatedEvent.event.button;
						detail.onDismissTab(section, button$1);
					})]])),
					apis: {
						getViewItems: (section) => {
							return getPart(section, detail, "tabview").map((tabview) => Replacing.contents(tabview)).getOr([]);
						},
						showTab: (section, tabKey) => {
							const getTabIfNotActive = (tabbar) => {
								return find$5(Highlighting.getCandidates(tabbar), (c) => Representing.getValue(c) === tabKey).filter((tab) => !Highlighting.isHighlighted(tabbar, tab));
							};
							changeTabBy(section, getTabIfNotActive);
						}
					}
				};
			};
			const TabSection = composite({
				name: "TabSection",
				configFields: schema(),
				partFields: parts(),
				factory,
				apis: {
					getViewItems: (apis, component) => apis.getViewItems(component),
					showTab: (apis, component, tabKey) => {
						apis.showTab(component, tabKey);
					}
				}
			});
			const measureHeights = (allTabs, tabview, tabviewComp) => map$2(allTabs, (_tab, i) => {
				Replacing.set(tabviewComp, allTabs[i].view());
				const rect$1 = tabview.dom.getBoundingClientRect();
				Replacing.set(tabviewComp, []);
				return rect$1.height;
			});
			const getMaxHeight = (heights) => head(sort(heights, (a, b$1) => {
				if (a > b$1) return -1;
				else if (a < b$1) return 1;
				else return 0;
			}));
			const getMaxTabviewHeight = (dialog, tabview, tablist) => {
				const documentElement$1 = documentElement(dialog).dom;
				const isFixed = get$e(ancestor(dialog, ".tox-dialog-wrap").getOr(dialog), "position") === "fixed";
				let maxHeight;
				if (isFixed) maxHeight = Math.max(documentElement$1.clientHeight, window.innerHeight);
				else maxHeight = Math.max(documentElement$1.offsetHeight, documentElement$1.scrollHeight);
				const tabviewHeight = get$d(tabview);
				const currentTabHeight = tabview.dom.offsetLeft >= tablist.dom.offsetLeft + get$c(tablist) ? Math.max(get$d(tablist), tabviewHeight) : tabviewHeight;
				const dialogTopMargin = parseInt(get$e(dialog, "margin-top"), 10) || 0;
				const dialogBottomMargin = parseInt(get$e(dialog, "margin-bottom"), 10) || 0;
				const chromeHeight = get$d(dialog) + dialogTopMargin + dialogBottomMargin - currentTabHeight;
				return maxHeight - chromeHeight;
			};
			const showTab = (allTabs, comp) => {
				head(allTabs).each((tab) => TabSection.showTab(comp, tab.value));
			};
			const setTabviewHeight = (tabview, height$1) => {
				set$8(tabview, "height", height$1 + "px");
				set$8(tabview, "flex-basis", height$1 + "px");
			};
			const updateTabviewHeight = (dialogBody, tabview, maxTabHeight) => {
				ancestor(dialogBody, "[role=\"dialog\"]").each((dialog) => {
					descendant(dialog, "[role=\"tablist\"]").each((tablist) => {
						maxTabHeight.get().map((height$1) => {
							set$8(tabview, "height", "0");
							set$8(tabview, "flex-basis", "0");
							return Math.min(height$1, getMaxTabviewHeight(dialog, tabview, tablist));
						}).each((height$1) => {
							setTabviewHeight(tabview, height$1);
						});
					});
				});
			};
			const getTabview = (dialog) => descendant(dialog, "[role=\"tabpanel\"]");
			const smartMode = (allTabs) => {
				const maxTabHeight = value$2();
				return {
					extraEvents: [
						runOnAttached((comp) => {
							const dialog = comp.element;
							getTabview(dialog).each((tabview) => {
								set$8(tabview, "visibility", "hidden");
								comp.getSystem().getByDom(tabview).toOptional().each((tabviewComp) => {
									getMaxHeight(measureHeights(allTabs, tabview, tabviewComp)).fold(maxTabHeight.clear, maxTabHeight.set);
								});
								updateTabviewHeight(dialog, tabview, maxTabHeight);
								remove$6(tabview, "visibility");
								showTab(allTabs, comp);
								requestAnimationFrame(() => {
									updateTabviewHeight(dialog, tabview, maxTabHeight);
								});
							});
						}),
						run$1(windowResize(), (comp) => {
							const dialog = comp.element;
							getTabview(dialog).each((tabview) => {
								updateTabviewHeight(dialog, tabview, maxTabHeight);
							});
						}),
						run$1(formResizeEvent, (comp, _se) => {
							const dialog = comp.element;
							getTabview(dialog).each((tabview) => {
								const oldFocus = active$1(getRootNode(tabview));
								set$8(tabview, "visibility", "hidden");
								const oldHeight = getRaw(tabview, "height").map((h) => parseInt(h, 10));
								remove$6(tabview, "height");
								remove$6(tabview, "flex-basis");
								const newHeight = tabview.dom.getBoundingClientRect().height;
								if (oldHeight.forall((h) => newHeight > h)) {
									maxTabHeight.set(newHeight);
									updateTabviewHeight(dialog, tabview, maxTabHeight);
								} else oldHeight.each((h) => {
									setTabviewHeight(tabview, h);
								});
								remove$6(tabview, "visibility");
								oldFocus.each(focus$3);
							});
						})
					],
					selectFirst: false
				};
			};
			const SendDataToSectionChannel = "send-data-to-section";
			const SendDataToViewChannel = "send-data-to-view";
			const renderTabPanel = (spec, dialogData, backstage) => {
				const storedValue = Cell({});
				const updateDataWithForm = (form) => {
					const validData = toValidValues(Representing.getValue(form)).getOr({});
					const newData = deepMerge(storedValue.get(), validData);
					storedValue.set(newData);
				};
				const setDataOnForm = (form) => {
					const tabData = storedValue.get();
					Representing.setValue(form, tabData);
				};
				const oldTab = Cell(null);
				const allTabs = map$2(spec.tabs, (tab) => {
					return {
						value: tab.name,
						dom: {
							tag: "div",
							classes: ["tox-dialog__body-nav-item"]
						},
						components: [text$2(backstage.shared.providers.translate(tab.title))],
						view: () => {
							return [Form.sketch((parts$10) => ({
								dom: {
									tag: "div",
									classes: ["tox-form"]
								},
								components: map$2(tab.items, (item$1) => interpretInForm(parts$10, item$1, dialogData, backstage)),
								formBehaviours: derive$1([
									Keying.config({
										mode: "acyclic",
										useTabstopAt: not(isPseudoStop)
									}),
									config("TabView.form.events", [runOnAttached(setDataOnForm), runOnDetached(updateDataWithForm)]),
									Receiving.config({ channels: wrapAll([{
										key: SendDataToSectionChannel,
										value: { onReceive: updateDataWithForm }
									}, {
										key: SendDataToViewChannel,
										value: { onReceive: setDataOnForm }
									}]) })
								])
							}))];
						}
					};
				});
				const tabMode = smartMode(allTabs);
				return TabSection.sketch({
					dom: {
						tag: "div",
						classes: ["tox-dialog__body"]
					},
					onChangeTab: (section, button$1, _viewItems) => {
						const name$4 = Representing.getValue(button$1);
						emitWith(section, formTabChangeEvent, {
							name: name$4,
							oldName: oldTab.get()
						});
						oldTab.set(name$4);
					},
					tabs: allTabs,
					components: [TabSection.parts.tabbar({
						dom: {
							tag: "div",
							classes: ["tox-dialog__body-nav"]
						},
						components: [Tabbar.parts.tabs({})],
						markers: {
							tabClass: "tox-tab",
							selectedClass: "tox-dialog__body-nav-item--active"
						},
						tabbarBehaviours: derive$1([Tabstopping.config({})])
					}), TabSection.parts.tabview({ dom: {
						tag: "div",
						classes: ["tox-dialog__body-content"]
					} })],
					selectFirst: tabMode.selectFirst,
					tabSectionBehaviours: derive$1([
						config("tabpanel", tabMode.extraEvents),
						Keying.config({ mode: "acyclic" }),
						Composing.config({ find: (comp) => head(TabSection.getViewItems(comp)) }),
						withComp(Optional.none(), (tsection) => {
							tsection.getSystem().broadcastOn([SendDataToSectionChannel], {});
							return storedValue.get();
						}, (tsection, value$5) => {
							storedValue.set(value$5);
							tsection.getSystem().broadcastOn([SendDataToViewChannel], {});
						})
					])
				});
			};
			const renderBody = (spec, dialogId, contentId, backstage, ariaAttrs) => {
				const renderComponents$1 = (incoming) => {
					const body$1 = incoming.body;
					switch (body$1.type) {
						case "tabpanel": return [renderTabPanel(body$1, incoming.initialData, backstage)];
						default: return [renderBodyPanel(body$1, incoming.initialData, backstage)];
					}
				};
				const updateState = (_comp, incoming) => Optional.some({ isTabPanel: () => incoming.body.type === "tabpanel" });
				const ariaAttributes = { "aria-live": "polite" };
				return {
					dom: {
						tag: "div",
						classes: ["tox-dialog__content-js"],
						attributes: {
							...contentId.map((x) => ({ id: x })).getOr({}),
							...ariaAttrs ? ariaAttributes : {}
						}
					},
					components: [],
					behaviours: derive$1([ComposingConfigs.childAt(0), Reflecting.config({
						channel: `${bodyChannel}-${dialogId}`,
						updateState,
						renderComponents: renderComponents$1,
						initialData: spec
					})])
				};
			};
			const renderInlineBody = (spec, dialogId, contentId, backstage, ariaAttrs) => renderBody(spec, dialogId, Optional.some(contentId), backstage, ariaAttrs);
			const renderModalBody = (spec, dialogId, backstage) => {
				const bodySpec = renderBody(spec, dialogId, Optional.none(), backstage, false);
				return ModalDialog.parts.body(bodySpec);
			};
			const renderIframeBody = (spec) => {
				const bodySpec = {
					dom: {
						tag: "div",
						classes: ["tox-dialog__content-js"]
					},
					components: [{
						dom: {
							tag: "div",
							classes: ["tox-dialog__body-iframe"]
						},
						components: [craft(Optional.none(), {
							dom: {
								tag: "iframe",
								attributes: { src: spec.url }
							},
							behaviours: derive$1([Tabstopping.config({}), Focusing.config({})])
						})]
					}],
					behaviours: derive$1([Keying.config({
						mode: "acyclic",
						useTabstopAt: not(isPseudoStop)
					})])
				};
				return ModalDialog.parts.body(bodySpec);
			};
			function _typeof(obj) {
				"@babel/helpers - typeof";
				return _typeof = "function" == typeof Symbol && "symbol" == typeof Symbol.iterator ? function(obj$1) {
					return typeof obj$1;
				} : function(obj$1) {
					return obj$1 && "function" == typeof Symbol && obj$1.constructor === Symbol && obj$1 !== Symbol.prototype ? "symbol" : typeof obj$1;
				}, _typeof(obj);
			}
			function _setPrototypeOf(o, p) {
				_setPrototypeOf = Object.setPrototypeOf || function _setPrototypeOf$1(o$1, p$1) {
					o$1.__proto__ = p$1;
					return o$1;
				};
				return _setPrototypeOf(o, p);
			}
			function _isNativeReflectConstruct() {
				if (typeof Reflect === "undefined" || !Reflect.construct) return false;
				if (Reflect.construct.sham) return false;
				if (typeof Proxy === "function") return true;
				try {
					Boolean.prototype.valueOf.call(Reflect.construct(Boolean, [], function() {}));
					return true;
				} catch (e) {
					return false;
				}
			}
			function _construct(Parent, args, Class) {
				if (_isNativeReflectConstruct()) _construct = Reflect.construct;
				else _construct = function _construct$1(Parent$1, args$1, Class$1) {
					var a = [null];
					a.push.apply(a, args$1);
					var instance = new (Function.bind.apply(Parent$1, a))();
					if (Class$1) _setPrototypeOf(instance, Class$1.prototype);
					return instance;
				};
				return _construct.apply(null, arguments);
			}
			function _toConsumableArray(arr) {
				return _arrayWithoutHoles(arr) || _iterableToArray(arr) || _unsupportedIterableToArray(arr) || _nonIterableSpread();
			}
			function _arrayWithoutHoles(arr) {
				if (Array.isArray(arr)) return _arrayLikeToArray(arr);
			}
			function _iterableToArray(iter) {
				if (typeof Symbol !== "undefined" && iter[Symbol.iterator] != null || iter["@@iterator"] != null) return Array.from(iter);
			}
			function _unsupportedIterableToArray(o, minLen) {
				if (!o) return;
				if (typeof o === "string") return _arrayLikeToArray(o, minLen);
				var n = Object.prototype.toString.call(o).slice(8, -1);
				if (n === "Object" && o.constructor) n = o.constructor.name;
				if (n === "Map" || n === "Set") return Array.from(o);
				if (n === "Arguments" || /^(?:Ui|I)nt(?:8|16|32)(?:Clamped)?Array$/.test(n)) return _arrayLikeToArray(o, minLen);
			}
			function _arrayLikeToArray(arr, len) {
				if (len == null || len > arr.length) len = arr.length;
				for (var i = 0, arr2 = new Array(len); i < len; i++) arr2[i] = arr[i];
				return arr2;
			}
			function _nonIterableSpread() {
				throw new TypeError("Invalid attempt to spread non-iterable instance.\nIn order to be iterable, non-array objects must have a [Symbol.iterator]() method.");
			}
			var hasOwnProperty = Object.hasOwnProperty, setPrototypeOf = Object.setPrototypeOf, isFrozen = Object.isFrozen, getPrototypeOf = Object.getPrototypeOf, getOwnPropertyDescriptor = Object.getOwnPropertyDescriptor;
			var freeze = Object.freeze, seal = Object.seal, create = Object.create;
			var _ref = typeof Reflect !== "undefined" && Reflect, apply = _ref.apply, construct = _ref.construct;
			if (!apply) apply = function apply$2(fun, thisValue, args) {
				return fun.apply(thisValue, args);
			};
			if (!freeze) freeze = function freeze$1(x) {
				return x;
			};
			if (!seal) seal = function seal$1(x) {
				return x;
			};
			if (!construct) construct = function construct$1(Func, args) {
				return _construct(Func, _toConsumableArray(args));
			};
			var arrayForEach = unapply(Array.prototype.forEach);
			var arrayPop = unapply(Array.prototype.pop);
			var arrayPush = unapply(Array.prototype.push);
			var stringToLowerCase = unapply(String.prototype.toLowerCase);
			var stringMatch = unapply(String.prototype.match);
			var stringReplace = unapply(String.prototype.replace);
			var stringIndexOf = unapply(String.prototype.indexOf);
			var stringTrim = unapply(String.prototype.trim);
			var regExpTest = unapply(RegExp.prototype.test);
			var typeErrorCreate = unconstruct(TypeError);
			function unapply(func) {
				return function(thisArg) {
					for (var _len = arguments.length, args = new Array(_len > 1 ? _len - 1 : 0), _key = 1; _key < _len; _key++) args[_key - 1] = arguments[_key];
					return apply(func, thisArg, args);
				};
			}
			function unconstruct(func) {
				return function() {
					for (var _len2 = arguments.length, args = new Array(_len2), _key2 = 0; _key2 < _len2; _key2++) args[_key2] = arguments[_key2];
					return construct(func, args);
				};
			}
			function addToSet(set$10, array) {
				if (setPrototypeOf) setPrototypeOf(set$10, null);
				var l$1 = array.length;
				while (l$1--) {
					var element$1 = array[l$1];
					if (typeof element$1 === "string") {
						var lcElement = stringToLowerCase(element$1);
						if (lcElement !== element$1) {
							if (!isFrozen(array)) array[l$1] = lcElement;
							element$1 = lcElement;
						}
					}
					set$10[element$1] = true;
				}
				return set$10;
			}
			function clone(object) {
				var newObject = create(null);
				var property;
				for (property in object) if (apply(hasOwnProperty, object, [property])) newObject[property] = object[property];
				return newObject;
			}
			function lookupGetter(object, prop) {
				while (object !== null) {
					var desc = getOwnPropertyDescriptor(object, prop);
					if (desc) {
						if (desc.get) return unapply(desc.get);
						if (typeof desc.value === "function") return unapply(desc.value);
					}
					object = getPrototypeOf(object);
				}
				function fallbackValue(element$1) {
					console.warn("fallback value for", element$1);
					return null;
				}
				return fallbackValue;
			}
			var html$1 = freeze([
				"a",
				"abbr",
				"acronym",
				"address",
				"area",
				"article",
				"aside",
				"audio",
				"b",
				"bdi",
				"bdo",
				"big",
				"blink",
				"blockquote",
				"body",
				"br",
				"button",
				"canvas",
				"caption",
				"center",
				"cite",
				"code",
				"col",
				"colgroup",
				"content",
				"data",
				"datalist",
				"dd",
				"decorator",
				"del",
				"details",
				"dfn",
				"dialog",
				"dir",
				"div",
				"dl",
				"dt",
				"element",
				"em",
				"fieldset",
				"figcaption",
				"figure",
				"font",
				"footer",
				"form",
				"h1",
				"h2",
				"h3",
				"h4",
				"h5",
				"h6",
				"head",
				"header",
				"hgroup",
				"hr",
				"html",
				"i",
				"img",
				"input",
				"ins",
				"kbd",
				"label",
				"legend",
				"li",
				"main",
				"map",
				"mark",
				"marquee",
				"menu",
				"menuitem",
				"meter",
				"nav",
				"nobr",
				"ol",
				"optgroup",
				"option",
				"output",
				"p",
				"picture",
				"pre",
				"progress",
				"q",
				"rp",
				"rt",
				"ruby",
				"s",
				"samp",
				"section",
				"select",
				"shadow",
				"small",
				"source",
				"spacer",
				"span",
				"strike",
				"strong",
				"style",
				"sub",
				"summary",
				"sup",
				"table",
				"tbody",
				"td",
				"template",
				"textarea",
				"tfoot",
				"th",
				"thead",
				"time",
				"tr",
				"track",
				"tt",
				"u",
				"ul",
				"var",
				"video",
				"wbr"
			]);
			var svg$1 = freeze([
				"svg",
				"a",
				"altglyph",
				"altglyphdef",
				"altglyphitem",
				"animatecolor",
				"animatemotion",
				"animatetransform",
				"circle",
				"clippath",
				"defs",
				"desc",
				"ellipse",
				"filter",
				"font",
				"g",
				"glyph",
				"glyphref",
				"hkern",
				"image",
				"line",
				"lineargradient",
				"marker",
				"mask",
				"metadata",
				"mpath",
				"path",
				"pattern",
				"polygon",
				"polyline",
				"radialgradient",
				"rect",
				"stop",
				"style",
				"switch",
				"symbol",
				"text",
				"textpath",
				"title",
				"tref",
				"tspan",
				"view",
				"vkern"
			]);
			var svgFilters = freeze([
				"feBlend",
				"feColorMatrix",
				"feComponentTransfer",
				"feComposite",
				"feConvolveMatrix",
				"feDiffuseLighting",
				"feDisplacementMap",
				"feDistantLight",
				"feFlood",
				"feFuncA",
				"feFuncB",
				"feFuncG",
				"feFuncR",
				"feGaussianBlur",
				"feImage",
				"feMerge",
				"feMergeNode",
				"feMorphology",
				"feOffset",
				"fePointLight",
				"feSpecularLighting",
				"feSpotLight",
				"feTile",
				"feTurbulence"
			]);
			var svgDisallowed = freeze([
				"animate",
				"color-profile",
				"cursor",
				"discard",
				"fedropshadow",
				"font-face",
				"font-face-format",
				"font-face-name",
				"font-face-src",
				"font-face-uri",
				"foreignobject",
				"hatch",
				"hatchpath",
				"mesh",
				"meshgradient",
				"meshpatch",
				"meshrow",
				"missing-glyph",
				"script",
				"set",
				"solidcolor",
				"unknown",
				"use"
			]);
			var mathMl$1 = freeze([
				"math",
				"menclose",
				"merror",
				"mfenced",
				"mfrac",
				"mglyph",
				"mi",
				"mlabeledtr",
				"mmultiscripts",
				"mn",
				"mo",
				"mover",
				"mpadded",
				"mphantom",
				"mroot",
				"mrow",
				"ms",
				"mspace",
				"msqrt",
				"mstyle",
				"msub",
				"msup",
				"msubsup",
				"mtable",
				"mtd",
				"mtext",
				"mtr",
				"munder",
				"munderover"
			]);
			var mathMlDisallowed = freeze([
				"maction",
				"maligngroup",
				"malignmark",
				"mlongdiv",
				"mscarries",
				"mscarry",
				"msgroup",
				"mstack",
				"msline",
				"msrow",
				"semantics",
				"annotation",
				"annotation-xml",
				"mprescripts",
				"none"
			]);
			var text = freeze(["#text"]);
			var html = freeze([
				"accept",
				"action",
				"align",
				"alt",
				"autocapitalize",
				"autocomplete",
				"autopictureinpicture",
				"autoplay",
				"background",
				"bgcolor",
				"border",
				"capture",
				"cellpadding",
				"cellspacing",
				"checked",
				"cite",
				"class",
				"clear",
				"color",
				"cols",
				"colspan",
				"controls",
				"controlslist",
				"coords",
				"crossorigin",
				"datetime",
				"decoding",
				"default",
				"dir",
				"disabled",
				"disablepictureinpicture",
				"disableremoteplayback",
				"download",
				"draggable",
				"enctype",
				"enterkeyhint",
				"face",
				"for",
				"headers",
				"height",
				"hidden",
				"high",
				"href",
				"hreflang",
				"id",
				"inputmode",
				"integrity",
				"ismap",
				"kind",
				"label",
				"lang",
				"list",
				"loading",
				"loop",
				"low",
				"max",
				"maxlength",
				"media",
				"method",
				"min",
				"minlength",
				"multiple",
				"muted",
				"name",
				"nonce",
				"noshade",
				"novalidate",
				"nowrap",
				"open",
				"optimum",
				"pattern",
				"placeholder",
				"playsinline",
				"poster",
				"preload",
				"pubdate",
				"radiogroup",
				"readonly",
				"rel",
				"required",
				"rev",
				"reversed",
				"role",
				"rows",
				"rowspan",
				"spellcheck",
				"scope",
				"selected",
				"shape",
				"size",
				"sizes",
				"span",
				"srclang",
				"start",
				"src",
				"srcset",
				"step",
				"style",
				"summary",
				"tabindex",
				"title",
				"translate",
				"type",
				"usemap",
				"valign",
				"value",
				"width",
				"xmlns",
				"slot"
			]);
			var svg = freeze([
				"accent-height",
				"accumulate",
				"additive",
				"alignment-baseline",
				"ascent",
				"attributename",
				"attributetype",
				"azimuth",
				"basefrequency",
				"baseline-shift",
				"begin",
				"bias",
				"by",
				"class",
				"clip",
				"clippathunits",
				"clip-path",
				"clip-rule",
				"color",
				"color-interpolation",
				"color-interpolation-filters",
				"color-profile",
				"color-rendering",
				"cx",
				"cy",
				"d",
				"dx",
				"dy",
				"diffuseconstant",
				"direction",
				"display",
				"divisor",
				"dur",
				"edgemode",
				"elevation",
				"end",
				"fill",
				"fill-opacity",
				"fill-rule",
				"filter",
				"filterunits",
				"flood-color",
				"flood-opacity",
				"font-family",
				"font-size",
				"font-size-adjust",
				"font-stretch",
				"font-style",
				"font-variant",
				"font-weight",
				"fx",
				"fy",
				"g1",
				"g2",
				"glyph-name",
				"glyphref",
				"gradientunits",
				"gradienttransform",
				"height",
				"href",
				"id",
				"image-rendering",
				"in",
				"in2",
				"k",
				"k1",
				"k2",
				"k3",
				"k4",
				"kerning",
				"keypoints",
				"keysplines",
				"keytimes",
				"lang",
				"lengthadjust",
				"letter-spacing",
				"kernelmatrix",
				"kernelunitlength",
				"lighting-color",
				"local",
				"marker-end",
				"marker-mid",
				"marker-start",
				"markerheight",
				"markerunits",
				"markerwidth",
				"maskcontentunits",
				"maskunits",
				"max",
				"mask",
				"media",
				"method",
				"mode",
				"min",
				"name",
				"numoctaves",
				"offset",
				"operator",
				"opacity",
				"order",
				"orient",
				"orientation",
				"origin",
				"overflow",
				"paint-order",
				"path",
				"pathlength",
				"patterncontentunits",
				"patterntransform",
				"patternunits",
				"points",
				"preservealpha",
				"preserveaspectratio",
				"primitiveunits",
				"r",
				"rx",
				"ry",
				"radius",
				"refx",
				"refy",
				"repeatcount",
				"repeatdur",
				"restart",
				"result",
				"rotate",
				"scale",
				"seed",
				"shape-rendering",
				"specularconstant",
				"specularexponent",
				"spreadmethod",
				"startoffset",
				"stddeviation",
				"stitchtiles",
				"stop-color",
				"stop-opacity",
				"stroke-dasharray",
				"stroke-dashoffset",
				"stroke-linecap",
				"stroke-linejoin",
				"stroke-miterlimit",
				"stroke-opacity",
				"stroke",
				"stroke-width",
				"style",
				"surfacescale",
				"systemlanguage",
				"tabindex",
				"targetx",
				"targety",
				"transform",
				"transform-origin",
				"text-anchor",
				"text-decoration",
				"text-rendering",
				"textlength",
				"type",
				"u1",
				"u2",
				"unicode",
				"values",
				"viewbox",
				"visibility",
				"version",
				"vert-adv-y",
				"vert-origin-x",
				"vert-origin-y",
				"width",
				"word-spacing",
				"wrap",
				"writing-mode",
				"xchannelselector",
				"ychannelselector",
				"x",
				"x1",
				"x2",
				"xmlns",
				"y",
				"y1",
				"y2",
				"z",
				"zoomandpan"
			]);
			var mathMl = freeze([
				"accent",
				"accentunder",
				"align",
				"bevelled",
				"close",
				"columnsalign",
				"columnlines",
				"columnspan",
				"denomalign",
				"depth",
				"dir",
				"display",
				"displaystyle",
				"encoding",
				"fence",
				"frame",
				"height",
				"href",
				"id",
				"largeop",
				"length",
				"linethickness",
				"lspace",
				"lquote",
				"mathbackground",
				"mathcolor",
				"mathsize",
				"mathvariant",
				"maxsize",
				"minsize",
				"movablelimits",
				"notation",
				"numalign",
				"open",
				"rowalign",
				"rowlines",
				"rowspacing",
				"rowspan",
				"rspace",
				"rquote",
				"scriptlevel",
				"scriptminsize",
				"scriptsizemultiplier",
				"selection",
				"separator",
				"separators",
				"stretchy",
				"subscriptshift",
				"supscriptshift",
				"symmetric",
				"voffset",
				"width",
				"xmlns"
			]);
			var xml = freeze([
				"xlink:href",
				"xml:id",
				"xlink:title",
				"xml:space",
				"xmlns:xlink"
			]);
			var MUSTACHE_EXPR = seal(/\{\{[\w\W]*|[\w\W]*\}\}/gm);
			var ERB_EXPR = seal(/<%[\w\W]*|[\w\W]*%>/gm);
			var DATA_ATTR = seal(/^data-[\-\w.\u00B7-\uFFFF]/);
			var ARIA_ATTR = seal(/^aria-[\-\w]+$/);
			var IS_ALLOWED_URI = seal(/^(?:(?:(?:f|ht)tps?|mailto|tel|callto|cid|xmpp):|[^a-z]|[a-z+.\-]+(?:[^a-z+.\-:]|$))/i);
			var IS_SCRIPT_OR_DATA = seal(/^(?:\w+script|data):/i);
			var ATTR_WHITESPACE = seal(/[\u0000-\u0020\u00A0\u1680\u180E\u2000-\u2029\u205F\u3000]/g);
			var DOCTYPE_NAME = seal(/^html$/i);
			var getGlobal = function getGlobal$1() {
				return typeof window === "undefined" ? null : window;
			};
			var _createTrustedTypesPolicy = function _createTrustedTypesPolicy$1(trustedTypes, document$1) {
				if (_typeof(trustedTypes) !== "object" || typeof trustedTypes.createPolicy !== "function") return null;
				var suffix$1 = null;
				var ATTR_NAME = "data-tt-policy-suffix";
				if (document$1.currentScript && document$1.currentScript.hasAttribute(ATTR_NAME)) suffix$1 = document$1.currentScript.getAttribute(ATTR_NAME);
				var policyName = "dompurify" + (suffix$1 ? "#" + suffix$1 : "");
				try {
					return trustedTypes.createPolicy(policyName, { createHTML: function createHTML(html$2) {
						return html$2;
					} });
				} catch (_) {
					console.warn("TrustedTypes policy " + policyName + " could not be created.");
					return null;
				}
			};
			function createDOMPurify() {
				var window$1 = arguments.length > 0 && arguments[0] !== void 0 ? arguments[0] : getGlobal();
				var DOMPurify = function DOMPurify$1(root) {
					return createDOMPurify(root);
				};
				DOMPurify.version = "2.3.8";
				DOMPurify.removed = [];
				if (!window$1 || !window$1.document || window$1.document.nodeType !== 9) {
					DOMPurify.isSupported = false;
					return DOMPurify;
				}
				var originalDocument = window$1.document;
				var document$1 = window$1.document;
				var DocumentFragment = window$1.DocumentFragment, HTMLTemplateElement = window$1.HTMLTemplateElement, Node$1 = window$1.Node, Element$1 = window$1.Element, NodeFilter$1 = window$1.NodeFilter, _window$NamedNodeMap = window$1.NamedNodeMap, NamedNodeMap = _window$NamedNodeMap === void 0 ? window$1.NamedNodeMap || window$1.MozNamedAttrMap : _window$NamedNodeMap, HTMLFormElement = window$1.HTMLFormElement, DOMParser$1 = window$1.DOMParser, trustedTypes = window$1.trustedTypes;
				var ElementPrototype = Element$1.prototype;
				var cloneNode = lookupGetter(ElementPrototype, "cloneNode");
				var getNextSibling = lookupGetter(ElementPrototype, "nextSibling");
				var getChildNodes = lookupGetter(ElementPrototype, "childNodes");
				var getParentNode = lookupGetter(ElementPrototype, "parentNode");
				if (typeof HTMLTemplateElement === "function") {
					var template = document$1.createElement("template");
					if (template.content && template.content.ownerDocument) document$1 = template.content.ownerDocument;
				}
				var trustedTypesPolicy = _createTrustedTypesPolicy(trustedTypes, originalDocument);
				var emptyHTML = trustedTypesPolicy ? trustedTypesPolicy.createHTML("") : "";
				var _document = document$1, implementation = _document.implementation, createNodeIterator = _document.createNodeIterator, createDocumentFragment = _document.createDocumentFragment, getElementsByTagName = _document.getElementsByTagName;
				var importNode = originalDocument.importNode;
				var documentMode = {};
				try {
					documentMode = clone(document$1).documentMode ? document$1.documentMode : {};
				} catch (_) {}
				var hooks = {};
				DOMPurify.isSupported = typeof getParentNode === "function" && implementation && typeof implementation.createHTMLDocument !== "undefined" && documentMode !== 9;
				var MUSTACHE_EXPR$1 = MUSTACHE_EXPR, ERB_EXPR$1 = ERB_EXPR, DATA_ATTR$1 = DATA_ATTR, ARIA_ATTR$1 = ARIA_ATTR, IS_SCRIPT_OR_DATA$1 = IS_SCRIPT_OR_DATA, ATTR_WHITESPACE$1 = ATTR_WHITESPACE;
				var IS_ALLOWED_URI$1 = IS_ALLOWED_URI;
				var ALLOWED_TAGS = null;
				var DEFAULT_ALLOWED_TAGS = addToSet({}, [].concat(_toConsumableArray(html$1), _toConsumableArray(svg$1), _toConsumableArray(svgFilters), _toConsumableArray(mathMl$1), _toConsumableArray(text)));
				var ALLOWED_ATTR = null;
				var DEFAULT_ALLOWED_ATTR = addToSet({}, [].concat(_toConsumableArray(html), _toConsumableArray(svg), _toConsumableArray(mathMl), _toConsumableArray(xml)));
				var CUSTOM_ELEMENT_HANDLING = Object.seal(Object.create(null, {
					tagNameCheck: {
						writable: true,
						configurable: false,
						enumerable: true,
						value: null
					},
					attributeNameCheck: {
						writable: true,
						configurable: false,
						enumerable: true,
						value: null
					},
					allowCustomizedBuiltInElements: {
						writable: true,
						configurable: false,
						enumerable: true,
						value: false
					}
				}));
				var FORBID_TAGS = null;
				var FORBID_ATTR = null;
				var ALLOW_ARIA_ATTR = true;
				var ALLOW_DATA_ATTR = true;
				var ALLOW_UNKNOWN_PROTOCOLS = false;
				var SAFE_FOR_TEMPLATES = false;
				var WHOLE_DOCUMENT = false;
				var SET_CONFIG = false;
				var FORCE_BODY = false;
				var RETURN_DOM = false;
				var RETURN_DOM_FRAGMENT = false;
				var RETURN_TRUSTED_TYPE = false;
				var SANITIZE_DOM = true;
				var KEEP_CONTENT = true;
				var IN_PLACE = false;
				var USE_PROFILES = {};
				var FORBID_CONTENTS = null;
				var DEFAULT_FORBID_CONTENTS = addToSet({}, [
					"annotation-xml",
					"audio",
					"colgroup",
					"desc",
					"foreignobject",
					"head",
					"iframe",
					"math",
					"mi",
					"mn",
					"mo",
					"ms",
					"mtext",
					"noembed",
					"noframes",
					"noscript",
					"plaintext",
					"script",
					"style",
					"svg",
					"template",
					"thead",
					"title",
					"video",
					"xmp"
				]);
				var DATA_URI_TAGS = null;
				var DEFAULT_DATA_URI_TAGS = addToSet({}, [
					"audio",
					"video",
					"img",
					"source",
					"image",
					"track"
				]);
				var URI_SAFE_ATTRIBUTES = null;
				var DEFAULT_URI_SAFE_ATTRIBUTES = addToSet({}, [
					"alt",
					"class",
					"for",
					"id",
					"label",
					"name",
					"pattern",
					"placeholder",
					"role",
					"summary",
					"title",
					"value",
					"style",
					"xmlns"
				]);
				var MATHML_NAMESPACE = "http://www.w3.org/1998/Math/MathML";
				var SVG_NAMESPACE = "http://www.w3.org/2000/svg";
				var HTML_NAMESPACE = "http://www.w3.org/1999/xhtml";
				var NAMESPACE = HTML_NAMESPACE;
				var IS_EMPTY_INPUT = false;
				var PARSER_MEDIA_TYPE;
				var SUPPORTED_PARSER_MEDIA_TYPES = ["application/xhtml+xml", "text/html"];
				var DEFAULT_PARSER_MEDIA_TYPE = "text/html";
				var transformCaseFunc;
				var CONFIG = null;
				var formElement = document$1.createElement("form");
				var isRegexOrFunction = function isRegexOrFunction$1(testValue) {
					return testValue instanceof RegExp || testValue instanceof Function;
				};
				var _parseConfig = function _parseConfig$1(cfg) {
					if (CONFIG && CONFIG === cfg) return;
					if (!cfg || _typeof(cfg) !== "object") cfg = {};
					cfg = clone(cfg);
					ALLOWED_TAGS = "ALLOWED_TAGS" in cfg ? addToSet({}, cfg.ALLOWED_TAGS) : DEFAULT_ALLOWED_TAGS;
					ALLOWED_ATTR = "ALLOWED_ATTR" in cfg ? addToSet({}, cfg.ALLOWED_ATTR) : DEFAULT_ALLOWED_ATTR;
					URI_SAFE_ATTRIBUTES = "ADD_URI_SAFE_ATTR" in cfg ? addToSet(clone(DEFAULT_URI_SAFE_ATTRIBUTES), cfg.ADD_URI_SAFE_ATTR) : DEFAULT_URI_SAFE_ATTRIBUTES;
					DATA_URI_TAGS = "ADD_DATA_URI_TAGS" in cfg ? addToSet(clone(DEFAULT_DATA_URI_TAGS), cfg.ADD_DATA_URI_TAGS) : DEFAULT_DATA_URI_TAGS;
					FORBID_CONTENTS = "FORBID_CONTENTS" in cfg ? addToSet({}, cfg.FORBID_CONTENTS) : DEFAULT_FORBID_CONTENTS;
					FORBID_TAGS = "FORBID_TAGS" in cfg ? addToSet({}, cfg.FORBID_TAGS) : {};
					FORBID_ATTR = "FORBID_ATTR" in cfg ? addToSet({}, cfg.FORBID_ATTR) : {};
					USE_PROFILES = "USE_PROFILES" in cfg ? cfg.USE_PROFILES : false;
					ALLOW_ARIA_ATTR = cfg.ALLOW_ARIA_ATTR !== false;
					ALLOW_DATA_ATTR = cfg.ALLOW_DATA_ATTR !== false;
					ALLOW_UNKNOWN_PROTOCOLS = cfg.ALLOW_UNKNOWN_PROTOCOLS || false;
					SAFE_FOR_TEMPLATES = cfg.SAFE_FOR_TEMPLATES || false;
					WHOLE_DOCUMENT = cfg.WHOLE_DOCUMENT || false;
					RETURN_DOM = cfg.RETURN_DOM || false;
					RETURN_DOM_FRAGMENT = cfg.RETURN_DOM_FRAGMENT || false;
					RETURN_TRUSTED_TYPE = cfg.RETURN_TRUSTED_TYPE || false;
					FORCE_BODY = cfg.FORCE_BODY || false;
					SANITIZE_DOM = cfg.SANITIZE_DOM !== false;
					KEEP_CONTENT = cfg.KEEP_CONTENT !== false;
					IN_PLACE = cfg.IN_PLACE || false;
					IS_ALLOWED_URI$1 = cfg.ALLOWED_URI_REGEXP || IS_ALLOWED_URI$1;
					NAMESPACE = cfg.NAMESPACE || HTML_NAMESPACE;
					if (cfg.CUSTOM_ELEMENT_HANDLING && isRegexOrFunction(cfg.CUSTOM_ELEMENT_HANDLING.tagNameCheck)) CUSTOM_ELEMENT_HANDLING.tagNameCheck = cfg.CUSTOM_ELEMENT_HANDLING.tagNameCheck;
					if (cfg.CUSTOM_ELEMENT_HANDLING && isRegexOrFunction(cfg.CUSTOM_ELEMENT_HANDLING.attributeNameCheck)) CUSTOM_ELEMENT_HANDLING.attributeNameCheck = cfg.CUSTOM_ELEMENT_HANDLING.attributeNameCheck;
					if (cfg.CUSTOM_ELEMENT_HANDLING && typeof cfg.CUSTOM_ELEMENT_HANDLING.allowCustomizedBuiltInElements === "boolean") CUSTOM_ELEMENT_HANDLING.allowCustomizedBuiltInElements = cfg.CUSTOM_ELEMENT_HANDLING.allowCustomizedBuiltInElements;
					PARSER_MEDIA_TYPE = SUPPORTED_PARSER_MEDIA_TYPES.indexOf(cfg.PARSER_MEDIA_TYPE) === -1 ? PARSER_MEDIA_TYPE = DEFAULT_PARSER_MEDIA_TYPE : PARSER_MEDIA_TYPE = cfg.PARSER_MEDIA_TYPE;
					transformCaseFunc = PARSER_MEDIA_TYPE === "application/xhtml+xml" ? function(x) {
						return x;
					} : stringToLowerCase;
					if (SAFE_FOR_TEMPLATES) ALLOW_DATA_ATTR = false;
					if (RETURN_DOM_FRAGMENT) RETURN_DOM = true;
					if (USE_PROFILES) {
						ALLOWED_TAGS = addToSet({}, _toConsumableArray(text));
						ALLOWED_ATTR = [];
						if (USE_PROFILES.html === true) {
							addToSet(ALLOWED_TAGS, html$1);
							addToSet(ALLOWED_ATTR, html);
						}
						if (USE_PROFILES.svg === true) {
							addToSet(ALLOWED_TAGS, svg$1);
							addToSet(ALLOWED_ATTR, svg);
							addToSet(ALLOWED_ATTR, xml);
						}
						if (USE_PROFILES.svgFilters === true) {
							addToSet(ALLOWED_TAGS, svgFilters);
							addToSet(ALLOWED_ATTR, svg);
							addToSet(ALLOWED_ATTR, xml);
						}
						if (USE_PROFILES.mathMl === true) {
							addToSet(ALLOWED_TAGS, mathMl$1);
							addToSet(ALLOWED_ATTR, mathMl);
							addToSet(ALLOWED_ATTR, xml);
						}
					}
					if (cfg.ADD_TAGS) {
						if (ALLOWED_TAGS === DEFAULT_ALLOWED_TAGS) ALLOWED_TAGS = clone(ALLOWED_TAGS);
						addToSet(ALLOWED_TAGS, cfg.ADD_TAGS);
					}
					if (cfg.ADD_ATTR) {
						if (ALLOWED_ATTR === DEFAULT_ALLOWED_ATTR) ALLOWED_ATTR = clone(ALLOWED_ATTR);
						addToSet(ALLOWED_ATTR, cfg.ADD_ATTR);
					}
					if (cfg.ADD_URI_SAFE_ATTR) addToSet(URI_SAFE_ATTRIBUTES, cfg.ADD_URI_SAFE_ATTR);
					if (cfg.FORBID_CONTENTS) {
						if (FORBID_CONTENTS === DEFAULT_FORBID_CONTENTS) FORBID_CONTENTS = clone(FORBID_CONTENTS);
						addToSet(FORBID_CONTENTS, cfg.FORBID_CONTENTS);
					}
					if (KEEP_CONTENT) ALLOWED_TAGS["#text"] = true;
					if (WHOLE_DOCUMENT) addToSet(ALLOWED_TAGS, [
						"html",
						"head",
						"body"
					]);
					if (ALLOWED_TAGS.table) {
						addToSet(ALLOWED_TAGS, ["tbody"]);
						delete FORBID_TAGS.tbody;
					}
					if (freeze) freeze(cfg);
					CONFIG = cfg;
				};
				var MATHML_TEXT_INTEGRATION_POINTS = addToSet({}, [
					"mi",
					"mo",
					"mn",
					"ms",
					"mtext"
				]);
				var HTML_INTEGRATION_POINTS = addToSet({}, [
					"foreignobject",
					"desc",
					"title",
					"annotation-xml"
				]);
				var COMMON_SVG_AND_HTML_ELEMENTS = addToSet({}, [
					"title",
					"style",
					"font",
					"a",
					"script"
				]);
				var ALL_SVG_TAGS = addToSet({}, svg$1);
				addToSet(ALL_SVG_TAGS, svgFilters);
				addToSet(ALL_SVG_TAGS, svgDisallowed);
				var ALL_MATHML_TAGS = addToSet({}, mathMl$1);
				addToSet(ALL_MATHML_TAGS, mathMlDisallowed);
				var _checkValidNamespace = function _checkValidNamespace$1(element$1) {
					var parent$1 = getParentNode(element$1);
					if (!parent$1 || !parent$1.tagName) parent$1 = {
						namespaceURI: HTML_NAMESPACE,
						tagName: "template"
					};
					var tagName = stringToLowerCase(element$1.tagName);
					var parentTagName = stringToLowerCase(parent$1.tagName);
					if (element$1.namespaceURI === SVG_NAMESPACE) {
						if (parent$1.namespaceURI === HTML_NAMESPACE) return tagName === "svg";
						if (parent$1.namespaceURI === MATHML_NAMESPACE) return tagName === "svg" && (parentTagName === "annotation-xml" || MATHML_TEXT_INTEGRATION_POINTS[parentTagName]);
						return Boolean(ALL_SVG_TAGS[tagName]);
					}
					if (element$1.namespaceURI === MATHML_NAMESPACE) {
						if (parent$1.namespaceURI === HTML_NAMESPACE) return tagName === "math";
						if (parent$1.namespaceURI === SVG_NAMESPACE) return tagName === "math" && HTML_INTEGRATION_POINTS[parentTagName];
						return Boolean(ALL_MATHML_TAGS[tagName]);
					}
					if (element$1.namespaceURI === HTML_NAMESPACE) {
						if (parent$1.namespaceURI === SVG_NAMESPACE && !HTML_INTEGRATION_POINTS[parentTagName]) return false;
						if (parent$1.namespaceURI === MATHML_NAMESPACE && !MATHML_TEXT_INTEGRATION_POINTS[parentTagName]) return false;
						return !ALL_MATHML_TAGS[tagName] && (COMMON_SVG_AND_HTML_ELEMENTS[tagName] || !ALL_SVG_TAGS[tagName]);
					}
					return false;
				};
				var _forceRemove = function _forceRemove$1(node) {
					arrayPush(DOMPurify.removed, { element: node });
					try {
						node.parentNode.removeChild(node);
					} catch (_) {
						try {
							node.outerHTML = emptyHTML;
						} catch (_$1) {
							node.remove();
						}
					}
				};
				var _removeAttribute = function _removeAttribute$1(name$4, node) {
					try {
						arrayPush(DOMPurify.removed, {
							attribute: node.getAttributeNode(name$4),
							from: node
						});
					} catch (_) {
						arrayPush(DOMPurify.removed, {
							attribute: null,
							from: node
						});
					}
					node.removeAttribute(name$4);
					if (name$4 === "is" && !ALLOWED_ATTR[name$4]) if (RETURN_DOM || RETURN_DOM_FRAGMENT) try {
						_forceRemove(node);
					} catch (_) {}
					else try {
						node.setAttribute(name$4, "");
					} catch (_) {}
				};
				var _initDocument = function _initDocument$1(dirty) {
					var doc;
					var leadingWhitespace;
					if (FORCE_BODY) dirty = "<remove></remove>" + dirty;
					else {
						var matches = stringMatch(dirty, /^[\r\n\t ]+/);
						leadingWhitespace = matches && matches[0];
					}
					if (PARSER_MEDIA_TYPE === "application/xhtml+xml") dirty = "<html xmlns=\"http://www.w3.org/1999/xhtml\"><head></head><body>" + dirty + "</body></html>";
					var dirtyPayload = trustedTypesPolicy ? trustedTypesPolicy.createHTML(dirty) : dirty;
					if (NAMESPACE === HTML_NAMESPACE) try {
						doc = new DOMParser$1().parseFromString(dirtyPayload, PARSER_MEDIA_TYPE);
					} catch (_) {}
					if (!doc || !doc.documentElement) {
						doc = implementation.createDocument(NAMESPACE, "template", null);
						try {
							doc.documentElement.innerHTML = IS_EMPTY_INPUT ? "" : dirtyPayload;
						} catch (_) {}
					}
					var body$1 = doc.body || doc.documentElement;
					if (dirty && leadingWhitespace) body$1.insertBefore(document$1.createTextNode(leadingWhitespace), body$1.childNodes[0] || null);
					if (NAMESPACE === HTML_NAMESPACE) return getElementsByTagName.call(doc, WHOLE_DOCUMENT ? "html" : "body")[0];
					return WHOLE_DOCUMENT ? doc.documentElement : body$1;
				};
				var _createIterator = function _createIterator$1(root) {
					return createNodeIterator.call(root.ownerDocument || root, root, NodeFilter$1.SHOW_ELEMENT | NodeFilter$1.SHOW_COMMENT | NodeFilter$1.SHOW_TEXT, null, false);
				};
				var _isClobbered = function _isClobbered$1(elm) {
					return elm instanceof HTMLFormElement && (typeof elm.nodeName !== "string" || typeof elm.textContent !== "string" || typeof elm.removeChild !== "function" || !(elm.attributes instanceof NamedNodeMap) || typeof elm.removeAttribute !== "function" || typeof elm.setAttribute !== "function" || typeof elm.namespaceURI !== "string" || typeof elm.insertBefore !== "function");
				};
				var _isNode = function _isNode$1(object) {
					return _typeof(Node$1) === "object" ? object instanceof Node$1 : object && _typeof(object) === "object" && typeof object.nodeType === "number" && typeof object.nodeName === "string";
				};
				var _executeHook = function _executeHook$1(entryPoint, currentNode, data) {
					if (!hooks[entryPoint]) return;
					arrayForEach(hooks[entryPoint], function(hook) {
						hook.call(DOMPurify, currentNode, data, CONFIG);
					});
				};
				var _sanitizeElements = function _sanitizeElements$1(currentNode) {
					var content;
					_executeHook("beforeSanitizeElements", currentNode, null);
					if (_isClobbered(currentNode)) {
						_forceRemove(currentNode);
						return true;
					}
					if (regExpTest(/[\u0080-\uFFFF]/, currentNode.nodeName)) {
						_forceRemove(currentNode);
						return true;
					}
					var tagName = transformCaseFunc(currentNode.nodeName);
					_executeHook("uponSanitizeElement", currentNode, {
						tagName,
						allowedTags: ALLOWED_TAGS
					});
					if (currentNode.hasChildNodes() && !_isNode(currentNode.firstElementChild) && (!_isNode(currentNode.content) || !_isNode(currentNode.content.firstElementChild)) && regExpTest(/<[/\w]/g, currentNode.innerHTML) && regExpTest(/<[/\w]/g, currentNode.textContent)) {
						_forceRemove(currentNode);
						return true;
					}
					if (tagName === "select" && regExpTest(/<template/i, currentNode.innerHTML)) {
						_forceRemove(currentNode);
						return true;
					}
					if (!ALLOWED_TAGS[tagName] || FORBID_TAGS[tagName]) {
						if (!FORBID_TAGS[tagName] && _basicCustomElementTest(tagName)) {
							if (CUSTOM_ELEMENT_HANDLING.tagNameCheck instanceof RegExp && regExpTest(CUSTOM_ELEMENT_HANDLING.tagNameCheck, tagName)) return false;
							if (CUSTOM_ELEMENT_HANDLING.tagNameCheck instanceof Function && CUSTOM_ELEMENT_HANDLING.tagNameCheck(tagName)) return false;
						}
						if (KEEP_CONTENT && !FORBID_CONTENTS[tagName]) {
							var parentNode$1 = getParentNode(currentNode) || currentNode.parentNode;
							var childNodes = getChildNodes(currentNode) || currentNode.childNodes;
							if (childNodes && parentNode$1) for (var i = childNodes.length - 1; i >= 0; --i) parentNode$1.insertBefore(cloneNode(childNodes[i], true), getNextSibling(currentNode));
						}
						_forceRemove(currentNode);
						return true;
					}
					if (currentNode instanceof Element$1 && !_checkValidNamespace(currentNode)) {
						_forceRemove(currentNode);
						return true;
					}
					if ((tagName === "noscript" || tagName === "noembed") && regExpTest(/<\/no(script|embed)/i, currentNode.innerHTML)) {
						_forceRemove(currentNode);
						return true;
					}
					if (SAFE_FOR_TEMPLATES && currentNode.nodeType === 3) {
						content = currentNode.textContent;
						content = stringReplace(content, MUSTACHE_EXPR$1, " ");
						content = stringReplace(content, ERB_EXPR$1, " ");
						if (currentNode.textContent !== content) {
							arrayPush(DOMPurify.removed, { element: currentNode.cloneNode() });
							currentNode.textContent = content;
						}
					}
					_executeHook("afterSanitizeElements", currentNode, null);
					return false;
				};
				var _isValidAttribute = function _isValidAttribute$1(lcTag, lcName, value$5) {
					if (SANITIZE_DOM && (lcName === "id" || lcName === "name") && (value$5 in document$1 || value$5 in formElement)) return false;
					if (ALLOW_DATA_ATTR && !FORBID_ATTR[lcName] && regExpTest(DATA_ATTR$1, lcName));
					else if (ALLOW_ARIA_ATTR && regExpTest(ARIA_ATTR$1, lcName));
					else if (!ALLOWED_ATTR[lcName] || FORBID_ATTR[lcName]) if (_basicCustomElementTest(lcTag) && (CUSTOM_ELEMENT_HANDLING.tagNameCheck instanceof RegExp && regExpTest(CUSTOM_ELEMENT_HANDLING.tagNameCheck, lcTag) || CUSTOM_ELEMENT_HANDLING.tagNameCheck instanceof Function && CUSTOM_ELEMENT_HANDLING.tagNameCheck(lcTag)) && (CUSTOM_ELEMENT_HANDLING.attributeNameCheck instanceof RegExp && regExpTest(CUSTOM_ELEMENT_HANDLING.attributeNameCheck, lcName) || CUSTOM_ELEMENT_HANDLING.attributeNameCheck instanceof Function && CUSTOM_ELEMENT_HANDLING.attributeNameCheck(lcName)) || lcName === "is" && CUSTOM_ELEMENT_HANDLING.allowCustomizedBuiltInElements && (CUSTOM_ELEMENT_HANDLING.tagNameCheck instanceof RegExp && regExpTest(CUSTOM_ELEMENT_HANDLING.tagNameCheck, value$5) || CUSTOM_ELEMENT_HANDLING.tagNameCheck instanceof Function && CUSTOM_ELEMENT_HANDLING.tagNameCheck(value$5)));
					else return false;
					else if (URI_SAFE_ATTRIBUTES[lcName]);
					else if (regExpTest(IS_ALLOWED_URI$1, stringReplace(value$5, ATTR_WHITESPACE$1, "")));
					else if ((lcName === "src" || lcName === "xlink:href" || lcName === "href") && lcTag !== "script" && stringIndexOf(value$5, "data:") === 0 && DATA_URI_TAGS[lcTag]);
					else if (ALLOW_UNKNOWN_PROTOCOLS && !regExpTest(IS_SCRIPT_OR_DATA$1, stringReplace(value$5, ATTR_WHITESPACE$1, "")));
					else if (!value$5);
					else return false;
					return true;
				};
				var _basicCustomElementTest = function _basicCustomElementTest$1(tagName) {
					return tagName.indexOf("-") > 0;
				};
				var _sanitizeAttributes = function _sanitizeAttributes$1(currentNode) {
					var attr;
					var value$5;
					var lcName;
					var l$1;
					_executeHook("beforeSanitizeAttributes", currentNode, null);
					var attributes = currentNode.attributes;
					if (!attributes) return;
					var hookEvent = {
						attrName: "",
						attrValue: "",
						keepAttr: true,
						allowedAttributes: ALLOWED_ATTR
					};
					l$1 = attributes.length;
					while (l$1--) {
						attr = attributes[l$1];
						var _attr = attr, name$4 = _attr.name, namespaceURI = _attr.namespaceURI;
						value$5 = name$4 === "value" ? attr.value : stringTrim(attr.value);
						lcName = transformCaseFunc(name$4);
						var initValue = value$5;
						hookEvent.attrName = lcName;
						hookEvent.attrValue = value$5;
						hookEvent.keepAttr = true;
						hookEvent.forceKeepAttr = void 0;
						_executeHook("uponSanitizeAttribute", currentNode, hookEvent);
						value$5 = hookEvent.attrValue;
						if (hookEvent.forceKeepAttr) continue;
						if (!hookEvent.keepAttr) {
							_removeAttribute(name$4, currentNode);
							continue;
						}
						if (regExpTest(/\/>/i, value$5)) {
							_removeAttribute(name$4, currentNode);
							continue;
						}
						if (SAFE_FOR_TEMPLATES) {
							value$5 = stringReplace(value$5, MUSTACHE_EXPR$1, " ");
							value$5 = stringReplace(value$5, ERB_EXPR$1, " ");
						}
						if (!_isValidAttribute(transformCaseFunc(currentNode.nodeName), lcName, value$5)) {
							_removeAttribute(name$4, currentNode);
							continue;
						}
						if (value$5 !== initValue) try {
							if (namespaceURI) currentNode.setAttributeNS(namespaceURI, name$4, value$5);
							else currentNode.setAttribute(name$4, value$5);
						} catch (_) {
							_removeAttribute(name$4, currentNode);
						}
					}
					_executeHook("afterSanitizeAttributes", currentNode, null);
				};
				var _sanitizeShadowDOM = function _sanitizeShadowDOM$1(fragment) {
					var shadowNode;
					var shadowIterator = _createIterator(fragment);
					_executeHook("beforeSanitizeShadowDOM", fragment, null);
					while (shadowNode = shadowIterator.nextNode()) {
						_executeHook("uponSanitizeShadowNode", shadowNode, null);
						if (_sanitizeElements(shadowNode)) continue;
						if (shadowNode.content instanceof DocumentFragment) _sanitizeShadowDOM$1(shadowNode.content);
						_sanitizeAttributes(shadowNode);
					}
					_executeHook("afterSanitizeShadowDOM", fragment, null);
				};
				DOMPurify.sanitize = function(dirty, cfg) {
					var body$1;
					var importedNode;
					var currentNode;
					var oldNode;
					var returnNode;
					IS_EMPTY_INPUT = !dirty;
					if (IS_EMPTY_INPUT) dirty = "<!-->";
					if (typeof dirty !== "string" && !_isNode(dirty)) if (typeof dirty.toString !== "function") throw typeErrorCreate("toString is not a function");
					else {
						dirty = dirty.toString();
						if (typeof dirty !== "string") throw typeErrorCreate("dirty is not a string, aborting");
					}
					if (!DOMPurify.isSupported) {
						if (_typeof(window$1.toStaticHTML) === "object" || typeof window$1.toStaticHTML === "function") {
							if (typeof dirty === "string") return window$1.toStaticHTML(dirty);
							if (_isNode(dirty)) return window$1.toStaticHTML(dirty.outerHTML);
						}
						return dirty;
					}
					if (!SET_CONFIG) _parseConfig(cfg);
					DOMPurify.removed = [];
					if (typeof dirty === "string") IN_PLACE = false;
					if (IN_PLACE) {
						if (dirty.nodeName) {
							var tagName = transformCaseFunc(dirty.nodeName);
							if (!ALLOWED_TAGS[tagName] || FORBID_TAGS[tagName]) throw typeErrorCreate("root node is forbidden and cannot be sanitized in-place");
						}
					} else if (dirty instanceof Node$1) {
						body$1 = _initDocument("<!---->");
						importedNode = body$1.ownerDocument.importNode(dirty, true);
						if (importedNode.nodeType === 1 && importedNode.nodeName === "BODY") body$1 = importedNode;
						else if (importedNode.nodeName === "HTML") body$1 = importedNode;
						else body$1.appendChild(importedNode);
					} else {
						if (!RETURN_DOM && !SAFE_FOR_TEMPLATES && !WHOLE_DOCUMENT && dirty.indexOf("<") === -1) return trustedTypesPolicy && RETURN_TRUSTED_TYPE ? trustedTypesPolicy.createHTML(dirty) : dirty;
						body$1 = _initDocument(dirty);
						if (!body$1) return RETURN_DOM ? null : RETURN_TRUSTED_TYPE ? emptyHTML : "";
					}
					if (body$1 && FORCE_BODY) _forceRemove(body$1.firstChild);
					var nodeIterator = _createIterator(IN_PLACE ? dirty : body$1);
					while (currentNode = nodeIterator.nextNode()) {
						if (currentNode.nodeType === 3 && currentNode === oldNode) continue;
						if (_sanitizeElements(currentNode)) continue;
						if (currentNode.content instanceof DocumentFragment) _sanitizeShadowDOM(currentNode.content);
						_sanitizeAttributes(currentNode);
						oldNode = currentNode;
					}
					oldNode = null;
					if (IN_PLACE) return dirty;
					if (RETURN_DOM) {
						if (RETURN_DOM_FRAGMENT) {
							returnNode = createDocumentFragment.call(body$1.ownerDocument);
							while (body$1.firstChild) returnNode.appendChild(body$1.firstChild);
						} else returnNode = body$1;
						if (ALLOWED_ATTR.shadowroot) returnNode = importNode.call(originalDocument, returnNode, true);
						return returnNode;
					}
					var serializedHTML = WHOLE_DOCUMENT ? body$1.outerHTML : body$1.innerHTML;
					if (WHOLE_DOCUMENT && ALLOWED_TAGS["!doctype"] && body$1.ownerDocument && body$1.ownerDocument.doctype && body$1.ownerDocument.doctype.name && regExpTest(DOCTYPE_NAME, body$1.ownerDocument.doctype.name)) serializedHTML = "<!DOCTYPE " + body$1.ownerDocument.doctype.name + ">\n" + serializedHTML;
					if (SAFE_FOR_TEMPLATES) {
						serializedHTML = stringReplace(serializedHTML, MUSTACHE_EXPR$1, " ");
						serializedHTML = stringReplace(serializedHTML, ERB_EXPR$1, " ");
					}
					return trustedTypesPolicy && RETURN_TRUSTED_TYPE ? trustedTypesPolicy.createHTML(serializedHTML) : serializedHTML;
				};
				DOMPurify.setConfig = function(cfg) {
					_parseConfig(cfg);
					SET_CONFIG = true;
				};
				DOMPurify.clearConfig = function() {
					CONFIG = null;
					SET_CONFIG = false;
				};
				DOMPurify.isValidAttribute = function(tag, attr, value$5) {
					if (!CONFIG) _parseConfig({});
					return _isValidAttribute(transformCaseFunc(tag), transformCaseFunc(attr), value$5);
				};
				DOMPurify.addHook = function(entryPoint, hookFunction) {
					if (typeof hookFunction !== "function") return;
					hooks[entryPoint] = hooks[entryPoint] || [];
					arrayPush(hooks[entryPoint], hookFunction);
				};
				DOMPurify.removeHook = function(entryPoint) {
					if (hooks[entryPoint]) return arrayPop(hooks[entryPoint]);
				};
				DOMPurify.removeHooks = function(entryPoint) {
					if (hooks[entryPoint]) hooks[entryPoint] = [];
				};
				DOMPurify.removeAllHooks = function() {
					hooks = {};
				};
				return DOMPurify;
			}
			var purify = createDOMPurify();
			const sanitizeHtmlString = (html$2) => purify().sanitize(html$2);
			const isTouch = global$5.deviceType.isTouch();
			const hiddenHeader = (title$1, close$2) => ({
				dom: {
					tag: "div",
					styles: { display: "none" },
					classes: ["tox-dialog__header"]
				},
				components: [title$1, close$2]
			});
			const pClose = (onClose, providersBackstage) => ModalDialog.parts.close(Button.sketch({
				dom: {
					tag: "button",
					classes: [
						"tox-button",
						"tox-button--icon",
						"tox-button--naked"
					],
					attributes: {
						"type": "button",
						"aria-label": providersBackstage.translate("Close")
					}
				},
				action: onClose,
				buttonBehaviours: derive$1([Tabstopping.config({})])
			}));
			const pUntitled = () => ModalDialog.parts.title({ dom: {
				tag: "div",
				classes: ["tox-dialog__title"],
				innerHtml: "",
				styles: { display: "none" }
			} });
			const pBodyMessage = (message, providersBackstage) => ModalDialog.parts.body({
				dom: {
					tag: "div",
					classes: ["tox-dialog__body"]
				},
				components: [{
					dom: {
						tag: "div",
						classes: ["tox-dialog__body-content"]
					},
					components: [{ dom: fromHtml(`<p>${sanitizeHtmlString(providersBackstage.translate(message))}</p>`) }]
				}]
			});
			const pFooter = (buttons) => ModalDialog.parts.footer({
				dom: {
					tag: "div",
					classes: ["tox-dialog__footer"]
				},
				components: buttons
			});
			const pFooterGroup = (startButtons, endButtons) => [Container.sketch({
				dom: {
					tag: "div",
					classes: ["tox-dialog__footer-start"]
				},
				components: startButtons
			}), Container.sketch({
				dom: {
					tag: "div",
					classes: ["tox-dialog__footer-end"]
				},
				components: endButtons
			})];
			const renderDialog$1 = (spec) => {
				const dialogClass = "tox-dialog";
				const blockerClass = dialogClass + "-wrap";
				const blockerBackdropClass = blockerClass + "__backdrop";
				const scrollLockClass = dialogClass + "__disable-scroll";
				return ModalDialog.sketch({
					lazySink: spec.lazySink,
					onEscape: (comp) => {
						spec.onEscape(comp);
						return Optional.some(true);
					},
					useTabstopAt: (elem) => !isPseudoStop(elem),
					firstTabstop: spec.firstTabstop,
					dom: {
						tag: "div",
						classes: [dialogClass].concat(spec.extraClasses),
						styles: {
							position: "relative",
							...spec.extraStyles
						}
					},
					components: [
						spec.header,
						spec.body,
						...spec.footer.toArray()
					],
					parts: { blocker: {
						dom: fromHtml(`<div class="${blockerClass}"></div>`),
						components: [{ dom: {
							tag: "div",
							classes: isTouch ? [blockerBackdropClass, blockerBackdropClass + "--opaque"] : [blockerBackdropClass]
						} }]
					} },
					dragBlockClass: blockerClass,
					modalBehaviours: derive$1([
						Focusing.config({}),
						config("dialog-events", spec.dialogEvents.concat([runOnSource(focusin(), (comp, _se) => {
							Blocking.isBlocked(comp) ? noop() : Keying.focusIn(comp);
						}), run$1(focusShifted(), (comp, se) => {
							comp.getSystem().broadcastOn([dialogFocusShiftedChannel], { newFocus: se.event.newFocus });
						})])),
						config("scroll-lock", [runOnAttached(() => {
							add$2(body(), scrollLockClass);
						}), runOnDetached(() => {
							remove$2(body(), scrollLockClass);
						})]),
						...spec.extraBehaviours
					]),
					eventOrder: {
						[execute$5()]: ["dialog-events"],
						[attachedToDom()]: [
							"scroll-lock",
							"dialog-events",
							"alloy.base.behaviour"
						],
						[detachedFromDom()]: [
							"alloy.base.behaviour",
							"dialog-events",
							"scroll-lock"
						],
						...spec.eventOrder
					}
				});
			};
			const renderClose = (providersBackstage) => Button.sketch({
				dom: {
					tag: "button",
					classes: [
						"tox-button",
						"tox-button--icon",
						"tox-button--naked"
					],
					attributes: {
						"type": "button",
						"aria-label": providersBackstage.translate("Close"),
						"title": providersBackstage.translate("Close")
					}
				},
				buttonBehaviours: derive$1([Tabstopping.config({})]),
				components: [render$3("close", {
					tag: "span",
					classes: ["tox-icon"]
				}, providersBackstage.icons)],
				action: (comp) => {
					emit(comp, formCancelEvent);
				}
			});
			const renderTitle = (spec, dialogId, titleId, providersBackstage) => {
				const renderComponents$1 = (data) => [text$2(providersBackstage.translate(data.title))];
				return {
					dom: {
						tag: "div",
						classes: ["tox-dialog__title"],
						attributes: { ...titleId.map((x) => ({ id: x })).getOr({}) }
					},
					components: [],
					behaviours: derive$1([Reflecting.config({
						channel: `${titleChannel}-${dialogId}`,
						initialData: spec,
						renderComponents: renderComponents$1
					})])
				};
			};
			const renderDragHandle = () => ({ dom: fromHtml("<div class=\"tox-dialog__draghandle\"></div>") });
			const renderInlineHeader = (spec, dialogId, titleId, providersBackstage) => Container.sketch({
				dom: fromHtml("<div class=\"tox-dialog__header\"></div>"),
				components: [
					renderTitle(spec, dialogId, Optional.some(titleId), providersBackstage),
					renderDragHandle(),
					renderClose(providersBackstage)
				],
				containerBehaviours: derive$1([Dragging.config({
					mode: "mouse",
					blockerClass: "blocker",
					getTarget: (handle$1) => {
						return closest$1(handle$1, "[role=\"dialog\"]").getOrDie();
					},
					snaps: {
						getSnapPoints: () => [],
						leftAttr: "data-drag-left",
						topAttr: "data-drag-top"
					}
				})])
			});
			const renderModalHeader = (spec, dialogId, providersBackstage) => {
				const pTitle = ModalDialog.parts.title(renderTitle(spec, dialogId, Optional.none(), providersBackstage));
				const pHandle = ModalDialog.parts.draghandle(renderDragHandle());
				const pClose$1 = ModalDialog.parts.close(renderClose(providersBackstage));
				const components$2 = [pTitle].concat(spec.draggable ? [pHandle] : []).concat([pClose$1]);
				return Container.sketch({
					dom: fromHtml("<div class=\"tox-dialog__header\"></div>"),
					components: components$2
				});
			};
			const getHeader = (title$1, dialogId, backstage) => renderModalHeader({
				title: backstage.shared.providers.translate(title$1),
				draggable: backstage.dialog.isDraggableModal()
			}, dialogId, backstage.shared.providers);
			const getBusySpec = (message, bs, providers, headerHeight) => ({
				dom: {
					tag: "div",
					classes: ["tox-dialog__busy-spinner"],
					attributes: { "aria-label": providers.translate(message) },
					styles: {
						left: "0px",
						right: "0px",
						bottom: "0px",
						top: `${headerHeight.getOr(0)}px`,
						position: "absolute"
					}
				},
				behaviours: bs,
				components: [{ dom: fromHtml("<div class=\"tox-spinner\"><div></div><div></div><div></div></div>") }]
			});
			const getEventExtras = (lazyDialog, providers, extra) => ({
				onClose: () => extra.closeWindow(),
				onBlock: (blockEvent) => {
					const headerHeight = descendant(lazyDialog().element, ".tox-dialog__header").map((header) => get$d(header));
					ModalDialog.setBusy(lazyDialog(), (_comp, bs) => getBusySpec(blockEvent.message, bs, providers, headerHeight));
				},
				onUnblock: () => {
					ModalDialog.setIdle(lazyDialog());
				}
			});
			const renderModalDialog = (spec, initialData, dialogEvents, backstage) => {
				const updateState = (_comp, incoming) => Optional.some(incoming);
				return build$1(renderDialog$1({
					...spec,
					firstTabstop: 1,
					lazySink: backstage.shared.getSink,
					extraBehaviours: [
						Reflecting.config({
							channel: `${dialogChannel}-${spec.id}`,
							updateState,
							initialData
						}),
						memory({}),
						...spec.extraBehaviours
					],
					onEscape: (comp) => {
						emit(comp, formCancelEvent);
					},
					dialogEvents,
					eventOrder: {
						[receive()]: [Reflecting.name(), Receiving.name()],
						[attachedToDom()]: [
							"scroll-lock",
							Reflecting.name(),
							"messages",
							"dialog-events",
							"alloy.base.behaviour"
						],
						[detachedFromDom()]: [
							"alloy.base.behaviour",
							"dialog-events",
							"messages",
							Reflecting.name(),
							"scroll-lock"
						]
					}
				}));
			};
			const mapMenuButtons = (buttons, menuItemStates = {}) => {
				const mapItems = (button$1) => {
					const items = map$2(button$1.items, (item$1) => {
						const cell = get$g(menuItemStates, item$1.name).getOr(Cell(false));
						return {
							...item$1,
							storage: cell
						};
					});
					return {
						...button$1,
						items
					};
				};
				return map$2(buttons, (button$1) => {
					return button$1.type === "menu" ? mapItems(button$1) : button$1;
				});
			};
			const extractCellsToObject = (buttons) => foldl(buttons, (acc, button$1) => {
				if (button$1.type === "menu") return foldl(button$1.items, (innerAcc, item$1) => {
					innerAcc[item$1.name] = item$1.storage;
					return innerAcc;
				}, acc);
				return acc;
			}, {});
			const initCommonEvents = (fireApiEvent, extras) => [
				runWithTarget(focusin(), onFocus),
				fireApiEvent(formCloseEvent, (_api, spec, _event, self$1) => {
					active$1(getRootNode(self$1.element)).fold(noop, blur$1);
					extras.onClose();
					spec.onClose();
				}),
				fireApiEvent(formCancelEvent, (api$3, spec, _event, self$1) => {
					spec.onCancel(api$3);
					emit(self$1, formCloseEvent);
				}),
				run$1(formUnblockEvent, (_c, _se) => extras.onUnblock()),
				run$1(formBlockEvent, (_c, se) => extras.onBlock(se.event))
			];
			const initUrlDialog = (getInstanceApi, extras) => {
				const fireApiEvent = (eventName, f$1) => run$1(eventName, (c, se) => {
					withSpec(c, (spec, _c) => {
						f$1(getInstanceApi(), spec, se.event, c);
					});
				});
				const withSpec = (c, f$1) => {
					Reflecting.getState(c).get().each((currentDialog) => {
						f$1(currentDialog, c);
					});
				};
				return [...initCommonEvents(fireApiEvent, extras), fireApiEvent(formActionEvent, (api$3, spec, event) => {
					spec.onAction(api$3, { name: event.name });
				})];
			};
			const initDialog = (getInstanceApi, extras, getSink$1) => {
				const fireApiEvent = (eventName, f$1) => run$1(eventName, (c, se) => {
					withSpec(c, (spec, _c) => {
						f$1(getInstanceApi(), spec, se.event, c);
					});
				});
				const withSpec = (c, f$1) => {
					Reflecting.getState(c).get().each((currentDialogInit) => {
						f$1(currentDialogInit.internalDialog, c);
					});
				};
				return [
					...initCommonEvents(fireApiEvent, extras),
					fireApiEvent(formSubmitEvent, (api$3, spec) => spec.onSubmit(api$3)),
					fireApiEvent(formChangeEvent, (api$3, spec, event) => {
						spec.onChange(api$3, { name: event.name });
					}),
					fireApiEvent(formActionEvent, (api$3, spec, event, component) => {
						const focusIn$4 = () => component.getSystem().isConnected() ? Keying.focusIn(component) : void 0;
						const isDisabled$1 = (focused) => has$1(focused, "disabled") || getOpt(focused, "aria-disabled").exists((val) => val === "true");
						const rootNode = getRootNode(component.element);
						const current = active$1(rootNode);
						spec.onAction(api$3, {
							name: event.name,
							value: event.value
						});
						active$1(rootNode).fold(focusIn$4, (focused) => {
							if (isDisabled$1(focused)) focusIn$4();
							else if (current.exists((cur) => contains(focused, cur) && isDisabled$1(cur))) focusIn$4();
							else getSink$1().toOptional().filter((sink) => !contains(sink.element, focused)).each(focusIn$4);
						});
					}),
					fireApiEvent(formTabChangeEvent, (api$3, spec, event) => {
						spec.onTabChange(api$3, {
							newTabName: event.name,
							oldTabName: event.oldName
						});
					}),
					runOnDetached((component) => {
						const api$3 = getInstanceApi();
						Representing.setValue(component, api$3.getData());
					})
				];
			};
			const makeButton = (button$1, backstage) => renderFooterButton(button$1, button$1.type, backstage);
			const lookup = (compInSystem, footerButtons, buttonName) => find$5(footerButtons, (button$1) => button$1.name === buttonName).bind((memButton) => memButton.memento.getOpt(compInSystem));
			const renderComponents = (_data, state) => {
				const buttonGroups = partition$3(state.map((s) => s.footerButtons).getOr([]), (button$1) => button$1.align === "start");
				const makeGroup = (edge$1, buttons) => Container.sketch({
					dom: {
						tag: "div",
						classes: [`tox-dialog__footer-${edge$1}`]
					},
					components: map$2(buttons, (button$1) => button$1.memento.asSpec())
				});
				return [makeGroup("start", buttonGroups.pass), makeGroup("end", buttonGroups.fail)];
			};
			const renderFooter = (initSpec, dialogId, backstage) => {
				const updateState = (comp, data) => {
					const footerButtons = map$2(data.buttons, (button$1) => {
						const memButton = record(makeButton(button$1, backstage));
						return {
							name: button$1.name,
							align: button$1.align,
							memento: memButton
						};
					});
					const lookupByName = (buttonName) => lookup(comp, footerButtons, buttonName);
					return Optional.some({
						lookupByName,
						footerButtons
					});
				};
				return {
					dom: fromHtml("<div class=\"tox-dialog__footer\"></div>"),
					components: [],
					behaviours: derive$1([Reflecting.config({
						channel: `${footerChannel}-${dialogId}`,
						initialData: initSpec,
						updateState,
						renderComponents
					})])
				};
			};
			const renderInlineFooter = (initSpec, dialogId, backstage) => renderFooter(initSpec, dialogId, backstage);
			const renderModalFooter = (initSpec, dialogId, backstage) => ModalDialog.parts.footer(renderFooter(initSpec, dialogId, backstage));
			const getCompByName = (access, name$4) => {
				if (access.getRoot().getSystem().isConnected()) {
					const form = Composing.getCurrent(access.getFormWrapper()).getOr(access.getFormWrapper());
					return Form.getField(form, name$4).orThunk(() => {
						return access.getFooter().bind((f$1) => Reflecting.getState(f$1).get()).bind((f$1) => f$1.lookupByName(name$4));
					});
				} else return Optional.none();
			};
			const validateData$1 = (access, data) => {
				const root = access.getRoot();
				return Reflecting.getState(root).get().map((dialogState) => getOrDie(asRaw("data", dialogState.dataValidator, data))).getOr(data);
			};
			const getDialogApi = (access, doRedial, menuItemStates) => {
				const withRoot = (f$1) => {
					const root = access.getRoot();
					if (root.getSystem().isConnected()) f$1(root);
				};
				const getData$3 = () => {
					const root = access.getRoot();
					const valueComp = root.getSystem().isConnected() ? access.getFormWrapper() : root;
					const representedValues = Representing.getValue(valueComp);
					const menuItemCurrentState = map$1(menuItemStates, (cell) => cell.get());
					return {
						...representedValues,
						...menuItemCurrentState
					};
				};
				const setData = (newData) => {
					withRoot((_) => {
						const mergedData = deepMerge(instanceApi.getData(), newData);
						const newInternalData = validateData$1(access, mergedData);
						const form = access.getFormWrapper();
						Representing.setValue(form, newInternalData);
						each(menuItemStates, (v, k) => {
							if (has$2(mergedData, k)) v.set(mergedData[k]);
						});
					});
				};
				const setEnabled = (name$4, state) => {
					getCompByName(access, name$4).each(state ? Disabling.enable : Disabling.disable);
				};
				const focus$5 = (name$4) => {
					getCompByName(access, name$4).each(Focusing.focus);
				};
				const block$1 = (message) => {
					if (!isString(message)) throw new Error("The dialogInstanceAPI.block function should be passed a blocking message of type string as an argument");
					withRoot((root) => {
						emitWith(root, formBlockEvent, { message });
					});
				};
				const unblock$1 = () => {
					withRoot((root) => {
						emit(root, formUnblockEvent);
					});
				};
				const showTab$1 = (name$4) => {
					withRoot((_) => {
						const body$1 = access.getBody();
						if (Reflecting.getState(body$1).get().exists((b$1) => b$1.isTabPanel())) Composing.getCurrent(body$1).each((tabSection) => {
							TabSection.showTab(tabSection, name$4);
						});
					});
				};
				const redial = (d) => {
					withRoot((root) => {
						const id = access.getId();
						const dialogInit = doRedial(d);
						const storedMenuButtons = mapMenuButtons(dialogInit.internalDialog.buttons, menuItemStates);
						root.getSystem().broadcastOn([`${dialogChannel}-${id}`], dialogInit);
						root.getSystem().broadcastOn([`${titleChannel}-${id}`], dialogInit.internalDialog);
						root.getSystem().broadcastOn([`${bodyChannel}-${id}`], dialogInit.internalDialog);
						root.getSystem().broadcastOn([`${footerChannel}-${id}`], {
							...dialogInit.internalDialog,
							buttons: storedMenuButtons
						});
						instanceApi.setData(dialogInit.initialData);
					});
				};
				const close$2 = () => {
					withRoot((root) => {
						emit(root, formCloseEvent);
					});
				};
				const instanceApi = {
					getData: getData$3,
					setData,
					setEnabled,
					focus: focus$5,
					block: block$1,
					unblock: unblock$1,
					showTab: showTab$1,
					redial,
					close: close$2,
					toggleFullscreen: access.toggleFullscreen
				};
				return instanceApi;
			};
			const getDialogSizeClasses = (size) => {
				switch (size) {
					case "large": return ["tox-dialog--width-lg"];
					case "medium": return ["tox-dialog--width-md"];
					default: return [];
				}
			};
			const renderDialog = (dialogInit, extra, backstage) => {
				const dialogId = generate$6("dialog");
				const internalDialog = dialogInit.internalDialog;
				const header = getHeader(internalDialog.title, dialogId, backstage);
				const body$1 = renderModalBody({
					body: internalDialog.body,
					initialData: internalDialog.initialData
				}, dialogId, backstage);
				const storedMenuButtons = mapMenuButtons(internalDialog.buttons);
				const objOfCells = extractCellsToObject(storedMenuButtons);
				const footer = someIf(storedMenuButtons.length !== 0, renderModalFooter({ buttons: storedMenuButtons }, dialogId, backstage));
				const dialogEvents = initDialog(() => instanceApi, getEventExtras(() => dialog, backstage.shared.providers, extra), backstage.shared.getSink);
				const dialogSize = getDialogSizeClasses(internalDialog.size);
				const dialog = renderModalDialog({
					id: dialogId,
					header,
					body: body$1,
					footer,
					extraClasses: dialogSize,
					extraBehaviours: [],
					extraStyles: {}
				}, dialogInit, dialogEvents, backstage);
				const instanceApi = getDialogApi((() => {
					const getForm = () => {
						const outerForm = ModalDialog.getBody(dialog);
						return Composing.getCurrent(outerForm).getOr(outerForm);
					};
					const toggleFullscreen = () => {
						const fullscreenClass = "tox-dialog--fullscreen";
						const sugarBody = SugarElement.fromDom(dialog.element.dom);
						if (!has(sugarBody, fullscreenClass)) {
							remove$1(sugarBody, dialogSize);
							add$2(sugarBody, fullscreenClass);
						} else {
							remove$2(sugarBody, fullscreenClass);
							add$1(sugarBody, dialogSize);
						}
					};
					return {
						getId: constant$1(dialogId),
						getRoot: constant$1(dialog),
						getBody: () => ModalDialog.getBody(dialog),
						getFooter: () => ModalDialog.getFooter(dialog),
						getFormWrapper: getForm,
						toggleFullscreen
					};
				})(), extra.redial, objOfCells);
				return {
					dialog,
					instanceApi
				};
			};
			const getInlineDialogSizeClass = (size) => {
				switch (size) {
					case "medium": return Optional.some("tox-dialog--width-md");
					default: return Optional.none();
				}
			};
			const renderInlineDialog = (dialogInit, extra, backstage, ariaAttrs = false) => {
				const dialogId = generate$6("dialog");
				const dialogLabelId = generate$6("dialog-label");
				const dialogContentId = generate$6("dialog-content");
				const internalDialog = dialogInit.internalDialog;
				const dialogSize = getInlineDialogSizeClass(internalDialog.size);
				const updateState = (_comp, incoming) => Optional.some(incoming);
				const memHeader = record(renderInlineHeader({
					title: internalDialog.title,
					draggable: true
				}, dialogId, dialogLabelId, backstage.shared.providers));
				const memBody = record(renderInlineBody({
					body: internalDialog.body,
					initialData: internalDialog.initialData
				}, dialogId, dialogContentId, backstage, ariaAttrs));
				const storagedMenuButtons = mapMenuButtons(internalDialog.buttons);
				const objOfCells = extractCellsToObject(storagedMenuButtons);
				const optMemFooter = someIf(storagedMenuButtons.length !== 0, record(renderInlineFooter({ buttons: storagedMenuButtons }, dialogId, backstage)));
				const dialogEvents = initDialog(() => instanceApi, {
					onBlock: (event) => {
						Blocking.block(dialog, (_comp, bs) => {
							const headerHeight = memHeader.getOpt(dialog).map((dialog$1) => get$d(dialog$1.element));
							return getBusySpec(event.message, bs, backstage.shared.providers, headerHeight);
						});
					},
					onUnblock: () => {
						Blocking.unblock(dialog);
					},
					onClose: () => extra.closeWindow()
				}, backstage.shared.getSink);
				const inlineClass = "tox-dialog-inline";
				const dialog = build$1({
					dom: {
						tag: "div",
						classes: [
							"tox-dialog",
							inlineClass,
							...dialogSize.toArray()
						],
						attributes: {
							role: "dialog",
							["aria-labelledby"]: dialogLabelId
						}
					},
					eventOrder: {
						[receive()]: [Reflecting.name(), Receiving.name()],
						[execute$5()]: ["execute-on-form"],
						[attachedToDom()]: ["reflecting", "execute-on-form"]
					},
					behaviours: derive$1([
						Keying.config({
							mode: "cyclic",
							onEscape: (c) => {
								emit(c, formCloseEvent);
								return Optional.some(true);
							},
							useTabstopAt: (elem) => !isPseudoStop(elem) && (name$3(elem) !== "button" || get$f(elem, "disabled") !== "disabled"),
							firstTabstop: 1
						}),
						Reflecting.config({
							channel: `${dialogChannel}-${dialogId}`,
							updateState,
							initialData: dialogInit
						}),
						Focusing.config({}),
						config("execute-on-form", dialogEvents.concat([runOnSource(focusin(), (comp, _se) => {
							Keying.focusIn(comp);
						}), run$1(focusShifted(), (comp, se) => {
							comp.getSystem().broadcastOn([dialogFocusShiftedChannel], { newFocus: se.event.newFocus });
						})])),
						Blocking.config({ getRoot: () => Optional.some(dialog) }),
						Replacing.config({}),
						memory({})
					]),
					components: [
						memHeader.asSpec(),
						memBody.asSpec(),
						...optMemFooter.map((memFooter) => memFooter.asSpec()).toArray()
					]
				});
				const toggleFullscreen = () => {
					const fullscreenClass = "tox-dialog--fullscreen";
					const sugarBody = SugarElement.fromDom(dialog.element.dom);
					if (!hasAll(sugarBody, [fullscreenClass])) {
						remove$1(sugarBody, [inlineClass]);
						add$1(sugarBody, [fullscreenClass]);
					} else {
						remove$1(sugarBody, [fullscreenClass]);
						add$1(sugarBody, [inlineClass]);
					}
				};
				const instanceApi = getDialogApi({
					getId: constant$1(dialogId),
					getRoot: constant$1(dialog),
					getFooter: () => optMemFooter.map((memFooter) => memFooter.get(dialog)),
					getBody: () => memBody.get(dialog),
					getFormWrapper: () => {
						const body$1 = memBody.get(dialog);
						return Composing.getCurrent(body$1).getOr(body$1);
					},
					toggleFullscreen
				}, extra.redial, objOfCells);
				return {
					dialog,
					instanceApi
				};
			};
			var global = tinymce.util.Tools.resolve("tinymce.util.URI");
			const getUrlDialogApi = (root) => {
				const withRoot = (f$1) => {
					if (root.getSystem().isConnected()) f$1(root);
				};
				const block$1 = (message) => {
					if (!isString(message)) throw new Error("The urlDialogInstanceAPI.block function should be passed a blocking message of type string as an argument");
					withRoot((root$1) => {
						emitWith(root$1, formBlockEvent, { message });
					});
				};
				const unblock$1 = () => {
					withRoot((root$1) => {
						emit(root$1, formUnblockEvent);
					});
				};
				const close$2 = () => {
					withRoot((root$1) => {
						emit(root$1, formCloseEvent);
					});
				};
				const sendMessage = (data) => {
					withRoot((root$1) => {
						root$1.getSystem().broadcastOn([bodySendMessageChannel], data);
					});
				};
				return {
					block: block$1,
					unblock: unblock$1,
					close: close$2,
					sendMessage
				};
			};
			const SUPPORTED_MESSAGE_ACTIONS = [
				"insertContent",
				"setContent",
				"execCommand",
				"close",
				"block",
				"unblock"
			];
			const isSupportedMessage = (data) => isObject(data) && SUPPORTED_MESSAGE_ACTIONS.indexOf(data.mceAction) !== -1;
			const isCustomMessage = (data) => !isSupportedMessage(data) && isObject(data) && has$2(data, "mceAction");
			const handleMessage = (editor, api$3, data) => {
				switch (data.mceAction) {
					case "insertContent":
						editor.insertContent(data.content);
						break;
					case "setContent":
						editor.setContent(data.content);
						break;
					case "execCommand":
						const ui = isBoolean(data.ui) ? data.ui : false;
						editor.execCommand(data.cmd, ui, data.value);
						break;
					case "close":
						api$3.close();
						break;
					case "block":
						api$3.block(data.message);
						break;
					case "unblock":
						api$3.unblock();
						break;
				}
			};
			const renderUrlDialog = (internalDialog, extra, editor, backstage) => {
				const dialogId = generate$6("dialog");
				const header = getHeader(internalDialog.title, dialogId, backstage);
				const body$1 = renderIframeBody(internalDialog);
				const footer = internalDialog.buttons.bind((buttons) => {
					if (buttons.length === 0) return Optional.none();
					else return Optional.some(renderModalFooter({ buttons }, dialogId, backstage));
				});
				const dialogEvents = initUrlDialog(() => instanceApi, getEventExtras(() => dialog, backstage.shared.providers, extra));
				const styles = {
					...internalDialog.height.fold(() => ({}), (height$1) => ({
						"height": height$1 + "px",
						"max-height": height$1 + "px"
					})),
					...internalDialog.width.fold(() => ({}), (width$1) => ({
						"width": width$1 + "px",
						"max-width": width$1 + "px"
					}))
				};
				const classes$1 = internalDialog.width.isNone() && internalDialog.height.isNone() ? ["tox-dialog--width-lg"] : [];
				const iframeUri = new global(internalDialog.url, { base_uri: new global(window.location.href) });
				const iframeDomain = `${iframeUri.protocol}://${iframeUri.host}${iframeUri.port ? ":" + iframeUri.port : ""}`;
				const messageHandlerUnbinder = unbindable();
				const dialog = renderModalDialog({
					id: dialogId,
					header,
					body: body$1,
					footer,
					extraClasses: classes$1,
					extraBehaviours: [config("messages", [runOnAttached(() => {
						const unbind$1 = bind(SugarElement.fromDom(window), "message", (e) => {
							if (iframeUri.isSameOrigin(new global(e.raw.origin))) {
								const data = e.raw.data;
								if (isSupportedMessage(data)) handleMessage(editor, instanceApi, data);
								else if (isCustomMessage(data)) internalDialog.onMessage(instanceApi, data);
							}
						});
						messageHandlerUnbinder.set(unbind$1);
					}), runOnDetached(messageHandlerUnbinder.clear)]), Receiving.config({ channels: { [bodySendMessageChannel]: { onReceive: (comp, data) => {
						descendant(comp.element, "iframe").each((iframeEle) => {
							const iframeWin = iframeEle.dom.contentWindow;
							if (isNonNullable(iframeWin)) iframeWin.postMessage(data, iframeDomain);
						});
					} } } })],
					extraStyles: styles
				}, internalDialog, dialogEvents, backstage);
				const instanceApi = getUrlDialogApi(dialog);
				return {
					dialog,
					instanceApi
				};
			};
			const setup$2 = (backstage) => {
				const sharedBackstage = backstage.shared;
				const open$2 = (message, callback) => {
					const closeDialog = () => {
						ModalDialog.hide(alertDialog);
						callback();
					};
					const memFooterClose = record(renderFooterButton({
						name: "close-alert",
						text: "OK",
						primary: true,
						buttonType: Optional.some("primary"),
						align: "end",
						enabled: true,
						icon: Optional.none()
					}, "cancel", backstage));
					const alertDialog = build$1(renderDialog$1({
						lazySink: () => sharedBackstage.getSink(),
						header: hiddenHeader(pUntitled(), pClose(closeDialog, sharedBackstage.providers)),
						body: pBodyMessage(message, sharedBackstage.providers),
						footer: Optional.some(pFooter(pFooterGroup([], [memFooterClose.asSpec()]))),
						onEscape: closeDialog,
						extraClasses: ["tox-alert-dialog"],
						extraBehaviours: [],
						extraStyles: {},
						dialogEvents: [run$1(formCancelEvent, closeDialog)],
						eventOrder: {}
					}));
					ModalDialog.show(alertDialog);
					const footerCloseButton = memFooterClose.get(alertDialog);
					Focusing.focus(footerCloseButton);
				};
				return { open: open$2 };
			};
			const setup$1 = (backstage) => {
				const sharedBackstage = backstage.shared;
				const open$2 = (message, callback) => {
					const closeDialog = (state) => {
						ModalDialog.hide(confirmDialog);
						callback(state);
					};
					const memFooterYes = record(renderFooterButton({
						name: "yes",
						text: "Yes",
						primary: true,
						buttonType: Optional.some("primary"),
						align: "end",
						enabled: true,
						icon: Optional.none()
					}, "submit", backstage));
					const footerNo = renderFooterButton({
						name: "no",
						text: "No",
						primary: false,
						buttonType: Optional.some("secondary"),
						align: "end",
						enabled: true,
						icon: Optional.none()
					}, "cancel", backstage);
					const confirmDialog = build$1(renderDialog$1({
						lazySink: () => sharedBackstage.getSink(),
						header: hiddenHeader(pUntitled(), pClose(() => closeDialog(false), sharedBackstage.providers)),
						body: pBodyMessage(message, sharedBackstage.providers),
						footer: Optional.some(pFooter(pFooterGroup([], [footerNo, memFooterYes.asSpec()]))),
						onEscape: () => closeDialog(false),
						extraClasses: ["tox-confirm-dialog"],
						extraBehaviours: [],
						extraStyles: {},
						dialogEvents: [run$1(formCancelEvent, () => closeDialog(false)), run$1(formSubmitEvent, () => closeDialog(true))],
						eventOrder: {}
					}));
					ModalDialog.show(confirmDialog);
					const footerYesButton = memFooterYes.get(confirmDialog);
					Focusing.focus(footerYesButton);
				};
				return { open: open$2 };
			};
			const validateData = (data, validator) => getOrDie(asRaw("data", validator, data));
			const isAlertOrConfirmDialog = (target) => closest(target, ".tox-alert-dialog") || closest(target, ".tox-confirm-dialog");
			const inlineAdditionalBehaviours = (editor, isStickyToolbar$1, isToolbarLocationTop) => {
				if (isStickyToolbar$1 && isToolbarLocationTop) return [];
				else return [Docking.config({
					contextual: {
						lazyContext: () => Optional.some(box$1(SugarElement.fromDom(editor.getContentAreaContainer()))),
						fadeInClass: "tox-dialog-dock-fadein",
						fadeOutClass: "tox-dialog-dock-fadeout",
						transitionClass: "tox-dialog-dock-transition"
					},
					modes: ["top"],
					lazyViewport: (comp) => {
						return detectWhenSplitUiMode(editor, comp.element).map((sc) => {
							return {
								bounds: getBoundsFrom(sc),
								optScrollEnv: Optional.some({
									currentScrollTop: sc.element.dom.scrollTop,
									scrollElmTop: absolute$3(sc.element).top
								})
							};
						}).getOrThunk(() => ({
							bounds: win(),
							optScrollEnv: Optional.none()
						}));
					}
				})];
			};
			const setup = (extras) => {
				const editor = extras.editor;
				const isStickyToolbar$1 = isStickyToolbar(editor);
				const alertDialog = setup$2(extras.backstages.dialog);
				const confirmDialog = setup$1(extras.backstages.dialog);
				const open$2 = (config$1, params, closeWindow) => {
					if (!isUndefined(params)) {
						if (params.inline === "toolbar") return openInlineDialog(config$1, extras.backstages.popup.shared.anchors.inlineDialog(), closeWindow, params);
						else if (params.inline === "bottom") return openBottomInlineDialog(config$1, extras.backstages.popup.shared.anchors.inlineBottomDialog(), closeWindow, params);
						else if (params.inline === "cursor") return openInlineDialog(config$1, extras.backstages.popup.shared.anchors.cursor(), closeWindow, params);
					}
					return openModalDialog(config$1, closeWindow);
				};
				const openUrl = (config$1, closeWindow) => openModalUrlDialog(config$1, closeWindow);
				const openModalUrlDialog = (config$1, closeWindow) => {
					const factory$10 = (contents$1) => {
						const dialog = renderUrlDialog(contents$1, { closeWindow: () => {
							ModalDialog.hide(dialog.dialog);
							closeWindow(dialog.instanceApi);
						} }, editor, extras.backstages.dialog);
						ModalDialog.show(dialog.dialog);
						return dialog.instanceApi;
					};
					return DialogManager.openUrl(factory$10, config$1);
				};
				const openModalDialog = (config$1, closeWindow) => {
					const factory$10 = (contents$1, internalInitialData, dataValidator) => {
						const initialData = internalInitialData;
						const dialog = renderDialog({
							dataValidator,
							initialData,
							internalDialog: contents$1
						}, {
							redial: DialogManager.redial,
							closeWindow: () => {
								ModalDialog.hide(dialog.dialog);
								closeWindow(dialog.instanceApi);
							}
						}, extras.backstages.dialog);
						ModalDialog.show(dialog.dialog);
						dialog.instanceApi.setData(initialData);
						return dialog.instanceApi;
					};
					return DialogManager.open(factory$10, config$1);
				};
				const openInlineDialog = (config$1, anchor$1, closeWindow, windowParams) => {
					const factory$10 = (contents$1, internalInitialData, dataValidator) => {
						const initialData = validateData(internalInitialData, dataValidator);
						const inlineDialog = value$2();
						const isToolbarLocationTop = extras.backstages.popup.shared.header.isPositionedAtTop();
						const dialogInit = {
							dataValidator,
							initialData,
							internalDialog: contents$1
						};
						const refreshDocking = () => inlineDialog.on((dialog) => {
							InlineView.reposition(dialog);
							Docking.refresh(dialog);
						});
						const dialogUi = renderInlineDialog(dialogInit, {
							redial: DialogManager.redial,
							closeWindow: () => {
								inlineDialog.on(InlineView.hide);
								editor.off("ResizeEditor", refreshDocking);
								inlineDialog.clear();
								closeWindow(dialogUi.instanceApi);
							}
						}, extras.backstages.popup, windowParams.ariaAttrs);
						const inlineDialogComp = build$1(InlineView.sketch({
							lazySink: extras.backstages.popup.shared.getSink,
							dom: {
								tag: "div",
								classes: []
							},
							fireDismissalEventInstead: windowParams.persistent ? { event: "doNotDismissYet" } : {},
							...isToolbarLocationTop ? {} : { fireRepositionEventInstead: {} },
							inlineBehaviours: derive$1([config("window-manager-inline-events", [run$1(dismissRequested(), (_comp, _se) => {
								emit(dialogUi.dialog, formCancelEvent);
							})]), ...inlineAdditionalBehaviours(editor, isStickyToolbar$1, isToolbarLocationTop)]),
							isExtraPart: (_comp, target) => isAlertOrConfirmDialog(target)
						}));
						inlineDialog.set(inlineDialogComp);
						const getInlineDialogBounds = () => {
							const bounds$2 = box$1(editor.inline ? body() : SugarElement.fromDom(editor.getContainer()));
							return Optional.some(bounds$2);
						};
						InlineView.showWithinBounds(inlineDialogComp, premade(dialogUi.dialog), { anchor: anchor$1 }, getInlineDialogBounds);
						if (!isStickyToolbar$1 || !isToolbarLocationTop) {
							Docking.refresh(inlineDialogComp);
							editor.on("ResizeEditor", refreshDocking);
						}
						dialogUi.instanceApi.setData(initialData);
						Keying.focusIn(dialogUi.dialog);
						return dialogUi.instanceApi;
					};
					return DialogManager.open(factory$10, config$1);
				};
				const openBottomInlineDialog = (config$1, anchor$1, closeWindow, windowParams) => {
					const factory$10 = (contents$1, internalInitialData, dataValidator) => {
						const initialData = validateData(internalInitialData, dataValidator);
						const inlineDialog = value$2();
						const isToolbarLocationTop = extras.backstages.popup.shared.header.isPositionedAtTop();
						const dialogInit = {
							dataValidator,
							initialData,
							internalDialog: contents$1
						};
						const refreshDocking = () => inlineDialog.on((dialog) => {
							InlineView.reposition(dialog);
							Docking.refresh(dialog);
						});
						const dialogUi = renderInlineDialog(dialogInit, {
							redial: DialogManager.redial,
							closeWindow: () => {
								inlineDialog.on(InlineView.hide);
								editor.off("ResizeEditor ScrollWindow ElementScroll", refreshDocking);
								inlineDialog.clear();
								closeWindow(dialogUi.instanceApi);
							}
						}, extras.backstages.popup, windowParams.ariaAttrs);
						const inlineDialogComp = build$1(InlineView.sketch({
							lazySink: extras.backstages.popup.shared.getSink,
							dom: {
								tag: "div",
								classes: []
							},
							fireDismissalEventInstead: windowParams.persistent ? { event: "doNotDismissYet" } : {},
							...isToolbarLocationTop ? {} : { fireRepositionEventInstead: {} },
							inlineBehaviours: derive$1([config("window-manager-inline-events", [run$1(dismissRequested(), (_comp, _se) => {
								emit(dialogUi.dialog, formCancelEvent);
							})]), Docking.config({
								contextual: {
									lazyContext: () => Optional.some(box$1(SugarElement.fromDom(editor.getContentAreaContainer()))),
									fadeInClass: "tox-dialog-dock-fadein",
									fadeOutClass: "tox-dialog-dock-fadeout",
									transitionClass: "tox-dialog-dock-transition"
								},
								modes: ["top", "bottom"],
								lazyViewport: (comp) => {
									return detectWhenSplitUiMode(editor, comp.element).map((sc) => {
										return {
											bounds: getBoundsFrom(sc),
											optScrollEnv: Optional.some({
												currentScrollTop: sc.element.dom.scrollTop,
												scrollElmTop: absolute$3(sc.element).top
											})
										};
									}).getOrThunk(() => ({
										bounds: win(),
										optScrollEnv: Optional.none()
									}));
								}
							})]),
							isExtraPart: (_comp, target) => isAlertOrConfirmDialog(target)
						}));
						inlineDialog.set(inlineDialogComp);
						const getInlineDialogBounds = () => {
							return extras.backstages.popup.shared.getSink().toOptional().bind((s) => {
								const optScrollingContext = detectWhenSplitUiMode(editor, s.element);
								const margin = 15;
								const bounds$1$1 = optScrollingContext.map((sc) => getBoundsFrom(sc)).getOr(win());
								const constrainedBounds = constrain(box$1(SugarElement.fromDom(editor.getContentAreaContainer())), bounds$1$1);
								return Optional.some(bounds(constrainedBounds.x, constrainedBounds.y, constrainedBounds.width, constrainedBounds.height - margin));
							});
						};
						InlineView.showWithinBounds(inlineDialogComp, premade(dialogUi.dialog), { anchor: anchor$1 }, getInlineDialogBounds);
						Docking.refresh(inlineDialogComp);
						editor.on("ResizeEditor ScrollWindow ElementScroll", refreshDocking);
						dialogUi.instanceApi.setData(initialData);
						Keying.focusIn(dialogUi.dialog);
						return dialogUi.instanceApi;
					};
					return DialogManager.open(factory$10, config$1);
				};
				const confirm = (message, callback) => {
					confirmDialog.open(message, callback);
				};
				const alert = (message, callback) => {
					alertDialog.open(message, callback);
				};
				const close$2 = (instanceApi) => {
					instanceApi.close();
				};
				return {
					open: open$2,
					openUrl,
					alert,
					close: close$2,
					confirm
				};
			};
			const registerOptions = (editor) => {
				register$e(editor);
				register$d(editor);
				register(editor);
			};
			var Theme = () => {
				global$a.add("silver", (editor) => {
					registerOptions(editor);
					let popupSinkBounds = () => win();
					const { dialogs, popups, renderUI: renderModeUI } = setup$3(editor, { getPopupSinkBounds: () => popupSinkBounds() });
					const renderUI = async () => {
						const renderResult = await renderModeUI();
						detectWhenSplitUiMode(editor, popups.getMothership().element).each((sc) => {
							popupSinkBounds = () => {
								return getBoundsFrom(sc);
							};
						});
						return renderResult;
					};
					Autocompleter.register(editor, popups.backstage.shared);
					const windowMgr = setup({
						editor,
						backstages: {
							popup: popups.backstage,
							dialog: dialogs.backstage
						}
					});
					const getNotificationManagerImpl = () => NotificationManagerImpl(editor, { backstage: popups.backstage }, popups.getMothership());
					return {
						renderUI,
						getWindowManagerImpl: constant$1(windowMgr),
						getNotificationManagerImpl
					};
				});
			};
			Theme();
		})();
	}));

//#endregion
//#region node_modules/tinymce/themes/silver/index.js
	require_theme();

//#endregion
//#region node_modules/tinymce/plugins/advlist/plugin.js
	var require_plugin$4 = /* @__PURE__ */ __commonJSMin((() => {
		/**
		* TinyMCE version 6.7.0 (2023-08-30)
		*/
		(function() {
			"use strict";
			var global$1 = tinymce.util.Tools.resolve("tinymce.PluginManager");
			const applyListFormat = (editor, listName, styleValue) => {
				const cmd = listName === "UL" ? "InsertUnorderedList" : "InsertOrderedList";
				editor.execCommand(cmd, false, styleValue === false ? null : { "list-style-type": styleValue });
			};
			const register$2 = (editor) => {
				editor.addCommand("ApplyUnorderedListStyle", (ui, value) => {
					applyListFormat(editor, "UL", value["list-style-type"]);
				});
				editor.addCommand("ApplyOrderedListStyle", (ui, value) => {
					applyListFormat(editor, "OL", value["list-style-type"]);
				});
			};
			const option = (name) => (editor) => editor.options.get(name);
			const register$1 = (editor) => {
				const registerOption = editor.options.register;
				registerOption("advlist_number_styles", {
					processor: "string[]",
					default: "default,lower-alpha,lower-greek,lower-roman,upper-alpha,upper-roman".split(",")
				});
				registerOption("advlist_bullet_styles", {
					processor: "string[]",
					default: "default,circle,square".split(",")
				});
			};
			const getNumberStyles = option("advlist_number_styles");
			const getBulletStyles = option("advlist_bullet_styles");
			const isNullable = (a) => a === null || a === void 0;
			const isNonNullable = (a) => !isNullable(a);
			var global = tinymce.util.Tools.resolve("tinymce.util.Tools");
			class Optional {
				constructor(tag, value) {
					this.tag = tag;
					this.value = value;
				}
				static some(value) {
					return new Optional(true, value);
				}
				static none() {
					return Optional.singletonNone;
				}
				fold(onNone, onSome) {
					if (this.tag) return onSome(this.value);
					else return onNone();
				}
				isSome() {
					return this.tag;
				}
				isNone() {
					return !this.tag;
				}
				map(mapper) {
					if (this.tag) return Optional.some(mapper(this.value));
					else return Optional.none();
				}
				bind(binder) {
					if (this.tag) return binder(this.value);
					else return Optional.none();
				}
				exists(predicate) {
					return this.tag && predicate(this.value);
				}
				forall(predicate) {
					return !this.tag || predicate(this.value);
				}
				filter(predicate) {
					if (!this.tag || predicate(this.value)) return this;
					else return Optional.none();
				}
				getOr(replacement) {
					return this.tag ? this.value : replacement;
				}
				or(replacement) {
					return this.tag ? this : replacement;
				}
				getOrThunk(thunk) {
					return this.tag ? this.value : thunk();
				}
				orThunk(thunk) {
					return this.tag ? this : thunk();
				}
				getOrDie(message) {
					if (!this.tag) throw new Error(message !== null && message !== void 0 ? message : "Called getOrDie on None");
					else return this.value;
				}
				static from(value) {
					return isNonNullable(value) ? Optional.some(value) : Optional.none();
				}
				getOrNull() {
					return this.tag ? this.value : null;
				}
				getOrUndefined() {
					return this.value;
				}
				each(worker) {
					if (this.tag) worker(this.value);
				}
				toArray() {
					return this.tag ? [this.value] : [];
				}
				toString() {
					return this.tag ? `some(${this.value})` : "none()";
				}
			}
			Optional.singletonNone = new Optional(false);
			const findUntil = (xs, pred, until) => {
				for (let i = 0, len = xs.length; i < len; i++) {
					const x = xs[i];
					if (pred(x, i)) return Optional.some(x);
					else if (until(x, i)) break;
				}
				return Optional.none();
			};
			const isCustomList = (list) => /\btox\-/.test(list.className);
			const isChildOfBody = (editor, elm) => {
				return editor.dom.isChildOf(elm, editor.getBody());
			};
			const matchNodeNames = (regex) => (node) => isNonNullable(node) && regex.test(node.nodeName);
			const isListNode = matchNodeNames(/^(OL|UL|DL)$/);
			const isTableCellNode = matchNodeNames(/^(TH|TD)$/);
			const inList = (editor, parents, nodeName) => findUntil(parents, (parent) => isListNode(parent) && !isCustomList(parent), isTableCellNode).exists((list) => list.nodeName === nodeName && isChildOfBody(editor, list));
			const getSelectedStyleType = (editor) => {
				const listElm = editor.dom.getParent(editor.selection.getNode(), "ol,ul");
				const style = editor.dom.getStyle(listElm, "listStyleType");
				return Optional.from(style);
			};
			const isWithinNonEditable = (editor, element) => element !== null && !editor.dom.isEditable(element);
			const isWithinNonEditableList = (editor, element) => {
				return isWithinNonEditable(editor, editor.dom.getParent(element, "ol,ul,dl")) && editor.selection.isEditable();
			};
			const setNodeChangeHandler = (editor, nodeChangeHandler) => {
				const initialNode = editor.selection.getNode();
				nodeChangeHandler({
					parents: editor.dom.getParents(initialNode),
					element: initialNode
				});
				editor.on("NodeChange", nodeChangeHandler);
				return () => editor.off("NodeChange", nodeChangeHandler);
			};
			const styleValueToText = (styleValue) => {
				return styleValue.replace(/\-/g, " ").replace(/\b\w/g, (chr) => {
					return chr.toUpperCase();
				});
			};
			const normalizeStyleValue = (styleValue) => isNullable(styleValue) || styleValue === "default" ? "" : styleValue;
			const makeSetupHandler = (editor, nodeName) => (api) => {
				const updateButtonState = (editor$1, parents) => {
					const element = editor$1.selection.getStart(true);
					api.setActive(inList(editor$1, parents, nodeName));
					api.setEnabled(!isWithinNonEditableList(editor$1, element) && editor$1.selection.isEditable());
				};
				const nodeChangeHandler = (e) => updateButtonState(editor, e.parents);
				return setNodeChangeHandler(editor, nodeChangeHandler);
			};
			const addSplitButton = (editor, id, tooltip, cmd, nodeName, styles) => {
				editor.ui.registry.addSplitButton(id, {
					tooltip,
					icon: nodeName === "OL" ? "ordered-list" : "unordered-list",
					presets: "listpreview",
					columns: 3,
					fetch: (callback) => {
						callback(global.map(styles, (styleValue) => {
							const iconStyle = nodeName === "OL" ? "num" : "bull";
							const iconName = styleValue === "disc" || styleValue === "decimal" ? "default" : styleValue;
							const itemValue = normalizeStyleValue(styleValue);
							const displayText = styleValueToText(styleValue);
							return {
								type: "choiceitem",
								value: itemValue,
								icon: "list-" + iconStyle + "-" + iconName,
								text: displayText
							};
						}));
					},
					onAction: () => editor.execCommand(cmd),
					onItemAction: (_splitButtonApi, value) => {
						applyListFormat(editor, nodeName, value);
					},
					select: (value) => {
						return getSelectedStyleType(editor).map((listStyle) => value === listStyle).getOr(false);
					},
					onSetup: makeSetupHandler(editor, nodeName)
				});
			};
			const addButton = (editor, id, tooltip, cmd, nodeName, styleValue) => {
				editor.ui.registry.addToggleButton(id, {
					active: false,
					tooltip,
					icon: nodeName === "OL" ? "ordered-list" : "unordered-list",
					onSetup: makeSetupHandler(editor, nodeName),
					onAction: () => editor.queryCommandState(cmd) || styleValue === "" ? editor.execCommand(cmd) : applyListFormat(editor, nodeName, styleValue)
				});
			};
			const addControl = (editor, id, tooltip, cmd, nodeName, styles) => {
				if (styles.length > 1) addSplitButton(editor, id, tooltip, cmd, nodeName, styles);
				else addButton(editor, id, tooltip, cmd, nodeName, normalizeStyleValue(styles[0]));
			};
			const register = (editor) => {
				addControl(editor, "numlist", "Numbered list", "InsertOrderedList", "OL", getNumberStyles(editor));
				addControl(editor, "bullist", "Bullet list", "InsertUnorderedList", "UL", getBulletStyles(editor));
			};
			var Plugin = () => {
				global$1.add("advlist", (editor) => {
					if (editor.hasPlugin("lists")) {
						register$1(editor);
						register(editor);
						register$2(editor);
					} else console.error("Please use the Lists plugin together with the Advanced List plugin.");
				});
			};
			Plugin();
		})();
	}));

//#endregion
//#region node_modules/tinymce/plugins/advlist/index.js
	require_plugin$4();

//#endregion
//#region node_modules/tinymce/plugins/code/plugin.js
	var require_plugin$3 = /* @__PURE__ */ __commonJSMin((() => {
		/**
		* TinyMCE version 6.7.0 (2023-08-30)
		*/
		(function() {
			"use strict";
			var global = tinymce.util.Tools.resolve("tinymce.PluginManager");
			const setContent = (editor, html) => {
				editor.focus();
				editor.undoManager.transact(() => {
					editor.setContent(html);
				});
				editor.selection.setCursorLocation();
				editor.nodeChanged();
			};
			const getContent = (editor) => {
				return editor.getContent({ source_view: true });
			};
			const open = (editor) => {
				const editorContent = getContent(editor);
				editor.windowManager.open({
					title: "Source Code",
					size: "large",
					body: {
						type: "panel",
						items: [{
							type: "textarea",
							name: "code"
						}]
					},
					buttons: [{
						type: "cancel",
						name: "cancel",
						text: "Cancel"
					}, {
						type: "submit",
						name: "save",
						text: "Save",
						primary: true
					}],
					initialData: { code: editorContent },
					onSubmit: (api) => {
						setContent(editor, api.getData().code);
						api.close();
					}
				});
			};
			const register$1 = (editor) => {
				editor.addCommand("mceCodeEditor", () => {
					open(editor);
				});
			};
			const register = (editor) => {
				const onAction = () => editor.execCommand("mceCodeEditor");
				editor.ui.registry.addButton("code", {
					icon: "sourcecode",
					tooltip: "Source code",
					onAction
				});
				editor.ui.registry.addMenuItem("code", {
					icon: "sourcecode",
					text: "Source code",
					onAction
				});
			};
			var Plugin = () => {
				global.add("code", (editor) => {
					register$1(editor);
					register(editor);
					return {};
				});
			};
			Plugin();
		})();
	}));

//#endregion
//#region node_modules/tinymce/plugins/code/index.js
	require_plugin$3();

//#endregion
//#region node_modules/tinymce/plugins/link/plugin.js
	var require_plugin$2 = /* @__PURE__ */ __commonJSMin((() => {
		/**
		* TinyMCE version 6.7.0 (2023-08-30)
		*/
		(function() {
			"use strict";
			var global$5 = tinymce.util.Tools.resolve("tinymce.PluginManager");
			const hasProto = (v, constructor, predicate) => {
				var _a;
				if (predicate(v, constructor.prototype)) return true;
				else return ((_a = v.constructor) === null || _a === void 0 ? void 0 : _a.name) === constructor.name;
			};
			const typeOf = (x) => {
				const t = typeof x;
				if (x === null) return "null";
				else if (t === "object" && Array.isArray(x)) return "array";
				else if (t === "object" && hasProto(x, String, (o, proto) => proto.isPrototypeOf(o))) return "string";
				else return t;
			};
			const isType = (type) => (value) => typeOf(value) === type;
			const isSimpleType = (type) => (value) => typeof value === type;
			const eq = (t) => (a) => t === a;
			const isString = isType("string");
			const isObject = isType("object");
			const isArray = isType("array");
			const isNull = eq(null);
			const isBoolean = isSimpleType("boolean");
			const isNullable = (a) => a === null || a === void 0;
			const isNonNullable = (a) => !isNullable(a);
			const isFunction = isSimpleType("function");
			const isArrayOf = (value, pred) => {
				if (isArray(value)) {
					for (let i = 0, len = value.length; i < len; ++i) if (!pred(value[i])) return false;
					return true;
				}
				return false;
			};
			const noop = () => {};
			const constant = (value) => {
				return () => {
					return value;
				};
			};
			const tripleEquals = (a, b) => {
				return a === b;
			};
			class Optional {
				constructor(tag, value) {
					this.tag = tag;
					this.value = value;
				}
				static some(value) {
					return new Optional(true, value);
				}
				static none() {
					return Optional.singletonNone;
				}
				fold(onNone, onSome) {
					if (this.tag) return onSome(this.value);
					else return onNone();
				}
				isSome() {
					return this.tag;
				}
				isNone() {
					return !this.tag;
				}
				map(mapper) {
					if (this.tag) return Optional.some(mapper(this.value));
					else return Optional.none();
				}
				bind(binder) {
					if (this.tag) return binder(this.value);
					else return Optional.none();
				}
				exists(predicate) {
					return this.tag && predicate(this.value);
				}
				forall(predicate) {
					return !this.tag || predicate(this.value);
				}
				filter(predicate) {
					if (!this.tag || predicate(this.value)) return this;
					else return Optional.none();
				}
				getOr(replacement) {
					return this.tag ? this.value : replacement;
				}
				or(replacement) {
					return this.tag ? this : replacement;
				}
				getOrThunk(thunk) {
					return this.tag ? this.value : thunk();
				}
				orThunk(thunk) {
					return this.tag ? this : thunk();
				}
				getOrDie(message) {
					if (!this.tag) throw new Error(message !== null && message !== void 0 ? message : "Called getOrDie on None");
					else return this.value;
				}
				static from(value) {
					return isNonNullable(value) ? Optional.some(value) : Optional.none();
				}
				getOrNull() {
					return this.tag ? this.value : null;
				}
				getOrUndefined() {
					return this.value;
				}
				each(worker) {
					if (this.tag) worker(this.value);
				}
				toArray() {
					return this.tag ? [this.value] : [];
				}
				toString() {
					return this.tag ? `some(${this.value})` : "none()";
				}
			}
			Optional.singletonNone = new Optional(false);
			const nativeIndexOf = Array.prototype.indexOf;
			const nativePush = Array.prototype.push;
			const rawIndexOf = (ts, t) => nativeIndexOf.call(ts, t);
			const contains = (xs, x) => rawIndexOf(xs, x) > -1;
			const map = (xs, f) => {
				const len = xs.length;
				const r = new Array(len);
				for (let i = 0; i < len; i++) {
					const x = xs[i];
					r[i] = f(x, i);
				}
				return r;
			};
			const each$1 = (xs, f) => {
				for (let i = 0, len = xs.length; i < len; i++) {
					const x = xs[i];
					f(x, i);
				}
			};
			const foldl = (xs, f, acc) => {
				each$1(xs, (x, i) => {
					acc = f(acc, x, i);
				});
				return acc;
			};
			const flatten = (xs) => {
				const r = [];
				for (let i = 0, len = xs.length; i < len; ++i) {
					if (!isArray(xs[i])) throw new Error("Arr.flatten item " + i + " was not an array, input: " + xs);
					nativePush.apply(r, xs[i]);
				}
				return r;
			};
			const bind = (xs, f) => flatten(map(xs, f));
			const findMap = (arr, f) => {
				for (let i = 0; i < arr.length; i++) {
					const r = f(arr[i], i);
					if (r.isSome()) return r;
				}
				return Optional.none();
			};
			const is = (lhs, rhs, comparator = tripleEquals) => lhs.exists((left) => comparator(left, rhs));
			const cat = (arr) => {
				const r = [];
				const push = (x) => {
					r.push(x);
				};
				for (let i = 0; i < arr.length; i++) arr[i].each(push);
				return r;
			};
			const someIf = (b, a) => b ? Optional.some(a) : Optional.none();
			const option = (name) => (editor) => editor.options.get(name);
			const register$1 = (editor) => {
				const registerOption = editor.options.register;
				registerOption("link_assume_external_targets", {
					processor: (value) => {
						const valid = isString(value) || isBoolean(value);
						if (valid) if (value === true) return {
							value: 1,
							valid
						};
						else if (value === "http" || value === "https") return {
							value,
							valid
						};
						else return {
							value: 0,
							valid
						};
						else return {
							valid: false,
							message: "Must be a string or a boolean."
						};
					},
					default: false
				});
				registerOption("link_context_toolbar", {
					processor: "boolean",
					default: false
				});
				registerOption("link_list", { processor: (value) => isString(value) || isFunction(value) || isArrayOf(value, isObject) });
				registerOption("link_default_target", { processor: "string" });
				registerOption("link_default_protocol", {
					processor: "string",
					default: "https"
				});
				registerOption("link_target_list", {
					processor: (value) => isBoolean(value) || isArrayOf(value, isObject),
					default: true
				});
				registerOption("link_rel_list", {
					processor: "object[]",
					default: []
				});
				registerOption("link_class_list", {
					processor: "object[]",
					default: []
				});
				registerOption("link_title", {
					processor: "boolean",
					default: true
				});
				registerOption("allow_unsafe_link_target", {
					processor: "boolean",
					default: false
				});
				registerOption("link_quicklink", {
					processor: "boolean",
					default: false
				});
			};
			const assumeExternalTargets = option("link_assume_external_targets");
			const hasContextToolbar = option("link_context_toolbar");
			const getLinkList = option("link_list");
			const getDefaultLinkTarget = option("link_default_target");
			const getDefaultLinkProtocol = option("link_default_protocol");
			const getTargetList = option("link_target_list");
			const getRelList = option("link_rel_list");
			const getLinkClassList = option("link_class_list");
			const shouldShowLinkTitle = option("link_title");
			const allowUnsafeLinkTarget = option("allow_unsafe_link_target");
			const useQuickLink = option("link_quicklink");
			var global$4 = tinymce.util.Tools.resolve("tinymce.util.Tools");
			const getValue = (item) => isString(item.value) ? item.value : "";
			const getText = (item) => {
				if (isString(item.text)) return item.text;
				else if (isString(item.title)) return item.title;
				else return "";
			};
			const sanitizeList = (list, extractValue) => {
				const out = [];
				global$4.each(list, (item) => {
					const text = getText(item);
					if (item.menu !== void 0) {
						const items = sanitizeList(item.menu, extractValue);
						out.push({
							text,
							items
						});
					} else {
						const value = extractValue(item);
						out.push({
							text,
							value
						});
					}
				});
				return out;
			};
			const sanitizeWith = (extracter = getValue) => (list) => Optional.from(list).map((list$1) => sanitizeList(list$1, extracter));
			const sanitize = (list) => sanitizeWith(getValue)(list);
			const createUi = (name, label) => (items) => ({
				name,
				type: "listbox",
				label,
				items
			});
			const ListOptions = {
				sanitize,
				sanitizeWith,
				createUi,
				getValue
			};
			const keys = Object.keys;
			const hasOwnProperty = Object.hasOwnProperty;
			const each = (obj, f) => {
				const props = keys(obj);
				for (let k = 0, len = props.length; k < len; k++) {
					const i = props[k];
					const x = obj[i];
					f(x, i);
				}
			};
			const objAcc = (r) => (x, i) => {
				r[i] = x;
			};
			const internalFilter = (obj, pred, onTrue, onFalse) => {
				each(obj, (x, i) => {
					(pred(x, i) ? onTrue : onFalse)(x, i);
				});
			};
			const filter = (obj, pred) => {
				const t = {};
				internalFilter(obj, pred, objAcc(t), noop);
				return t;
			};
			const has = (obj, key) => hasOwnProperty.call(obj, key);
			const hasNonNullableKey = (obj, key) => has(obj, key) && obj[key] !== void 0 && obj[key] !== null;
			var global$3 = tinymce.util.Tools.resolve("tinymce.dom.TreeWalker");
			var global$2 = tinymce.util.Tools.resolve("tinymce.util.URI");
			const isAnchor = (elm) => isNonNullable(elm) && elm.nodeName.toLowerCase() === "a";
			const isLink = (elm) => isAnchor(elm) && !!getHref(elm);
			const collectNodesInRange = (rng, predicate) => {
				if (rng.collapsed) return [];
				else {
					const contents = rng.cloneContents();
					const firstChild = contents.firstChild;
					const walker = new global$3(firstChild, contents);
					const elements = [];
					let current = firstChild;
					do
						if (predicate(current)) elements.push(current);
					while (current = walker.next());
					return elements;
				}
			};
			const hasProtocol = (url) => /^\w+:/i.test(url);
			const getHref = (elm) => {
				var _a, _b;
				return (_b = (_a = elm.getAttribute("data-mce-href")) !== null && _a !== void 0 ? _a : elm.getAttribute("href")) !== null && _b !== void 0 ? _b : "";
			};
			const applyRelTargetRules = (rel, isUnsafe) => {
				const rules = ["noopener"];
				const rels = rel ? rel.split(/\s+/) : [];
				const toString = (rels$1) => global$4.trim(rels$1.sort().join(" "));
				const addTargetRules = (rels$1) => {
					rels$1 = removeTargetRules(rels$1);
					return rels$1.length > 0 ? rels$1.concat(rules) : rules;
				};
				const removeTargetRules = (rels$1) => rels$1.filter((val) => global$4.inArray(rules, val) === -1);
				const newRels = isUnsafe ? addTargetRules(rels) : removeTargetRules(rels);
				return newRels.length > 0 ? toString(newRels) : "";
			};
			const trimCaretContainers = (text) => text.replace(/\uFEFF/g, "");
			const getAnchorElement = (editor, selectedElm) => {
				selectedElm = selectedElm || getLinksInSelection(editor.selection.getRng())[0] || editor.selection.getNode();
				if (isImageFigure(selectedElm)) return Optional.from(editor.dom.select("a[href]", selectedElm)[0]);
				else return Optional.from(editor.dom.getParent(selectedElm, "a[href]"));
			};
			const isInAnchor = (editor, selectedElm) => getAnchorElement(editor, selectedElm).isSome();
			const getAnchorText = (selection, anchorElm) => {
				return trimCaretContainers(anchorElm.fold(() => selection.getContent({ format: "text" }), (anchorElm$1) => anchorElm$1.innerText || anchorElm$1.textContent || ""));
			};
			const getLinksInSelection = (rng) => collectNodesInRange(rng, isLink);
			const getLinks$1 = (elements) => global$4.grep(elements, isLink);
			const hasLinks = (elements) => getLinks$1(elements).length > 0;
			const hasLinksInSelection = (rng) => getLinksInSelection(rng).length > 0;
			const isOnlyTextSelected = (editor) => {
				const inlineTextElements = editor.schema.getTextInlineElements();
				const isElement = (elm) => elm.nodeType === 1 && !isAnchor(elm) && !has(inlineTextElements, elm.nodeName.toLowerCase());
				if (getAnchorElement(editor).exists((anchor) => anchor.hasAttribute("data-mce-block"))) return false;
				const rng = editor.selection.getRng();
				if (!rng.collapsed) return collectNodesInRange(rng, isElement).length === 0;
				else return true;
			};
			const isImageFigure = (elm) => isNonNullable(elm) && elm.nodeName === "FIGURE" && /\bimage\b/i.test(elm.className);
			const getLinkAttrs = (data) => {
				return foldl([
					"title",
					"rel",
					"class",
					"target"
				], (acc, key) => {
					data[key].each((value) => {
						acc[key] = value.length > 0 ? value : null;
					});
					return acc;
				}, { href: data.href });
			};
			const handleExternalTargets = (href, assumeExternalTargets$1) => {
				if ((assumeExternalTargets$1 === "http" || assumeExternalTargets$1 === "https") && !hasProtocol(href)) return assumeExternalTargets$1 + "://" + href;
				return href;
			};
			const applyLinkOverrides = (editor, linkAttrs) => {
				const newLinkAttrs = { ...linkAttrs };
				if (getRelList(editor).length === 0 && !allowUnsafeLinkTarget(editor)) {
					const newRel = applyRelTargetRules(newLinkAttrs.rel, newLinkAttrs.target === "_blank");
					newLinkAttrs.rel = newRel ? newRel : null;
				}
				if (Optional.from(newLinkAttrs.target).isNone() && getTargetList(editor) === false) newLinkAttrs.target = getDefaultLinkTarget(editor);
				newLinkAttrs.href = handleExternalTargets(newLinkAttrs.href, assumeExternalTargets(editor));
				return newLinkAttrs;
			};
			const updateLink = (editor, anchorElm, text, linkAttrs) => {
				text.each((text$1) => {
					if (has(anchorElm, "innerText")) anchorElm.innerText = text$1;
					else anchorElm.textContent = text$1;
				});
				editor.dom.setAttribs(anchorElm, linkAttrs);
				editor.selection.select(anchorElm);
			};
			const createLink = (editor, selectedElm, text, linkAttrs) => {
				const dom = editor.dom;
				if (isImageFigure(selectedElm)) linkImageFigure(dom, selectedElm, linkAttrs);
				else text.fold(() => {
					editor.execCommand("mceInsertLink", false, linkAttrs);
				}, (text$1) => {
					editor.insertContent(dom.createHTML("a", linkAttrs, dom.encode(text$1)));
				});
			};
			const linkDomMutation = (editor, attachState, data) => {
				const selectedElm = editor.selection.getNode();
				const anchorElm = getAnchorElement(editor, selectedElm);
				const linkAttrs = applyLinkOverrides(editor, getLinkAttrs(data));
				editor.undoManager.transact(() => {
					if (data.href === attachState.href) attachState.attach();
					anchorElm.fold(() => {
						createLink(editor, selectedElm, data.text, linkAttrs);
					}, (elm) => {
						editor.focus();
						updateLink(editor, elm, data.text, linkAttrs);
					});
				});
			};
			const unlinkSelection = (editor) => {
				const dom = editor.dom, selection = editor.selection;
				const bookmark = selection.getBookmark();
				const rng = selection.getRng().cloneRange();
				const startAnchorElm = dom.getParent(rng.startContainer, "a[href]", editor.getBody());
				const endAnchorElm = dom.getParent(rng.endContainer, "a[href]", editor.getBody());
				if (startAnchorElm) rng.setStartBefore(startAnchorElm);
				if (endAnchorElm) rng.setEndAfter(endAnchorElm);
				selection.setRng(rng);
				editor.execCommand("unlink");
				selection.moveToBookmark(bookmark);
			};
			const unlinkDomMutation = (editor) => {
				editor.undoManager.transact(() => {
					const node = editor.selection.getNode();
					if (isImageFigure(node)) unlinkImageFigure(editor, node);
					else unlinkSelection(editor);
					editor.focus();
				});
			};
			const unwrapOptions = (data) => {
				const { class: cls, href, rel, target, text, title } = data;
				return filter({
					class: cls.getOrNull(),
					href,
					rel: rel.getOrNull(),
					target: target.getOrNull(),
					text: text.getOrNull(),
					title: title.getOrNull()
				}, (v, _k) => isNull(v) === false);
			};
			const sanitizeData = (editor, data) => {
				const getOption = editor.options.get;
				const uriOptions = {
					allow_html_data_urls: getOption("allow_html_data_urls"),
					allow_script_urls: getOption("allow_script_urls"),
					allow_svg_data_urls: getOption("allow_svg_data_urls")
				};
				const href = data.href;
				return {
					...data,
					href: global$2.isDomSafe(href, "a", uriOptions) ? href : ""
				};
			};
			const link = (editor, attachState, data) => {
				const sanitizedData = sanitizeData(editor, data);
				editor.hasPlugin("rtc", true) ? editor.execCommand("createlink", false, unwrapOptions(sanitizedData)) : linkDomMutation(editor, attachState, sanitizedData);
			};
			const unlink = (editor) => {
				editor.hasPlugin("rtc", true) ? editor.execCommand("unlink") : unlinkDomMutation(editor);
			};
			const unlinkImageFigure = (editor, fig) => {
				var _a;
				const img = editor.dom.select("img", fig)[0];
				if (img) {
					const a = editor.dom.getParents(img, "a[href]", fig)[0];
					if (a) {
						(_a = a.parentNode) === null || _a === void 0 || _a.insertBefore(img, a);
						editor.dom.remove(a);
					}
				}
			};
			const linkImageFigure = (dom, fig, attrs) => {
				var _a;
				const img = dom.select("img", fig)[0];
				if (img) {
					const a = dom.create("a", attrs);
					(_a = img.parentNode) === null || _a === void 0 || _a.insertBefore(a, img);
					a.appendChild(img);
				}
			};
			const isListGroup = (item) => hasNonNullableKey(item, "items");
			const findTextByValue = (value, catalog) => findMap(catalog, (item) => {
				if (isListGroup(item)) return findTextByValue(value, item.items);
				else return someIf(item.value === value, item);
			});
			const getDelta = (persistentText, fieldName, catalog, data) => {
				const value = data[fieldName];
				const hasPersistentText = persistentText.length > 0;
				return value !== void 0 ? findTextByValue(value, catalog).map((i) => ({
					url: {
						value: i.value,
						meta: {
							text: hasPersistentText ? persistentText : i.text,
							attach: noop
						}
					},
					text: hasPersistentText ? persistentText : i.text
				})) : Optional.none();
			};
			const findCatalog = (catalogs, fieldName) => {
				if (fieldName === "link") return catalogs.link;
				else if (fieldName === "anchor") return catalogs.anchor;
				else return Optional.none();
			};
			const init = (initialData, linkCatalog) => {
				const persistentData = {
					text: initialData.text,
					title: initialData.title
				};
				const getTitleFromUrlChange = (url) => {
					var _a;
					return someIf(persistentData.title.length <= 0, Optional.from((_a = url.meta) === null || _a === void 0 ? void 0 : _a.title).getOr(""));
				};
				const getTextFromUrlChange = (url) => {
					var _a;
					return someIf(persistentData.text.length <= 0, Optional.from((_a = url.meta) === null || _a === void 0 ? void 0 : _a.text).getOr(url.value));
				};
				const onUrlChange = (data) => {
					const text = getTextFromUrlChange(data.url);
					const title = getTitleFromUrlChange(data.url);
					if (text.isSome() || title.isSome()) return Optional.some({
						...text.map((text$1) => ({ text: text$1 })).getOr({}),
						...title.map((title$1) => ({ title: title$1 })).getOr({})
					});
					else return Optional.none();
				};
				const onCatalogChange = (data, change) => {
					const catalog = findCatalog(linkCatalog, change).getOr([]);
					return getDelta(persistentData.text, change, catalog, data);
				};
				const onChange = (getData, change) => {
					const name = change.name;
					if (name === "url") return onUrlChange(getData());
					else if (contains(["anchor", "link"], name)) return onCatalogChange(getData(), name);
					else if (name === "text" || name === "title") {
						persistentData[name] = getData()[name];
						return Optional.none();
					} else return Optional.none();
				};
				return { onChange };
			};
			const DialogChanges = {
				init,
				getDelta
			};
			var global$1 = tinymce.util.Tools.resolve("tinymce.util.Delay");
			const delayedConfirm = (editor, message, callback) => {
				const rng = editor.selection.getRng();
				global$1.setEditorTimeout(editor, () => {
					editor.windowManager.confirm(message, (state) => {
						editor.selection.setRng(rng);
						callback(state);
					});
				});
			};
			const tryEmailTransform = (data) => {
				const url = data.href;
				return url.indexOf("@") > 0 && url.indexOf("/") === -1 && url.indexOf("mailto:") === -1 ? Optional.some({
					message: "The URL you entered seems to be an email address. Do you want to add the required mailto: prefix?",
					preprocess: (oldData) => ({
						...oldData,
						href: "mailto:" + url
					})
				}) : Optional.none();
			};
			const tryProtocolTransform = (assumeExternalTargets$1, defaultLinkProtocol) => (data) => {
				const url = data.href;
				return assumeExternalTargets$1 === 1 && !hasProtocol(url) || assumeExternalTargets$1 === 0 && /^\s*www(\.|\d\.)/i.test(url) ? Optional.some({
					message: `The URL you entered seems to be an external link. Do you want to add the required ${defaultLinkProtocol}:// prefix?`,
					preprocess: (oldData) => ({
						...oldData,
						href: defaultLinkProtocol + "://" + url
					})
				}) : Optional.none();
			};
			const preprocess = (editor, data) => findMap([tryEmailTransform, tryProtocolTransform(assumeExternalTargets(editor), getDefaultLinkProtocol(editor))], (f) => f(data)).fold(() => Promise.resolve(data), (transform) => new Promise((callback) => {
				delayedConfirm(editor, transform.message, (state) => {
					callback(state ? transform.preprocess(data) : data);
				});
			}));
			const DialogConfirms = { preprocess };
			const getAnchors = (editor) => {
				const anchors = bind(editor.dom.select("a:not([href])"), (anchor) => {
					const id = anchor.name || anchor.id;
					return id ? [{
						text: id,
						value: "#" + id
					}] : [];
				});
				return anchors.length > 0 ? Optional.some([{
					text: "None",
					value: ""
				}].concat(anchors)) : Optional.none();
			};
			const AnchorListOptions = { getAnchors };
			const getClasses = (editor) => {
				const list = getLinkClassList(editor);
				if (list.length > 0) return ListOptions.sanitize(list);
				return Optional.none();
			};
			const ClassListOptions = { getClasses };
			const parseJson = (text) => {
				try {
					return Optional.some(JSON.parse(text));
				} catch (err) {
					return Optional.none();
				}
			};
			const getLinks = (editor) => {
				const extractor = (item) => editor.convertURL(item.value || item.url || "", "href");
				const linkList = getLinkList(editor);
				return new Promise((resolve) => {
					if (isString(linkList)) fetch(linkList).then((res) => res.ok ? res.text().then(parseJson) : Promise.reject()).then(resolve, () => resolve(Optional.none()));
					else if (isFunction(linkList)) linkList((output) => resolve(Optional.some(output)));
					else resolve(Optional.from(linkList));
				}).then((optItems) => optItems.bind(ListOptions.sanitizeWith(extractor)).map((items) => {
					if (items.length > 0) return [{
						text: "None",
						value: ""
					}].concat(items);
					else return items;
				}));
			};
			const LinkListOptions = { getLinks };
			const getRels = (editor, initialTarget) => {
				const list = getRelList(editor);
				if (list.length > 0) {
					const isTargetBlank = is(initialTarget, "_blank");
					const enforceSafe = allowUnsafeLinkTarget(editor) === false;
					const safeRelExtractor = (item) => applyRelTargetRules(ListOptions.getValue(item), isTargetBlank);
					return (enforceSafe ? ListOptions.sanitizeWith(safeRelExtractor) : ListOptions.sanitize)(list);
				}
				return Optional.none();
			};
			const RelOptions = { getRels };
			const fallbacks = [{
				text: "Current window",
				value: ""
			}, {
				text: "New window",
				value: "_blank"
			}];
			const getTargets = (editor) => {
				const list = getTargetList(editor);
				if (isArray(list)) return ListOptions.sanitize(list).orThunk(() => Optional.some(fallbacks));
				else if (list === false) return Optional.none();
				return Optional.some(fallbacks);
			};
			const TargetOptions = { getTargets };
			const nonEmptyAttr = (dom, elem, name) => {
				const val = dom.getAttrib(elem, name);
				return val !== null && val.length > 0 ? Optional.some(val) : Optional.none();
			};
			const extractFromAnchor = (editor, anchor) => {
				const dom = editor.dom;
				const text = isOnlyTextSelected(editor) ? Optional.some(getAnchorText(editor.selection, anchor)) : Optional.none();
				const url = anchor.bind((anchorElm) => Optional.from(dom.getAttrib(anchorElm, "href")));
				const target = anchor.bind((anchorElm) => Optional.from(dom.getAttrib(anchorElm, "target")));
				const rel = anchor.bind((anchorElm) => nonEmptyAttr(dom, anchorElm, "rel"));
				const linkClass = anchor.bind((anchorElm) => nonEmptyAttr(dom, anchorElm, "class"));
				return {
					url,
					text,
					title: anchor.bind((anchorElm) => nonEmptyAttr(dom, anchorElm, "title")),
					target,
					rel,
					linkClass
				};
			};
			const collect = (editor, linkNode) => LinkListOptions.getLinks(editor).then((links) => {
				const anchor = extractFromAnchor(editor, linkNode);
				return {
					anchor,
					catalogs: {
						targets: TargetOptions.getTargets(editor),
						rels: RelOptions.getRels(editor, anchor.target),
						classes: ClassListOptions.getClasses(editor),
						anchor: AnchorListOptions.getAnchors(editor),
						link: links
					},
					optNode: linkNode,
					flags: { titleEnabled: shouldShowLinkTitle(editor) }
				};
			});
			const DialogInfo = { collect };
			const handleSubmit = (editor, info) => (api) => {
				const data = api.getData();
				if (!data.url.value) {
					unlink(editor);
					api.close();
					return;
				}
				const getChangedValue = (key) => Optional.from(data[key]).filter((value) => !is(info.anchor[key], value));
				const changedData = {
					href: data.url.value,
					text: getChangedValue("text"),
					target: getChangedValue("target"),
					rel: getChangedValue("rel"),
					class: getChangedValue("linkClass"),
					title: getChangedValue("title")
				};
				const attachState = {
					href: data.url.value,
					attach: data.url.meta !== void 0 && data.url.meta.attach ? data.url.meta.attach : noop
				};
				DialogConfirms.preprocess(editor, changedData).then((pData) => {
					link(editor, attachState, pData);
				});
				api.close();
			};
			const collectData = (editor) => {
				const anchorNode = getAnchorElement(editor);
				return DialogInfo.collect(editor, anchorNode);
			};
			const getInitialData = (info, defaultTarget) => {
				const anchor = info.anchor;
				const url = anchor.url.getOr("");
				return {
					url: {
						value: url,
						meta: { original: { value: url } }
					},
					text: anchor.text.getOr(""),
					title: anchor.title.getOr(""),
					anchor: url,
					link: url,
					rel: anchor.rel.getOr(""),
					target: anchor.target.or(defaultTarget).getOr(""),
					linkClass: anchor.linkClass.getOr("")
				};
			};
			const makeDialog = (settings, onSubmit, editor) => {
				const urlInput = [{
					name: "url",
					type: "urlinput",
					filetype: "file",
					label: "URL"
				}];
				const displayText = settings.anchor.text.map(() => ({
					name: "text",
					type: "input",
					label: "Text to display"
				})).toArray();
				const titleText = settings.flags.titleEnabled ? [{
					name: "title",
					type: "input",
					label: "Title"
				}] : [];
				const initialData = getInitialData(settings, Optional.from(getDefaultLinkTarget(editor)));
				const catalogs = settings.catalogs;
				const dialogDelta = DialogChanges.init(initialData, catalogs);
				return {
					title: "Insert/Edit Link",
					size: "normal",
					body: {
						type: "panel",
						items: flatten([
							urlInput,
							displayText,
							titleText,
							cat([
								catalogs.anchor.map(ListOptions.createUi("anchor", "Anchors")),
								catalogs.rels.map(ListOptions.createUi("rel", "Rel")),
								catalogs.targets.map(ListOptions.createUi("target", "Open link in...")),
								catalogs.link.map(ListOptions.createUi("link", "Link list")),
								catalogs.classes.map(ListOptions.createUi("linkClass", "Class"))
							])
						])
					},
					buttons: [{
						type: "cancel",
						name: "cancel",
						text: "Cancel"
					}, {
						type: "submit",
						name: "save",
						text: "Save",
						primary: true
					}],
					initialData,
					onChange: (api, { name }) => {
						dialogDelta.onChange(api.getData, { name }).each((newData) => {
							api.setData(newData);
						});
					},
					onSubmit
				};
			};
			const open$1 = (editor) => {
				collectData(editor).then((info) => {
					return makeDialog(info, handleSubmit(editor, info), editor);
				}).then((spec) => {
					editor.windowManager.open(spec);
				});
			};
			const register = (editor) => {
				editor.addCommand("mceLink", (_ui, value) => {
					if ((value === null || value === void 0 ? void 0 : value.dialog) === true || !useQuickLink(editor)) open$1(editor);
					else editor.dispatch("contexttoolbar-show", { toolbarKey: "quicklink" });
				});
			};
			var global = tinymce.util.Tools.resolve("tinymce.util.VK");
			const appendClickRemove = (link$1, evt) => {
				document.body.appendChild(link$1);
				link$1.dispatchEvent(evt);
				document.body.removeChild(link$1);
			};
			const open = (url) => {
				const link$1 = document.createElement("a");
				link$1.target = "_blank";
				link$1.href = url;
				link$1.rel = "noreferrer noopener";
				const evt = document.createEvent("MouseEvents");
				evt.initMouseEvent("click", true, true, window, 0, 0, 0, 0, 0, false, false, false, false, 0, null);
				appendClickRemove(link$1, evt);
			};
			const getLink = (editor, elm) => editor.dom.getParent(elm, "a[href]");
			const getSelectedLink = (editor) => getLink(editor, editor.selection.getStart());
			const hasOnlyAltModifier = (e) => {
				return e.altKey === true && e.shiftKey === false && e.ctrlKey === false && e.metaKey === false;
			};
			const gotoLink = (editor, a) => {
				if (a) {
					const href = getHref(a);
					if (/^#/.test(href)) {
						const targetEl = editor.dom.select(href);
						if (targetEl.length) editor.selection.scrollIntoView(targetEl[0], true);
					} else open(a.href);
				}
			};
			const openDialog = (editor) => () => {
				editor.execCommand("mceLink", false, { dialog: true });
			};
			const gotoSelectedLink = (editor) => () => {
				gotoLink(editor, getSelectedLink(editor));
			};
			const setupGotoLinks = (editor) => {
				editor.on("click", (e) => {
					const link$1 = getLink(editor, e.target);
					if (link$1 && global.metaKeyPressed(e)) {
						e.preventDefault();
						gotoLink(editor, link$1);
					}
				});
				editor.on("keydown", (e) => {
					if (!e.isDefaultPrevented() && e.keyCode === 13 && hasOnlyAltModifier(e)) {
						const link$1 = getSelectedLink(editor);
						if (link$1) {
							e.preventDefault();
							gotoLink(editor, link$1);
						}
					}
				});
			};
			const toggleState = (editor, toggler) => {
				editor.on("NodeChange", toggler);
				return () => editor.off("NodeChange", toggler);
			};
			const toggleLinkState = (editor) => (api) => {
				const updateState = () => {
					api.setActive(!editor.mode.isReadOnly() && isInAnchor(editor, editor.selection.getNode()));
					api.setEnabled(editor.selection.isEditable());
				};
				updateState();
				return toggleState(editor, updateState);
			};
			const toggleLinkMenuState = (editor) => (api) => {
				const updateState = () => {
					api.setEnabled(editor.selection.isEditable());
				};
				updateState();
				return toggleState(editor, updateState);
			};
			const hasExactlyOneLinkInSelection = (editor) => {
				return (editor.selection.isCollapsed() ? getLinks$1(editor.dom.getParents(editor.selection.getStart())) : getLinksInSelection(editor.selection.getRng())).length === 1;
			};
			const toggleGotoLinkState = (editor) => (api) => {
				const updateState = () => api.setEnabled(hasExactlyOneLinkInSelection(editor));
				updateState();
				return toggleState(editor, updateState);
			};
			const toggleUnlinkState = (editor) => (api) => {
				const hasLinks$1 = (parents$1) => hasLinks(parents$1) || hasLinksInSelection(editor.selection.getRng());
				const parents = editor.dom.getParents(editor.selection.getStart());
				const updateEnabled = (parents$1) => {
					api.setEnabled(hasLinks$1(parents$1) && editor.selection.isEditable());
				};
				updateEnabled(parents);
				return toggleState(editor, (e) => updateEnabled(e.parents));
			};
			const setup = (editor) => {
				editor.addShortcut("Meta+K", "", () => {
					editor.execCommand("mceLink");
				});
			};
			const setupButtons = (editor) => {
				editor.ui.registry.addToggleButton("link", {
					icon: "link",
					tooltip: "Insert/edit link",
					onAction: openDialog(editor),
					onSetup: toggleLinkState(editor)
				});
				editor.ui.registry.addButton("openlink", {
					icon: "new-tab",
					tooltip: "Open link",
					onAction: gotoSelectedLink(editor),
					onSetup: toggleGotoLinkState(editor)
				});
				editor.ui.registry.addButton("unlink", {
					icon: "unlink",
					tooltip: "Remove link",
					onAction: () => unlink(editor),
					onSetup: toggleUnlinkState(editor)
				});
			};
			const setupMenuItems = (editor) => {
				editor.ui.registry.addMenuItem("openlink", {
					text: "Open link",
					icon: "new-tab",
					onAction: gotoSelectedLink(editor),
					onSetup: toggleGotoLinkState(editor)
				});
				editor.ui.registry.addMenuItem("link", {
					icon: "link",
					text: "Link...",
					shortcut: "Meta+K",
					onSetup: toggleLinkMenuState(editor),
					onAction: openDialog(editor)
				});
				editor.ui.registry.addMenuItem("unlink", {
					icon: "unlink",
					text: "Remove link",
					onAction: () => unlink(editor),
					onSetup: toggleUnlinkState(editor)
				});
			};
			const setupContextMenu = (editor) => {
				const inLink = "link unlink openlink";
				const noLink = "link";
				editor.ui.registry.addContextMenu("link", { update: (element) => {
					if (!editor.dom.isEditable(element)) return "";
					return hasLinks(editor.dom.getParents(element, "a")) ? inLink : noLink;
				} });
			};
			const setupContextToolbars = (editor) => {
				const collapseSelectionToEnd = (editor$1) => {
					editor$1.selection.collapse(false);
				};
				const onSetupLink = (buttonApi) => {
					const node = editor.selection.getNode();
					buttonApi.setEnabled(isInAnchor(editor, node));
					return noop;
				};
				const getLinkText = (value) => {
					const anchor = getAnchorElement(editor);
					const onlyText = isOnlyTextSelected(editor);
					if (anchor.isNone() && onlyText) return someIf(getAnchorText(editor.selection, anchor).length === 0, value);
					else return Optional.none();
				};
				editor.ui.registry.addContextForm("quicklink", {
					launch: {
						type: "contextformtogglebutton",
						icon: "link",
						tooltip: "Link",
						onSetup: toggleLinkState(editor)
					},
					label: "Link",
					predicate: (node) => hasContextToolbar(editor) && isInAnchor(editor, node),
					initValue: () => {
						return getAnchorElement(editor).fold(constant(""), getHref);
					},
					commands: [
						{
							type: "contextformtogglebutton",
							icon: "link",
							tooltip: "Link",
							primary: true,
							onSetup: (buttonApi) => {
								const node = editor.selection.getNode();
								buttonApi.setActive(isInAnchor(editor, node));
								return toggleLinkState(editor)(buttonApi);
							},
							onAction: (formApi) => {
								const value = formApi.getValue();
								const text = getLinkText(value);
								link(editor, {
									href: value,
									attach: noop
								}, {
									href: value,
									text,
									title: Optional.none(),
									rel: Optional.none(),
									target: Optional.none(),
									class: Optional.none()
								});
								collapseSelectionToEnd(editor);
								formApi.hide();
							}
						},
						{
							type: "contextformbutton",
							icon: "unlink",
							tooltip: "Remove link",
							onSetup: onSetupLink,
							onAction: (formApi) => {
								unlink(editor);
								formApi.hide();
							}
						},
						{
							type: "contextformbutton",
							icon: "new-tab",
							tooltip: "Open link",
							onSetup: onSetupLink,
							onAction: (formApi) => {
								gotoSelectedLink(editor)();
								formApi.hide();
							}
						}
					]
				});
			};
			var Plugin = () => {
				global$5.add("link", (editor) => {
					register$1(editor);
					setupButtons(editor);
					setupMenuItems(editor);
					setupContextMenu(editor);
					setupContextToolbars(editor);
					setupGotoLinks(editor);
					register(editor);
					setup(editor);
				});
			};
			Plugin();
		})();
	}));

//#endregion
//#region node_modules/tinymce/plugins/link/index.js
	require_plugin$2();

//#endregion
//#region node_modules/tinymce/plugins/lists/plugin.js
	var require_plugin$1 = /* @__PURE__ */ __commonJSMin((() => {
		/**
		* TinyMCE version 6.7.0 (2023-08-30)
		*/
		(function() {
			"use strict";
			var global$7 = tinymce.util.Tools.resolve("tinymce.PluginManager");
			const hasProto = (v, constructor, predicate) => {
				var _a;
				if (predicate(v, constructor.prototype)) return true;
				else return ((_a = v.constructor) === null || _a === void 0 ? void 0 : _a.name) === constructor.name;
			};
			const typeOf = (x) => {
				const t = typeof x;
				if (x === null) return "null";
				else if (t === "object" && Array.isArray(x)) return "array";
				else if (t === "object" && hasProto(x, String, (o, proto) => proto.isPrototypeOf(o))) return "string";
				else return t;
			};
			const isType$1 = (type$1) => (value) => typeOf(value) === type$1;
			const isSimpleType = (type$1) => (value) => typeof value === type$1;
			const isString = isType$1("string");
			const isObject = isType$1("object");
			const isArray = isType$1("array");
			const isBoolean = isSimpleType("boolean");
			const isNullable = (a) => a === null || a === void 0;
			const isNonNullable = (a) => !isNullable(a);
			const isFunction = isSimpleType("function");
			const isNumber = isSimpleType("number");
			const noop = () => {};
			const constant = (value) => {
				return () => {
					return value;
				};
			};
			const tripleEquals = (a, b) => {
				return a === b;
			};
			function curry(fn, ...initialArgs) {
				return (...restArgs) => {
					const all = initialArgs.concat(restArgs);
					return fn.apply(null, all);
				};
			}
			const not = (f) => (t) => !f(t);
			const never = constant(false);
			class Optional {
				constructor(tag, value) {
					this.tag = tag;
					this.value = value;
				}
				static some(value) {
					return new Optional(true, value);
				}
				static none() {
					return Optional.singletonNone;
				}
				fold(onNone, onSome) {
					if (this.tag) return onSome(this.value);
					else return onNone();
				}
				isSome() {
					return this.tag;
				}
				isNone() {
					return !this.tag;
				}
				map(mapper) {
					if (this.tag) return Optional.some(mapper(this.value));
					else return Optional.none();
				}
				bind(binder) {
					if (this.tag) return binder(this.value);
					else return Optional.none();
				}
				exists(predicate) {
					return this.tag && predicate(this.value);
				}
				forall(predicate) {
					return !this.tag || predicate(this.value);
				}
				filter(predicate) {
					if (!this.tag || predicate(this.value)) return this;
					else return Optional.none();
				}
				getOr(replacement) {
					return this.tag ? this.value : replacement;
				}
				or(replacement) {
					return this.tag ? this : replacement;
				}
				getOrThunk(thunk) {
					return this.tag ? this.value : thunk();
				}
				orThunk(thunk) {
					return this.tag ? this : thunk();
				}
				getOrDie(message) {
					if (!this.tag) throw new Error(message !== null && message !== void 0 ? message : "Called getOrDie on None");
					else return this.value;
				}
				static from(value) {
					return isNonNullable(value) ? Optional.some(value) : Optional.none();
				}
				getOrNull() {
					return this.tag ? this.value : null;
				}
				getOrUndefined() {
					return this.value;
				}
				each(worker) {
					if (this.tag) worker(this.value);
				}
				toArray() {
					return this.tag ? [this.value] : [];
				}
				toString() {
					return this.tag ? `some(${this.value})` : "none()";
				}
			}
			Optional.singletonNone = new Optional(false);
			const nativeSlice = Array.prototype.slice;
			const nativeIndexOf = Array.prototype.indexOf;
			const nativePush = Array.prototype.push;
			const rawIndexOf = (ts, t) => nativeIndexOf.call(ts, t);
			const contains$1 = (xs, x) => rawIndexOf(xs, x) > -1;
			const exists = (xs, pred) => {
				for (let i = 0, len = xs.length; i < len; i++) {
					const x = xs[i];
					if (pred(x, i)) return true;
				}
				return false;
			};
			const map = (xs, f) => {
				const len = xs.length;
				const r = new Array(len);
				for (let i = 0; i < len; i++) {
					const x = xs[i];
					r[i] = f(x, i);
				}
				return r;
			};
			const each$1 = (xs, f) => {
				for (let i = 0, len = xs.length; i < len; i++) {
					const x = xs[i];
					f(x, i);
				}
			};
			const filter$1 = (xs, pred) => {
				const r = [];
				for (let i = 0, len = xs.length; i < len; i++) {
					const x = xs[i];
					if (pred(x, i)) r.push(x);
				}
				return r;
			};
			const groupBy = (xs, f) => {
				if (xs.length === 0) return [];
				else {
					let wasType = f(xs[0]);
					const r = [];
					let group = [];
					for (let i = 0, len = xs.length; i < len; i++) {
						const x = xs[i];
						const type$1 = f(x);
						if (type$1 !== wasType) {
							r.push(group);
							group = [];
						}
						wasType = type$1;
						group.push(x);
					}
					if (group.length !== 0) r.push(group);
					return r;
				}
			};
			const foldl = (xs, f, acc) => {
				each$1(xs, (x, i) => {
					acc = f(acc, x, i);
				});
				return acc;
			};
			const findUntil = (xs, pred, until) => {
				for (let i = 0, len = xs.length; i < len; i++) {
					const x = xs[i];
					if (pred(x, i)) return Optional.some(x);
					else if (until(x, i)) break;
				}
				return Optional.none();
			};
			const find = (xs, pred) => {
				return findUntil(xs, pred, never);
			};
			const flatten = (xs) => {
				const r = [];
				for (let i = 0, len = xs.length; i < len; ++i) {
					if (!isArray(xs[i])) throw new Error("Arr.flatten item " + i + " was not an array, input: " + xs);
					nativePush.apply(r, xs[i]);
				}
				return r;
			};
			const bind = (xs, f) => flatten(map(xs, f));
			const reverse = (xs) => {
				const r = nativeSlice.call(xs, 0);
				r.reverse();
				return r;
			};
			const get$1 = (xs, i) => i >= 0 && i < xs.length ? Optional.some(xs[i]) : Optional.none();
			const head = (xs) => get$1(xs, 0);
			const last = (xs) => get$1(xs, xs.length - 1);
			const unique = (xs, comparator) => {
				const r = [];
				const isDuplicated = isFunction(comparator) ? (x) => exists(r, (i) => comparator(i, x)) : (x) => contains$1(r, x);
				for (let i = 0, len = xs.length; i < len; i++) {
					const x = xs[i];
					if (!isDuplicated(x)) r.push(x);
				}
				return r;
			};
			const is$2 = (lhs, rhs, comparator = tripleEquals) => lhs.exists((left) => comparator(left, rhs));
			const equals = (lhs, rhs, comparator = tripleEquals) => lift2(lhs, rhs, comparator).getOr(lhs.isNone() && rhs.isNone());
			const lift2 = (oa, ob, f) => oa.isSome() && ob.isSome() ? Optional.some(f(oa.getOrDie(), ob.getOrDie())) : Optional.none();
			const ELEMENT = 1;
			const fromHtml = (html, scope) => {
				const div = (scope || document).createElement("div");
				div.innerHTML = html;
				if (!div.hasChildNodes() || div.childNodes.length > 1) {
					const message = "HTML does not have a single root node";
					console.error(message, html);
					throw new Error(message);
				}
				return fromDom$1(div.childNodes[0]);
			};
			const fromTag = (tag, scope) => {
				return fromDom$1((scope || document).createElement(tag));
			};
			const fromText = (text, scope) => {
				return fromDom$1((scope || document).createTextNode(text));
			};
			const fromDom$1 = (node) => {
				if (node === null || node === void 0) throw new Error("Node cannot be null or undefined");
				return { dom: node };
			};
			const fromPoint = (docElm, x, y) => Optional.from(docElm.dom.elementFromPoint(x, y)).map(fromDom$1);
			const SugarElement = {
				fromHtml,
				fromTag,
				fromText,
				fromDom: fromDom$1,
				fromPoint
			};
			const is$1 = (element, selector) => {
				const dom = element.dom;
				if (dom.nodeType !== ELEMENT) return false;
				else {
					const elem = dom;
					if (elem.matches !== void 0) return elem.matches(selector);
					else if (elem.msMatchesSelector !== void 0) return elem.msMatchesSelector(selector);
					else if (elem.webkitMatchesSelector !== void 0) return elem.webkitMatchesSelector(selector);
					else if (elem.mozMatchesSelector !== void 0) return elem.mozMatchesSelector(selector);
					else throw new Error("Browser lacks native selectors");
				}
			};
			const eq = (e1, e2) => e1.dom === e2.dom;
			const contains = (e1, e2) => {
				const d1 = e1.dom;
				const d2 = e2.dom;
				return d1 === d2 ? false : d1.contains(d2);
			};
			const is = is$1;
			var ClosestOrAncestor = (is$3, ancestor$3, scope, a, isRoot) => {
				if (is$3(scope, a)) return Optional.some(scope);
				else if (isFunction(isRoot) && isRoot(scope)) return Optional.none();
				else return ancestor$3(scope, a, isRoot);
			};
			typeof window !== "undefined" ? window : Function("return this;")();
			const name = (element) => {
				return element.dom.nodeName.toLowerCase();
			};
			const type = (element) => element.dom.nodeType;
			const isType = (t) => (element) => type(element) === t;
			const isElement$1 = isType(ELEMENT);
			const isTag = (tag) => (e) => isElement$1(e) && name(e) === tag;
			const parent = (element) => Optional.from(element.dom.parentNode).map(SugarElement.fromDom);
			const parentElement = (element) => Optional.from(element.dom.parentElement).map(SugarElement.fromDom);
			const nextSibling = (element) => Optional.from(element.dom.nextSibling).map(SugarElement.fromDom);
			const children = (element) => map(element.dom.childNodes, SugarElement.fromDom);
			const child = (element, index) => {
				const cs = element.dom.childNodes;
				return Optional.from(cs[index]).map(SugarElement.fromDom);
			};
			const firstChild = (element) => child(element, 0);
			const lastChild = (element) => child(element, element.dom.childNodes.length - 1);
			const ancestor$2 = (scope, predicate, isRoot) => {
				let element = scope.dom;
				const stop = isFunction(isRoot) ? isRoot : never;
				while (element.parentNode) {
					element = element.parentNode;
					const el = SugarElement.fromDom(element);
					if (predicate(el)) return Optional.some(el);
					else if (stop(el)) break;
				}
				return Optional.none();
			};
			const closest = (scope, predicate, isRoot) => {
				const is$3 = (s, test) => test(s);
				return ClosestOrAncestor(is$3, ancestor$2, scope, predicate, isRoot);
			};
			const before$1 = (marker, element) => {
				parent(marker).each((v) => {
					v.dom.insertBefore(element.dom, marker.dom);
				});
			};
			const after = (marker, element) => {
				nextSibling(marker).fold(() => {
					parent(marker).each((v) => {
						append$1(v, element);
					});
				}, (v) => {
					before$1(v, element);
				});
			};
			const append$1 = (parent$1, element) => {
				parent$1.dom.appendChild(element.dom);
			};
			const before = (marker, elements) => {
				each$1(elements, (x) => {
					before$1(marker, x);
				});
			};
			const append = (parent$1, elements) => {
				each$1(elements, (x) => {
					append$1(parent$1, x);
				});
			};
			const empty = (element) => {
				element.dom.textContent = "";
				each$1(children(element), (rogue) => {
					remove(rogue);
				});
			};
			const remove = (element) => {
				const dom = element.dom;
				if (dom.parentNode !== null) dom.parentNode.removeChild(dom);
			};
			var global$6 = tinymce.util.Tools.resolve("tinymce.dom.RangeUtils");
			var global$5 = tinymce.util.Tools.resolve("tinymce.dom.TreeWalker");
			var global$4 = tinymce.util.Tools.resolve("tinymce.util.VK");
			const fromDom = (nodes) => map(nodes, SugarElement.fromDom);
			const keys = Object.keys;
			const each = (obj, f) => {
				const props = keys(obj);
				for (let k = 0, len = props.length; k < len; k++) {
					const i = props[k];
					const x = obj[i];
					f(x, i);
				}
			};
			const objAcc = (r) => (x, i) => {
				r[i] = x;
			};
			const internalFilter = (obj, pred, onTrue, onFalse) => {
				each(obj, (x, i) => {
					(pred(x, i) ? onTrue : onFalse)(x, i);
				});
			};
			const filter = (obj, pred) => {
				const t = {};
				internalFilter(obj, pred, objAcc(t), noop);
				return t;
			};
			const rawSet = (dom, key, value) => {
				if (isString(value) || isBoolean(value) || isNumber(value)) dom.setAttribute(key, value + "");
				else {
					console.error("Invalid call to Attribute.set. Key ", key, ":: Value ", value, ":: Element ", dom);
					throw new Error("Attribute value was not simple");
				}
			};
			const setAll = (element, attrs) => {
				const dom = element.dom;
				each(attrs, (v, k) => {
					rawSet(dom, k, v);
				});
			};
			const clone$1 = (element) => foldl(element.dom.attributes, (acc, attr) => {
				acc[attr.name] = attr.value;
				return acc;
			}, {});
			const clone = (original, isDeep) => SugarElement.fromDom(original.dom.cloneNode(isDeep));
			const deep = (original) => clone(original, true);
			const shallowAs = (original, tag) => {
				const nu = SugarElement.fromTag(tag);
				setAll(nu, clone$1(original));
				return nu;
			};
			const mutate = (original, tag) => {
				const nu = shallowAs(original, tag);
				after(original, nu);
				append(nu, children(original));
				remove(original);
				return nu;
			};
			var global$3 = tinymce.util.Tools.resolve("tinymce.dom.DOMUtils");
			var global$2 = tinymce.util.Tools.resolve("tinymce.util.Tools");
			const matchNodeName = (name$1) => (node) => isNonNullable(node) && node.nodeName.toLowerCase() === name$1;
			const matchNodeNames = (regex) => (node) => isNonNullable(node) && regex.test(node.nodeName);
			const isTextNode$1 = (node) => isNonNullable(node) && node.nodeType === 3;
			const isElement = (node) => isNonNullable(node) && node.nodeType === 1;
			const isListNode = matchNodeNames(/^(OL|UL|DL)$/);
			const isOlUlNode = matchNodeNames(/^(OL|UL)$/);
			const isOlNode = matchNodeName("ol");
			const isListItemNode = matchNodeNames(/^(LI|DT|DD)$/);
			const isDlItemNode = matchNodeNames(/^(DT|DD)$/);
			const isTableCellNode = matchNodeNames(/^(TH|TD)$/);
			const isBr = matchNodeName("br");
			const isFirstChild = (node) => {
				var _a;
				return ((_a = node.parentNode) === null || _a === void 0 ? void 0 : _a.firstChild) === node;
			};
			const isTextBlock = (editor, node) => isNonNullable(node) && node.nodeName in editor.schema.getTextBlockElements();
			const isBlock = (node, blockElements) => isNonNullable(node) && node.nodeName in blockElements;
			const isVoid = (editor, node) => isNonNullable(node) && node.nodeName in editor.schema.getVoidElements();
			const isBogusBr = (dom, node) => {
				if (!isBr(node)) return false;
				return dom.isBlock(node.nextSibling) && !isBr(node.previousSibling);
			};
			const isEmpty$2 = (dom, elm, keepBookmarks) => {
				const empty$1 = dom.isEmpty(elm);
				if (keepBookmarks && dom.select("span[data-mce-type=bookmark]", elm).length > 0) return false;
				return empty$1;
			};
			const isChildOfBody = (dom, elm) => dom.isChildOf(elm, dom.getRoot());
			const option = (name$1) => (editor) => editor.options.get(name$1);
			const register$3 = (editor) => {
				const registerOption = editor.options.register;
				registerOption("lists_indent_on_tab", {
					processor: "boolean",
					default: true
				});
			};
			const shouldIndentOnTab = option("lists_indent_on_tab");
			const getForcedRootBlock = option("forced_root_block");
			const getForcedRootBlockAttrs = option("forced_root_block_attrs");
			const createTextBlock = (editor, contentNode) => {
				const dom = editor.dom;
				const blockElements = editor.schema.getBlockElements();
				const fragment = dom.createFragment();
				const blockName = getForcedRootBlock(editor);
				const blockAttrs = getForcedRootBlockAttrs(editor);
				let node;
				let textBlock;
				let hasContentNode = false;
				textBlock = dom.create(blockName, blockAttrs);
				if (!isBlock(contentNode.firstChild, blockElements)) fragment.appendChild(textBlock);
				while (node = contentNode.firstChild) {
					const nodeName = node.nodeName;
					if (!hasContentNode && (nodeName !== "SPAN" || node.getAttribute("data-mce-type") !== "bookmark")) hasContentNode = true;
					if (isBlock(node, blockElements)) {
						fragment.appendChild(node);
						textBlock = null;
					} else {
						if (!textBlock) {
							textBlock = dom.create(blockName, blockAttrs);
							fragment.appendChild(textBlock);
						}
						textBlock.appendChild(node);
					}
				}
				if (!hasContentNode && textBlock) textBlock.appendChild(dom.create("br", { "data-mce-bogus": "1" }));
				return fragment;
			};
			const DOM$2 = global$3.DOM;
			const splitList = (editor, list, li) => {
				const removeAndKeepBookmarks = (targetNode) => {
					const parent$2 = targetNode.parentNode;
					if (parent$2) global$2.each(bookmarks, (node) => {
						parent$2.insertBefore(node, li.parentNode);
					});
					DOM$2.remove(targetNode);
				};
				const bookmarks = DOM$2.select("span[data-mce-type=\"bookmark\"]", list);
				const newBlock = createTextBlock(editor, li);
				const tmpRng = DOM$2.createRng();
				tmpRng.setStartAfter(li);
				tmpRng.setEndAfter(list);
				const fragment = tmpRng.extractContents();
				for (let node = fragment.firstChild; node; node = node.firstChild) if (node.nodeName === "LI" && editor.dom.isEmpty(node)) {
					DOM$2.remove(node);
					break;
				}
				if (!editor.dom.isEmpty(fragment)) DOM$2.insertAfter(fragment, list);
				DOM$2.insertAfter(newBlock, list);
				const parent$1 = li.parentElement;
				if (parent$1 && isEmpty$2(editor.dom, parent$1)) removeAndKeepBookmarks(parent$1);
				DOM$2.remove(li);
				if (isEmpty$2(editor.dom, list)) DOM$2.remove(list);
			};
			const isDescriptionDetail = isTag("dd");
			const isDescriptionTerm = isTag("dt");
			const outdentDlItem = (editor, item) => {
				if (isDescriptionDetail(item)) mutate(item, "dt");
				else if (isDescriptionTerm(item)) parentElement(item).each((dl) => splitList(editor, dl.dom, item.dom));
			};
			const indentDlItem = (item) => {
				if (isDescriptionTerm(item)) mutate(item, "dd");
			};
			const dlIndentation = (editor, indentation, dlItems) => {
				if (indentation === "Indent") each$1(dlItems, indentDlItem);
				else each$1(dlItems, (item) => outdentDlItem(editor, item));
			};
			const getNormalizedPoint = (container, offset) => {
				if (isTextNode$1(container)) return {
					container,
					offset
				};
				const node = global$6.getNode(container, offset);
				if (isTextNode$1(node)) return {
					container: node,
					offset: offset >= container.childNodes.length ? node.data.length : 0
				};
				else if (node.previousSibling && isTextNode$1(node.previousSibling)) return {
					container: node.previousSibling,
					offset: node.previousSibling.data.length
				};
				else if (node.nextSibling && isTextNode$1(node.nextSibling)) return {
					container: node.nextSibling,
					offset: 0
				};
				return {
					container,
					offset
				};
			};
			const normalizeRange = (rng) => {
				const outRng = rng.cloneRange();
				const rangeStart = getNormalizedPoint(rng.startContainer, rng.startOffset);
				outRng.setStart(rangeStart.container, rangeStart.offset);
				const rangeEnd = getNormalizedPoint(rng.endContainer, rng.endOffset);
				outRng.setEnd(rangeEnd.container, rangeEnd.offset);
				return outRng;
			};
			const listNames = [
				"OL",
				"UL",
				"DL"
			];
			const listSelector = listNames.join(",");
			const getParentList = (editor, node) => {
				const selectionStart = node || editor.selection.getStart(true);
				return editor.dom.getParent(selectionStart, listSelector, getClosestListHost(editor, selectionStart));
			};
			const isParentListSelected = (parentList, selectedBlocks) => isNonNullable(parentList) && selectedBlocks.length === 1 && selectedBlocks[0] === parentList;
			const findSubLists = (parentList) => filter$1(parentList.querySelectorAll(listSelector), isListNode);
			const getSelectedSubLists = (editor) => {
				const parentList = getParentList(editor);
				const selectedBlocks = editor.selection.getSelectedBlocks();
				if (isParentListSelected(parentList, selectedBlocks)) return findSubLists(parentList);
				else return filter$1(selectedBlocks, (elm) => {
					return isListNode(elm) && parentList !== elm;
				});
			};
			const findParentListItemsNodes = (editor, elms) => {
				return unique(global$2.map(elms, (elm) => {
					const parentLi = editor.dom.getParent(elm, "li,dd,dt", getClosestListHost(editor, elm));
					return parentLi ? parentLi : elm;
				}));
			};
			const getSelectedListItems = (editor) => {
				return filter$1(findParentListItemsNodes(editor, editor.selection.getSelectedBlocks()), isListItemNode);
			};
			const getSelectedDlItems = (editor) => filter$1(getSelectedListItems(editor), isDlItemNode);
			const getClosestEditingHost = (editor, elm) => {
				const parentTableCell = editor.dom.getParents(elm, "TD,TH");
				return parentTableCell.length > 0 ? parentTableCell[0] : editor.getBody();
			};
			const isListHost = (schema, node) => !isListNode(node) && !isListItemNode(node) && exists(listNames, (listName) => schema.isValidChild(node.nodeName, listName));
			const getClosestListHost = (editor, elm) => {
				return find(editor.dom.getParents(elm, editor.dom.isBlock), (elm$1) => isListHost(editor.schema, elm$1)).getOr(editor.getBody());
			};
			const findLastParentListNode = (editor, elm) => {
				return last(editor.dom.getParents(elm, "ol,ul", getClosestListHost(editor, elm)));
			};
			const getSelectedLists = (editor) => {
				const firstList = findLastParentListNode(editor, editor.selection.getStart());
				const subsequentLists = filter$1(editor.selection.getSelectedBlocks(), isOlUlNode);
				return firstList.toArray().concat(subsequentLists);
			};
			const getSelectedListRoots = (editor) => {
				return getUniqueListRoots(editor, getSelectedLists(editor));
			};
			const getUniqueListRoots = (editor, lists) => {
				return unique(map(lists, (list) => findLastParentListNode(editor, list).getOr(list)));
			};
			const isCustomList = (list) => /\btox\-/.test(list.className);
			const inList = (parents, listName) => findUntil(parents, isListNode, isTableCellNode).exists((list) => list.nodeName === listName && !isCustomList(list));
			const isWithinNonEditable = (editor, element) => element !== null && !editor.dom.isEditable(element);
			const selectionIsWithinNonEditableList = (editor) => {
				return isWithinNonEditable(editor, getParentList(editor));
			};
			const isWithinNonEditableList = (editor, element) => {
				return isWithinNonEditable(editor, editor.dom.getParent(element, "ol,ul,dl"));
			};
			const setNodeChangeHandler = (editor, nodeChangeHandler) => {
				const initialNode = editor.selection.getNode();
				nodeChangeHandler({
					parents: editor.dom.getParents(initialNode),
					element: initialNode
				});
				editor.on("NodeChange", nodeChangeHandler);
				return () => editor.off("NodeChange", nodeChangeHandler);
			};
			const fromElements = (elements, scope) => {
				const fragment = (scope || document).createDocumentFragment();
				each$1(elements, (element) => {
					fragment.appendChild(element.dom);
				});
				return SugarElement.fromDom(fragment);
			};
			const fireListEvent = (editor, action, element) => editor.dispatch("ListMutation", {
				action,
				element
			});
			const blank = (r) => (s) => s.replace(r, "");
			const trim = blank(/^\s+|\s+$/g);
			const isNotEmpty = (s) => s.length > 0;
			const isEmpty$1 = (s) => !isNotEmpty(s);
			const isSupported = (dom) => dom.style !== void 0 && isFunction(dom.style.getPropertyValue);
			const internalSet = (dom, property, value) => {
				if (!isString(value)) {
					console.error("Invalid call to CSS.set. Property ", property, ":: Value ", value, ":: Element ", dom);
					throw new Error("CSS value must be a string: " + value);
				}
				if (isSupported(dom)) dom.style.setProperty(property, value);
			};
			const set = (element, property, value) => {
				const dom = element.dom;
				internalSet(dom, property, value);
			};
			const joinSegment = (parent$1, child$1) => {
				append$1(parent$1.item, child$1.list);
			};
			const joinSegments = (segments) => {
				for (let i = 1; i < segments.length; i++) joinSegment(segments[i - 1], segments[i]);
			};
			const appendSegments = (head$1, tail) => {
				lift2(last(head$1), head(tail), joinSegment);
			};
			const createSegment = (scope, listType) => {
				const segment = {
					list: SugarElement.fromTag(listType, scope),
					item: SugarElement.fromTag("li", scope)
				};
				append$1(segment.list, segment.item);
				return segment;
			};
			const createSegments = (scope, entry, size) => {
				const segments = [];
				for (let i = 0; i < size; i++) segments.push(createSegment(scope, entry.listType));
				return segments;
			};
			const populateSegments = (segments, entry) => {
				for (let i = 0; i < segments.length - 1; i++) set(segments[i].item, "list-style-type", "none");
				last(segments).each((segment) => {
					setAll(segment.list, entry.listAttributes);
					setAll(segment.item, entry.itemAttributes);
					append(segment.item, entry.content);
				});
			};
			const normalizeSegment = (segment, entry) => {
				if (name(segment.list) !== entry.listType) segment.list = mutate(segment.list, entry.listType);
				setAll(segment.list, entry.listAttributes);
			};
			const createItem = (scope, attr, content) => {
				const item = SugarElement.fromTag("li", scope);
				setAll(item, attr);
				append(item, content);
				return item;
			};
			const appendItem = (segment, item) => {
				append$1(segment.list, item);
				segment.item = item;
			};
			const writeShallow = (scope, cast, entry) => {
				const newCast = cast.slice(0, entry.depth);
				last(newCast).each((segment) => {
					appendItem(segment, createItem(scope, entry.itemAttributes, entry.content));
					normalizeSegment(segment, entry);
				});
				return newCast;
			};
			const writeDeep = (scope, cast, entry) => {
				const segments = createSegments(scope, entry, entry.depth - cast.length);
				joinSegments(segments);
				populateSegments(segments, entry);
				appendSegments(cast, segments);
				return cast.concat(segments);
			};
			const composeList = (scope, entries) => {
				return head(foldl(entries, (cast, entry) => {
					return entry.depth > cast.length ? writeDeep(scope, cast, entry) : writeShallow(scope, cast, entry);
				}, [])).map((segment) => segment.list);
			};
			const isList = (el) => is(el, "OL,UL");
			const hasFirstChildList = (el) => firstChild(el).exists(isList);
			const hasLastChildList = (el) => lastChild(el).exists(isList);
			const isIndented = (entry) => entry.depth > 0;
			const isSelected = (entry) => entry.isSelected;
			const cloneItemContent = (li) => {
				const children$1 = children(li);
				return map(hasLastChildList(li) ? children$1.slice(0, -1) : children$1, deep);
			};
			const createEntry = (li, depth, isSelected$1) => parent(li).filter(isElement$1).map((list) => ({
				depth,
				dirty: false,
				isSelected: isSelected$1,
				content: cloneItemContent(li),
				itemAttributes: clone$1(li),
				listAttributes: clone$1(list),
				listType: name(list)
			}));
			const indentEntry = (indentation, entry) => {
				switch (indentation) {
					case "Indent":
						entry.depth++;
						break;
					case "Outdent":
						entry.depth--;
						break;
					case "Flatten": entry.depth = 0;
				}
				entry.dirty = true;
			};
			const cloneListProperties = (target, source) => {
				target.listType = source.listType;
				target.listAttributes = { ...source.listAttributes };
			};
			const cleanListProperties = (entry) => {
				entry.listAttributes = filter(entry.listAttributes, (_value, key) => key !== "start");
			};
			const closestSiblingEntry = (entries, start) => {
				const depth = entries[start].depth;
				const matches = (entry) => entry.depth === depth && !entry.dirty;
				const until = (entry) => entry.depth < depth;
				return findUntil(reverse(entries.slice(0, start)), matches, until).orThunk(() => findUntil(entries.slice(start + 1), matches, until));
			};
			const normalizeEntries = (entries) => {
				each$1(entries, (entry, i) => {
					closestSiblingEntry(entries, i).fold(() => {
						if (entry.dirty) cleanListProperties(entry);
					}, (matchingEntry) => cloneListProperties(entry, matchingEntry));
				});
				return entries;
			};
			const Cell = (initial) => {
				let value = initial;
				const get$2 = () => {
					return value;
				};
				const set$1 = (v) => {
					value = v;
				};
				return {
					get: get$2,
					set: set$1
				};
			};
			const parseItem = (depth, itemSelection, selectionState, item) => firstChild(item).filter(isList).fold(() => {
				itemSelection.each((selection) => {
					if (eq(selection.start, item)) selectionState.set(true);
				});
				const currentItemEntry = createEntry(item, depth, selectionState.get());
				itemSelection.each((selection) => {
					if (eq(selection.end, item)) selectionState.set(false);
				});
				const childListEntries = lastChild(item).filter(isList).map((list) => parseList(depth, itemSelection, selectionState, list)).getOr([]);
				return currentItemEntry.toArray().concat(childListEntries);
			}, (list) => parseList(depth, itemSelection, selectionState, list));
			const parseList = (depth, itemSelection, selectionState, list) => bind(children(list), (element) => {
				return (isList(element) ? parseList : parseItem)(depth + 1, itemSelection, selectionState, element);
			});
			const parseLists = (lists, itemSelection) => {
				const selectionState = Cell(false);
				const initialDepth = 0;
				return map(lists, (list) => ({
					sourceList: list,
					entries: parseList(initialDepth, itemSelection, selectionState, list)
				}));
			};
			const outdentedComposer = (editor, entries) => {
				return map(normalizeEntries(entries), (entry) => {
					const content = fromElements(entry.content);
					return SugarElement.fromDom(createTextBlock(editor, content.dom));
				});
			};
			const indentedComposer = (editor, entries) => {
				const normalizedEntries = normalizeEntries(entries);
				return composeList(editor.contentDocument, normalizedEntries).toArray();
			};
			const composeEntries = (editor, entries) => bind(groupBy(entries, isIndented), (entries$1) => {
				return head(entries$1).exists(isIndented) ? indentedComposer(editor, entries$1) : outdentedComposer(editor, entries$1);
			});
			const indentSelectedEntries = (entries, indentation) => {
				each$1(filter$1(entries, isSelected), (entry) => indentEntry(indentation, entry));
			};
			const getItemSelection = (editor) => {
				const selectedListItems = map(getSelectedListItems(editor), SugarElement.fromDom);
				return lift2(find(selectedListItems, not(hasFirstChildList)), find(reverse(selectedListItems), not(hasFirstChildList)), (start, end) => ({
					start,
					end
				}));
			};
			const listIndentation = (editor, lists, indentation) => {
				each$1(parseLists(lists, getItemSelection(editor)), (entrySet) => {
					indentSelectedEntries(entrySet.entries, indentation);
					const composedLists = composeEntries(editor, entrySet.entries);
					each$1(composedLists, (composedList) => {
						fireListEvent(editor, indentation === "Indent" ? "IndentList" : "OutdentList", composedList.dom);
					});
					before(entrySet.sourceList, composedLists);
					remove(entrySet.sourceList);
				});
			};
			const selectionIndentation = (editor, indentation) => {
				const lists = fromDom(getSelectedListRoots(editor));
				const dlItems = fromDom(getSelectedDlItems(editor));
				let isHandled = false;
				if (lists.length || dlItems.length) {
					const bookmark = editor.selection.getBookmark();
					listIndentation(editor, lists, indentation);
					dlIndentation(editor, indentation, dlItems);
					editor.selection.moveToBookmark(bookmark);
					editor.selection.setRng(normalizeRange(editor.selection.getRng()));
					editor.nodeChanged();
					isHandled = true;
				}
				return isHandled;
			};
			const handleIndentation = (editor, indentation) => !selectionIsWithinNonEditableList(editor) && selectionIndentation(editor, indentation);
			const indentListSelection = (editor) => handleIndentation(editor, "Indent");
			const outdentListSelection = (editor) => handleIndentation(editor, "Outdent");
			const flattenListSelection = (editor) => handleIndentation(editor, "Flatten");
			const zeroWidth = "";
			const isZwsp = (char) => char === zeroWidth;
			const ancestor$1 = (scope, predicate, isRoot) => ancestor$2(scope, predicate, isRoot).isSome();
			const ancestor = (element, target) => ancestor$1(element, curry(eq, target));
			var global$1 = tinymce.util.Tools.resolve("tinymce.dom.BookmarkManager");
			const DOM$1 = global$3.DOM;
			const createBookmark = (rng) => {
				const bookmark = {};
				const setupEndPoint = (start) => {
					let container = rng[start ? "startContainer" : "endContainer"];
					let offset = rng[start ? "startOffset" : "endOffset"];
					if (isElement(container)) {
						const offsetNode = DOM$1.create("span", { "data-mce-type": "bookmark" });
						if (container.hasChildNodes()) {
							offset = Math.min(offset, container.childNodes.length - 1);
							if (start) container.insertBefore(offsetNode, container.childNodes[offset]);
							else DOM$1.insertAfter(offsetNode, container.childNodes[offset]);
						} else container.appendChild(offsetNode);
						container = offsetNode;
						offset = 0;
					}
					bookmark[start ? "startContainer" : "endContainer"] = container;
					bookmark[start ? "startOffset" : "endOffset"] = offset;
				};
				setupEndPoint(true);
				if (!rng.collapsed) setupEndPoint();
				return bookmark;
			};
			const resolveBookmark = (bookmark) => {
				const restoreEndPoint = (start) => {
					const nodeIndex = (container$1) => {
						var _a;
						let node = (_a = container$1.parentNode) === null || _a === void 0 ? void 0 : _a.firstChild;
						let idx = 0;
						while (node) {
							if (node === container$1) return idx;
							if (!isElement(node) || node.getAttribute("data-mce-type") !== "bookmark") idx++;
							node = node.nextSibling;
						}
						return -1;
					};
					let container = bookmark[start ? "startContainer" : "endContainer"];
					let offset = bookmark[start ? "startOffset" : "endOffset"];
					if (!container) return;
					if (isElement(container) && container.parentNode) {
						const node = container;
						offset = nodeIndex(container);
						container = container.parentNode;
						DOM$1.remove(node);
						if (!container.hasChildNodes() && DOM$1.isBlock(container)) container.appendChild(DOM$1.create("br"));
					}
					bookmark[start ? "startContainer" : "endContainer"] = container;
					bookmark[start ? "startOffset" : "endOffset"] = offset;
				};
				restoreEndPoint(true);
				restoreEndPoint();
				const rng = DOM$1.createRng();
				rng.setStart(bookmark.startContainer, bookmark.startOffset);
				if (bookmark.endContainer) rng.setEnd(bookmark.endContainer, bookmark.endOffset);
				return normalizeRange(rng);
			};
			const listToggleActionFromListName = (listName) => {
				switch (listName) {
					case "UL": return "ToggleUlList";
					case "OL": return "ToggleOlList";
					case "DL": return "ToggleDLList";
				}
			};
			const updateListStyle = (dom, el, detail) => {
				const type$1 = detail["list-style-type"] ? detail["list-style-type"] : null;
				dom.setStyle(el, "list-style-type", type$1);
			};
			const setAttribs = (elm, attrs) => {
				global$2.each(attrs, (value, key) => {
					elm.setAttribute(key, value);
				});
			};
			const updateListAttrs = (dom, el, detail) => {
				setAttribs(el, detail["list-attributes"]);
				global$2.each(dom.select("li", el), (li) => {
					setAttribs(li, detail["list-item-attributes"]);
				});
			};
			const updateListWithDetails = (dom, el, detail) => {
				updateListStyle(dom, el, detail);
				updateListAttrs(dom, el, detail);
			};
			const removeStyles = (dom, element, styles) => {
				global$2.each(styles, (style) => dom.setStyle(element, style, ""));
			};
			const isInline = (editor, node) => isNonNullable(node) && !isBlock(node, editor.schema.getBlockElements());
			const getEndPointNode = (editor, rng, start, root) => {
				let container = rng[start ? "startContainer" : "endContainer"];
				const offset = rng[start ? "startOffset" : "endOffset"];
				if (isElement(container)) container = container.childNodes[Math.min(offset, container.childNodes.length - 1)] || container;
				if (!start && isBr(container.nextSibling)) container = container.nextSibling;
				const findBlockAncestor = (node) => {
					while (!editor.dom.isBlock(node) && node.parentNode && root !== node) node = node.parentNode;
					return node;
				};
				const findBetterContainer = (container$1, forward) => {
					var _a;
					const walker = new global$5(container$1, findBlockAncestor(container$1));
					const dir = forward ? "next" : "prev";
					let node;
					while (node = walker[dir]()) if (!(isVoid(editor, node) || isZwsp(node.textContent) || ((_a = node.textContent) === null || _a === void 0 ? void 0 : _a.length) === 0)) return Optional.some(node);
					return Optional.none();
				};
				if (start && isTextNode$1(container)) if (isZwsp(container.textContent)) container = findBetterContainer(container, false).getOr(container);
				else {
					if (container.parentNode !== null && isInline(editor, container.parentNode)) container = container.parentNode;
					while (container.previousSibling !== null && (isInline(editor, container.previousSibling) || isTextNode$1(container.previousSibling))) container = container.previousSibling;
				}
				if (!start && isTextNode$1(container)) if (isZwsp(container.textContent)) container = findBetterContainer(container, true).getOr(container);
				else {
					if (container.parentNode !== null && isInline(editor, container.parentNode)) container = container.parentNode;
					while (container.nextSibling !== null && (isInline(editor, container.nextSibling) || isTextNode$1(container.nextSibling))) container = container.nextSibling;
				}
				while (container.parentNode !== root) {
					const parent$1 = container.parentNode;
					if (isTextBlock(editor, container)) return container;
					if (/^(TD|TH)$/.test(parent$1.nodeName)) return container;
					container = parent$1;
				}
				return container;
			};
			const getSelectedTextBlocks = (editor, rng, root) => {
				const textBlocks = [];
				const dom = editor.dom;
				const startNode = getEndPointNode(editor, rng, true, root);
				const endNode = getEndPointNode(editor, rng, false, root);
				let block;
				const siblings = [];
				for (let node = startNode; node; node = node.nextSibling) {
					siblings.push(node);
					if (node === endNode) break;
				}
				global$2.each(siblings, (node) => {
					var _a;
					if (isTextBlock(editor, node)) {
						textBlocks.push(node);
						block = null;
						return;
					}
					if (dom.isBlock(node) || isBr(node)) {
						if (isBr(node)) dom.remove(node);
						block = null;
						return;
					}
					const nextSibling$1 = node.nextSibling;
					if (global$1.isBookmarkNode(node)) {
						if (isListNode(nextSibling$1) || isTextBlock(editor, nextSibling$1) || !nextSibling$1 && node.parentNode === root) {
							block = null;
							return;
						}
					}
					if (!block) {
						block = dom.create("p");
						(_a = node.parentNode) === null || _a === void 0 || _a.insertBefore(block, node);
						textBlocks.push(block);
					}
					block.appendChild(node);
				});
				return textBlocks;
			};
			const hasCompatibleStyle = (dom, sib, detail) => {
				const sibStyle = dom.getStyle(sib, "list-style-type");
				let detailStyle = detail ? detail["list-style-type"] : "";
				detailStyle = detailStyle === null ? "" : detailStyle;
				return sibStyle === detailStyle;
			};
			const getRootSearchStart = (editor, range) => {
				const start = editor.selection.getStart(true);
				const startPoint = getEndPointNode(editor, range, true, editor.getBody());
				if (ancestor(SugarElement.fromDom(startPoint), SugarElement.fromDom(range.commonAncestorContainer))) return range.commonAncestorContainer;
				else return start;
			};
			const applyList = (editor, listName, detail) => {
				const rng = editor.selection.getRng();
				let listItemName = "LI";
				const root = getClosestListHost(editor, getRootSearchStart(editor, rng));
				const dom = editor.dom;
				if (dom.getContentEditable(editor.selection.getNode()) === "false") return;
				listName = listName.toUpperCase();
				if (listName === "DL") listItemName = "DT";
				const bookmark = createBookmark(rng);
				const selectedTextBlocks = filter$1(getSelectedTextBlocks(editor, rng, root), editor.dom.isEditable);
				global$2.each(selectedTextBlocks, (block) => {
					let listBlock;
					const sibling = block.previousSibling;
					const parent$1 = block.parentNode;
					if (!isListItemNode(parent$1)) {
						if (sibling && isListNode(sibling) && sibling.nodeName === listName && hasCompatibleStyle(dom, sibling, detail)) {
							listBlock = sibling;
							block = dom.rename(block, listItemName);
							sibling.appendChild(block);
						} else {
							listBlock = dom.create(listName);
							parent$1.insertBefore(listBlock, block);
							listBlock.appendChild(block);
							block = dom.rename(block, listItemName);
						}
						removeStyles(dom, block, [
							"margin",
							"margin-right",
							"margin-bottom",
							"margin-left",
							"margin-top",
							"padding",
							"padding-right",
							"padding-bottom",
							"padding-left",
							"padding-top"
						]);
						updateListWithDetails(dom, listBlock, detail);
						mergeWithAdjacentLists(editor.dom, listBlock);
					}
				});
				editor.selection.setRng(resolveBookmark(bookmark));
			};
			const isValidLists = (list1, list2) => {
				return isListNode(list1) && list1.nodeName === (list2 === null || list2 === void 0 ? void 0 : list2.nodeName);
			};
			const hasSameListStyle = (dom, list1, list2) => {
				return dom.getStyle(list1, "list-style-type", true) === dom.getStyle(list2, "list-style-type", true);
			};
			const hasSameClasses = (elm1, elm2) => {
				return elm1.className === elm2.className;
			};
			const shouldMerge = (dom, list1, list2) => {
				return isValidLists(list1, list2) && hasSameListStyle(dom, list1, list2) && hasSameClasses(list1, list2);
			};
			const mergeWithAdjacentLists = (dom, listBlock) => {
				let node;
				let sibling = listBlock.nextSibling;
				if (shouldMerge(dom, listBlock, sibling)) {
					const liSibling = sibling;
					while (node = liSibling.firstChild) listBlock.appendChild(node);
					dom.remove(liSibling);
				}
				sibling = listBlock.previousSibling;
				if (shouldMerge(dom, listBlock, sibling)) {
					const liSibling = sibling;
					while (node = liSibling.lastChild) listBlock.insertBefore(node, listBlock.firstChild);
					dom.remove(liSibling);
				}
			};
			const updateList$1 = (editor, list, listName, detail) => {
				if (list.nodeName !== listName) {
					const newList = editor.dom.rename(list, listName);
					updateListWithDetails(editor.dom, newList, detail);
					fireListEvent(editor, listToggleActionFromListName(listName), newList);
				} else {
					updateListWithDetails(editor.dom, list, detail);
					fireListEvent(editor, listToggleActionFromListName(listName), list);
				}
			};
			const updateCustomList = (editor, list, listName, detail) => {
				list.classList.forEach((cls, _, classList) => {
					if (cls.startsWith("tox-")) {
						classList.remove(cls);
						if (classList.length === 0) list.removeAttribute("class");
					}
				});
				if (list.nodeName !== listName) {
					const newList = editor.dom.rename(list, listName);
					updateListWithDetails(editor.dom, newList, detail);
					fireListEvent(editor, listToggleActionFromListName(listName), newList);
				} else {
					updateListWithDetails(editor.dom, list, detail);
					fireListEvent(editor, listToggleActionFromListName(listName), list);
				}
			};
			const toggleMultipleLists = (editor, parentList, lists, listName, detail) => {
				const parentIsList = isListNode(parentList);
				if (parentIsList && parentList.nodeName === listName && !hasListStyleDetail(detail) && !isCustomList(parentList)) flattenListSelection(editor);
				else {
					applyList(editor, listName, detail);
					const bookmark = createBookmark(editor.selection.getRng());
					const allLists = parentIsList ? [parentList, ...lists] : lists;
					const updateFunction = parentIsList && isCustomList(parentList) ? updateCustomList : updateList$1;
					global$2.each(allLists, (elm) => {
						updateFunction(editor, elm, listName, detail);
					});
					editor.selection.setRng(resolveBookmark(bookmark));
				}
			};
			const hasListStyleDetail = (detail) => {
				return "list-style-type" in detail;
			};
			const toggleSingleList = (editor, parentList, listName, detail) => {
				if (parentList === editor.getBody()) return;
				if (parentList) if (parentList.nodeName === listName && !hasListStyleDetail(detail) && !isCustomList(parentList)) flattenListSelection(editor);
				else {
					const bookmark = createBookmark(editor.selection.getRng());
					if (isCustomList(parentList)) parentList.classList.forEach((cls, _, classList) => {
						if (cls.startsWith("tox-")) {
							classList.remove(cls);
							if (classList.length === 0) parentList.removeAttribute("class");
						}
					});
					updateListWithDetails(editor.dom, parentList, detail);
					const newList = editor.dom.rename(parentList, listName);
					mergeWithAdjacentLists(editor.dom, newList);
					editor.selection.setRng(resolveBookmark(bookmark));
					applyList(editor, listName, detail);
					fireListEvent(editor, listToggleActionFromListName(listName), newList);
				}
				else {
					applyList(editor, listName, detail);
					fireListEvent(editor, listToggleActionFromListName(listName), parentList);
				}
			};
			const toggleList = (editor, listName, _detail) => {
				const parentList = getParentList(editor);
				if (isWithinNonEditableList(editor, parentList)) return;
				const selectedSubLists = getSelectedSubLists(editor);
				const detail = isObject(_detail) ? _detail : {};
				if (selectedSubLists.length > 0) toggleMultipleLists(editor, parentList, selectedSubLists, listName, detail);
				else toggleSingleList(editor, parentList, listName, detail);
			};
			const DOM = global$3.DOM;
			const normalizeList = (dom, list) => {
				const parentNode = list.parentElement;
				if (parentNode && parentNode.nodeName === "LI" && parentNode.firstChild === list) {
					const sibling = parentNode.previousSibling;
					if (sibling && sibling.nodeName === "LI") {
						sibling.appendChild(list);
						if (isEmpty$2(dom, parentNode)) DOM.remove(parentNode);
					} else DOM.setStyle(parentNode, "listStyleType", "none");
				}
				if (isListNode(parentNode)) {
					const sibling = parentNode.previousSibling;
					if (sibling && sibling.nodeName === "LI") sibling.appendChild(list);
				}
			};
			const normalizeLists = (dom, element) => {
				const lists = global$2.grep(dom.select("ol,ul", element));
				global$2.each(lists, (list) => {
					normalizeList(dom, list);
				});
			};
			const findNextCaretContainer = (editor, rng, isForward, root) => {
				let node = rng.startContainer;
				const offset = rng.startOffset;
				if (isTextNode$1(node) && (isForward ? offset < node.data.length : offset > 0)) return node;
				const nonEmptyBlocks = editor.schema.getNonEmptyElements();
				if (isElement(node)) node = global$6.getNode(node, offset);
				const walker = new global$5(node, root);
				if (isForward) {
					if (isBogusBr(editor.dom, node)) walker.next();
				}
				const walkFn = isForward ? walker.next.bind(walker) : walker.prev2.bind(walker);
				while (node = walkFn()) {
					if (node.nodeName === "LI" && !node.hasChildNodes()) return node;
					if (nonEmptyBlocks[node.nodeName]) return node;
					if (isTextNode$1(node) && node.data.length > 0) return node;
				}
				return null;
			};
			const hasOnlyOneBlockChild = (dom, elm) => {
				const childNodes = elm.childNodes;
				return childNodes.length === 1 && !isListNode(childNodes[0]) && dom.isBlock(childNodes[0]);
			};
			const unwrapSingleBlockChild = (dom, elm) => {
				if (hasOnlyOneBlockChild(dom, elm)) dom.remove(elm.firstChild, true);
			};
			const moveChildren = (dom, fromElm, toElm) => {
				let node;
				const targetElm = hasOnlyOneBlockChild(dom, toElm) ? toElm.firstChild : toElm;
				unwrapSingleBlockChild(dom, fromElm);
				if (!isEmpty$2(dom, fromElm, true)) while (node = fromElm.firstChild) targetElm.appendChild(node);
			};
			const mergeLiElements = (dom, fromElm, toElm) => {
				let listNode;
				const ul = fromElm.parentNode;
				if (!isChildOfBody(dom, fromElm) || !isChildOfBody(dom, toElm)) return;
				if (isListNode(toElm.lastChild)) listNode = toElm.lastChild;
				if (ul === toElm.lastChild) {
					if (isBr(ul.previousSibling)) dom.remove(ul.previousSibling);
				}
				const node = toElm.lastChild;
				if (node && isBr(node) && fromElm.hasChildNodes()) dom.remove(node);
				if (isEmpty$2(dom, toElm, true)) empty(SugarElement.fromDom(toElm));
				moveChildren(dom, fromElm, toElm);
				if (listNode) toElm.appendChild(listNode);
				const nestedLists = contains(SugarElement.fromDom(toElm), SugarElement.fromDom(fromElm)) ? dom.getParents(fromElm, isListNode, toElm) : [];
				dom.remove(fromElm);
				each$1(nestedLists, (list) => {
					if (isEmpty$2(dom, list) && list !== dom.getRoot()) dom.remove(list);
				});
			};
			const mergeIntoEmptyLi = (editor, fromLi, toLi) => {
				empty(SugarElement.fromDom(toLi));
				mergeLiElements(editor.dom, fromLi, toLi);
				editor.selection.setCursorLocation(toLi, 0);
			};
			const mergeForward = (editor, rng, fromLi, toLi) => {
				const dom = editor.dom;
				if (dom.isEmpty(toLi)) mergeIntoEmptyLi(editor, fromLi, toLi);
				else {
					const bookmark = createBookmark(rng);
					mergeLiElements(dom, fromLi, toLi);
					editor.selection.setRng(resolveBookmark(bookmark));
				}
			};
			const mergeBackward = (editor, rng, fromLi, toLi) => {
				const bookmark = createBookmark(rng);
				mergeLiElements(editor.dom, fromLi, toLi);
				const resolvedBookmark = resolveBookmark(bookmark);
				editor.selection.setRng(resolvedBookmark);
			};
			const backspaceDeleteFromListToListCaret = (editor, isForward) => {
				const dom = editor.dom, selection = editor.selection;
				const root = getClosestEditingHost(editor, selection.getStart());
				const li = dom.getParent(selection.getStart(), "LI", root);
				if (li) {
					const ul = li.parentElement;
					if (ul === editor.getBody() && isEmpty$2(dom, ul)) return true;
					const rng = normalizeRange(selection.getRng());
					const otherLi = dom.getParent(findNextCaretContainer(editor, rng, isForward, root), "LI", root);
					if (otherLi && otherLi !== li) {
						editor.undoManager.transact(() => {
							if (isForward) mergeForward(editor, rng, otherLi, li);
							else if (isFirstChild(li)) outdentListSelection(editor);
							else mergeBackward(editor, rng, li, otherLi);
						});
						return true;
					} else if (!otherLi) {
						if (!isForward && rng.startOffset === 0 && rng.endOffset === 0) {
							editor.undoManager.transact(() => {
								flattenListSelection(editor);
							});
							return true;
						}
					}
				}
				return false;
			};
			const removeBlock = (dom, block, root) => {
				const parentBlock = dom.getParent(block.parentNode, dom.isBlock, root);
				dom.remove(block);
				if (parentBlock && dom.isEmpty(parentBlock)) dom.remove(parentBlock);
			};
			const backspaceDeleteIntoListCaret = (editor, isForward) => {
				const dom = editor.dom;
				const selectionStartElm = editor.selection.getStart();
				const root = getClosestEditingHost(editor, selectionStartElm);
				const block = dom.getParent(selectionStartElm, dom.isBlock, root);
				if (block && dom.isEmpty(block)) {
					const rng = normalizeRange(editor.selection.getRng());
					const otherLi = dom.getParent(findNextCaretContainer(editor, rng, isForward, root), "LI", root);
					if (otherLi) {
						const findValidElement = (element) => contains$1([
							"td",
							"th",
							"caption"
						], name(element));
						const findRoot = (node) => node.dom === root;
						if (!equals(closest(SugarElement.fromDom(otherLi), findValidElement, findRoot), closest(SugarElement.fromDom(rng.startContainer), findValidElement, findRoot), eq)) return false;
						editor.undoManager.transact(() => {
							const parentNode = otherLi.parentNode;
							removeBlock(dom, block, root);
							mergeWithAdjacentLists(dom, parentNode);
							editor.selection.select(otherLi, true);
							editor.selection.collapse(isForward);
						});
						return true;
					}
				}
				return false;
			};
			const backspaceDeleteCaret = (editor, isForward) => {
				return backspaceDeleteFromListToListCaret(editor, isForward) || backspaceDeleteIntoListCaret(editor, isForward);
			};
			const hasListSelection = (editor) => {
				const selectionStartElm = editor.selection.getStart();
				const root = getClosestEditingHost(editor, selectionStartElm);
				return editor.dom.getParent(selectionStartElm, "LI,DT,DD", root) || getSelectedListItems(editor).length > 0;
			};
			const backspaceDeleteRange = (editor) => {
				if (hasListSelection(editor)) {
					editor.undoManager.transact(() => {
						editor.execCommand("Delete");
						normalizeLists(editor.dom, editor.getBody());
					});
					return true;
				}
				return false;
			};
			const backspaceDelete = (editor, isForward) => {
				const selection = editor.selection;
				return !isWithinNonEditableList(editor, selection.getNode()) && (selection.isCollapsed() ? backspaceDeleteCaret(editor, isForward) : backspaceDeleteRange(editor));
			};
			const setup$2 = (editor) => {
				editor.on("ExecCommand", (e) => {
					const cmd = e.command.toLowerCase();
					if ((cmd === "delete" || cmd === "forwarddelete") && hasListSelection(editor)) normalizeLists(editor.dom, editor.getBody());
				});
				editor.on("keydown", (e) => {
					if (e.keyCode === global$4.BACKSPACE) {
						if (backspaceDelete(editor, false)) e.preventDefault();
					} else if (e.keyCode === global$4.DELETE) {
						if (backspaceDelete(editor, true)) e.preventDefault();
					}
				});
			};
			const get = (editor) => ({ backspaceDelete: (isForward) => {
				backspaceDelete(editor, isForward);
			} });
			const updateList = (editor, update) => {
				const parentList = getParentList(editor);
				if (parentList === null || isWithinNonEditableList(editor, parentList)) return;
				editor.undoManager.transact(() => {
					if (isObject(update.styles)) editor.dom.setStyles(parentList, update.styles);
					if (isObject(update.attrs)) each(update.attrs, (v, k) => editor.dom.setAttrib(parentList, k, v));
				});
			};
			const parseAlphabeticBase26 = (str) => {
				return foldl(map(reverse(trim(str).split("")), (char, i) => {
					const charValue = char.toUpperCase().charCodeAt(0) - "A".charCodeAt(0) + 1;
					return Math.pow(26, i) * charValue;
				}), (sum, v) => sum + v, 0);
			};
			const composeAlphabeticBase26 = (value) => {
				value--;
				if (value < 0) return "";
				else {
					const remainder = value % 26;
					return composeAlphabeticBase26(Math.floor(value / 26)) + String.fromCharCode("A".charCodeAt(0) + remainder);
				}
			};
			const isUppercase = (str) => /^[A-Z]+$/.test(str);
			const isLowercase = (str) => /^[a-z]+$/.test(str);
			const isNumeric = (str) => /^[0-9]+$/.test(str);
			const deduceListType = (start) => {
				if (isNumeric(start)) return 2;
				else if (isUppercase(start)) return 0;
				else if (isLowercase(start)) return 1;
				else if (isEmpty$1(start)) return 3;
				else return 4;
			};
			const parseStartValue = (start) => {
				switch (deduceListType(start)) {
					case 2: return Optional.some({
						listStyleType: Optional.none(),
						start
					});
					case 0: return Optional.some({
						listStyleType: Optional.some("upper-alpha"),
						start: parseAlphabeticBase26(start).toString()
					});
					case 1: return Optional.some({
						listStyleType: Optional.some("lower-alpha"),
						start: parseAlphabeticBase26(start).toString()
					});
					case 3: return Optional.some({
						listStyleType: Optional.none(),
						start: ""
					});
					case 4: return Optional.none();
				}
			};
			const parseDetail = (detail) => {
				const start = parseInt(detail.start, 10);
				if (is$2(detail.listStyleType, "upper-alpha")) return composeAlphabeticBase26(start);
				else if (is$2(detail.listStyleType, "lower-alpha")) return composeAlphabeticBase26(start).toLowerCase();
				else return detail.start;
			};
			const open = (editor) => {
				const currentList = getParentList(editor);
				if (!isOlNode(currentList) || isWithinNonEditableList(editor, currentList)) return;
				editor.windowManager.open({
					title: "List Properties",
					body: {
						type: "panel",
						items: [{
							type: "input",
							name: "start",
							label: "Start list at number",
							inputMode: "numeric"
						}]
					},
					initialData: { start: parseDetail({
						start: editor.dom.getAttrib(currentList, "start", "1"),
						listStyleType: Optional.from(editor.dom.getStyle(currentList, "list-style-type"))
					}) },
					buttons: [{
						type: "cancel",
						name: "cancel",
						text: "Cancel"
					}, {
						type: "submit",
						name: "save",
						text: "Save",
						primary: true
					}],
					onSubmit: (api) => {
						parseStartValue(api.getData().start).each((detail) => {
							editor.execCommand("mceListUpdate", false, {
								attrs: { start: detail.start === "1" ? "" : detail.start },
								styles: { "list-style-type": detail.listStyleType.getOr("") }
							});
						});
						api.close();
					}
				});
			};
			const queryListCommandState = (editor, listName) => () => {
				const parentList = getParentList(editor);
				return isNonNullable(parentList) && parentList.nodeName === listName;
			};
			const registerDialog = (editor) => {
				editor.addCommand("mceListProps", () => {
					open(editor);
				});
			};
			const register$2 = (editor) => {
				editor.on("BeforeExecCommand", (e) => {
					const cmd = e.command.toLowerCase();
					if (cmd === "indent") indentListSelection(editor);
					else if (cmd === "outdent") outdentListSelection(editor);
				});
				editor.addCommand("InsertUnorderedList", (ui, detail) => {
					toggleList(editor, "UL", detail);
				});
				editor.addCommand("InsertOrderedList", (ui, detail) => {
					toggleList(editor, "OL", detail);
				});
				editor.addCommand("InsertDefinitionList", (ui, detail) => {
					toggleList(editor, "DL", detail);
				});
				editor.addCommand("RemoveList", () => {
					flattenListSelection(editor);
				});
				registerDialog(editor);
				editor.addCommand("mceListUpdate", (ui, detail) => {
					if (isObject(detail)) updateList(editor, detail);
				});
				editor.addQueryStateHandler("InsertUnorderedList", queryListCommandState(editor, "UL"));
				editor.addQueryStateHandler("InsertOrderedList", queryListCommandState(editor, "OL"));
				editor.addQueryStateHandler("InsertDefinitionList", queryListCommandState(editor, "DL"));
			};
			var global = tinymce.util.Tools.resolve("tinymce.html.Node");
			const isTextNode = (node) => node.type === 3;
			const isEmpty = (nodeBuffer) => nodeBuffer.length === 0;
			const wrapInvalidChildren = (list) => {
				const insertListItem = (buffer, refNode) => {
					const li = global.create("li");
					each$1(buffer, (node) => li.append(node));
					if (refNode) list.insert(li, refNode, true);
					else list.append(li);
				};
				const reducer = (buffer, node) => {
					if (isTextNode(node)) return [...buffer, node];
					else if (!isEmpty(buffer) && !isTextNode(node)) {
						insertListItem(buffer, node);
						return [];
					} else return buffer;
				};
				const restBuffer = foldl(list.children(), reducer, []);
				if (!isEmpty(restBuffer)) insertListItem(restBuffer);
			};
			const setup$1 = (editor) => {
				editor.on("PreInit", () => {
					const { parser } = editor;
					parser.addNodeFilter("ul,ol", (nodes) => each$1(nodes, wrapInvalidChildren));
				});
			};
			const setupTabKey = (editor) => {
				editor.on("keydown", (e) => {
					if (e.keyCode !== global$4.TAB || global$4.metaKeyPressed(e)) return;
					editor.undoManager.transact(() => {
						if (e.shiftKey ? outdentListSelection(editor) : indentListSelection(editor)) e.preventDefault();
					});
				});
			};
			const setup = (editor) => {
				if (shouldIndentOnTab(editor)) setupTabKey(editor);
				setup$2(editor);
			};
			const setupToggleButtonHandler = (editor, listName) => (api) => {
				const toggleButtonHandler = (e) => {
					api.setActive(inList(e.parents, listName));
					api.setEnabled(!isWithinNonEditableList(editor, e.element) && editor.selection.isEditable());
				};
				api.setEnabled(editor.selection.isEditable());
				return setNodeChangeHandler(editor, toggleButtonHandler);
			};
			const register$1 = (editor) => {
				const exec = (command) => () => editor.execCommand(command);
				if (!editor.hasPlugin("advlist")) {
					editor.ui.registry.addToggleButton("numlist", {
						icon: "ordered-list",
						active: false,
						tooltip: "Numbered list",
						onAction: exec("InsertOrderedList"),
						onSetup: setupToggleButtonHandler(editor, "OL")
					});
					editor.ui.registry.addToggleButton("bullist", {
						icon: "unordered-list",
						active: false,
						tooltip: "Bullet list",
						onAction: exec("InsertUnorderedList"),
						onSetup: setupToggleButtonHandler(editor, "UL")
					});
				}
			};
			const setupMenuButtonHandler = (editor, listName) => (api) => {
				const menuButtonHandler = (e) => api.setEnabled(inList(e.parents, listName) && !isWithinNonEditableList(editor, e.element));
				return setNodeChangeHandler(editor, menuButtonHandler);
			};
			const register = (editor) => {
				const listProperties = {
					text: "List properties...",
					icon: "ordered-list",
					onAction: () => editor.execCommand("mceListProps"),
					onSetup: setupMenuButtonHandler(editor, "OL")
				};
				editor.ui.registry.addMenuItem("listprops", listProperties);
				editor.ui.registry.addContextMenu("lists", { update: (node) => {
					return isOlNode(getParentList(editor, node)) ? ["listprops"] : [];
				} });
			};
			var Plugin = () => {
				global$7.add("lists", (editor) => {
					register$3(editor);
					setup$1(editor);
					if (!editor.hasPlugin("rtc", true)) {
						setup(editor);
						register$2(editor);
					} else registerDialog(editor);
					register$1(editor);
					register(editor);
					return get(editor);
				});
			};
			Plugin();
		})();
	}));

//#endregion
//#region node_modules/tinymce/plugins/lists/index.js
	require_plugin$1();

//#endregion
//#region node_modules/tinymce/plugins/table/plugin.js
	var require_plugin = /* @__PURE__ */ __commonJSMin((() => {
		/**
		* TinyMCE version 6.7.0 (2023-08-30)
		*/
		(function() {
			"use strict";
			var global$3 = tinymce.util.Tools.resolve("tinymce.PluginManager");
			const hasProto = (v, constructor, predicate) => {
				var _a;
				if (predicate(v, constructor.prototype)) return true;
				else return ((_a = v.constructor) === null || _a === void 0 ? void 0 : _a.name) === constructor.name;
			};
			const typeOf = (x) => {
				const t = typeof x;
				if (x === null) return "null";
				else if (t === "object" && Array.isArray(x)) return "array";
				else if (t === "object" && hasProto(x, String, (o, proto) => proto.isPrototypeOf(o))) return "string";
				else return t;
			};
			const isType$1 = (type$1) => (value) => typeOf(value) === type$1;
			const isSimpleType = (type$1) => (value) => typeof value === type$1;
			const eq$1 = (t) => (a) => t === a;
			const isString = isType$1("string");
			const isArray = isType$1("array");
			const isBoolean = isSimpleType("boolean");
			const isUndefined = eq$1(void 0);
			const isNullable = (a) => a === null || a === void 0;
			const isNonNullable = (a) => !isNullable(a);
			const isFunction = isSimpleType("function");
			const isNumber = isSimpleType("number");
			const noop = () => {};
			const compose1 = (fbc, fab) => (a) => fbc(fab(a));
			const constant = (value) => {
				return () => {
					return value;
				};
			};
			const identity = (x) => {
				return x;
			};
			const tripleEquals = (a, b) => {
				return a === b;
			};
			function curry(fn, ...initialArgs) {
				return (...restArgs) => {
					const all$2 = initialArgs.concat(restArgs);
					return fn.apply(null, all$2);
				};
			}
			const call = (f) => {
				f();
			};
			const never = constant(false);
			const always = constant(true);
			class Optional {
				constructor(tag, value) {
					this.tag = tag;
					this.value = value;
				}
				static some(value) {
					return new Optional(true, value);
				}
				static none() {
					return Optional.singletonNone;
				}
				fold(onNone, onSome) {
					if (this.tag) return onSome(this.value);
					else return onNone();
				}
				isSome() {
					return this.tag;
				}
				isNone() {
					return !this.tag;
				}
				map(mapper) {
					if (this.tag) return Optional.some(mapper(this.value));
					else return Optional.none();
				}
				bind(binder) {
					if (this.tag) return binder(this.value);
					else return Optional.none();
				}
				exists(predicate) {
					return this.tag && predicate(this.value);
				}
				forall(predicate) {
					return !this.tag || predicate(this.value);
				}
				filter(predicate) {
					if (!this.tag || predicate(this.value)) return this;
					else return Optional.none();
				}
				getOr(replacement) {
					return this.tag ? this.value : replacement;
				}
				or(replacement) {
					return this.tag ? this : replacement;
				}
				getOrThunk(thunk) {
					return this.tag ? this.value : thunk();
				}
				orThunk(thunk) {
					return this.tag ? this : thunk();
				}
				getOrDie(message) {
					if (!this.tag) throw new Error(message !== null && message !== void 0 ? message : "Called getOrDie on None");
					else return this.value;
				}
				static from(value) {
					return isNonNullable(value) ? Optional.some(value) : Optional.none();
				}
				getOrNull() {
					return this.tag ? this.value : null;
				}
				getOrUndefined() {
					return this.value;
				}
				each(worker) {
					if (this.tag) worker(this.value);
				}
				toArray() {
					return this.tag ? [this.value] : [];
				}
				toString() {
					return this.tag ? `some(${this.value})` : "none()";
				}
			}
			Optional.singletonNone = new Optional(false);
			const keys = Object.keys;
			const hasOwnProperty = Object.hasOwnProperty;
			const each$1 = (obj, f) => {
				const props = keys(obj);
				for (let k = 0, len = props.length; k < len; k++) {
					const i = props[k];
					const x = obj[i];
					f(x, i);
				}
			};
			const objAcc = (r) => (x, i) => {
				r[i] = x;
			};
			const internalFilter = (obj, pred, onTrue, onFalse) => {
				each$1(obj, (x, i) => {
					(pred(x, i) ? onTrue : onFalse)(x, i);
				});
			};
			const filter$1 = (obj, pred) => {
				const t = {};
				internalFilter(obj, pred, objAcc(t), noop);
				return t;
			};
			const mapToArray = (obj, f) => {
				const r = [];
				each$1(obj, (value, name$1) => {
					r.push(f(value, name$1));
				});
				return r;
			};
			const values = (obj) => {
				return mapToArray(obj, identity);
			};
			const size = (obj) => {
				return keys(obj).length;
			};
			const get$4 = (obj, key$1) => {
				return has(obj, key$1) ? Optional.from(obj[key$1]) : Optional.none();
			};
			const has = (obj, key$1) => hasOwnProperty.call(obj, key$1);
			const hasNonNullableKey = (obj, key$1) => has(obj, key$1) && obj[key$1] !== void 0 && obj[key$1] !== null;
			const isEmpty$1 = (r) => {
				for (const x in r) if (hasOwnProperty.call(r, x)) return false;
				return true;
			};
			const nativeIndexOf = Array.prototype.indexOf;
			const nativePush = Array.prototype.push;
			const rawIndexOf = (ts, t) => nativeIndexOf.call(ts, t);
			const contains = (xs, x) => rawIndexOf(xs, x) > -1;
			const exists = (xs, pred) => {
				for (let i = 0, len = xs.length; i < len; i++) {
					const x = xs[i];
					if (pred(x, i)) return true;
				}
				return false;
			};
			const range = (num, f) => {
				const r = [];
				for (let i = 0; i < num; i++) r.push(f(i));
				return r;
			};
			const map = (xs, f) => {
				const len = xs.length;
				const r = new Array(len);
				for (let i = 0; i < len; i++) {
					const x = xs[i];
					r[i] = f(x, i);
				}
				return r;
			};
			const each = (xs, f) => {
				for (let i = 0, len = xs.length; i < len; i++) {
					const x = xs[i];
					f(x, i);
				}
			};
			const eachr = (xs, f) => {
				for (let i = xs.length - 1; i >= 0; i--) {
					const x = xs[i];
					f(x, i);
				}
			};
			const partition = (xs, pred) => {
				const pass = [];
				const fail = [];
				for (let i = 0, len = xs.length; i < len; i++) {
					const x = xs[i];
					(pred(x, i) ? pass : fail).push(x);
				}
				return {
					pass,
					fail
				};
			};
			const filter = (xs, pred) => {
				const r = [];
				for (let i = 0, len = xs.length; i < len; i++) {
					const x = xs[i];
					if (pred(x, i)) r.push(x);
				}
				return r;
			};
			const foldr = (xs, f, acc) => {
				eachr(xs, (x, i) => {
					acc = f(acc, x, i);
				});
				return acc;
			};
			const foldl = (xs, f, acc) => {
				each(xs, (x, i) => {
					acc = f(acc, x, i);
				});
				return acc;
			};
			const findUntil = (xs, pred, until) => {
				for (let i = 0, len = xs.length; i < len; i++) {
					const x = xs[i];
					if (pred(x, i)) return Optional.some(x);
					else if (until(x, i)) break;
				}
				return Optional.none();
			};
			const find = (xs, pred) => {
				return findUntil(xs, pred, never);
			};
			const flatten$1 = (xs) => {
				const r = [];
				for (let i = 0, len = xs.length; i < len; ++i) {
					if (!isArray(xs[i])) throw new Error("Arr.flatten item " + i + " was not an array, input: " + xs);
					nativePush.apply(r, xs[i]);
				}
				return r;
			};
			const bind = (xs, f) => flatten$1(map(xs, f));
			const forall = (xs, pred) => {
				for (let i = 0, len = xs.length; i < len; ++i) {
					const x = xs[i];
					if (pred(x, i) !== true) return false;
				}
				return true;
			};
			const mapToObject = (xs, f) => {
				const r = {};
				for (let i = 0, len = xs.length; i < len; i++) {
					const x = xs[i];
					r[String(x)] = f(x, i);
				}
				return r;
			};
			const get$3 = (xs, i) => i >= 0 && i < xs.length ? Optional.some(xs[i]) : Optional.none();
			const head = (xs) => get$3(xs, 0);
			const last = (xs) => get$3(xs, xs.length - 1);
			const findMap = (arr, f) => {
				for (let i = 0; i < arr.length; i++) {
					const r = f(arr[i], i);
					if (r.isSome()) return r;
				}
				return Optional.none();
			};
			const COMMENT = 8;
			const DOCUMENT = 9;
			const DOCUMENT_FRAGMENT = 11;
			const ELEMENT = 1;
			const TEXT = 3;
			const fromHtml = (html, scope) => {
				const div = (scope || document).createElement("div");
				div.innerHTML = html;
				if (!div.hasChildNodes() || div.childNodes.length > 1) {
					const message = "HTML does not have a single root node";
					console.error(message, html);
					throw new Error(message);
				}
				return fromDom$1(div.childNodes[0]);
			};
			const fromTag = (tag, scope) => {
				return fromDom$1((scope || document).createElement(tag));
			};
			const fromText = (text, scope) => {
				return fromDom$1((scope || document).createTextNode(text));
			};
			const fromDom$1 = (node) => {
				if (node === null || node === void 0) throw new Error("Node cannot be null or undefined");
				return { dom: node };
			};
			const fromPoint = (docElm, x, y) => Optional.from(docElm.dom.elementFromPoint(x, y)).map(fromDom$1);
			const SugarElement = {
				fromHtml,
				fromTag,
				fromText,
				fromDom: fromDom$1,
				fromPoint
			};
			const is$2 = (element, selector) => {
				const dom = element.dom;
				if (dom.nodeType !== ELEMENT) return false;
				else {
					const elem = dom;
					if (elem.matches !== void 0) return elem.matches(selector);
					else if (elem.msMatchesSelector !== void 0) return elem.msMatchesSelector(selector);
					else if (elem.webkitMatchesSelector !== void 0) return elem.webkitMatchesSelector(selector);
					else if (elem.mozMatchesSelector !== void 0) return elem.mozMatchesSelector(selector);
					else throw new Error("Browser lacks native selectors");
				}
			};
			const bypassSelector = (dom) => dom.nodeType !== ELEMENT && dom.nodeType !== DOCUMENT && dom.nodeType !== DOCUMENT_FRAGMENT || dom.childElementCount === 0;
			const all$1 = (selector, scope) => {
				const base = scope === void 0 ? document : scope.dom;
				return bypassSelector(base) ? [] : map(base.querySelectorAll(selector), SugarElement.fromDom);
			};
			const one = (selector, scope) => {
				const base = scope === void 0 ? document : scope.dom;
				return bypassSelector(base) ? Optional.none() : Optional.from(base.querySelector(selector)).map(SugarElement.fromDom);
			};
			const eq = (e1, e2) => e1.dom === e2.dom;
			const is$1 = is$2;
			typeof window !== "undefined" ? window : Function("return this;")();
			const name = (element) => {
				return element.dom.nodeName.toLowerCase();
			};
			const type = (element) => element.dom.nodeType;
			const isType = (t) => (element) => type(element) === t;
			const isComment = (element) => type(element) === COMMENT || name(element) === "#comment";
			const isElement = isType(ELEMENT);
			const isText = isType(TEXT);
			const isDocument = isType(DOCUMENT);
			const isDocumentFragment = isType(DOCUMENT_FRAGMENT);
			const isTag = (tag) => (e) => isElement(e) && name(e) === tag;
			const owner = (element) => SugarElement.fromDom(element.dom.ownerDocument);
			const documentOrOwner = (dos) => isDocument(dos) ? dos : owner(dos);
			const parent = (element) => Optional.from(element.dom.parentNode).map(SugarElement.fromDom);
			const parents = (element, isRoot) => {
				const stop = isFunction(isRoot) ? isRoot : never;
				let dom = element.dom;
				const ret = [];
				while (dom.parentNode !== null && dom.parentNode !== void 0) {
					const rawParent = dom.parentNode;
					const p = SugarElement.fromDom(rawParent);
					ret.push(p);
					if (stop(p) === true) break;
					else dom = rawParent;
				}
				return ret;
			};
			const prevSibling = (element) => Optional.from(element.dom.previousSibling).map(SugarElement.fromDom);
			const nextSibling = (element) => Optional.from(element.dom.nextSibling).map(SugarElement.fromDom);
			const children$3 = (element) => map(element.dom.childNodes, SugarElement.fromDom);
			const child$3 = (element, index) => {
				const cs = element.dom.childNodes;
				return Optional.from(cs[index]).map(SugarElement.fromDom);
			};
			const firstChild = (element) => child$3(element, 0);
			const isShadowRoot = (dos) => isDocumentFragment(dos) && isNonNullable(dos.dom.host);
			const getRootNode = isFunction(Element.prototype.attachShadow) && isFunction(Node.prototype.getRootNode) ? (e) => SugarElement.fromDom(e.dom.getRootNode()) : documentOrOwner;
			const getShadowRoot = (e) => {
				const r = getRootNode(e);
				return isShadowRoot(r) ? Optional.some(r) : Optional.none();
			};
			const getShadowHost = (e) => SugarElement.fromDom(e.dom.host);
			const inBody = (element) => {
				const dom = isText(element) ? element.dom.parentNode : element.dom;
				if (dom === void 0 || dom === null || dom.ownerDocument === null) return false;
				const doc = dom.ownerDocument;
				return getShadowRoot(SugarElement.fromDom(dom)).fold(() => doc.body.contains(dom), compose1(inBody, getShadowHost));
			};
			var ClosestOrAncestor = (is$3, ancestor$2, scope, a, isRoot) => {
				if (is$3(scope, a)) return Optional.some(scope);
				else if (isFunction(isRoot) && isRoot(scope)) return Optional.none();
				else return ancestor$2(scope, a, isRoot);
			};
			const ancestor$1 = (scope, predicate, isRoot) => {
				let element = scope.dom;
				const stop = isFunction(isRoot) ? isRoot : never;
				while (element.parentNode) {
					element = element.parentNode;
					const el = SugarElement.fromDom(element);
					if (predicate(el)) return Optional.some(el);
					else if (stop(el)) break;
				}
				return Optional.none();
			};
			const closest$2 = (scope, predicate, isRoot) => {
				const is$3 = (s, test) => test(s);
				return ClosestOrAncestor(is$3, ancestor$1, scope, predicate, isRoot);
			};
			const child$2 = (scope, predicate) => {
				const pred = (node) => predicate(SugarElement.fromDom(node));
				return find(scope.dom.childNodes, pred).map(SugarElement.fromDom);
			};
			const ancestor = (scope, selector, isRoot) => ancestor$1(scope, (e) => is$2(e, selector), isRoot);
			const child$1 = (scope, selector) => child$2(scope, (e) => is$2(e, selector));
			const descendant = (scope, selector) => one(selector, scope);
			const closest$1 = (scope, selector, isRoot) => {
				const is$3 = (element, selector$1) => is$2(element, selector$1);
				return ClosestOrAncestor(is$3, ancestor, scope, selector, isRoot);
			};
			const closest = (target) => closest$1(target, "[contenteditable]");
			const isEditable = (element, assumeEditable = false) => {
				if (inBody(element)) return element.dom.isContentEditable;
				else return closest(element).fold(constant(assumeEditable), (editable) => getRaw$1(editable) === "true");
			};
			const getRaw$1 = (element) => element.dom.contentEditable;
			const getNodeName = (elm) => elm.nodeName.toLowerCase();
			const getBody = (editor) => SugarElement.fromDom(editor.getBody());
			const getIsRoot = (editor) => (element) => eq(element, getBody(editor));
			const removePxSuffix = (size$1) => size$1 ? size$1.replace(/px$/, "") : "";
			const addPxSuffix = (size$1) => /^\d+(\.\d+)?$/.test(size$1) ? size$1 + "px" : size$1;
			const getSelectionStart = (editor) => SugarElement.fromDom(editor.selection.getStart());
			const getSelectionEnd = (editor) => SugarElement.fromDom(editor.selection.getEnd());
			const isInEditableContext = (cell$1) => closest$2(cell$1, isTag("table")).forall(isEditable);
			const children$2 = (scope, predicate) => filter(children$3(scope), predicate);
			const descendants$1 = (scope, predicate) => {
				let result = [];
				each(children$3(scope), (x) => {
					if (predicate(x)) result = result.concat([x]);
					result = result.concat(descendants$1(x, predicate));
				});
				return result;
			};
			const children$1 = (scope, selector) => children$2(scope, (e) => is$2(e, selector));
			const descendants = (scope, selector) => all$1(selector, scope);
			const rawSet = (dom, key$1, value) => {
				if (isString(value) || isBoolean(value) || isNumber(value)) dom.setAttribute(key$1, value + "");
				else {
					console.error("Invalid call to Attribute.set. Key ", key$1, ":: Value ", value, ":: Element ", dom);
					throw new Error("Attribute value was not simple");
				}
			};
			const set$2 = (element, key$1, value) => {
				rawSet(element.dom, key$1, value);
			};
			const setAll = (element, attrs) => {
				const dom = element.dom;
				each$1(attrs, (v, k) => {
					rawSet(dom, k, v);
				});
			};
			const get$2 = (element, key$1) => {
				const v = element.dom.getAttribute(key$1);
				return v === null ? void 0 : v;
			};
			const getOpt = (element, key$1) => Optional.from(get$2(element, key$1));
			const remove$2 = (element, key$1) => {
				element.dom.removeAttribute(key$1);
			};
			const clone = (element) => foldl(element.dom.attributes, (acc, attr) => {
				acc[attr.name] = attr.value;
				return acc;
			}, {});
			const is = (lhs, rhs, comparator = tripleEquals) => lhs.exists((left) => comparator(left, rhs));
			const cat = (arr) => {
				const r = [];
				const push = (x) => {
					r.push(x);
				};
				for (let i = 0; i < arr.length; i++) arr[i].each(push);
				return r;
			};
			const lift2 = (oa, ob, f) => oa.isSome() && ob.isSome() ? Optional.some(f(oa.getOrDie(), ob.getOrDie())) : Optional.none();
			const flatten = (oot) => oot.bind(identity);
			const someIf = (b, a) => b ? Optional.some(a) : Optional.none();
			const removeFromStart = (str, numChars) => {
				return str.substring(numChars);
			};
			const checkRange = (str, substr, start) => substr === "" || str.length >= substr.length && str.substr(start, start + substr.length) === substr;
			const removeLeading = (str, prefix) => {
				return startsWith(str, prefix) ? removeFromStart(str, prefix.length) : str;
			};
			const startsWith = (str, prefix) => {
				return checkRange(str, prefix, 0);
			};
			const blank = (r) => (s) => s.replace(r, "");
			const trim = blank(/^\s+|\s+$/g);
			const isNotEmpty = (s) => s.length > 0;
			const isEmpty = (s) => !isNotEmpty(s);
			const toInt = (value, radix = 10) => {
				const num = parseInt(value, radix);
				return isNaN(num) ? Optional.none() : Optional.some(num);
			};
			const toFloat = (value) => {
				const num = parseFloat(value);
				return isNaN(num) ? Optional.none() : Optional.some(num);
			};
			const isSupported = (dom) => dom.style !== void 0 && isFunction(dom.style.getPropertyValue);
			const internalSet = (dom, property, value) => {
				if (!isString(value)) {
					console.error("Invalid call to CSS.set. Property ", property, ":: Value ", value, ":: Element ", dom);
					throw new Error("CSS value must be a string: " + value);
				}
				if (isSupported(dom)) dom.style.setProperty(property, value);
			};
			const internalRemove = (dom, property) => {
				if (isSupported(dom)) dom.style.removeProperty(property);
			};
			const set$1 = (element, property, value) => {
				const dom = element.dom;
				internalSet(dom, property, value);
			};
			const get$1 = (element, property) => {
				const dom = element.dom;
				const r = window.getComputedStyle(dom).getPropertyValue(property);
				return r === "" && !inBody(element) ? getUnsafeProperty(dom, property) : r;
			};
			const getUnsafeProperty = (dom, property) => isSupported(dom) ? dom.style.getPropertyValue(property) : "";
			const getRaw = (element, property) => {
				const dom = element.dom;
				const raw = getUnsafeProperty(dom, property);
				return Optional.from(raw).filter((r) => r.length > 0);
			};
			const remove$1 = (element, property) => {
				const dom = element.dom;
				internalRemove(dom, property);
				if (is(getOpt(element, "style").map(trim), "")) remove$2(element, "style");
			};
			const getAttrValue = (cell$1, name$1, fallback = 0) => getOpt(cell$1, name$1).map((value) => parseInt(value, 10)).getOr(fallback);
			const firstLayer = (scope, selector) => {
				return filterFirstLayer(scope, selector, always);
			};
			const filterFirstLayer = (scope, selector, predicate) => {
				return bind(children$3(scope), (x) => {
					if (is$2(x, selector)) return predicate(x) ? [x] : [];
					else return filterFirstLayer(x, selector, predicate);
				});
			};
			const validSectionList = [
				"tfoot",
				"thead",
				"tbody",
				"colgroup"
			];
			const isValidSection = (parentName) => contains(validSectionList, parentName);
			const grid = (rows$1, columns$1) => ({
				rows: rows$1,
				columns: columns$1
			});
			const detail = (element, rowspan, colspan) => ({
				element,
				rowspan,
				colspan
			});
			const extended = (element, rowspan, colspan, row, column, isLocked) => ({
				element,
				rowspan,
				colspan,
				row,
				column,
				isLocked
			});
			const rowdetail = (element, cells$1, section) => ({
				element,
				cells: cells$1,
				section
			});
			const bounds = (startRow, startCol, finishRow, finishCol) => ({
				startRow,
				startCol,
				finishRow,
				finishCol
			});
			const columnext = (element, colspan, column) => ({
				element,
				colspan,
				column
			});
			const colgroup = (element, columns$1) => ({
				element,
				columns: columns$1
			});
			const lookup = (tags, element, isRoot = never) => {
				if (isRoot(element)) return Optional.none();
				if (contains(tags, name(element))) return Optional.some(element);
				const isRootOrUpperTable = (elm) => is$2(elm, "table") || isRoot(elm);
				return ancestor(element, tags.join(","), isRootOrUpperTable);
			};
			const cell = (element, isRoot) => lookup(["td", "th"], element, isRoot);
			const cells = (ancestor$2) => firstLayer(ancestor$2, "th,td");
			const columns = (ancestor$2) => {
				if (is$2(ancestor$2, "colgroup")) return children$1(ancestor$2, "col");
				else return bind(columnGroups(ancestor$2), (columnGroup) => children$1(columnGroup, "col"));
			};
			const table = (element, isRoot) => closest$1(element, "table", isRoot);
			const rows = (ancestor$2) => firstLayer(ancestor$2, "tr");
			const columnGroups = (ancestor$2) => table(ancestor$2).fold(constant([]), (table$1) => children$1(table$1, "colgroup"));
			const fromRowsOrColGroups = (elems, getSection) => map(elems, (row) => {
				if (name(row) === "colgroup") return rowdetail(row, map(columns(row), (column) => {
					return detail(column, 1, getAttrValue(column, "span", 1));
				}), "colgroup");
				else return rowdetail(row, map(cells(row), (cell$1) => {
					return detail(cell$1, getAttrValue(cell$1, "rowspan", 1), getAttrValue(cell$1, "colspan", 1));
				}), getSection(row));
			});
			const getParentSection = (group) => parent(group).map((parent$1) => {
				const parentName = name(parent$1);
				return isValidSection(parentName) ? parentName : "tbody";
			}).getOr("tbody");
			const fromTable$1 = (table$1) => {
				const rows$1 = rows(table$1);
				return fromRowsOrColGroups([...columnGroups(table$1), ...rows$1], getParentSection);
			};
			const LOCKED_COL_ATTR = "data-snooker-locked-cols";
			const getLockedColumnsFromTable = (table$1) => getOpt(table$1, LOCKED_COL_ATTR).bind((lockedColStr) => Optional.from(lockedColStr.match(/\d+/g))).map((lockedCols) => mapToObject(lockedCols, always));
			const key = (row, column) => {
				return row + "," + column;
			};
			const getAt = (warehouse, row, column) => Optional.from(warehouse.access[key(row, column)]);
			const findItem = (warehouse, item, comparator) => {
				const filtered = filterItems(warehouse, (detail$1) => {
					return comparator(item, detail$1.element);
				});
				return filtered.length > 0 ? Optional.some(filtered[0]) : Optional.none();
			};
			const filterItems = (warehouse, predicate) => {
				return filter(bind(warehouse.all, (r) => {
					return r.cells;
				}), predicate);
			};
			const generateColumns = (rowData) => {
				const columnsGroup = {};
				let index = 0;
				each(rowData.cells, (column) => {
					const colspan = column.colspan;
					range(colspan, (columnIndex) => {
						const colIndex = index + columnIndex;
						columnsGroup[colIndex] = columnext(column.element, colspan, colIndex);
					});
					index += colspan;
				});
				return columnsGroup;
			};
			const generate$1 = (list) => {
				const access = {};
				const cells$1 = [];
				const lockedColumns = head(list).map((rowData) => rowData.element).bind(table).bind(getLockedColumnsFromTable).getOr({});
				let maxRows = 0;
				let maxColumns = 0;
				let rowCount = 0;
				const { pass: colgroupRows, fail: rows$1 } = partition(list, (rowData) => rowData.section === "colgroup");
				each(rows$1, (rowData) => {
					const currentRow = [];
					each(rowData.cells, (rowCell) => {
						let start = 0;
						while (access[key(rowCount, start)] !== void 0) start++;
						const isLocked = hasNonNullableKey(lockedColumns, start.toString());
						const current = extended(rowCell.element, rowCell.rowspan, rowCell.colspan, rowCount, start, isLocked);
						for (let occupiedColumnPosition = 0; occupiedColumnPosition < rowCell.colspan; occupiedColumnPosition++) for (let occupiedRowPosition = 0; occupiedRowPosition < rowCell.rowspan; occupiedRowPosition++) {
							const rowPosition = rowCount + occupiedRowPosition;
							const columnPosition = start + occupiedColumnPosition;
							const newpos = key(rowPosition, columnPosition);
							access[newpos] = current;
							maxColumns = Math.max(maxColumns, columnPosition + 1);
						}
						currentRow.push(current);
					});
					maxRows++;
					cells$1.push(rowdetail(rowData.element, currentRow, rowData.section));
					rowCount++;
				});
				const { columns: columns$1, colgroups } = last(colgroupRows).map((rowData) => {
					const columns$2 = generateColumns(rowData);
					return {
						colgroups: [colgroup(rowData.element, values(columns$2))],
						columns: columns$2
					};
				}).getOrThunk(() => ({
					colgroups: [],
					columns: {}
				}));
				return {
					grid: grid(maxRows, maxColumns),
					access,
					all: cells$1,
					columns: columns$1,
					colgroups
				};
			};
			const fromTable = (table$1) => {
				return generate$1(fromTable$1(table$1));
			};
			const justCells = (warehouse) => bind(warehouse.all, (w) => w.cells);
			const justColumns = (warehouse) => values(warehouse.columns);
			const hasColumns = (warehouse) => keys(warehouse.columns).length > 0;
			const getColumnAt = (warehouse, columnIndex) => Optional.from(warehouse.columns[columnIndex]);
			const Warehouse = {
				fromTable,
				generate: generate$1,
				getAt,
				findItem,
				filterItems,
				justCells,
				justColumns,
				hasColumns,
				getColumnAt
			};
			var global$2 = tinymce.util.Tools.resolve("tinymce.util.Tools");
			const getTDTHOverallStyle = (dom, elm, name$1) => {
				const cells$1 = dom.select("td,th", elm);
				let firstChildStyle;
				for (let i = 0; i < cells$1.length; i++) {
					const currentStyle = dom.getStyle(cells$1[i], name$1);
					if (isUndefined(firstChildStyle)) firstChildStyle = currentStyle;
					if (firstChildStyle !== currentStyle) return "";
				}
				return firstChildStyle;
			};
			const setAlign = (editor, elm, name$1) => {
				global$2.each("left center right".split(" "), (align) => {
					if (align !== name$1) editor.formatter.remove("align" + align, {}, elm);
				});
				if (name$1) editor.formatter.apply("align" + name$1, {}, elm);
			};
			const setVAlign = (editor, elm, name$1) => {
				global$2.each("top middle bottom".split(" "), (align) => {
					if (align !== name$1) editor.formatter.remove("valign" + align, {}, elm);
				});
				if (name$1) editor.formatter.apply("valign" + name$1, {}, elm);
			};
			const fireTableModified = (editor, table$1, data) => {
				editor.dispatch("TableModified", {
					...data,
					table: table$1
				});
			};
			const toNumber = (px, fallback) => toFloat(px).getOr(fallback);
			const getProp = (element, name$1, fallback) => toNumber(get$1(element, name$1), fallback);
			const calcContentBoxSize = (element, size$1, upper, lower) => {
				const paddingUpper = getProp(element, `padding-${upper}`, 0);
				const paddingLower = getProp(element, `padding-${lower}`, 0);
				const borderUpper = getProp(element, `border-${upper}-width`, 0);
				const borderLower = getProp(element, `border-${lower}-width`, 0);
				return size$1 - paddingUpper - paddingLower - borderUpper - borderLower;
			};
			const getCalculatedWidth = (element, boxSizing) => {
				const dom = element.dom;
				const width = dom.getBoundingClientRect().width || dom.offsetWidth;
				return boxSizing === "border-box" ? width : calcContentBoxSize(element, width, "left", "right");
			};
			const getInnerWidth = (element) => getCalculatedWidth(element, "content-box");
			const getInner = getInnerWidth;
			var global$1 = tinymce.util.Tools.resolve("tinymce.Env");
			const defaultTableToolbar = "tableprops tabledelete | tableinsertrowbefore tableinsertrowafter tabledeleterow | tableinsertcolbefore tableinsertcolafter tabledeletecol";
			const defaultCellBorderWidths = range(5, (i) => {
				const size$1 = `${i + 1}px`;
				return {
					title: size$1,
					value: size$1
				};
			});
			const defaultCellBorderStyles = map([
				"Solid",
				"Dotted",
				"Dashed",
				"Double",
				"Groove",
				"Ridge",
				"Inset",
				"Outset",
				"None",
				"Hidden"
			], (type$1) => {
				return {
					title: type$1,
					value: type$1.toLowerCase()
				};
			});
			const defaultWidth = "100%";
			const getPixelForcedWidth = (editor) => {
				var _a;
				const dom = editor.dom;
				const parentBlock = (_a = dom.getParent(editor.selection.getStart(), dom.isBlock)) !== null && _a !== void 0 ? _a : editor.getBody();
				return getInner(SugarElement.fromDom(parentBlock)) + "px";
			};
			const determineDefaultStyles = (editor, defaultStyles) => {
				if (isResponsiveForced(editor) || !shouldStyleWithCss(editor)) return defaultStyles;
				else if (isPixelsForced(editor)) return {
					...defaultStyles,
					width: getPixelForcedWidth(editor)
				};
				else return {
					...defaultStyles,
					width: defaultWidth
				};
			};
			const determineDefaultAttributes = (editor, defaultAttributes) => {
				if (isResponsiveForced(editor) || shouldStyleWithCss(editor)) return defaultAttributes;
				else if (isPixelsForced(editor)) return {
					...defaultAttributes,
					width: getPixelForcedWidth(editor)
				};
				else return {
					...defaultAttributes,
					width: defaultWidth
				};
			};
			const option = (name$1) => (editor) => editor.options.get(name$1);
			const register = (editor) => {
				const registerOption = editor.options.register;
				registerOption("table_border_widths", {
					processor: "object[]",
					default: defaultCellBorderWidths
				});
				registerOption("table_border_styles", {
					processor: "object[]",
					default: defaultCellBorderStyles
				});
				registerOption("table_cell_advtab", {
					processor: "boolean",
					default: true
				});
				registerOption("table_row_advtab", {
					processor: "boolean",
					default: true
				});
				registerOption("table_advtab", {
					processor: "boolean",
					default: true
				});
				registerOption("table_appearance_options", {
					processor: "boolean",
					default: true
				});
				registerOption("table_grid", {
					processor: "boolean",
					default: !global$1.deviceType.isTouch()
				});
				registerOption("table_cell_class_list", {
					processor: "object[]",
					default: []
				});
				registerOption("table_row_class_list", {
					processor: "object[]",
					default: []
				});
				registerOption("table_class_list", {
					processor: "object[]",
					default: []
				});
				registerOption("table_toolbar", {
					processor: "string",
					default: defaultTableToolbar
				});
				registerOption("table_background_color_map", {
					processor: "object[]",
					default: []
				});
				registerOption("table_border_color_map", {
					processor: "object[]",
					default: []
				});
			};
			const getTableSizingMode = option("table_sizing_mode");
			const getTableBorderWidths = option("table_border_widths");
			const getTableBorderStyles = option("table_border_styles");
			const hasAdvancedCellTab = option("table_cell_advtab");
			const hasAdvancedRowTab = option("table_row_advtab");
			const hasAdvancedTableTab = option("table_advtab");
			const hasAppearanceOptions = option("table_appearance_options");
			const hasTableGrid = option("table_grid");
			const shouldStyleWithCss = option("table_style_by_css");
			const getCellClassList = option("table_cell_class_list");
			const getRowClassList = option("table_row_class_list");
			const getTableClassList = option("table_class_list");
			const getToolbar = option("table_toolbar");
			const getTableBackgroundColorMap = option("table_background_color_map");
			const getTableBorderColorMap = option("table_border_color_map");
			const isPixelsForced = (editor) => getTableSizingMode(editor) === "fixed";
			const isResponsiveForced = (editor) => getTableSizingMode(editor) === "responsive";
			const getDefaultStyles = (editor) => {
				const options = editor.options;
				const defaultStyles = options.get("table_default_styles");
				return options.isSet("table_default_styles") ? defaultStyles : determineDefaultStyles(editor, defaultStyles);
			};
			const getDefaultAttributes = (editor) => {
				const options = editor.options;
				const defaultAttributes = options.get("table_default_attributes");
				return options.isSet("table_default_attributes") ? defaultAttributes : determineDefaultAttributes(editor, defaultAttributes);
			};
			const isWithin = (bounds$1, detail$1) => {
				return detail$1.column >= bounds$1.startCol && detail$1.column + detail$1.colspan - 1 <= bounds$1.finishCol && detail$1.row >= bounds$1.startRow && detail$1.row + detail$1.rowspan - 1 <= bounds$1.finishRow;
			};
			const isRectangular = (warehouse, bounds$1) => {
				let isRect = true;
				const detailIsWithin = curry(isWithin, bounds$1);
				for (let i = bounds$1.startRow; i <= bounds$1.finishRow; i++) for (let j = bounds$1.startCol; j <= bounds$1.finishCol; j++) isRect = isRect && Warehouse.getAt(warehouse, i, j).exists(detailIsWithin);
				return isRect ? Optional.some(bounds$1) : Optional.none();
			};
			const getBounds = (detailA, detailB) => {
				return bounds(Math.min(detailA.row, detailB.row), Math.min(detailA.column, detailB.column), Math.max(detailA.row + detailA.rowspan - 1, detailB.row + detailB.rowspan - 1), Math.max(detailA.column + detailA.colspan - 1, detailB.column + detailB.colspan - 1));
			};
			const getAnyBox = (warehouse, startCell, finishCell) => {
				const startCoords = Warehouse.findItem(warehouse, startCell, eq);
				const finishCoords = Warehouse.findItem(warehouse, finishCell, eq);
				return startCoords.bind((sc) => {
					return finishCoords.map((fc) => {
						return getBounds(sc, fc);
					});
				});
			};
			const getBox$1 = (warehouse, startCell, finishCell) => {
				return getAnyBox(warehouse, startCell, finishCell).bind((bounds$1) => {
					return isRectangular(warehouse, bounds$1);
				});
			};
			const getBox = (table$1, first, last$1) => {
				return getBox$1(getWarehouse(table$1), first, last$1);
			};
			const getWarehouse = Warehouse.fromTable;
			const before = (marker, element) => {
				parent(marker).each((v) => {
					v.dom.insertBefore(element.dom, marker.dom);
				});
			};
			const after$1 = (marker, element) => {
				nextSibling(marker).fold(() => {
					parent(marker).each((v) => {
						append$1(v, element);
					});
				}, (v) => {
					before(v, element);
				});
			};
			const prepend = (parent$1, element) => {
				firstChild(parent$1).fold(() => {
					append$1(parent$1, element);
				}, (v) => {
					parent$1.dom.insertBefore(element.dom, v.dom);
				});
			};
			const append$1 = (parent$1, element) => {
				parent$1.dom.appendChild(element.dom);
			};
			const wrap = (element, wrapper) => {
				before(element, wrapper);
				append$1(wrapper, element);
			};
			const after = (marker, elements) => {
				each(elements, (x, i) => {
					after$1(i === 0 ? marker : elements[i - 1], x);
				});
			};
			const append = (parent$1, elements) => {
				each(elements, (x) => {
					append$1(parent$1, x);
				});
			};
			const remove = (element) => {
				const dom = element.dom;
				if (dom.parentNode !== null) dom.parentNode.removeChild(dom);
			};
			const unwrap = (wrapper) => {
				const children$4 = children$3(wrapper);
				if (children$4.length > 0) after(wrapper, children$4);
				remove(wrapper);
			};
			const NodeValue = (is$3, name$1) => {
				const get$5 = (element) => {
					if (!is$3(element)) throw new Error("Can only get " + name$1 + " value of a " + name$1 + " node");
					return getOption(element).getOr("");
				};
				const getOption = (element) => is$3(element) ? Optional.from(element.dom.nodeValue) : Optional.none();
				const set$3 = (element, value) => {
					if (!is$3(element)) throw new Error("Can only set raw " + name$1 + " value of a " + name$1 + " node");
					element.dom.nodeValue = value;
				};
				return {
					get: get$5,
					getOption,
					set: set$3
				};
			};
			const api = NodeValue(isText, "text");
			const get = (element) => api.get(element);
			const set = (element, value) => api.set(element, value);
			var TagBoundaries = [
				"body",
				"p",
				"div",
				"article",
				"aside",
				"figcaption",
				"figure",
				"footer",
				"header",
				"nav",
				"section",
				"ol",
				"ul",
				"li",
				"table",
				"thead",
				"tbody",
				"tfoot",
				"caption",
				"tr",
				"td",
				"th",
				"h1",
				"h2",
				"h3",
				"h4",
				"h5",
				"h6",
				"blockquote",
				"pre",
				"address"
			];
			var DomUniverse = () => {
				const clone$1 = (element) => {
					return SugarElement.fromDom(element.dom.cloneNode(false));
				};
				const document$1 = (element) => documentOrOwner(element).dom;
				const isBoundary = (element) => {
					if (!isElement(element)) return false;
					if (name(element) === "body") return true;
					return contains(TagBoundaries, name(element));
				};
				const isEmptyTag = (element) => {
					if (!isElement(element)) return false;
					return contains([
						"br",
						"img",
						"hr",
						"input"
					], name(element));
				};
				const isNonEditable = (element) => isElement(element) && get$2(element, "contenteditable") === "false";
				const comparePosition = (element, other) => {
					return element.dom.compareDocumentPosition(other.dom);
				};
				const copyAttributesTo = (source, destination) => {
					setAll(destination, clone(source));
				};
				const isSpecial = (element) => {
					return contains([
						"script",
						"noscript",
						"iframe",
						"noframes",
						"noembed",
						"title",
						"style",
						"textarea",
						"xmp"
					], name(element));
				};
				const getLanguage = (element) => isElement(element) ? getOpt(element, "lang") : Optional.none();
				return {
					up: constant({
						selector: ancestor,
						closest: closest$1,
						predicate: ancestor$1,
						all: parents
					}),
					down: constant({
						selector: descendants,
						predicate: descendants$1
					}),
					styles: constant({
						get: get$1,
						getRaw,
						set: set$1,
						remove: remove$1
					}),
					attrs: constant({
						get: get$2,
						set: set$2,
						remove: remove$2,
						copyTo: copyAttributesTo
					}),
					insert: constant({
						before,
						after: after$1,
						afterAll: after,
						append: append$1,
						appendAll: append,
						prepend,
						wrap
					}),
					remove: constant({
						unwrap,
						remove
					}),
					create: constant({
						nu: SugarElement.fromTag,
						clone: clone$1,
						text: SugarElement.fromText
					}),
					query: constant({
						comparePosition,
						prevSibling,
						nextSibling
					}),
					property: constant({
						children: children$3,
						name,
						parent,
						document: document$1,
						isText,
						isComment,
						isElement,
						isSpecial,
						getLanguage,
						getText: get,
						setText: set,
						isBoundary,
						isEmptyTag,
						isNonEditable
					}),
					eq,
					is: is$1
				};
			};
			const all = (universe$1, look, elements, f) => {
				const head$1 = elements[0];
				return f(universe$1, look, head$1, elements.slice(1));
			};
			const oneAll = (universe$1, look, elements) => {
				return elements.length > 0 ? all(universe$1, look, elements, unsafeOne) : Optional.none();
			};
			const unsafeOne = (universe$1, look, head$1, tail) => {
				return foldr(tail, (b, a) => {
					return commonElement(universe$1, b, look(universe$1, a));
				}, look(universe$1, head$1));
			};
			const commonElement = (universe$1, start, end) => {
				return start.bind((s) => {
					return end.filter(curry(universe$1.eq, s));
				});
			};
			const sharedOne$1 = oneAll;
			const universe = DomUniverse();
			const sharedOne = (look, elements) => {
				return sharedOne$1(universe, (_universe, element) => {
					return look(element);
				}, elements);
			};
			const lookupTable = (container) => {
				return ancestor(container, "table");
			};
			const retrieve$1 = (container, selector) => {
				const sels = descendants(container, selector);
				return sels.length > 0 ? Optional.some(sels) : Optional.none();
			};
			const getEdges = (container, firstSelectedSelector, lastSelectedSelector) => {
				return descendant(container, firstSelectedSelector).bind((first) => {
					return descendant(container, lastSelectedSelector).bind((last$1) => {
						return sharedOne(lookupTable, [first, last$1]).map((table$1) => {
							return {
								first,
								last: last$1,
								table: table$1
							};
						});
					});
				});
			};
			const retrieve = (container, selector) => {
				return retrieve$1(container, selector);
			};
			const retrieveBox = (container, firstSelectedSelector, lastSelectedSelector) => {
				return getEdges(container, firstSelectedSelector, lastSelectedSelector).bind((edges) => {
					const isRoot = (ancestor$2) => {
						return eq(container, ancestor$2);
					};
					const sectionSelector = "thead,tfoot,tbody,table";
					const firstAncestor = ancestor(edges.first, sectionSelector, isRoot);
					const lastAncestor = ancestor(edges.last, sectionSelector, isRoot);
					return firstAncestor.bind((fA) => {
						return lastAncestor.bind((lA) => {
							return eq(fA, lA) ? getBox(edges.table, edges.first, edges.last) : Optional.none();
						});
					});
				});
			};
			const fromDom = (nodes) => map(nodes, SugarElement.fromDom);
			const strSelected = "data-mce-selected";
			const strSelectedSelector = "td[" + strSelected + "],th[data-mce-selected]";
			const strFirstSelected = "data-mce-first-selected";
			const strFirstSelectedSelector = "td[" + strFirstSelected + "],th[data-mce-first-selected]";
			const strLastSelected = "data-mce-last-selected";
			const ephemera = {
				selected: strSelected,
				selectedSelector: strSelectedSelector,
				firstSelected: strFirstSelected,
				firstSelectedSelector: strFirstSelectedSelector,
				lastSelected: strLastSelected,
				lastSelectedSelector: "td[" + strLastSelected + "],th[data-mce-last-selected]"
			};
			const getSelectionCellFallback = (element) => table(element).bind((table$1) => retrieve(table$1, ephemera.firstSelectedSelector)).fold(constant(element), (cells$1) => cells$1[0]);
			const getSelectionFromSelector = (selector) => (initCell, isRoot) => {
				const cellName = name(initCell);
				return closest$1(cellName === "col" || cellName === "colgroup" ? getSelectionCellFallback(initCell) : initCell, selector, isRoot);
			};
			const getSelectionCellOrCaption = getSelectionFromSelector("th,td,caption");
			const getSelectionCell = getSelectionFromSelector("th,td");
			const getCellsFromSelection = (editor) => fromDom(editor.model.table.getSelectedCells());
			const getRowsFromSelection = (selected, selector) => {
				const cellOpt = getSelectionCell(selected);
				return lift2(cellOpt, cellOpt.bind((cell$1) => table(cell$1)).map((table$1) => rows(table$1)), (cell$1, rows$1) => filter(rows$1, (row) => exists(fromDom(row.dom.cells), (rowCell) => get$2(rowCell, selector) === "1" || eq(rowCell, cell$1)))).getOr([]);
			};
			const verticalAlignValues = [
				{
					text: "None",
					value: ""
				},
				{
					text: "Top",
					value: "top"
				},
				{
					text: "Middle",
					value: "middle"
				},
				{
					text: "Bottom",
					value: "bottom"
				}
			];
			const hexColour = (value) => ({ value: normalizeHex(value) });
			const shorthandRegex = /^#?([a-f\d])([a-f\d])([a-f\d])$/i;
			const longformRegex = /^#?([a-f\d]{2})([a-f\d]{2})([a-f\d]{2})$/i;
			const isHexString = (hex) => shorthandRegex.test(hex) || longformRegex.test(hex);
			const normalizeHex = (hex) => removeLeading(hex, "#").toUpperCase();
			const fromString$1 = (hex) => isHexString(hex) ? Optional.some({ value: normalizeHex(hex) }) : Optional.none();
			const toHex = (component) => {
				const hex = component.toString(16);
				return (hex.length === 1 ? "0" + hex : hex).toUpperCase();
			};
			const fromRgba = (rgbaColour$1) => {
				return hexColour(toHex(rgbaColour$1.red) + toHex(rgbaColour$1.green) + toHex(rgbaColour$1.blue));
			};
			const rgbRegex = /^\s*rgb\s*\(\s*(\d+)\s*,\s*(\d+)\s*,\s*(\d+)\s*\)\s*$/i;
			const rgbaRegex = /^\s*rgba\s*\(\s*(\d+)\s*,\s*(\d+)\s*,\s*(\d+)\s*,\s*(\d?(?:\.\d+)?)\s*\)\s*$/i;
			const rgbaColour = (red, green, blue, alpha) => ({
				red,
				green,
				blue,
				alpha
			});
			const fromStringValues = (red, green, blue, alpha) => {
				return rgbaColour(parseInt(red, 10), parseInt(green, 10), parseInt(blue, 10), parseFloat(alpha));
			};
			const fromString = (rgbaString) => {
				if (rgbaString === "transparent") return Optional.some(rgbaColour(0, 0, 0, 0));
				const rgbMatch = rgbRegex.exec(rgbaString);
				if (rgbMatch !== null) return Optional.some(fromStringValues(rgbMatch[1], rgbMatch[2], rgbMatch[3], "1"));
				const rgbaMatch = rgbaRegex.exec(rgbaString);
				if (rgbaMatch !== null) return Optional.some(fromStringValues(rgbaMatch[1], rgbaMatch[2], rgbaMatch[3], rgbaMatch[4]));
				return Optional.none();
			};
			const anyToHex = (color) => fromString$1(color).orThunk(() => fromString(color).map(fromRgba)).getOrThunk(() => {
				const canvas = document.createElement("canvas");
				canvas.height = 1;
				canvas.width = 1;
				const canvasContext = canvas.getContext("2d");
				canvasContext.clearRect(0, 0, canvas.width, canvas.height);
				canvasContext.fillStyle = "#FFFFFF";
				canvasContext.fillStyle = color;
				canvasContext.fillRect(0, 0, 1, 1);
				const rgba = canvasContext.getImageData(0, 0, 1, 1).data;
				const r = rgba[0];
				const g = rgba[1];
				const b = rgba[2];
				const a = rgba[3];
				return fromRgba(rgbaColour(r, g, b, a));
			});
			const rgbaToHexString = (color) => fromString(color).map(fromRgba).map((h) => "#" + h.value).getOr(color);
			const Cell = (initial) => {
				let value = initial;
				const get$5 = () => {
					return value;
				};
				const set$3 = (v) => {
					value = v;
				};
				return {
					get: get$5,
					set: set$3
				};
			};
			const singleton = (doRevoke) => {
				const subject = Cell(Optional.none());
				const revoke = () => subject.get().each(doRevoke);
				const clear = () => {
					revoke();
					subject.set(Optional.none());
				};
				const isSet = () => subject.get().isSome();
				const get$5 = () => subject.get();
				const set$3 = (s) => {
					revoke();
					subject.set(Optional.some(s));
				};
				return {
					clear,
					isSet,
					get: get$5,
					set: set$3
				};
			};
			const unbindable = () => singleton((s) => s.unbind());
			const onSetupToggle = (editor, formatName, formatValue) => {
				return (api$1) => {
					const boundCallback = unbindable();
					const isNone = isEmpty(formatValue);
					const init = () => {
						const selectedCells = getCellsFromSelection(editor);
						const checkNode = (cell$1) => editor.formatter.match(formatName, { value: formatValue }, cell$1.dom, isNone);
						if (isNone) {
							api$1.setActive(!exists(selectedCells, checkNode));
							boundCallback.set(editor.formatter.formatChanged(formatName, (match) => api$1.setActive(!match), true));
						} else {
							api$1.setActive(forall(selectedCells, checkNode));
							boundCallback.set(editor.formatter.formatChanged(formatName, api$1.setActive, false, { value: formatValue }));
						}
					};
					editor.initialized ? init() : editor.on("init", init);
					return boundCallback.clear;
				};
			};
			const isListGroup = (item) => hasNonNullableKey(item, "menu");
			const buildListItems = (items) => map(items, (item) => {
				const text = item.text || item.title || "";
				if (isListGroup(item)) return {
					text,
					items: buildListItems(item.menu)
				};
				else return {
					text,
					value: item.value
				};
			});
			const buildMenuItems = (editor, items, format, onAction) => map(items, (item) => {
				const text = item.text || item.title;
				if (isListGroup(item)) return {
					type: "nestedmenuitem",
					text,
					getSubmenuItems: () => buildMenuItems(editor, item.menu, format, onAction)
				};
				else return {
					text,
					type: "togglemenuitem",
					onAction: () => onAction(item.value),
					onSetup: onSetupToggle(editor, format, item.value)
				};
			});
			const applyTableCellStyle = (editor, style) => (value) => {
				editor.execCommand("mceTableApplyCellStyle", false, { [style]: value });
			};
			const filterNoneItem = (list) => bind(list, (item) => {
				if (isListGroup(item)) return [{
					...item,
					menu: filterNoneItem(item.menu)
				}];
				else return isNotEmpty(item.value) ? [item] : [];
			});
			const generateMenuItemsCallback = (editor, items, format, onAction) => (callback) => callback(buildMenuItems(editor, items, format, onAction));
			const buildColorMenu = (editor, colorList, style) => {
				const colorMap = map(colorList, (entry) => ({
					text: entry.title,
					value: "#" + anyToHex(entry.value).value,
					type: "choiceitem"
				}));
				return [{
					type: "fancymenuitem",
					fancytype: "colorswatch",
					initData: {
						colors: colorMap.length > 0 ? colorMap : void 0,
						allowCustomColors: false
					},
					onAction: (data) => {
						const value = data.value === "remove" ? "" : data.value;
						editor.execCommand("mceTableApplyCellStyle", false, { [style]: value });
					}
				}];
			};
			const changeRowHeader = (editor) => () => {
				const newType = editor.queryCommandValue("mceTableRowType") === "header" ? "body" : "header";
				editor.execCommand("mceTableRowType", false, { type: newType });
			};
			const changeColumnHeader = (editor) => () => {
				const newType = editor.queryCommandValue("mceTableColType") === "th" ? "td" : "th";
				editor.execCommand("mceTableColType", false, { type: newType });
			};
			const getClassList$1 = (editor) => {
				const classes = buildListItems(getCellClassList(editor));
				if (classes.length > 0) return Optional.some({
					name: "class",
					type: "listbox",
					label: "Class",
					items: classes
				});
				return Optional.none();
			};
			const children = [
				{
					name: "width",
					type: "input",
					label: "Width"
				},
				{
					name: "height",
					type: "input",
					label: "Height"
				},
				{
					name: "celltype",
					type: "listbox",
					label: "Cell type",
					items: [{
						text: "Cell",
						value: "td"
					}, {
						text: "Header cell",
						value: "th"
					}]
				},
				{
					name: "scope",
					type: "listbox",
					label: "Scope",
					items: [
						{
							text: "None",
							value: ""
						},
						{
							text: "Row",
							value: "row"
						},
						{
							text: "Column",
							value: "col"
						},
						{
							text: "Row group",
							value: "rowgroup"
						},
						{
							text: "Column group",
							value: "colgroup"
						}
					]
				},
				{
					name: "halign",
					type: "listbox",
					label: "Horizontal align",
					items: [
						{
							text: "None",
							value: ""
						},
						{
							text: "Left",
							value: "left"
						},
						{
							text: "Center",
							value: "center"
						},
						{
							text: "Right",
							value: "right"
						}
					]
				},
				{
					name: "valign",
					type: "listbox",
					label: "Vertical align",
					items: verticalAlignValues
				}
			];
			const getItems$2 = (editor) => children.concat(getClassList$1(editor).toArray());
			const getAdvancedTab = (editor, dialogName) => {
				const advTabItems = [
					{
						name: "borderstyle",
						type: "listbox",
						label: "Border style",
						items: [{
							text: "Select...",
							value: ""
						}].concat(buildListItems(getTableBorderStyles(editor)))
					},
					{
						name: "bordercolor",
						type: "colorinput",
						label: "Border color"
					},
					{
						name: "backgroundcolor",
						type: "colorinput",
						label: "Background color"
					}
				];
				return {
					title: "Advanced",
					name: "advanced",
					items: dialogName === "cell" ? [{
						name: "borderwidth",
						type: "input",
						label: "Border width"
					}].concat(advTabItems) : advTabItems
				};
			};
			const normal = (editor, element) => {
				const dom = editor.dom;
				const setAttrib = (attr, value) => {
					dom.setAttrib(element, attr, value);
				};
				const setStyle = (prop, value) => {
					dom.setStyle(element, prop, value);
				};
				const setFormat = (formatName, value) => {
					if (value === "") editor.formatter.remove(formatName, { value: null }, element, true);
					else editor.formatter.apply(formatName, { value }, element);
				};
				return {
					setAttrib,
					setStyle,
					setFormat
				};
			};
			const DomModifier = { normal };
			const isHeaderCell = isTag("th");
			const getRowHeaderType = (isHeaderRow, isHeaderCells) => {
				if (isHeaderRow && isHeaderCells) return "sectionCells";
				else if (isHeaderRow) return "section";
				else return "cells";
			};
			const getRowType$1 = (row) => {
				const isHeaderRow = row.section === "thead";
				const isHeaderCells = is(findCommonCellType(row.cells), "th");
				if (row.section === "tfoot") return { type: "footer" };
				else if (isHeaderRow || isHeaderCells) return {
					type: "header",
					subType: getRowHeaderType(isHeaderRow, isHeaderCells)
				};
				else return { type: "body" };
			};
			const findCommonCellType = (cells$1) => {
				const headerCells = filter(cells$1, (cell$1) => isHeaderCell(cell$1.element));
				if (headerCells.length === 0) return Optional.some("td");
				else if (headerCells.length === cells$1.length) return Optional.some("th");
				else return Optional.none();
			};
			const findCommonRowType = (rows$1) => {
				const rowTypes = map(rows$1, (row) => getRowType$1(row).type);
				const hasHeader = contains(rowTypes, "header");
				const hasFooter = contains(rowTypes, "footer");
				if (!hasHeader && !hasFooter) return Optional.some("body");
				else {
					const hasBody = contains(rowTypes, "body");
					if (hasHeader && !hasBody && !hasFooter) return Optional.some("header");
					else if (!hasHeader && !hasBody && hasFooter) return Optional.some("footer");
					else return Optional.none();
				}
			};
			const cached = (f) => {
				let called = false;
				let r;
				return (...args) => {
					if (!called) {
						called = true;
						r = f.apply(null, args);
					}
					return r;
				};
			};
			const findInWarehouse = (warehouse, element) => findMap(warehouse.all, (r) => find(r.cells, (e) => eq(element, e.element)));
			const extractCells = (warehouse, target, predicate) => {
				const cells$1 = cat(map(target.selection, (cell$1) => {
					return cell(cell$1).bind((lc) => findInWarehouse(warehouse, lc)).filter(predicate);
				}));
				return someIf(cells$1.length > 0, cells$1);
			};
			const onMergable = (_warehouse, target) => target.mergable;
			const onUnmergable = (_warehouse, target) => target.unmergable;
			const onCells = (warehouse, target) => extractCells(warehouse, target, always);
			const isUnlockedTableCell = (warehouse, cell$1) => findInWarehouse(warehouse, cell$1).exists((detail$1) => !detail$1.isLocked);
			const allUnlocked = (warehouse, cells$1) => forall(cells$1, (cell$1) => isUnlockedTableCell(warehouse, cell$1));
			const onUnlockedMergable = (warehouse, target) => onMergable(warehouse, target).filter((mergeable) => allUnlocked(warehouse, mergeable.cells));
			const onUnlockedUnmergable = (warehouse, target) => onUnmergable(warehouse, target).filter((cells$1) => allUnlocked(warehouse, cells$1));
			const generate = (cases) => {
				if (!isArray(cases)) throw new Error("cases must be an array");
				if (cases.length === 0) throw new Error("there must be at least one case");
				const constructors = [];
				const adt = {};
				each(cases, (acase, count) => {
					const keys$1 = keys(acase);
					if (keys$1.length !== 1) throw new Error("one and only one name per case");
					const key$1 = keys$1[0];
					const value = acase[key$1];
					if (adt[key$1] !== void 0) throw new Error("duplicate key detected:" + key$1);
					else if (key$1 === "cata") throw new Error("cannot have a case named cata (sorry)");
					else if (!isArray(value)) throw new Error("case arguments must be an array");
					constructors.push(key$1);
					adt[key$1] = (...args) => {
						const argLength = args.length;
						if (argLength !== value.length) throw new Error("Wrong number of arguments to case " + key$1 + ". Expected " + value.length + " (" + value + "), got " + argLength);
						const match = (branches) => {
							const branchKeys = keys(branches);
							if (constructors.length !== branchKeys.length) throw new Error("Wrong number of arguments to match. Expected: " + constructors.join(",") + "\nActual: " + branchKeys.join(","));
							if (!forall(constructors, (reqKey) => {
								return contains(branchKeys, reqKey);
							})) throw new Error("Not all branches were specified when using match. Specified: " + branchKeys.join(", ") + "\nRequired: " + constructors.join(", "));
							return branches[key$1].apply(null, args);
						};
						return {
							fold: (...foldArgs) => {
								if (foldArgs.length !== cases.length) throw new Error("Wrong number of arguments to fold. Expected " + cases.length + ", got " + foldArgs.length);
								return foldArgs[count].apply(null, args);
							},
							match,
							log: (label) => {
								console.log(label, {
									constructors,
									constructor: key$1,
									params: args
								});
							}
						};
					};
				});
				return adt;
			};
			({ ...{ generate }.generate([
				{ none: [] },
				{ only: ["index"] },
				{ left: ["index", "next"] },
				{ middle: [
					"prev",
					"index",
					"next"
				] },
				{ right: ["prev", "index"] }
			]) });
			const opGetRowsType = (table$1, target) => {
				const house = Warehouse.fromTable(table$1);
				return onCells(house, target).bind((selectedCells) => {
					const lastSelectedCell = selectedCells[selectedCells.length - 1];
					const minRowRange = selectedCells[0].row;
					const maxRowRange = lastSelectedCell.row + lastSelectedCell.rowspan;
					return findCommonRowType(house.all.slice(minRowRange, maxRowRange));
				}).getOr("");
			};
			const getRowsType = opGetRowsType;
			const rgbToHex = (value) => startsWith(value, "rgb") ? rgbaToHexString(value) : value;
			const extractAdvancedStyles = (elm) => {
				const element = SugarElement.fromDom(elm);
				return {
					borderwidth: getRaw(element, "border-width").getOr(""),
					borderstyle: getRaw(element, "border-style").getOr(""),
					bordercolor: getRaw(element, "border-color").map(rgbToHex).getOr(""),
					backgroundcolor: getRaw(element, "background-color").map(rgbToHex).getOr("")
				};
			};
			const getSharedValues = (data) => {
				const baseData = data[0];
				each(data.slice(1), (items) => {
					each(keys(baseData), (key$1) => {
						each$1(items, (itemValue, itemKey) => {
							const comparisonValue = baseData[key$1];
							if (comparisonValue !== "" && key$1 === itemKey) {
								if (comparisonValue !== itemValue) baseData[key$1] = "";
							}
						});
					});
				});
				return baseData;
			};
			const getAlignment = (formats, formatName, editor, elm) => find(formats, (name$1) => !isUndefined(editor.formatter.matchNode(elm, formatName + name$1))).getOr("");
			const getHAlignment = curry(getAlignment, [
				"left",
				"center",
				"right"
			], "align");
			const getVAlignment = curry(getAlignment, [
				"top",
				"middle",
				"bottom"
			], "valign");
			const extractDataFromSettings = (editor, hasAdvTableTab) => {
				const style = getDefaultStyles(editor);
				const attrs = getDefaultAttributes(editor);
				const extractAdvancedStyleData = () => ({
					borderstyle: get$4(style, "border-style").getOr(""),
					bordercolor: rgbToHex(get$4(style, "border-color").getOr("")),
					backgroundcolor: rgbToHex(get$4(style, "background-color").getOr(""))
				});
				const defaultData = {
					height: "",
					width: "100%",
					cellspacing: "",
					cellpadding: "",
					caption: false,
					class: "",
					align: "",
					border: ""
				};
				const getBorder = () => {
					const borderWidth = style["border-width"];
					if (shouldStyleWithCss(editor) && borderWidth) return { border: borderWidth };
					return get$4(attrs, "border").fold(() => ({}), (border) => ({ border }));
				};
				const advStyle = hasAdvTableTab ? extractAdvancedStyleData() : {};
				const getCellPaddingCellSpacing = () => {
					const spacing = get$4(style, "border-spacing").or(get$4(attrs, "cellspacing")).fold(() => ({}), (cellspacing) => ({ cellspacing }));
					const padding = get$4(style, "border-padding").or(get$4(attrs, "cellpadding")).fold(() => ({}), (cellpadding) => ({ cellpadding }));
					return {
						...spacing,
						...padding
					};
				};
				return {
					...defaultData,
					...style,
					...attrs,
					...advStyle,
					...getBorder(),
					...getCellPaddingCellSpacing()
				};
			};
			const getRowType = (elm) => table(SugarElement.fromDom(elm)).map((table$1) => {
				return getRowsType(table$1, { selection: fromDom(elm.cells) });
			}).getOr("");
			const extractDataFromTableElement = (editor, elm, hasAdvTableTab) => {
				const getBorder = (dom$1, elm$1) => {
					const optBorderWidth = getRaw(SugarElement.fromDom(elm$1), "border-width");
					if (shouldStyleWithCss(editor) && optBorderWidth.isSome()) return optBorderWidth.getOr("");
					return dom$1.getAttrib(elm$1, "border") || getTDTHOverallStyle(editor.dom, elm$1, "border-width") || getTDTHOverallStyle(editor.dom, elm$1, "border") || "";
				};
				const dom = editor.dom;
				const cellspacing = shouldStyleWithCss(editor) ? dom.getStyle(elm, "border-spacing") || dom.getAttrib(elm, "cellspacing") : dom.getAttrib(elm, "cellspacing") || dom.getStyle(elm, "border-spacing");
				const cellpadding = shouldStyleWithCss(editor) ? getTDTHOverallStyle(dom, elm, "padding") || dom.getAttrib(elm, "cellpadding") : dom.getAttrib(elm, "cellpadding") || getTDTHOverallStyle(dom, elm, "padding");
				return {
					width: dom.getStyle(elm, "width") || dom.getAttrib(elm, "width"),
					height: dom.getStyle(elm, "height") || dom.getAttrib(elm, "height"),
					cellspacing: cellspacing !== null && cellspacing !== void 0 ? cellspacing : "",
					cellpadding: cellpadding !== null && cellpadding !== void 0 ? cellpadding : "",
					border: getBorder(dom, elm),
					caption: !!dom.select("caption", elm)[0],
					class: dom.getAttrib(elm, "class", ""),
					align: getHAlignment(editor, elm),
					...hasAdvTableTab ? extractAdvancedStyles(elm) : {}
				};
			};
			const extractDataFromRowElement = (editor, elm, hasAdvancedRowTab$1) => {
				const dom = editor.dom;
				return {
					height: dom.getStyle(elm, "height") || dom.getAttrib(elm, "height"),
					class: dom.getAttrib(elm, "class", ""),
					type: getRowType(elm),
					align: getHAlignment(editor, elm),
					...hasAdvancedRowTab$1 ? extractAdvancedStyles(elm) : {}
				};
			};
			const extractDataFromCellElement = (editor, cell$1, hasAdvancedCellTab$1, column) => {
				const dom = editor.dom;
				const colElm = column.getOr(cell$1);
				const getStyle = (element, style) => dom.getStyle(element, style) || dom.getAttrib(element, style);
				return {
					width: getStyle(colElm, "width"),
					height: getStyle(cell$1, "height"),
					scope: dom.getAttrib(cell$1, "scope"),
					celltype: getNodeName(cell$1),
					class: dom.getAttrib(cell$1, "class", ""),
					halign: getHAlignment(editor, cell$1),
					valign: getVAlignment(editor, cell$1),
					...hasAdvancedCellTab$1 ? extractAdvancedStyles(cell$1) : {}
				};
			};
			const getSelectedCells = (table$1, cells$1) => {
				const warehouse = Warehouse.fromTable(table$1);
				return map(filter(Warehouse.justCells(warehouse), (cellA) => exists(cells$1, (cellB) => eq(cellA.element, cellB))), (cell$1) => ({
					element: cell$1.element.dom,
					column: Warehouse.getColumnAt(warehouse, cell$1.column).map((col) => col.element.dom)
				}));
			};
			const updateSimpleProps$1 = (modifier, colModifier, data, shouldUpdate) => {
				if (shouldUpdate("scope")) modifier.setAttrib("scope", data.scope);
				if (shouldUpdate("class")) modifier.setAttrib("class", data.class);
				if (shouldUpdate("height")) modifier.setStyle("height", addPxSuffix(data.height));
				if (shouldUpdate("width")) colModifier.setStyle("width", addPxSuffix(data.width));
			};
			const updateAdvancedProps$1 = (modifier, data, shouldUpdate) => {
				if (shouldUpdate("backgroundcolor")) modifier.setFormat("tablecellbackgroundcolor", data.backgroundcolor);
				if (shouldUpdate("bordercolor")) modifier.setFormat("tablecellbordercolor", data.bordercolor);
				if (shouldUpdate("borderstyle")) modifier.setFormat("tablecellborderstyle", data.borderstyle);
				if (shouldUpdate("borderwidth")) modifier.setFormat("tablecellborderwidth", addPxSuffix(data.borderwidth));
			};
			const applyStyleData$1 = (editor, cells$1, data, wasChanged) => {
				const isSingleCell = cells$1.length === 1;
				each(cells$1, (item) => {
					const cellElm = item.element;
					const shouldOverrideCurrentValue = isSingleCell ? always : wasChanged;
					const modifier = DomModifier.normal(editor, cellElm);
					updateSimpleProps$1(modifier, item.column.map((col) => DomModifier.normal(editor, col)).getOr(modifier), data, shouldOverrideCurrentValue);
					if (hasAdvancedCellTab(editor)) updateAdvancedProps$1(modifier, data, shouldOverrideCurrentValue);
					if (wasChanged("halign")) setAlign(editor, cellElm, data.halign);
					if (wasChanged("valign")) setVAlign(editor, cellElm, data.valign);
				});
			};
			const applyStructureData$1 = (editor, data) => {
				editor.execCommand("mceTableCellType", false, {
					type: data.celltype,
					no_events: true
				});
			};
			const applyCellData = (editor, cells$1, oldData, data) => {
				const modifiedData = filter$1(data, (value, key$1) => oldData[key$1] !== value);
				if (size(modifiedData) > 0 && cells$1.length >= 1) table(cells$1[0]).each((table$1) => {
					const selectedCells = getSelectedCells(table$1, cells$1);
					const styleModified = size(filter$1(modifiedData, (_value, key$1) => key$1 !== "scope" && key$1 !== "celltype")) > 0;
					const structureModified = has(modifiedData, "celltype");
					if (styleModified || has(modifiedData, "scope")) applyStyleData$1(editor, selectedCells, data, curry(has, modifiedData));
					if (structureModified) applyStructureData$1(editor, data);
					fireTableModified(editor, table$1.dom, {
						structure: structureModified,
						style: styleModified
					});
				});
			};
			const onSubmitCellForm = (editor, cells$1, oldData, api$1) => {
				const data = api$1.getData();
				api$1.close();
				editor.undoManager.transact(() => {
					applyCellData(editor, cells$1, oldData, data);
					editor.focus();
				});
			};
			const getData$1 = (editor, cells$1) => {
				return getSharedValues(table(cells$1[0]).map((table$1) => map(getSelectedCells(table$1, cells$1), (item) => extractDataFromCellElement(editor, item.element, hasAdvancedCellTab(editor), item.column))).getOrDie());
			};
			const open$2 = (editor) => {
				const cells$1 = getCellsFromSelection(editor);
				if (cells$1.length === 0) return;
				const data = getData$1(editor, cells$1);
				const dialogTabPanel = {
					type: "tabpanel",
					tabs: [{
						title: "General",
						name: "general",
						items: getItems$2(editor)
					}, getAdvancedTab(editor, "cell")]
				};
				const dialogPanel = {
					type: "panel",
					items: [{
						type: "grid",
						columns: 2,
						items: getItems$2(editor)
					}]
				};
				editor.windowManager.open({
					title: "Cell Properties",
					size: "normal",
					body: hasAdvancedCellTab(editor) ? dialogTabPanel : dialogPanel,
					buttons: [{
						type: "cancel",
						name: "cancel",
						text: "Cancel"
					}, {
						type: "submit",
						name: "save",
						text: "Save",
						primary: true
					}],
					initialData: data,
					onSubmit: curry(onSubmitCellForm, editor, cells$1, data)
				});
			};
			const getClassList = (editor) => {
				const classes = buildListItems(getRowClassList(editor));
				if (classes.length > 0) return Optional.some({
					name: "class",
					type: "listbox",
					label: "Class",
					items: classes
				});
				return Optional.none();
			};
			const formChildren = [
				{
					type: "listbox",
					name: "type",
					label: "Row type",
					items: [
						{
							text: "Header",
							value: "header"
						},
						{
							text: "Body",
							value: "body"
						},
						{
							text: "Footer",
							value: "footer"
						}
					]
				},
				{
					type: "listbox",
					name: "align",
					label: "Alignment",
					items: [
						{
							text: "None",
							value: ""
						},
						{
							text: "Left",
							value: "left"
						},
						{
							text: "Center",
							value: "center"
						},
						{
							text: "Right",
							value: "right"
						}
					]
				},
				{
					label: "Height",
					name: "height",
					type: "input"
				}
			];
			const getItems$1 = (editor) => formChildren.concat(getClassList(editor).toArray());
			const updateSimpleProps = (modifier, data, shouldUpdate) => {
				if (shouldUpdate("class")) modifier.setAttrib("class", data.class);
				if (shouldUpdate("height")) modifier.setStyle("height", addPxSuffix(data.height));
			};
			const updateAdvancedProps = (modifier, data, shouldUpdate) => {
				if (shouldUpdate("backgroundcolor")) modifier.setStyle("background-color", data.backgroundcolor);
				if (shouldUpdate("bordercolor")) modifier.setStyle("border-color", data.bordercolor);
				if (shouldUpdate("borderstyle")) modifier.setStyle("border-style", data.borderstyle);
			};
			const applyStyleData = (editor, rows$1, data, wasChanged) => {
				const shouldOverrideCurrentValue = rows$1.length === 1 ? always : wasChanged;
				each(rows$1, (rowElm) => {
					const modifier = DomModifier.normal(editor, rowElm);
					updateSimpleProps(modifier, data, shouldOverrideCurrentValue);
					if (hasAdvancedRowTab(editor)) updateAdvancedProps(modifier, data, shouldOverrideCurrentValue);
					if (wasChanged("align")) setAlign(editor, rowElm, data.align);
				});
			};
			const applyStructureData = (editor, data) => {
				editor.execCommand("mceTableRowType", false, {
					type: data.type,
					no_events: true
				});
			};
			const applyRowData = (editor, rows$1, oldData, data) => {
				const modifiedData = filter$1(data, (value, key$1) => oldData[key$1] !== value);
				if (size(modifiedData) > 0) {
					const typeModified = has(modifiedData, "type");
					const styleModified = typeModified ? size(modifiedData) > 1 : true;
					if (styleModified) applyStyleData(editor, rows$1, data, curry(has, modifiedData));
					if (typeModified) applyStructureData(editor, data);
					table(SugarElement.fromDom(rows$1[0])).each((table$1) => fireTableModified(editor, table$1.dom, {
						structure: typeModified,
						style: styleModified
					}));
				}
			};
			const onSubmitRowForm = (editor, rows$1, oldData, api$1) => {
				const data = api$1.getData();
				api$1.close();
				editor.undoManager.transact(() => {
					applyRowData(editor, rows$1, oldData, data);
					editor.focus();
				});
			};
			const open$1 = (editor) => {
				const rows$1 = getRowsFromSelection(getSelectionStart(editor), ephemera.selected);
				if (rows$1.length === 0) return;
				const data = getSharedValues(map(rows$1, (rowElm) => extractDataFromRowElement(editor, rowElm.dom, hasAdvancedRowTab(editor))));
				const dialogTabPanel = {
					type: "tabpanel",
					tabs: [{
						title: "General",
						name: "general",
						items: getItems$1(editor)
					}, getAdvancedTab(editor, "row")]
				};
				const dialogPanel = {
					type: "panel",
					items: [{
						type: "grid",
						columns: 2,
						items: getItems$1(editor)
					}]
				};
				editor.windowManager.open({
					title: "Row Properties",
					size: "normal",
					body: hasAdvancedRowTab(editor) ? dialogTabPanel : dialogPanel,
					buttons: [{
						type: "cancel",
						name: "cancel",
						text: "Cancel"
					}, {
						type: "submit",
						name: "save",
						text: "Save",
						primary: true
					}],
					initialData: data,
					onSubmit: curry(onSubmitRowForm, editor, map(rows$1, (r) => r.dom), data)
				});
			};
			const getItems = (editor, classes, insertNewTable) => {
				const rowColCountItems = !insertNewTable ? [] : [{
					type: "input",
					name: "cols",
					label: "Cols",
					inputMode: "numeric"
				}, {
					type: "input",
					name: "rows",
					label: "Rows",
					inputMode: "numeric"
				}];
				const alwaysItems = [{
					type: "input",
					name: "width",
					label: "Width"
				}, {
					type: "input",
					name: "height",
					label: "Height"
				}];
				const appearanceItems = hasAppearanceOptions(editor) ? [
					{
						type: "input",
						name: "cellspacing",
						label: "Cell spacing",
						inputMode: "numeric"
					},
					{
						type: "input",
						name: "cellpadding",
						label: "Cell padding",
						inputMode: "numeric"
					},
					{
						type: "input",
						name: "border",
						label: "Border width"
					},
					{
						type: "label",
						label: "Caption",
						items: [{
							type: "checkbox",
							name: "caption",
							label: "Show caption"
						}]
					}
				] : [];
				const alignmentItem = [{
					type: "listbox",
					name: "align",
					label: "Alignment",
					items: [
						{
							text: "None",
							value: ""
						},
						{
							text: "Left",
							value: "left"
						},
						{
							text: "Center",
							value: "center"
						},
						{
							text: "Right",
							value: "right"
						}
					]
				}];
				const classListItem = classes.length > 0 ? [{
					type: "listbox",
					name: "class",
					label: "Class",
					items: classes
				}] : [];
				return rowColCountItems.concat(alwaysItems).concat(appearanceItems).concat(alignmentItem).concat(classListItem);
			};
			const styleTDTH = (dom, elm, name$1, value) => {
				if (elm.tagName === "TD" || elm.tagName === "TH") if (isString(name$1) && isNonNullable(value)) dom.setStyle(elm, name$1, value);
				else dom.setStyles(elm, name$1);
				else if (elm.children) for (let i = 0; i < elm.children.length; i++) styleTDTH(dom, elm.children[i], name$1, value);
			};
			const applyDataToElement = (editor, tableElm, data, shouldApplyOnCell) => {
				const dom = editor.dom;
				const attrs = {};
				const styles = {};
				const shouldStyleWithCss$1 = shouldStyleWithCss(editor);
				const hasAdvancedTableTab$1 = hasAdvancedTableTab(editor);
				if (!isUndefined(data.class)) attrs.class = data.class;
				styles.height = addPxSuffix(data.height);
				if (shouldStyleWithCss$1) styles.width = addPxSuffix(data.width);
				else if (dom.getAttrib(tableElm, "width")) attrs.width = removePxSuffix(data.width);
				if (shouldStyleWithCss$1) {
					styles["border-width"] = addPxSuffix(data.border);
					styles["border-spacing"] = addPxSuffix(data.cellspacing);
				} else {
					attrs.border = data.border;
					attrs.cellpadding = data.cellpadding;
					attrs.cellspacing = data.cellspacing;
				}
				if (shouldStyleWithCss$1 && tableElm.children) {
					const cellStyles = {};
					if (shouldApplyOnCell.border) cellStyles["border-width"] = addPxSuffix(data.border);
					if (shouldApplyOnCell.cellpadding) cellStyles.padding = addPxSuffix(data.cellpadding);
					if (hasAdvancedTableTab$1 && shouldApplyOnCell.bordercolor) cellStyles["border-color"] = data.bordercolor;
					if (!isEmpty$1(cellStyles)) for (let i = 0; i < tableElm.children.length; i++) styleTDTH(dom, tableElm.children[i], cellStyles);
				}
				if (hasAdvancedTableTab$1) {
					const advData = data;
					styles["background-color"] = advData.backgroundcolor;
					styles["border-color"] = advData.bordercolor;
					styles["border-style"] = advData.borderstyle;
				}
				dom.setStyles(tableElm, {
					...getDefaultStyles(editor),
					...styles
				});
				dom.setAttribs(tableElm, {
					...getDefaultAttributes(editor),
					...attrs
				});
			};
			const onSubmitTableForm = (editor, tableElm, oldData, api$1) => {
				const dom = editor.dom;
				const data = api$1.getData();
				const modifiedData = filter$1(data, (value, key$1) => oldData[key$1] !== value);
				api$1.close();
				if (data.class === "") delete data.class;
				editor.undoManager.transact(() => {
					if (!tableElm) {
						const cols = toInt(data.cols).getOr(1);
						const rows$1 = toInt(data.rows).getOr(1);
						editor.execCommand("mceInsertTable", false, {
							rows: rows$1,
							columns: cols
						});
						tableElm = getSelectionCell(getSelectionStart(editor), getIsRoot(editor)).bind((cell$1) => table(cell$1, getIsRoot(editor))).map((table$1) => table$1.dom).getOrDie();
					}
					if (size(modifiedData) > 0) {
						const applicableCellProperties = {
							border: has(modifiedData, "border"),
							bordercolor: has(modifiedData, "bordercolor"),
							cellpadding: has(modifiedData, "cellpadding")
						};
						applyDataToElement(editor, tableElm, data, applicableCellProperties);
						const captionElm = dom.select("caption", tableElm)[0];
						if (captionElm && !data.caption || !captionElm && data.caption) editor.execCommand("mceTableToggleCaption");
						setAlign(editor, tableElm, data.align);
					}
					editor.focus();
					editor.addVisual();
					if (size(modifiedData) > 0) {
						const captionModified = has(modifiedData, "caption");
						const styleModified = captionModified ? size(modifiedData) > 1 : true;
						fireTableModified(editor, tableElm, {
							structure: captionModified,
							style: styleModified
						});
					}
				});
			};
			const open = (editor, insertNewTable) => {
				const dom = editor.dom;
				let tableElm;
				let data = extractDataFromSettings(editor, hasAdvancedTableTab(editor));
				if (insertNewTable) {
					data.cols = "1";
					data.rows = "1";
					if (hasAdvancedTableTab(editor)) {
						data.borderstyle = "";
						data.bordercolor = "";
						data.backgroundcolor = "";
					}
				} else {
					tableElm = dom.getParent(editor.selection.getStart(), "table", editor.getBody());
					if (tableElm) data = extractDataFromTableElement(editor, tableElm, hasAdvancedTableTab(editor));
					else if (hasAdvancedTableTab(editor)) {
						data.borderstyle = "";
						data.bordercolor = "";
						data.backgroundcolor = "";
					}
				}
				const classes = buildListItems(getTableClassList(editor));
				if (classes.length > 0) {
					if (data.class) data.class = data.class.replace(/\s*mce\-item\-table\s*/g, "");
				}
				const generalPanel = {
					type: "grid",
					columns: 2,
					items: getItems(editor, classes, insertNewTable)
				};
				const nonAdvancedForm = () => ({
					type: "panel",
					items: [generalPanel]
				});
				const advancedForm = () => ({
					type: "tabpanel",
					tabs: [{
						title: "General",
						name: "general",
						items: [generalPanel]
					}, getAdvancedTab(editor, "table")]
				});
				const dialogBody = hasAdvancedTableTab(editor) ? advancedForm() : nonAdvancedForm();
				editor.windowManager.open({
					title: "Table Properties",
					size: "normal",
					body: dialogBody,
					onSubmit: curry(onSubmitTableForm, editor, tableElm, data),
					buttons: [{
						type: "cancel",
						name: "cancel",
						text: "Cancel"
					}, {
						type: "submit",
						name: "save",
						text: "Save",
						primary: true
					}],
					initialData: data
				});
			};
			const registerCommands = (editor) => {
				const runAction = (f) => {
					if (isInEditableContext(getSelectionStart(editor))) f();
				};
				each$1({
					mceTableProps: curry(open, editor, false),
					mceTableRowProps: curry(open$1, editor),
					mceTableCellProps: curry(open$2, editor),
					mceInsertTableDialog: curry(open, editor, true)
				}, (func, name$1) => editor.addCommand(name$1, () => runAction(func)));
			};
			const child = (scope, selector) => child$1(scope, selector).isSome();
			const selection = identity;
			const unmergable = (selectedCells) => {
				const hasSpan = (elem, type$1) => getOpt(elem, type$1).exists((span) => parseInt(span, 10) > 1);
				const hasRowOrColSpan = (elem) => hasSpan(elem, "rowspan") || hasSpan(elem, "colspan");
				return selectedCells.length > 0 && forall(selectedCells, hasRowOrColSpan) ? Optional.some(selectedCells) : Optional.none();
			};
			const mergable = (table$1, selectedCells, ephemera$1) => {
				if (selectedCells.length <= 1) return Optional.none();
				else return retrieveBox(table$1, ephemera$1.firstSelectedSelector, ephemera$1.lastSelectedSelector).map((bounds$1) => ({
					bounds: bounds$1,
					cells: selectedCells
				}));
			};
			const noMenu = (cell$1) => ({
				element: cell$1,
				mergable: Optional.none(),
				unmergable: Optional.none(),
				selection: [cell$1]
			});
			const forMenu = (selectedCells, table$1, cell$1) => ({
				element: cell$1,
				mergable: mergable(table$1, selectedCells, ephemera),
				unmergable: unmergable(selectedCells),
				selection: selection(selectedCells)
			});
			const getSelectionTargets = (editor) => {
				const targets = Cell(Optional.none());
				const changeHandlers = Cell([]);
				let selectionDetails = Optional.none();
				const isCaption = isTag("caption");
				const isDisabledForSelection = (key$1) => selectionDetails.forall((details) => !details[key$1]);
				const getStart = () => getSelectionCellOrCaption(getSelectionStart(editor), getIsRoot(editor));
				const getEnd = () => getSelectionCellOrCaption(getSelectionEnd(editor), getIsRoot(editor));
				const findTargets = () => getStart().bind((startCellOrCaption) => flatten(lift2(table(startCellOrCaption), getEnd().bind(table), (startTable, endTable) => {
					if (eq(startTable, endTable)) if (isCaption(startCellOrCaption)) return Optional.some(noMenu(startCellOrCaption));
					else return Optional.some(forMenu(getCellsFromSelection(editor), startTable, startCellOrCaption));
					return Optional.none();
				})));
				const getExtractedDetails = (targets$1) => {
					return table(targets$1.element).map((table$1) => {
						const warehouse = Warehouse.fromTable(table$1);
						const locked = foldl(onCells(warehouse, targets$1).getOr([]), (acc, cell$1) => {
							if (cell$1.isLocked) {
								acc.onAny = true;
								if (cell$1.column === 0) acc.onFirst = true;
								else if (cell$1.column + cell$1.colspan >= warehouse.grid.columns) acc.onLast = true;
							}
							return acc;
						}, {
							onAny: false,
							onFirst: false,
							onLast: false
						});
						return {
							mergeable: onUnlockedMergable(warehouse, targets$1).isSome(),
							unmergeable: onUnlockedUnmergable(warehouse, targets$1).isSome(),
							locked
						};
					});
				};
				const resetTargets = () => {
					targets.set(cached(findTargets)());
					selectionDetails = targets.get().bind(getExtractedDetails);
					each(changeHandlers.get(), call);
				};
				const setupHandler = (handler) => {
					handler();
					changeHandlers.set(changeHandlers.get().concat([handler]));
					return () => {
						changeHandlers.set(filter(changeHandlers.get(), (h) => h !== handler));
					};
				};
				const onSetup = (api$1, isDisabled) => setupHandler(() => targets.get().fold(() => {
					api$1.setEnabled(false);
				}, (targets$1) => {
					api$1.setEnabled(!isDisabled(targets$1) && editor.selection.isEditable());
				}));
				const onSetupWithToggle = (api$1, isDisabled, isActive) => setupHandler(() => targets.get().fold(() => {
					api$1.setEnabled(false);
					api$1.setActive(false);
				}, (targets$1) => {
					api$1.setEnabled(!isDisabled(targets$1) && editor.selection.isEditable());
					api$1.setActive(isActive(targets$1));
				}));
				const isDisabledFromLocked = (lockedDisable) => selectionDetails.exists((details) => details.locked[lockedDisable]);
				const onSetupTable = (api$1) => onSetup(api$1, (_) => false);
				const onSetupCellOrRow = (api$1) => onSetup(api$1, (targets$1) => isCaption(targets$1.element));
				const onSetupColumn = (lockedDisable) => (api$1) => onSetup(api$1, (targets$1) => isCaption(targets$1.element) || isDisabledFromLocked(lockedDisable));
				const onSetupPasteable = (getClipboardData) => (api$1) => onSetup(api$1, (targets$1) => isCaption(targets$1.element) || getClipboardData().isNone());
				const onSetupPasteableColumn = (getClipboardData, lockedDisable) => (api$1) => onSetup(api$1, (targets$1) => isCaption(targets$1.element) || getClipboardData().isNone() || isDisabledFromLocked(lockedDisable));
				const onSetupMergeable = (api$1) => onSetup(api$1, (_targets) => isDisabledForSelection("mergeable"));
				const onSetupUnmergeable = (api$1) => onSetup(api$1, (_targets) => isDisabledForSelection("unmergeable"));
				const onSetupTableWithCaption = (api$1) => {
					return onSetupWithToggle(api$1, never, (targets$1) => {
						return table(targets$1.element, getIsRoot(editor)).exists((table$1) => child(table$1, "caption"));
					});
				};
				const onSetupTableHeaders = (command, headerType) => (api$1) => {
					return onSetupWithToggle(api$1, (targets$1) => isCaption(targets$1.element), () => editor.queryCommandValue(command) === headerType);
				};
				const onSetupTableRowHeaders = onSetupTableHeaders("mceTableRowType", "header");
				const onSetupTableColumnHeaders = onSetupTableHeaders("mceTableColType", "th");
				editor.on("NodeChange ExecCommand TableSelectorChange", resetTargets);
				return {
					onSetupTable,
					onSetupCellOrRow,
					onSetupColumn,
					onSetupPasteable,
					onSetupPasteableColumn,
					onSetupMergeable,
					onSetupUnmergeable,
					resetTargets,
					onSetupTableWithCaption,
					onSetupTableRowHeaders,
					onSetupTableColumnHeaders,
					targets: targets.get
				};
			};
			var global = tinymce.util.Tools.resolve("tinymce.FakeClipboard");
			const tableTypeBase = "x-tinymce/dom-table-";
			const tableTypeRow = tableTypeBase + "rows";
			const tableTypeColumn = tableTypeBase + "columns";
			const getData = (type$1) => {
				var _a;
				return findMap((_a = global.read()) !== null && _a !== void 0 ? _a : [], (item) => Optional.from(item.getType(type$1)));
			};
			const getRows = () => getData(tableTypeRow);
			const getColumns = () => getData(tableTypeColumn);
			const onSetupEditable$1 = (editor) => (api$1) => {
				const nodeChanged = () => {
					api$1.setEnabled(editor.selection.isEditable());
				};
				editor.on("NodeChange", nodeChanged);
				nodeChanged();
				return () => {
					editor.off("NodeChange", nodeChanged);
				};
			};
			const addButtons = (editor, selectionTargets) => {
				editor.ui.registry.addMenuButton("table", {
					tooltip: "Table",
					icon: "table",
					onSetup: onSetupEditable$1(editor),
					fetch: (callback) => callback("inserttable | cell row column | advtablesort | tableprops deletetable")
				});
				const cmd = (command) => () => editor.execCommand(command);
				const addButtonIfRegistered = (name$1, spec) => {
					if (editor.queryCommandSupported(spec.command)) editor.ui.registry.addButton(name$1, {
						...spec,
						onAction: isFunction(spec.onAction) ? spec.onAction : cmd(spec.command)
					});
				};
				const addToggleButtonIfRegistered = (name$1, spec) => {
					if (editor.queryCommandSupported(spec.command)) editor.ui.registry.addToggleButton(name$1, {
						...spec,
						onAction: isFunction(spec.onAction) ? spec.onAction : cmd(spec.command)
					});
				};
				addButtonIfRegistered("tableprops", {
					tooltip: "Table properties",
					command: "mceTableProps",
					icon: "table",
					onSetup: selectionTargets.onSetupTable
				});
				addButtonIfRegistered("tabledelete", {
					tooltip: "Delete table",
					command: "mceTableDelete",
					icon: "table-delete-table",
					onSetup: selectionTargets.onSetupTable
				});
				addButtonIfRegistered("tablecellprops", {
					tooltip: "Cell properties",
					command: "mceTableCellProps",
					icon: "table-cell-properties",
					onSetup: selectionTargets.onSetupCellOrRow
				});
				addButtonIfRegistered("tablemergecells", {
					tooltip: "Merge cells",
					command: "mceTableMergeCells",
					icon: "table-merge-cells",
					onSetup: selectionTargets.onSetupMergeable
				});
				addButtonIfRegistered("tablesplitcells", {
					tooltip: "Split cell",
					command: "mceTableSplitCells",
					icon: "table-split-cells",
					onSetup: selectionTargets.onSetupUnmergeable
				});
				addButtonIfRegistered("tableinsertrowbefore", {
					tooltip: "Insert row before",
					command: "mceTableInsertRowBefore",
					icon: "table-insert-row-above",
					onSetup: selectionTargets.onSetupCellOrRow
				});
				addButtonIfRegistered("tableinsertrowafter", {
					tooltip: "Insert row after",
					command: "mceTableInsertRowAfter",
					icon: "table-insert-row-after",
					onSetup: selectionTargets.onSetupCellOrRow
				});
				addButtonIfRegistered("tabledeleterow", {
					tooltip: "Delete row",
					command: "mceTableDeleteRow",
					icon: "table-delete-row",
					onSetup: selectionTargets.onSetupCellOrRow
				});
				addButtonIfRegistered("tablerowprops", {
					tooltip: "Row properties",
					command: "mceTableRowProps",
					icon: "table-row-properties",
					onSetup: selectionTargets.onSetupCellOrRow
				});
				addButtonIfRegistered("tableinsertcolbefore", {
					tooltip: "Insert column before",
					command: "mceTableInsertColBefore",
					icon: "table-insert-column-before",
					onSetup: selectionTargets.onSetupColumn("onFirst")
				});
				addButtonIfRegistered("tableinsertcolafter", {
					tooltip: "Insert column after",
					command: "mceTableInsertColAfter",
					icon: "table-insert-column-after",
					onSetup: selectionTargets.onSetupColumn("onLast")
				});
				addButtonIfRegistered("tabledeletecol", {
					tooltip: "Delete column",
					command: "mceTableDeleteCol",
					icon: "table-delete-column",
					onSetup: selectionTargets.onSetupColumn("onAny")
				});
				addButtonIfRegistered("tablecutrow", {
					tooltip: "Cut row",
					command: "mceTableCutRow",
					icon: "cut-row",
					onSetup: selectionTargets.onSetupCellOrRow
				});
				addButtonIfRegistered("tablecopyrow", {
					tooltip: "Copy row",
					command: "mceTableCopyRow",
					icon: "duplicate-row",
					onSetup: selectionTargets.onSetupCellOrRow
				});
				addButtonIfRegistered("tablepasterowbefore", {
					tooltip: "Paste row before",
					command: "mceTablePasteRowBefore",
					icon: "paste-row-before",
					onSetup: selectionTargets.onSetupPasteable(getRows)
				});
				addButtonIfRegistered("tablepasterowafter", {
					tooltip: "Paste row after",
					command: "mceTablePasteRowAfter",
					icon: "paste-row-after",
					onSetup: selectionTargets.onSetupPasteable(getRows)
				});
				addButtonIfRegistered("tablecutcol", {
					tooltip: "Cut column",
					command: "mceTableCutCol",
					icon: "cut-column",
					onSetup: selectionTargets.onSetupColumn("onAny")
				});
				addButtonIfRegistered("tablecopycol", {
					tooltip: "Copy column",
					command: "mceTableCopyCol",
					icon: "duplicate-column",
					onSetup: selectionTargets.onSetupColumn("onAny")
				});
				addButtonIfRegistered("tablepastecolbefore", {
					tooltip: "Paste column before",
					command: "mceTablePasteColBefore",
					icon: "paste-column-before",
					onSetup: selectionTargets.onSetupPasteableColumn(getColumns, "onFirst")
				});
				addButtonIfRegistered("tablepastecolafter", {
					tooltip: "Paste column after",
					command: "mceTablePasteColAfter",
					icon: "paste-column-after",
					onSetup: selectionTargets.onSetupPasteableColumn(getColumns, "onLast")
				});
				addButtonIfRegistered("tableinsertdialog", {
					tooltip: "Insert table",
					command: "mceInsertTableDialog",
					icon: "table",
					onSetup: onSetupEditable$1(editor)
				});
				const tableClassList = filterNoneItem(getTableClassList(editor));
				if (tableClassList.length !== 0 && editor.queryCommandSupported("mceTableToggleClass")) editor.ui.registry.addMenuButton("tableclass", {
					icon: "table-classes",
					tooltip: "Table styles",
					fetch: generateMenuItemsCallback(editor, tableClassList, "tableclass", (value) => editor.execCommand("mceTableToggleClass", false, value)),
					onSetup: selectionTargets.onSetupTable
				});
				const tableCellClassList = filterNoneItem(getCellClassList(editor));
				if (tableCellClassList.length !== 0 && editor.queryCommandSupported("mceTableCellToggleClass")) editor.ui.registry.addMenuButton("tablecellclass", {
					icon: "table-cell-classes",
					tooltip: "Cell styles",
					fetch: generateMenuItemsCallback(editor, tableCellClassList, "tablecellclass", (value) => editor.execCommand("mceTableCellToggleClass", false, value)),
					onSetup: selectionTargets.onSetupCellOrRow
				});
				if (editor.queryCommandSupported("mceTableApplyCellStyle")) {
					editor.ui.registry.addMenuButton("tablecellvalign", {
						icon: "vertical-align",
						tooltip: "Vertical align",
						fetch: generateMenuItemsCallback(editor, verticalAlignValues, "tablecellverticalalign", applyTableCellStyle(editor, "vertical-align")),
						onSetup: selectionTargets.onSetupCellOrRow
					});
					editor.ui.registry.addMenuButton("tablecellborderwidth", {
						icon: "border-width",
						tooltip: "Border width",
						fetch: generateMenuItemsCallback(editor, getTableBorderWidths(editor), "tablecellborderwidth", applyTableCellStyle(editor, "border-width")),
						onSetup: selectionTargets.onSetupCellOrRow
					});
					editor.ui.registry.addMenuButton("tablecellborderstyle", {
						icon: "border-style",
						tooltip: "Border style",
						fetch: generateMenuItemsCallback(editor, getTableBorderStyles(editor), "tablecellborderstyle", applyTableCellStyle(editor, "border-style")),
						onSetup: selectionTargets.onSetupCellOrRow
					});
					editor.ui.registry.addMenuButton("tablecellbackgroundcolor", {
						icon: "cell-background-color",
						tooltip: "Background color",
						fetch: (callback) => callback(buildColorMenu(editor, getTableBackgroundColorMap(editor), "background-color")),
						onSetup: selectionTargets.onSetupCellOrRow
					});
					editor.ui.registry.addMenuButton("tablecellbordercolor", {
						icon: "cell-border-color",
						tooltip: "Border color",
						fetch: (callback) => callback(buildColorMenu(editor, getTableBorderColorMap(editor), "border-color")),
						onSetup: selectionTargets.onSetupCellOrRow
					});
				}
				addToggleButtonIfRegistered("tablecaption", {
					tooltip: "Table caption",
					icon: "table-caption",
					command: "mceTableToggleCaption",
					onSetup: selectionTargets.onSetupTableWithCaption
				});
				addToggleButtonIfRegistered("tablerowheader", {
					tooltip: "Row header",
					icon: "table-top-header",
					command: "mceTableRowType",
					onAction: changeRowHeader(editor),
					onSetup: selectionTargets.onSetupTableRowHeaders
				});
				addToggleButtonIfRegistered("tablecolheader", {
					tooltip: "Column header",
					icon: "table-left-header",
					command: "mceTableColType",
					onAction: changeColumnHeader(editor),
					onSetup: selectionTargets.onSetupTableColumnHeaders
				});
			};
			const addToolbars = (editor) => {
				const isEditableTable = (table$1) => editor.dom.is(table$1, "table") && editor.getBody().contains(table$1) && editor.dom.isEditable(table$1.parentNode);
				const toolbar = getToolbar(editor);
				if (toolbar.length > 0) editor.ui.registry.addContextToolbar("table", {
					predicate: isEditableTable,
					items: toolbar,
					scope: "node",
					position: "node"
				});
			};
			const onSetupEditable = (editor) => (api$1) => {
				const nodeChanged = () => {
					api$1.setEnabled(editor.selection.isEditable());
				};
				editor.on("NodeChange", nodeChanged);
				nodeChanged();
				return () => {
					editor.off("NodeChange", nodeChanged);
				};
			};
			const addMenuItems = (editor, selectionTargets) => {
				const cmd = (command) => () => editor.execCommand(command);
				const addMenuIfRegistered = (name$1, spec) => {
					if (editor.queryCommandSupported(spec.command)) {
						editor.ui.registry.addMenuItem(name$1, {
							...spec,
							onAction: isFunction(spec.onAction) ? spec.onAction : cmd(spec.command)
						});
						return true;
					} else return false;
				};
				const addToggleMenuIfRegistered = (name$1, spec) => {
					if (editor.queryCommandSupported(spec.command)) editor.ui.registry.addToggleMenuItem(name$1, {
						...spec,
						onAction: isFunction(spec.onAction) ? spec.onAction : cmd(spec.command)
					});
				};
				const insertTableAction = (data) => {
					editor.execCommand("mceInsertTable", false, {
						rows: data.numRows,
						columns: data.numColumns
					});
				};
				const hasRowMenuItems = [
					addMenuIfRegistered("tableinsertrowbefore", {
						text: "Insert row before",
						icon: "table-insert-row-above",
						command: "mceTableInsertRowBefore",
						onSetup: selectionTargets.onSetupCellOrRow
					}),
					addMenuIfRegistered("tableinsertrowafter", {
						text: "Insert row after",
						icon: "table-insert-row-after",
						command: "mceTableInsertRowAfter",
						onSetup: selectionTargets.onSetupCellOrRow
					}),
					addMenuIfRegistered("tabledeleterow", {
						text: "Delete row",
						icon: "table-delete-row",
						command: "mceTableDeleteRow",
						onSetup: selectionTargets.onSetupCellOrRow
					}),
					addMenuIfRegistered("tablerowprops", {
						text: "Row properties",
						icon: "table-row-properties",
						command: "mceTableRowProps",
						onSetup: selectionTargets.onSetupCellOrRow
					}),
					addMenuIfRegistered("tablecutrow", {
						text: "Cut row",
						icon: "cut-row",
						command: "mceTableCutRow",
						onSetup: selectionTargets.onSetupCellOrRow
					}),
					addMenuIfRegistered("tablecopyrow", {
						text: "Copy row",
						icon: "duplicate-row",
						command: "mceTableCopyRow",
						onSetup: selectionTargets.onSetupCellOrRow
					}),
					addMenuIfRegistered("tablepasterowbefore", {
						text: "Paste row before",
						icon: "paste-row-before",
						command: "mceTablePasteRowBefore",
						onSetup: selectionTargets.onSetupPasteable(getRows)
					}),
					addMenuIfRegistered("tablepasterowafter", {
						text: "Paste row after",
						icon: "paste-row-after",
						command: "mceTablePasteRowAfter",
						onSetup: selectionTargets.onSetupPasteable(getRows)
					})
				];
				const hasColumnMenuItems = [
					addMenuIfRegistered("tableinsertcolumnbefore", {
						text: "Insert column before",
						icon: "table-insert-column-before",
						command: "mceTableInsertColBefore",
						onSetup: selectionTargets.onSetupColumn("onFirst")
					}),
					addMenuIfRegistered("tableinsertcolumnafter", {
						text: "Insert column after",
						icon: "table-insert-column-after",
						command: "mceTableInsertColAfter",
						onSetup: selectionTargets.onSetupColumn("onLast")
					}),
					addMenuIfRegistered("tabledeletecolumn", {
						text: "Delete column",
						icon: "table-delete-column",
						command: "mceTableDeleteCol",
						onSetup: selectionTargets.onSetupColumn("onAny")
					}),
					addMenuIfRegistered("tablecutcolumn", {
						text: "Cut column",
						icon: "cut-column",
						command: "mceTableCutCol",
						onSetup: selectionTargets.onSetupColumn("onAny")
					}),
					addMenuIfRegistered("tablecopycolumn", {
						text: "Copy column",
						icon: "duplicate-column",
						command: "mceTableCopyCol",
						onSetup: selectionTargets.onSetupColumn("onAny")
					}),
					addMenuIfRegistered("tablepastecolumnbefore", {
						text: "Paste column before",
						icon: "paste-column-before",
						command: "mceTablePasteColBefore",
						onSetup: selectionTargets.onSetupPasteableColumn(getColumns, "onFirst")
					}),
					addMenuIfRegistered("tablepastecolumnafter", {
						text: "Paste column after",
						icon: "paste-column-after",
						command: "mceTablePasteColAfter",
						onSetup: selectionTargets.onSetupPasteableColumn(getColumns, "onLast")
					})
				];
				const hasCellMenuItems = [
					addMenuIfRegistered("tablecellprops", {
						text: "Cell properties",
						icon: "table-cell-properties",
						command: "mceTableCellProps",
						onSetup: selectionTargets.onSetupCellOrRow
					}),
					addMenuIfRegistered("tablemergecells", {
						text: "Merge cells",
						icon: "table-merge-cells",
						command: "mceTableMergeCells",
						onSetup: selectionTargets.onSetupMergeable
					}),
					addMenuIfRegistered("tablesplitcells", {
						text: "Split cell",
						icon: "table-split-cells",
						command: "mceTableSplitCells",
						onSetup: selectionTargets.onSetupUnmergeable
					})
				];
				if (!hasTableGrid(editor)) editor.ui.registry.addMenuItem("inserttable", {
					text: "Table",
					icon: "table",
					onAction: cmd("mceInsertTableDialog"),
					onSetup: onSetupEditable(editor)
				});
				else editor.ui.registry.addNestedMenuItem("inserttable", {
					text: "Table",
					icon: "table",
					getSubmenuItems: () => [{
						type: "fancymenuitem",
						fancytype: "inserttable",
						onAction: insertTableAction
					}],
					onSetup: onSetupEditable(editor)
				});
				editor.ui.registry.addMenuItem("inserttabledialog", {
					text: "Insert table",
					icon: "table",
					onAction: cmd("mceInsertTableDialog"),
					onSetup: onSetupEditable(editor)
				});
				addMenuIfRegistered("tableprops", {
					text: "Table properties",
					onSetup: selectionTargets.onSetupTable,
					command: "mceTableProps"
				});
				addMenuIfRegistered("deletetable", {
					text: "Delete table",
					icon: "table-delete-table",
					onSetup: selectionTargets.onSetupTable,
					command: "mceTableDelete"
				});
				if (contains(hasRowMenuItems, true)) editor.ui.registry.addNestedMenuItem("row", {
					type: "nestedmenuitem",
					text: "Row",
					getSubmenuItems: constant("tableinsertrowbefore tableinsertrowafter tabledeleterow tablerowprops | tablecutrow tablecopyrow tablepasterowbefore tablepasterowafter")
				});
				if (contains(hasColumnMenuItems, true)) editor.ui.registry.addNestedMenuItem("column", {
					type: "nestedmenuitem",
					text: "Column",
					getSubmenuItems: constant("tableinsertcolumnbefore tableinsertcolumnafter tabledeletecolumn | tablecutcolumn tablecopycolumn tablepastecolumnbefore tablepastecolumnafter")
				});
				if (contains(hasCellMenuItems, true)) editor.ui.registry.addNestedMenuItem("cell", {
					type: "nestedmenuitem",
					text: "Cell",
					getSubmenuItems: constant("tablecellprops tablemergecells tablesplitcells")
				});
				editor.ui.registry.addContextMenu("table", { update: () => {
					selectionTargets.resetTargets();
					return selectionTargets.targets().fold(constant(""), (targets) => {
						if (name(targets.element) === "caption") return "tableprops deletetable";
						else return "cell row column | advtablesort | tableprops deletetable";
					});
				} });
				const tableClassList = filterNoneItem(getTableClassList(editor));
				if (tableClassList.length !== 0 && editor.queryCommandSupported("mceTableToggleClass")) editor.ui.registry.addNestedMenuItem("tableclass", {
					icon: "table-classes",
					text: "Table styles",
					getSubmenuItems: () => buildMenuItems(editor, tableClassList, "tableclass", (value) => editor.execCommand("mceTableToggleClass", false, value)),
					onSetup: selectionTargets.onSetupTable
				});
				const tableCellClassList = filterNoneItem(getCellClassList(editor));
				if (tableCellClassList.length !== 0 && editor.queryCommandSupported("mceTableCellToggleClass")) editor.ui.registry.addNestedMenuItem("tablecellclass", {
					icon: "table-cell-classes",
					text: "Cell styles",
					getSubmenuItems: () => buildMenuItems(editor, tableCellClassList, "tablecellclass", (value) => editor.execCommand("mceTableCellToggleClass", false, value)),
					onSetup: selectionTargets.onSetupCellOrRow
				});
				if (editor.queryCommandSupported("mceTableApplyCellStyle")) {
					editor.ui.registry.addNestedMenuItem("tablecellvalign", {
						icon: "vertical-align",
						text: "Vertical align",
						getSubmenuItems: () => buildMenuItems(editor, verticalAlignValues, "tablecellverticalalign", applyTableCellStyle(editor, "vertical-align")),
						onSetup: selectionTargets.onSetupCellOrRow
					});
					editor.ui.registry.addNestedMenuItem("tablecellborderwidth", {
						icon: "border-width",
						text: "Border width",
						getSubmenuItems: () => buildMenuItems(editor, getTableBorderWidths(editor), "tablecellborderwidth", applyTableCellStyle(editor, "border-width")),
						onSetup: selectionTargets.onSetupCellOrRow
					});
					editor.ui.registry.addNestedMenuItem("tablecellborderstyle", {
						icon: "border-style",
						text: "Border style",
						getSubmenuItems: () => buildMenuItems(editor, getTableBorderStyles(editor), "tablecellborderstyle", applyTableCellStyle(editor, "border-style")),
						onSetup: selectionTargets.onSetupCellOrRow
					});
					editor.ui.registry.addNestedMenuItem("tablecellbackgroundcolor", {
						icon: "cell-background-color",
						text: "Background color",
						getSubmenuItems: () => buildColorMenu(editor, getTableBackgroundColorMap(editor), "background-color"),
						onSetup: selectionTargets.onSetupCellOrRow
					});
					editor.ui.registry.addNestedMenuItem("tablecellbordercolor", {
						icon: "cell-border-color",
						text: "Border color",
						getSubmenuItems: () => buildColorMenu(editor, getTableBorderColorMap(editor), "border-color"),
						onSetup: selectionTargets.onSetupCellOrRow
					});
				}
				addToggleMenuIfRegistered("tablecaption", {
					icon: "table-caption",
					text: "Table caption",
					command: "mceTableToggleCaption",
					onSetup: selectionTargets.onSetupTableWithCaption
				});
				addToggleMenuIfRegistered("tablerowheader", {
					text: "Row header",
					icon: "table-top-header",
					command: "mceTableRowType",
					onAction: changeRowHeader(editor),
					onSetup: selectionTargets.onSetupTableRowHeaders
				});
				addToggleMenuIfRegistered("tablecolheader", {
					text: "Column header",
					icon: "table-left-header",
					command: "mceTableColType",
					onAction: changeColumnHeader(editor),
					onSetup: selectionTargets.onSetupTableRowHeaders
				});
			};
			const Plugin = (editor) => {
				const selectionTargets = getSelectionTargets(editor);
				register(editor);
				registerCommands(editor);
				addMenuItems(editor, selectionTargets);
				addButtons(editor, selectionTargets);
				addToolbars(editor);
			};
			var Plugin$1 = () => {
				global$3.add("table", Plugin);
			};
			Plugin$1();
		})();
	}));

//#endregion
//#region node_modules/tinymce/plugins/table/index.js
	require_plugin();

//#endregion
//#region node_modules/tinymce/skins/ui/oxide/content.css
	var content_default$1 = ".mce-content-body .mce-item-anchor {\n  background: transparent url(\"data:image/svg+xml;charset=UTF-8,%3Csvg%20width%3D'8'%20height%3D'12'%20xmlns%3D'http%3A%2F%2Fwww.w3.org%2F2000%2Fsvg'%3E%3Cpath%20d%3D'M0%200L8%200%208%2012%204.09117821%209%200%2012z'%2F%3E%3C%2Fsvg%3E%0A\") no-repeat center;\n}\n.mce-content-body .mce-item-anchor:empty {\n  cursor: default;\n  display: inline-block;\n  height: 12px !important;\n  padding: 0 2px;\n  -webkit-user-modify: read-only;\n  -moz-user-modify: read-only;\n  -webkit-user-select: all;\n  -moz-user-select: all;\n  user-select: all;\n  width: 8px !important;\n}\n.mce-content-body .mce-item-anchor:not(:empty) {\n  background-position-x: 2px;\n  display: inline-block;\n  padding-left: 12px;\n}\n.mce-content-body .mce-item-anchor[data-mce-selected] {\n  outline-offset: 1px;\n}\n.tox-comments-visible .tox-comment[contenteditable=\"false\"]:not([data-mce-selected]),\n.tox-comments-visible span.tox-comment img:not([data-mce-selected]),\n.tox-comments-visible span.tox-comment > audio:not([data-mce-selected]),\n.tox-comments-visible span.tox-comment > video:not([data-mce-selected]),\n.tox-comments-visible span.tox-comment span.mce-preview-object:not([data-mce-selected]) {\n  outline: 3px solid #ffe89d;\n}\n.tox-comments-visible .tox-comment[contenteditable=\"false\"][data-mce-annotation-active=\"true\"]:not([data-mce-selected]) {\n  outline: 3px solid #fed635;\n}\n.tox-comments-visible span.tox-comment[data-mce-annotation-active=\"true\"] img:not([data-mce-selected]),\n.tox-comments-visible span.tox-comment[data-mce-annotation-active=\"true\"] > audio:not([data-mce-selected]),\n.tox-comments-visible span.tox-comment[data-mce-annotation-active=\"true\"] > video:not([data-mce-selected]),\n.tox-comments-visible span.tox-comment[data-mce-annotation-active=\"true\"] span.mce-preview-object:not([data-mce-selected]) {\n  outline: 3px solid #fed635;\n}\n.tox-comments-visible span.tox-comment:not([data-mce-selected]) {\n  background-color: #ffe89d;\n  outline: none;\n}\n.tox-comments-visible span.tox-comment[data-mce-annotation-active=\"true\"]:not([data-mce-selected=\"inline-boundary\"]) {\n  background-color: #fed635;\n}\n.tox-checklist > li:not(.tox-checklist--hidden) {\n  list-style: none;\n  margin: 0.25em 0;\n}\n.tox-checklist > li:not(.tox-checklist--hidden)::before {\n  content: url(\"data:image/svg+xml;charset=UTF-8,%3Csvg%20xmlns%3D%22http%3A%2F%2Fwww.w3.org%2F2000%2Fsvg%22%20width%3D%2216%22%20height%3D%2216%22%20viewBox%3D%220%200%2016%2016%22%3E%3Cg%20id%3D%22checklist-unchecked%22%20fill%3D%22none%22%20fill-rule%3D%22evenodd%22%3E%3Crect%20id%3D%22Rectangle%22%20width%3D%2215%22%20height%3D%2215%22%20x%3D%22.5%22%20y%3D%22.5%22%20fill-rule%3D%22nonzero%22%20stroke%3D%22%234C4C4C%22%20rx%3D%222%22%2F%3E%3C%2Fg%3E%3C%2Fsvg%3E%0A\");\n  cursor: pointer;\n  height: 1em;\n  margin-left: -1.5em;\n  margin-top: 0.125em;\n  position: absolute;\n  width: 1em;\n}\n.tox-checklist li:not(.tox-checklist--hidden).tox-checklist--checked::before {\n  content: url(\"data:image/svg+xml;charset=UTF-8,%3Csvg%20xmlns%3D%22http%3A%2F%2Fwww.w3.org%2F2000%2Fsvg%22%20width%3D%2216%22%20height%3D%2216%22%20viewBox%3D%220%200%2016%2016%22%3E%3Cg%20id%3D%22checklist-checked%22%20fill%3D%22none%22%20fill-rule%3D%22evenodd%22%3E%3Crect%20id%3D%22Rectangle%22%20width%3D%2216%22%20height%3D%2216%22%20fill%3D%22%234099FF%22%20fill-rule%3D%22nonzero%22%20rx%3D%222%22%2F%3E%3Cpath%20id%3D%22Path%22%20fill%3D%22%23FFF%22%20fill-rule%3D%22nonzero%22%20d%3D%22M11.5703186%2C3.14417309%20C11.8516238%2C2.73724603%2012.4164781%2C2.62829933%2012.83558%2C2.89774797%20C13.260121%2C3.17069355%2013.3759736%2C3.72932262%2013.0909105%2C4.14168582%20L7.7580587%2C11.8560195%20C7.43776896%2C12.3193404%206.76483983%2C12.3852142%206.35607322%2C11.9948725%20L3.02491697%2C8.8138662%20C2.66090143%2C8.46625845%202.65798871%2C7.89594698%203.01850234%2C7.54483354%20C3.373942%2C7.19866177%203.94940006%2C7.19592841%204.30829608%2C7.5386474%20L6.85276923%2C9.9684299%20L11.5703186%2C3.14417309%20Z%22%2F%3E%3C%2Fg%3E%3C%2Fsvg%3E%0A\");\n}\n[dir=rtl] .tox-checklist > li:not(.tox-checklist--hidden)::before {\n  margin-left: 0;\n  margin-right: -1.5em;\n}\n/* stylelint-disable */\n/* http://prismjs.com/ */\n/**\n * prism.js default theme for JavaScript, CSS and HTML\n * Based on dabblet (http://dabblet.com)\n * @author Lea Verou\n */\ncode[class*=\"language-\"],\npre[class*=\"language-\"] {\n  color: black;\n  background: none;\n  text-shadow: 0 1px white;\n  font-family: Consolas, Monaco, 'Andale Mono', 'Ubuntu Mono', monospace;\n  font-size: 1em;\n  text-align: left;\n  white-space: pre;\n  word-spacing: normal;\n  word-break: normal;\n  word-wrap: normal;\n  line-height: 1.5;\n  -moz-tab-size: 4;\n  tab-size: 4;\n  -webkit-hyphens: none;\n  hyphens: none;\n}\npre[class*=\"language-\"]::-moz-selection,\npre[class*=\"language-\"] ::-moz-selection,\ncode[class*=\"language-\"]::-moz-selection,\ncode[class*=\"language-\"] ::-moz-selection {\n  text-shadow: none;\n  background: #b3d4fc;\n}\npre[class*=\"language-\"]::selection,\npre[class*=\"language-\"] ::selection,\ncode[class*=\"language-\"]::selection,\ncode[class*=\"language-\"] ::selection {\n  text-shadow: none;\n  background: #b3d4fc;\n}\n@media print {\n  code[class*=\"language-\"],\n  pre[class*=\"language-\"] {\n    text-shadow: none;\n  }\n}\n/* Code blocks */\npre[class*=\"language-\"] {\n  padding: 1em;\n  margin: 0.5em 0;\n  overflow: auto;\n}\n:not(pre) > code[class*=\"language-\"],\npre[class*=\"language-\"] {\n  background: #f5f2f0;\n}\n/* Inline code */\n:not(pre) > code[class*=\"language-\"] {\n  padding: 0.1em;\n  border-radius: 0.3em;\n  white-space: normal;\n}\n.token.comment,\n.token.prolog,\n.token.doctype,\n.token.cdata {\n  color: slategray;\n}\n.token.punctuation {\n  color: #999;\n}\n.token.namespace {\n  opacity: 0.7;\n}\n.token.property,\n.token.tag,\n.token.boolean,\n.token.number,\n.token.constant,\n.token.symbol,\n.token.deleted {\n  color: #905;\n}\n.token.selector,\n.token.attr-name,\n.token.string,\n.token.char,\n.token.builtin,\n.token.inserted {\n  color: #690;\n}\n.token.operator,\n.token.entity,\n.token.url,\n.language-css .token.string,\n.style .token.string {\n  color: #9a6e3a;\n  /* This background color was intended by the author of this theme. */\n  background: hsla(0, 0%, 100%, 0.5);\n}\n.token.atrule,\n.token.attr-value,\n.token.keyword {\n  color: #07a;\n}\n.token.function,\n.token.class-name {\n  color: #DD4A68;\n}\n.token.regex,\n.token.important,\n.token.variable {\n  color: #e90;\n}\n.token.important,\n.token.bold {\n  font-weight: bold;\n}\n.token.italic {\n  font-style: italic;\n}\n.token.entity {\n  cursor: help;\n}\n/* stylelint-enable */\n.mce-content-body {\n  overflow-wrap: break-word;\n  word-wrap: break-word;\n}\n.mce-content-body .mce-visual-caret {\n  background-color: black;\n  background-color: currentColor;\n  position: absolute;\n}\n.mce-content-body .mce-visual-caret-hidden {\n  display: none;\n}\n.mce-content-body *[data-mce-caret] {\n  left: -1000px;\n  margin: 0;\n  padding: 0;\n  position: absolute;\n  right: auto;\n  top: 0;\n}\n.mce-content-body .mce-offscreen-selection {\n  left: -2000000px;\n  max-width: 1000000px;\n  position: absolute;\n}\n.mce-content-body *[contentEditable=false] {\n  cursor: default;\n}\n.mce-content-body *[contentEditable=true] {\n  cursor: text;\n}\n.tox-cursor-format-painter {\n  cursor: url(\"data:image/svg+xml;charset=UTF-8,%3Csvg%20xmlns%3D%22http%3A%2F%2Fwww.w3.org%2F2000%2Fsvg%22%20width%3D%2224%22%20height%3D%2224%22%20viewBox%3D%220%200%2024%2024%22%3E%0A%20%20%3Cg%20fill%3D%22none%22%20fill-rule%3D%22evenodd%22%3E%0A%20%20%20%20%3Cpath%20fill%3D%22%23000%22%20fill-rule%3D%22nonzero%22%20d%3D%22M15%2C6%20C15%2C5.45%2014.55%2C5%2014%2C5%20L6%2C5%20C5.45%2C5%205%2C5.45%205%2C6%20L5%2C10%20C5%2C10.55%205.45%2C11%206%2C11%20L14%2C11%20C14.55%2C11%2015%2C10.55%2015%2C10%20L15%2C9%20L16%2C9%20L16%2C12%20L9%2C12%20L9%2C19%20C9%2C19.55%209.45%2C20%2010%2C20%20L11%2C20%20C11.55%2C20%2012%2C19.55%2012%2C19%20L12%2C14%20L18%2C14%20L18%2C7%20L15%2C7%20L15%2C6%20Z%22%2F%3E%0A%20%20%20%20%3Cpath%20fill%3D%22%23000%22%20fill-rule%3D%22nonzero%22%20d%3D%22M1%2C1%20L8.25%2C1%20C8.66421356%2C1%209%2C1.33578644%209%2C1.75%20L9%2C1.75%20C9%2C2.16421356%208.66421356%2C2.5%208.25%2C2.5%20L2.5%2C2.5%20L2.5%2C8.25%20C2.5%2C8.66421356%202.16421356%2C9%201.75%2C9%20L1.75%2C9%20C1.33578644%2C9%201%2C8.66421356%201%2C8.25%20L1%2C1%20Z%22%2F%3E%0A%20%20%3C%2Fg%3E%0A%3C%2Fsvg%3E%0A\"), default;\n}\ndiv.mce-footnotes hr {\n  margin-inline-end: auto;\n  margin-inline-start: 0;\n  width: 25%;\n}\ndiv.mce-footnotes li > a.mce-footnotes-backlink {\n  text-decoration: none;\n}\n@media print {\n  sup.mce-footnote a {\n    color: black;\n    text-decoration: none;\n  }\n  div.mce-footnotes {\n    break-inside: avoid;\n    width: 100%;\n  }\n  div.mce-footnotes li > a.mce-footnotes-backlink {\n    display: none;\n  }\n}\n.mce-content-body figure.align-left {\n  float: left;\n}\n.mce-content-body figure.align-right {\n  float: right;\n}\n.mce-content-body figure.image.align-center {\n  display: table;\n  margin-left: auto;\n  margin-right: auto;\n}\n.mce-preview-object {\n  border: 1px solid gray;\n  display: inline-block;\n  line-height: 0;\n  margin: 0 2px 0 2px;\n  position: relative;\n}\n.mce-preview-object .mce-shim {\n  background: url(data:image/gif;base64,R0lGODlhAQABAIAAAAAAAP///yH5BAEAAAAALAAAAAABAAEAAAIBRAA7);\n  height: 100%;\n  left: 0;\n  position: absolute;\n  top: 0;\n  width: 100%;\n}\n.mce-preview-object[data-mce-selected=\"2\"] .mce-shim {\n  display: none;\n}\n.mce-content-body .mce-mergetag {\n  cursor: default !important;\n  -webkit-user-select: none;\n     -moz-user-select: none;\n          user-select: none;\n}\n.mce-content-body .mce-mergetag:hover {\n  background-color: rgba(0, 108, 231, 0.1);\n}\n.mce-content-body .mce-mergetag-affix {\n  background-color: rgba(0, 108, 231, 0.1);\n  color: #006ce7;\n}\n.mce-object {\n  background: transparent url(\"data:image/svg+xml;charset=UTF-8,%3Csvg%20xmlns%3D%22http%3A%2F%2Fwww.w3.org%2F2000%2Fsvg%22%20width%3D%2224%22%20height%3D%2224%22%3E%3Cpath%20d%3D%22M4%203h16a1%201%200%200%201%201%201v16a1%201%200%200%201-1%201H4a1%201%200%200%201-1-1V4a1%201%200%200%201%201-1zm1%202v14h14V5H5zm4.79%202.565l5.64%204.028a.5.5%200%200%201%200%20.814l-5.64%204.028a.5.5%200%200%201-.79-.407V7.972a.5.5%200%200%201%20.79-.407z%22%2F%3E%3C%2Fsvg%3E%0A\") no-repeat center;\n  border: 1px dashed #aaa;\n}\n.mce-pagebreak {\n  border: 1px dashed #aaa;\n  cursor: default;\n  display: block;\n  height: 5px;\n  margin-top: 15px;\n  page-break-before: always;\n  width: 100%;\n}\n@media print {\n  .mce-pagebreak {\n    border: 0;\n  }\n}\n.tiny-pageembed .mce-shim {\n  background: url(data:image/gif;base64,R0lGODlhAQABAIAAAAAAAP///yH5BAEAAAAALAAAAAABAAEAAAIBRAA7);\n  height: 100%;\n  left: 0;\n  position: absolute;\n  top: 0;\n  width: 100%;\n}\n.tiny-pageembed[data-mce-selected=\"2\"] .mce-shim {\n  display: none;\n}\n.tiny-pageembed {\n  display: inline-block;\n  position: relative;\n}\n.tiny-pageembed--21by9,\n.tiny-pageembed--16by9,\n.tiny-pageembed--4by3,\n.tiny-pageembed--1by1 {\n  display: block;\n  overflow: hidden;\n  padding: 0;\n  position: relative;\n  width: 100%;\n}\n.tiny-pageembed--21by9 {\n  padding-top: 42.857143%;\n}\n.tiny-pageembed--16by9 {\n  padding-top: 56.25%;\n}\n.tiny-pageembed--4by3 {\n  padding-top: 75%;\n}\n.tiny-pageembed--1by1 {\n  padding-top: 100%;\n}\n.tiny-pageembed--21by9 iframe,\n.tiny-pageembed--16by9 iframe,\n.tiny-pageembed--4by3 iframe,\n.tiny-pageembed--1by1 iframe {\n  border: 0;\n  height: 100%;\n  left: 0;\n  position: absolute;\n  top: 0;\n  width: 100%;\n}\n.mce-content-body[data-mce-placeholder] {\n  position: relative;\n}\n.mce-content-body[data-mce-placeholder]:not(.mce-visualblocks)::before {\n  color: rgba(34, 47, 62, 0.7);\n  content: attr(data-mce-placeholder);\n  position: absolute;\n}\n.mce-content-body:not([dir=rtl])[data-mce-placeholder]:not(.mce-visualblocks)::before {\n  left: 1px;\n}\n.mce-content-body[dir=rtl][data-mce-placeholder]:not(.mce-visualblocks)::before {\n  right: 1px;\n}\n.mce-content-body div.mce-resizehandle {\n  background-color: #4099ff;\n  border-color: #4099ff;\n  border-style: solid;\n  border-width: 1px;\n  box-sizing: border-box;\n  height: 10px;\n  position: absolute;\n  width: 10px;\n  z-index: 1298;\n}\n.mce-content-body div.mce-resizehandle:hover {\n  background-color: #4099ff;\n}\n.mce-content-body div.mce-resizehandle:nth-of-type(1) {\n  cursor: nwse-resize;\n}\n.mce-content-body div.mce-resizehandle:nth-of-type(2) {\n  cursor: nesw-resize;\n}\n.mce-content-body div.mce-resizehandle:nth-of-type(3) {\n  cursor: nwse-resize;\n}\n.mce-content-body div.mce-resizehandle:nth-of-type(4) {\n  cursor: nesw-resize;\n}\n.mce-content-body .mce-resize-backdrop {\n  z-index: 10000;\n}\n.mce-content-body .mce-clonedresizable {\n  cursor: default;\n  opacity: 0.5;\n  outline: 1px dashed black;\n  position: absolute;\n  z-index: 10001;\n}\n.mce-content-body .mce-clonedresizable.mce-resizetable-columns th,\n.mce-content-body .mce-clonedresizable.mce-resizetable-columns td {\n  border: 0;\n}\n.mce-content-body .mce-resize-helper {\n  background: #555;\n  background: rgba(0, 0, 0, 0.75);\n  border: 1px;\n  border-radius: 3px;\n  color: white;\n  display: none;\n  font-family: sans-serif;\n  font-size: 12px;\n  line-height: 14px;\n  margin: 5px 10px;\n  padding: 5px;\n  position: absolute;\n  white-space: nowrap;\n  z-index: 10002;\n}\n.tox-rtc-user-selection {\n  position: relative;\n}\n.tox-rtc-user-cursor {\n  bottom: 0;\n  cursor: default;\n  position: absolute;\n  top: 0;\n  width: 2px;\n}\n.tox-rtc-user-cursor::before {\n  background-color: inherit;\n  border-radius: 50%;\n  content: '';\n  display: block;\n  height: 8px;\n  position: absolute;\n  right: -3px;\n  top: -3px;\n  width: 8px;\n}\n.tox-rtc-user-cursor:hover::after {\n  background-color: inherit;\n  border-radius: 100px;\n  box-sizing: border-box;\n  color: #fff;\n  content: attr(data-user);\n  display: block;\n  font-size: 12px;\n  font-weight: bold;\n  left: -5px;\n  min-height: 8px;\n  min-width: 8px;\n  padding: 0 12px;\n  position: absolute;\n  top: -11px;\n  white-space: nowrap;\n  z-index: 1000;\n}\n.tox-rtc-user-selection--1 .tox-rtc-user-cursor {\n  background-color: #2dc26b;\n}\n.tox-rtc-user-selection--2 .tox-rtc-user-cursor {\n  background-color: #e03e2d;\n}\n.tox-rtc-user-selection--3 .tox-rtc-user-cursor {\n  background-color: #f1c40f;\n}\n.tox-rtc-user-selection--4 .tox-rtc-user-cursor {\n  background-color: #3598db;\n}\n.tox-rtc-user-selection--5 .tox-rtc-user-cursor {\n  background-color: #b96ad9;\n}\n.tox-rtc-user-selection--6 .tox-rtc-user-cursor {\n  background-color: #e67e23;\n}\n.tox-rtc-user-selection--7 .tox-rtc-user-cursor {\n  background-color: #aaa69d;\n}\n.tox-rtc-user-selection--8 .tox-rtc-user-cursor {\n  background-color: #f368e0;\n}\n.tox-rtc-remote-image {\n  background: #eaeaea url(\"data:image/svg+xml;charset=UTF-8,%3Csvg%20width%3D%2236%22%20height%3D%2212%22%20viewBox%3D%220%200%2036%2012%22%20xmlns%3D%22http%3A%2F%2Fwww.w3.org%2F2000%2Fsvg%22%3E%0A%20%20%3Ccircle%20cx%3D%226%22%20cy%3D%226%22%20r%3D%223%22%20fill%3D%22rgba(0%2C%200%2C%200%2C%20.2)%22%3E%0A%20%20%20%20%3Canimate%20attributeName%3D%22r%22%20values%3D%223%3B5%3B3%22%20calcMode%3D%22linear%22%20dur%3D%221s%22%20repeatCount%3D%22indefinite%22%20%2F%3E%0A%20%20%3C%2Fcircle%3E%0A%20%20%3Ccircle%20cx%3D%2218%22%20cy%3D%226%22%20r%3D%223%22%20fill%3D%22rgba(0%2C%200%2C%200%2C%20.2)%22%3E%0A%20%20%20%20%3Canimate%20attributeName%3D%22r%22%20values%3D%223%3B5%3B3%22%20calcMode%3D%22linear%22%20begin%3D%22.33s%22%20dur%3D%221s%22%20repeatCount%3D%22indefinite%22%20%2F%3E%0A%20%20%3C%2Fcircle%3E%0A%20%20%3Ccircle%20cx%3D%2230%22%20cy%3D%226%22%20r%3D%223%22%20fill%3D%22rgba(0%2C%200%2C%200%2C%20.2)%22%3E%0A%20%20%20%20%3Canimate%20attributeName%3D%22r%22%20values%3D%223%3B5%3B3%22%20calcMode%3D%22linear%22%20begin%3D%22.66s%22%20dur%3D%221s%22%20repeatCount%3D%22indefinite%22%20%2F%3E%0A%20%20%3C%2Fcircle%3E%0A%3C%2Fsvg%3E%0A\") no-repeat center center;\n  border: 1px solid #ccc;\n  min-height: 240px;\n  min-width: 320px;\n}\n.mce-match-marker {\n  background: #aaa;\n  color: #fff;\n}\n.mce-match-marker-selected {\n  background: #39f;\n  color: #fff;\n}\n.mce-match-marker-selected::-moz-selection {\n  background: #39f;\n  color: #fff;\n}\n.mce-match-marker-selected::selection {\n  background: #39f;\n  color: #fff;\n}\n.mce-content-body img[data-mce-selected],\n.mce-content-body video[data-mce-selected],\n.mce-content-body audio[data-mce-selected],\n.mce-content-body object[data-mce-selected],\n.mce-content-body embed[data-mce-selected],\n.mce-content-body table[data-mce-selected],\n.mce-content-body details[data-mce-selected] {\n  outline: 3px solid #b4d7ff;\n}\n.mce-content-body hr[data-mce-selected] {\n  outline: 3px solid #b4d7ff;\n  outline-offset: 1px;\n}\n.mce-content-body *[contentEditable=false] *[contentEditable=true]:focus {\n  outline: 3px solid #b4d7ff;\n}\n.mce-content-body *[contentEditable=false] *[contentEditable=true]:hover {\n  outline: 3px solid #b4d7ff;\n}\n.mce-content-body *[contentEditable=false][data-mce-selected] {\n  cursor: not-allowed;\n  outline: 3px solid #b4d7ff;\n}\n.mce-content-body.mce-content-readonly *[contentEditable=true]:focus,\n.mce-content-body.mce-content-readonly *[contentEditable=true]:hover {\n  outline: none;\n}\n.mce-content-body *[data-mce-selected=\"inline-boundary\"] {\n  background-color: #b4d7ff;\n}\n.mce-content-body .mce-edit-focus {\n  outline: 3px solid #b4d7ff;\n}\n.mce-content-body td[data-mce-selected],\n.mce-content-body th[data-mce-selected] {\n  position: relative;\n}\n.mce-content-body td[data-mce-selected]::-moz-selection,\n.mce-content-body th[data-mce-selected]::-moz-selection {\n  background: none;\n}\n.mce-content-body td[data-mce-selected]::selection,\n.mce-content-body th[data-mce-selected]::selection {\n  background: none;\n}\n.mce-content-body td[data-mce-selected] *,\n.mce-content-body th[data-mce-selected] * {\n  outline: none;\n  -webkit-touch-callout: none;\n  -webkit-user-select: none;\n     -moz-user-select: none;\n          user-select: none;\n}\n.mce-content-body td[data-mce-selected]::after,\n.mce-content-body th[data-mce-selected]::after {\n  background-color: rgba(180, 215, 255, 0.7);\n  border: 1px solid rgba(180, 215, 255, 0.7);\n  bottom: -1px;\n  content: '';\n  left: -1px;\n  mix-blend-mode: multiply;\n  position: absolute;\n  right: -1px;\n  top: -1px;\n}\n@media screen and (-ms-high-contrast: active), (-ms-high-contrast: none) {\n  .mce-content-body td[data-mce-selected]::after,\n  .mce-content-body th[data-mce-selected]::after {\n    border-color: rgba(0, 84, 180, 0.7);\n  }\n}\n.mce-content-body img[data-mce-selected]::-moz-selection {\n  background: none;\n}\n.mce-content-body img[data-mce-selected]::selection {\n  background: none;\n}\n.ephox-snooker-resizer-bar {\n  background-color: #b4d7ff;\n  opacity: 0;\n  -webkit-user-select: none;\n  -moz-user-select: none;\n  user-select: none;\n}\n.ephox-snooker-resizer-cols {\n  cursor: col-resize;\n}\n.ephox-snooker-resizer-rows {\n  cursor: row-resize;\n}\n.ephox-snooker-resizer-bar.ephox-snooker-resizer-bar-dragging {\n  opacity: 1;\n}\n.mce-spellchecker-word {\n  background-image: url(\"data:image/svg+xml;charset=UTF-8,%3Csvg%20width%3D'4'%20height%3D'4'%20xmlns%3D'http%3A%2F%2Fwww.w3.org%2F2000%2Fsvg'%3E%3Cpath%20stroke%3D'%23ff0000'%20fill%3D'none'%20stroke-linecap%3D'round'%20stroke-opacity%3D'.75'%20d%3D'M0%203L2%201%204%203'%2F%3E%3C%2Fsvg%3E%0A\");\n  background-position: 0 calc(100% + 1px);\n  background-repeat: repeat-x;\n  background-size: auto 6px;\n  cursor: default;\n  height: 2rem;\n}\n.mce-spellchecker-grammar {\n  background-image: url(\"data:image/svg+xml;charset=UTF-8,%3Csvg%20width%3D'4'%20height%3D'4'%20xmlns%3D'http%3A%2F%2Fwww.w3.org%2F2000%2Fsvg'%3E%3Cpath%20stroke%3D'%2300A835'%20fill%3D'none'%20stroke-linecap%3D'round'%20d%3D'M0%203L2%201%204%203'%2F%3E%3C%2Fsvg%3E%0A\");\n  background-position: 0 calc(100% + 1px);\n  background-repeat: repeat-x;\n  background-size: auto 6px;\n  cursor: default;\n}\n.mce-toc {\n  border: 1px solid gray;\n}\n.mce-toc h2 {\n  margin: 4px;\n}\n.mce-toc ul > li {\n  list-style-type: none;\n}\n[data-mce-block] {\n  display: block;\n}\ntable[style*=\"border-width: 0px\"],\n.mce-item-table:not([border]),\n.mce-item-table[border=\"0\"],\ntable[style*=\"border-width: 0px\"] td,\n.mce-item-table:not([border]) td,\n.mce-item-table[border=\"0\"] td,\ntable[style*=\"border-width: 0px\"] th,\n.mce-item-table:not([border]) th,\n.mce-item-table[border=\"0\"] th,\ntable[style*=\"border-width: 0px\"] caption,\n.mce-item-table:not([border]) caption,\n.mce-item-table[border=\"0\"] caption {\n  border: 1px dashed #bbb;\n}\n.mce-visualblocks p,\n.mce-visualblocks h1,\n.mce-visualblocks h2,\n.mce-visualblocks h3,\n.mce-visualblocks h4,\n.mce-visualblocks h5,\n.mce-visualblocks h6,\n.mce-visualblocks div:not([data-mce-bogus]),\n.mce-visualblocks section,\n.mce-visualblocks article,\n.mce-visualblocks blockquote,\n.mce-visualblocks address,\n.mce-visualblocks pre,\n.mce-visualblocks figure,\n.mce-visualblocks figcaption,\n.mce-visualblocks hgroup,\n.mce-visualblocks aside,\n.mce-visualblocks ul,\n.mce-visualblocks ol,\n.mce-visualblocks dl {\n  background-repeat: no-repeat;\n  border: 1px dashed #bbb;\n  margin-left: 3px;\n  padding-top: 10px;\n}\n.mce-visualblocks p {\n  background-image: url(data:image/gif;base64,R0lGODlhCQAJAJEAAAAAAP///7u7u////yH5BAEAAAMALAAAAAAJAAkAAAIQnG+CqCN/mlyvsRUpThG6AgA7);\n}\n.mce-visualblocks h1 {\n  background-image: url(data:image/gif;base64,R0lGODlhDQAKAIABALu7u////yH5BAEAAAEALAAAAAANAAoAAAIXjI8GybGu1JuxHoAfRNRW3TWXyF2YiRUAOw==);\n}\n.mce-visualblocks h2 {\n  background-image: url(data:image/gif;base64,R0lGODlhDgAKAIABALu7u////yH5BAEAAAEALAAAAAAOAAoAAAIajI8Hybbx4oOuqgTynJd6bGlWg3DkJzoaUAAAOw==);\n}\n.mce-visualblocks h3 {\n  background-image: url(data:image/gif;base64,R0lGODlhDgAKAIABALu7u////yH5BAEAAAEALAAAAAAOAAoAAAIZjI8Hybbx4oOuqgTynJf2Ln2NOHpQpmhAAQA7);\n}\n.mce-visualblocks h4 {\n  background-image: url(data:image/gif;base64,R0lGODlhDgAKAIABALu7u////yH5BAEAAAEALAAAAAAOAAoAAAIajI8HybbxInR0zqeAdhtJlXwV1oCll2HaWgAAOw==);\n}\n.mce-visualblocks h5 {\n  background-image: url(data:image/gif;base64,R0lGODlhDgAKAIABALu7u////yH5BAEAAAEALAAAAAAOAAoAAAIajI8HybbxIoiuwjane4iq5GlW05GgIkIZUAAAOw==);\n}\n.mce-visualblocks h6 {\n  background-image: url(data:image/gif;base64,R0lGODlhDgAKAIABALu7u////yH5BAEAAAEALAAAAAAOAAoAAAIajI8HybbxIoiuwjan04jep1iZ1XRlAo5bVgAAOw==);\n}\n.mce-visualblocks div:not([data-mce-bogus]) {\n  background-image: url(data:image/gif;base64,R0lGODlhEgAKAIABALu7u////yH5BAEAAAEALAAAAAASAAoAAAIfjI9poI0cgDywrhuxfbrzDEbQM2Ei5aRjmoySW4pAAQA7);\n}\n.mce-visualblocks section {\n  background-image: url(data:image/gif;base64,R0lGODlhKAAKAIABALu7u////yH5BAEAAAEALAAAAAAoAAoAAAI5jI+pywcNY3sBWHdNrplytD2ellDeSVbp+GmWqaDqDMepc8t17Y4vBsK5hDyJMcI6KkuYU+jpjLoKADs=);\n}\n.mce-visualblocks article {\n  background-image: url(data:image/gif;base64,R0lGODlhKgAKAIABALu7u////yH5BAEAAAEALAAAAAAqAAoAAAI6jI+pywkNY3wG0GBvrsd2tXGYSGnfiF7ikpXemTpOiJScasYoDJJrjsG9gkCJ0ag6KhmaIe3pjDYBBQA7);\n}\n.mce-visualblocks blockquote {\n  background-image: url(data:image/gif;base64,R0lGODlhPgAKAIABALu7u////yH5BAEAAAEALAAAAAA+AAoAAAJPjI+py+0Knpz0xQDyuUhvfoGgIX5iSKZYgq5uNL5q69asZ8s5rrf0yZmpNkJZzFesBTu8TOlDVAabUyatguVhWduud3EyiUk45xhTTgMBBQA7);\n}\n.mce-visualblocks address {\n  background-image: url(data:image/gif;base64,R0lGODlhLQAKAIABALu7u////yH5BAEAAAEALAAAAAAtAAoAAAI/jI+pywwNozSP1gDyyZcjb3UaRpXkWaXmZW4OqKLhBmLs+K263DkJK7OJeifh7FicKD9A1/IpGdKkyFpNmCkAADs=);\n}\n.mce-visualblocks pre {\n  background-image: url(data:image/gif;base64,R0lGODlhFQAKAIABALu7uwAAACH5BAEAAAEALAAAAAAVAAoAAAIjjI+ZoN0cgDwSmnpz1NCueYERhnibZVKLNnbOq8IvKpJtVQAAOw==);\n}\n.mce-visualblocks figure {\n  background-image: url(data:image/gif;base64,R0lGODlhJAAKAIAAALu7u////yH5BAEAAAEALAAAAAAkAAoAAAI0jI+py+2fwAHUSFvD3RlvG4HIp4nX5JFSpnZUJ6LlrM52OE7uSWosBHScgkSZj7dDKnWAAgA7);\n}\n.mce-visualblocks figcaption {\n  border: 1px dashed #bbb;\n}\n.mce-visualblocks hgroup {\n  background-image: url(data:image/gif;base64,R0lGODlhJwAKAIABALu7uwAAACH5BAEAAAEALAAAAAAnAAoAAAI3jI+pywYNI3uB0gpsRtt5fFnfNZaVSYJil4Wo03Hv6Z62uOCgiXH1kZIIJ8NiIxRrAZNMZAtQAAA7);\n}\n.mce-visualblocks aside {\n  background-image: url(data:image/gif;base64,R0lGODlhHgAKAIABAKqqqv///yH5BAEAAAEALAAAAAAeAAoAAAItjI+pG8APjZOTzgtqy7I3f1yehmQcFY4WKZbqByutmW4aHUd6vfcVbgudgpYCADs=);\n}\n.mce-visualblocks ul {\n  background-image: url(data:image/gif;base64,R0lGODlhDQAKAIAAALu7u////yH5BAEAAAEALAAAAAANAAoAAAIXjI8GybGuYnqUVSjvw26DzzXiqIDlVwAAOw==);\n}\n.mce-visualblocks ol {\n  background-image: url(data:image/gif;base64,R0lGODlhDQAKAIABALu7u////yH5BAEAAAEALAAAAAANAAoAAAIXjI8GybH6HHt0qourxC6CvzXieHyeWQAAOw==);\n}\n.mce-visualblocks dl {\n  background-image: url(data:image/gif;base64,R0lGODlhDQAKAIABALu7u////yH5BAEAAAEALAAAAAANAAoAAAIXjI8GybEOnmOvUoWznTqeuEjNSCqeGRUAOw==);\n}\n.mce-visualblocks:not([dir=rtl]) p,\n.mce-visualblocks:not([dir=rtl]) h1,\n.mce-visualblocks:not([dir=rtl]) h2,\n.mce-visualblocks:not([dir=rtl]) h3,\n.mce-visualblocks:not([dir=rtl]) h4,\n.mce-visualblocks:not([dir=rtl]) h5,\n.mce-visualblocks:not([dir=rtl]) h6,\n.mce-visualblocks:not([dir=rtl]) div:not([data-mce-bogus]),\n.mce-visualblocks:not([dir=rtl]) section,\n.mce-visualblocks:not([dir=rtl]) article,\n.mce-visualblocks:not([dir=rtl]) blockquote,\n.mce-visualblocks:not([dir=rtl]) address,\n.mce-visualblocks:not([dir=rtl]) pre,\n.mce-visualblocks:not([dir=rtl]) figure,\n.mce-visualblocks:not([dir=rtl]) figcaption,\n.mce-visualblocks:not([dir=rtl]) hgroup,\n.mce-visualblocks:not([dir=rtl]) aside,\n.mce-visualblocks:not([dir=rtl]) ul,\n.mce-visualblocks:not([dir=rtl]) ol,\n.mce-visualblocks:not([dir=rtl]) dl {\n  margin-left: 3px;\n}\n.mce-visualblocks[dir=rtl] p,\n.mce-visualblocks[dir=rtl] h1,\n.mce-visualblocks[dir=rtl] h2,\n.mce-visualblocks[dir=rtl] h3,\n.mce-visualblocks[dir=rtl] h4,\n.mce-visualblocks[dir=rtl] h5,\n.mce-visualblocks[dir=rtl] h6,\n.mce-visualblocks[dir=rtl] div:not([data-mce-bogus]),\n.mce-visualblocks[dir=rtl] section,\n.mce-visualblocks[dir=rtl] article,\n.mce-visualblocks[dir=rtl] blockquote,\n.mce-visualblocks[dir=rtl] address,\n.mce-visualblocks[dir=rtl] pre,\n.mce-visualblocks[dir=rtl] figure,\n.mce-visualblocks[dir=rtl] figcaption,\n.mce-visualblocks[dir=rtl] hgroup,\n.mce-visualblocks[dir=rtl] aside,\n.mce-visualblocks[dir=rtl] ul,\n.mce-visualblocks[dir=rtl] ol,\n.mce-visualblocks[dir=rtl] dl {\n  background-position-x: right;\n  margin-right: 3px;\n}\n.mce-nbsp,\n.mce-shy {\n  background: #aaa;\n}\n.mce-shy::after {\n  content: '-';\n}\nbody {\n  font-family: sans-serif;\n}\ntable {\n  border-collapse: collapse;\n}\n";

//#endregion
//#region node_modules/tinymce/skins/content/default/content.css
	var content_default = "body {\n  font-family: -apple-system, BlinkMacSystemFont, 'Segoe UI', Roboto, Oxygen, Ubuntu, Cantarell, 'Open Sans', 'Helvetica Neue', sans-serif;\n  line-height: 1.4;\n  margin: 1rem;\n}\ntable {\n  border-collapse: collapse;\n}\n/* Apply a default padding if legacy cellpadding attribute is missing */\ntable:not([cellpadding]) th,\ntable:not([cellpadding]) td {\n  padding: 0.4rem;\n}\n/* Set default table styles if a table has a positive border attribute\n   and no inline css */\ntable[border]:not([border=\"0\"]):not([style*=\"border-width\"]) th,\ntable[border]:not([border=\"0\"]):not([style*=\"border-width\"]) td {\n  border-width: 1px;\n}\n/* Set default table styles if a table has a positive border attribute\n   and no inline css */\ntable[border]:not([border=\"0\"]):not([style*=\"border-style\"]) th,\ntable[border]:not([border=\"0\"]):not([style*=\"border-style\"]) td {\n  border-style: solid;\n}\n/* Set default table styles if a table has a positive border attribute\n   and no inline css */\ntable[border]:not([border=\"0\"]):not([style*=\"border-color\"]) th,\ntable[border]:not([border=\"0\"]):not([style*=\"border-color\"]) td {\n  border-color: #ccc;\n}\nfigure {\n  display: table;\n  margin: 1rem auto;\n}\nfigure figcaption {\n  color: #999;\n  display: block;\n  margin-top: 0.25rem;\n  text-align: center;\n}\nhr {\n  border-color: #ccc;\n  border-style: solid;\n  border-width: 1px 0 0 0;\n}\ncode {\n  background-color: #e8e8e8;\n  border-radius: 3px;\n  padding: 0.1rem 0.2rem;\n}\n.mce-content-body:not([dir=rtl]) blockquote {\n  border-left: 2px solid #ccc;\n  margin-left: 1.5rem;\n  padding-left: 1rem;\n}\n.mce-content-body[dir=rtl] blockquote {\n  border-right: 2px solid #ccc;\n  margin-right: 1.5rem;\n  padding-right: 1rem;\n}\n";

//#endregion
//#region src/WebFormsCore.Extensions.TinyMCE/Scripts/tiny.ts
	document.addEventListener("wfc:discardElement", function(e) {
		if (e.target.classList.contains("tox")) e.preventDefault();
	});
	wfc.bind(".js-tinymce", {
		init: async function(element) {
			const textArea = element.querySelector("textarea");
			const options = JSON.parse(element.getAttribute("data-options") || "{}");
			element._editor = (await import_tinymce.default.init({
				target: textArea,
				plugins: "advlist code link lists table",
				skin: false,
				content_css: false,
				content_style: content_default$1.toString() + "\n" + content_default.toString(),
				branding: true,
				promotion: false,
				...options
			}))[0];
			element.removeAttribute("style");
		},
		update: function(element, newElement) {
			const newTextArea = newElement.querySelector("textarea");
			const editor = element._editor;
			if (newTextArea.innerText) editor.setContent(newTextArea.innerText);
			editor.readonly = newTextArea.hasAttribute("disabled");
			return true;
		},
		submit: function(element, data) {
			const textArea = element.querySelector("textarea");
			data.set(textArea.name, element._editor.getContent());
		},
		destroy: function(element) {
			element._editor.destroy();
		}
	});

//#endregion
})();