# Code-only UI

WebForms Core allows you to build user interfaces entirely in C# without using `.aspx` or `.ascx` files. This approach gives you full compiler support, easy refactoring, and is the recommended path for [Native AOT](native-aot.md) scenarios.

## Mapping a Control to a Route

Use `MapControl` in `Program.cs` to serve a control tree at a specific URL:

```csharp
app.MapControl("/counter", sp =>
{
    var counter = new Ref<int>();

    return new Panel
    {
        Controls =
        [
            new Panel
            {
                Controls = 
                [ 
                    Text(() => $"Counter: {counter.Value}")
                ],
                Style =
                {
                    ["margin-bottom"] = "10px"
                }
            },
            new Button
            {
                Text = "Increment",
                OnClick = (_, _) => counter.Value++
            }
        ]
    };
});
```

### `MapControl` Overloads

| Overload | Description |
|---|---|
| `MapControl<TControl>(pattern)` | Maps a DI-activated control type to a route. |
| `MapControl(pattern, () => control)` | Maps a factory that returns a control. |
| `MapControl(pattern, sp => control)` | Maps a factory that receives `IServiceProvider`. |

The factory overloads wrap your control in a `FuncRefControl`, which manages `Ref<T>` ViewState persistence automatically.

## Collection Initializer Syntax

`ControlCollection` supports C# collection expressions, so you can use the `Controls = [...]` syntax to declare child controls inline:

```csharp
new Panel
{
    Controls =
    [
        new Label { Text = "Hello" },
        new Button { Text = "Click" }
    ]
}
```

You can also spread collections using the `..` operator:

```csharp
var items = new List<Panel> { /* ... */ };

new Panel
{
    Controls = [..items]
}
```

## Reactive State with `Ref<T>`

`Ref<T>` holds a value that is automatically persisted in ViewState across postbacks. Use it for counter state, form data, or any value that should survive a round-trip.

```csharp
var counter = new Ref<int>();        // default value: 0
var name = new Ref<string>("World"); // explicit default

// Read / write
counter.Value++;
var greeting = $"Hello, {name.Value}!";
```

### Referencing Controls

Every control has a `Ref` extension property that lets you capture a reference for later use:

```csharp
var label = new Ref<Label>();

new Panel
{
    Controls =
    [
        new Label
        {
            Ref = label,  // captures reference
            Text = "Not clicked"
        },
        new Button
        {
            Text = "Click me",
            OnClick = (_, _) => label.Value.Text = "Clicked!",
        }
    ]
};
```

## Event Handlers

Server controls with events (like `Button.Click`) expose lambda-friendly extension properties generated by the source generator:

| Property | Type | Description |
|---|---|---|
| `OnClick` | `Action<T, EventArgs>` | Synchronous click handler. |
| `OnClickAsync` | `Func<T, EventArgs, Task>` | Asynchronous click handler. |

```csharp
new Button
{
    Text = "Save",
    OnClick = (sender, e) => { /* sync handler */ }
}

new Button
{
    Text = "Save",
    OnClickAsync = async (sender, e) => { await SaveAsync(); }
}
```

These properties are generated for every `AsyncEventHandler` event on control subclasses.

## Dynamic Text and HTML

### `Literal` with Lambda

Create literals with dynamic text using a `Func<string>` constructor:

```csharp
new Literal(() => $"Count: {counter.Value}")
```

The lambda is evaluated on every render, so it always reflects the current state.

### Functional Helpers

Import the static helpers for a more concise syntax:

```csharp
using static WebFormsCore.UI.WebControls.LiteralMethods; // Not required when implicit usings are enabled

// Dynamic text (HTML-encoded)
Text(() => $"The time is {DateTime.Now}")

// Static text
Text("Welcome")

// Raw HTML (not encoded)
Html("<strong>Bold</strong>")
Html(() => $"<em>{someValue}</em>")
```

## Dynamic Attributes

Set HTML attributes using lambdas for values that have to be evaluated at render time:

```csharp
new Label
{
    Attributes =
    {
        { "data-count", () => counter.Value.ToString() },
        { "class", "my-class" }
    },
    Controls = [new Literal(() => $"Count: {counter.Value}")]
}
```

## Inline Templates

For controls that accept `ITemplate` (like `Repeater`), use `InlineTemplateMethods`:

```csharp
using static WebFormsCore.UI.InlineTemplateMethods; // Not required when implicit usings are enabled

new Repeater
{
    ItemTemplate = Template(() =>
    [
        new Label { Text = "Item" },
        new Literal(() => "content")
    ])
}
```

## Code-only Pages

You can also build full pages without `.aspx` files by inheriting from `Page`:

```csharp
using static WebFormsCore.UI.WebControls.LiteralMethods; // Not required when implicit usings are enabled

public class MyCodePage : Page
{
    protected override async ValueTask OnInitAsync(CancellationToken token)
    {
        await base.OnInitAsync(token);

        await Controls.AddAsync(new Panel
        {
            Controls =
            [
                Text("Welcome"),
                Text(() => $"The time is {DateTime.Now}")
            ]
        });
    }
}
```

## Full Example

A complete counter with dynamic text, attributes, and multiple buttons:

```csharp
app.MapControl("/counter", sp =>
{
    var counter = new Ref<int>();
    var label = new Ref<Label>();

    return new Panel
    {
        Controls =
        [
            new Label
            {
                Ref = label,
                Attributes =
                {
                    { "data-count", () => counter.Value.ToString() }
                },
                Controls =
                [
                    new Literal(() => $"Count: {counter.Value}")
                ]
            },
            new Button
            {
                Text = "Increment",
                OnClick = (_, _) => counter.Value++
            },
            new Button
            {
                Text = "Reset",
                OnClick = (_, _) =>
                {
                    counter.Value = 0;
                    label.Value.Attributes["class"] = "reset";
                }
            }
        ]
    };
});
```

## Benefits

- **Strongly Typed**: Full compiler support and IntelliSense for your UI tree.
- **Easy Refactoring**: Move UI logic into shared methods or classes.
- **Performance**: Skips the parsing and compilation step required for `.aspx` files.
- **Native AOT**: Code-only UI is fully compatible with Native AOT compilation.
- **Testable**: Inline controls work directly with the [testing framework](testing.md).
